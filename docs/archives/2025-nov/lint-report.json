[{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\App.tsx","messages":[{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-non-null-assertion').","line":91,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3263,3331],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-non-null-assertion').","line":93,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3397,3465],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-non-null-assertion').","line":95,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3531,3599],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-non-null-assertion').","line":97,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3665,3733],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-non-null-assertion').","line":99,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3799,3867],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-non-null-assertion').","line":101,"column":3,"severity":1,"nodeType":null,"fix":{"range":[3935,4003],"text":" "}},{"ruleId":null,"message":"Unused eslint-disable directive (no problems were reported from '@typescript-eslint/no-non-null-assertion').","line":103,"column":3,"severity":1,"nodeType":null,"fix":{"range":[4075,4143],"text":" "}}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":7,"source":"import { useEffect, useRef, useState } from 'react';\nimport { logComponent, startupLogger } from './utils/startupLogger';\nimport { Outlet } from 'react-router-dom';\nimport { Toaster } from 'sonner';\nimport PlannerStatus from './components/PlannerStatus';\nimport './App.css';\nimport {\n  useFaceLandmarker,\n  useHandLandmarker,\n  useObjectDetector,\n  usePoseLandmarker,\n  useAudioClassifier,\n  useImageClassifier,\n  useGestureRecognizer,\n  useImageSegmenter,\n  useImageEmbedder,\n  useSpeechResponder,\n  useVoiceIntent,\n  useMediaPipeModels,\n} from './hooks';\nimport { useAppStore } from './store/appStore';\nimport { hearingSense } from './senses/hearing';\nimport type { HearingPerceptPayload } from './senses/hearing';\nimport type { Percept } from './types';\nimport LisaCanvas from './components/LisaCanvas';\nimport ResourceViewer from './components/ResourceViewer';\nimport MicIndicator from './components/MicIndicator';\nimport PlanExplanationPanel from './components/PlanExplanationPanel';\nimport useAlarmTimerScheduler from './hooks/useAlarmTimerScheduler';\nimport { useWakeWord } from './hooks/useWakeWord';\nimport { useWorkflowManager } from './hooks/useWorkflowManager';\nimport useSpeechSynthesis from './hooks/useSpeechSynthesis';\nimport { MetaHumanCanvas } from './components/MetaHumanCanvas';\nimport { ChatInterface } from './components/ChatInterface';\nimport { LoginForm } from './components/LoginForm';\nimport { RegisterForm } from './components/RegisterForm';\nimport { useAuth } from './hooks/useAuth';\nimport { ErrorBoundary } from './components/ErrorBoundary';\n\nfunction App() {\n  logComponent('App', 'Component mounting');\n  startupLogger.startTimer('app-component-init');\n  \n  const videoRef = useRef<HTMLVideoElement>(null);\n  const [micStream, setMicStream] = useState<MediaStream>();\n  const [audioCtx] = useState(() => new AudioContext());\n  const [advancedVision] = useState(false);\n  const [advancedHearing] = useState(false);\n  const [showAuthForm, setShowAuthForm] = useState<'login' | 'register' | null>(null);\n  const { isAuthenticated, isLoading } = useAuth();\n\n  useEffect(() => {\n    navigator.mediaDevices\n      .getUserMedia({\n        video: { width: 640, height: 360, facingMode: 'user' },\n        audio: true,\n      })\n      .then((stream) => {\n        if (videoRef.current) videoRef.current.srcObject = stream;\n        setMicStream(stream);\n      });\n  }, [advancedVision]);\n\n  // Subscribe to hearingSense percepts and update store\n  useEffect(() => {\n    const handleHearingPercept = (percept: Percept<HearingPerceptPayload>) => {\n      useAppStore.setState((state) => ({\n        hearingPercepts: [...(state.hearingPercepts || []), percept],\n      }));\n    };\n\n    if (advancedHearing) {\n      hearingSense.setOnPerceptCallback(handleHearingPercept);\n      hearingSense.initialize(); // Initialize hearing sense\n    } else {\n      hearingSense.terminate();\n      hearingSense.setOnPerceptCallback(null);\n    }\n\n    return () => {\n      hearingSense.terminate();\n      hearingSense.setOnPerceptCallback(null);\n    };\n  }, [advancedHearing, audioCtx, micStream]);\n\n  // Load MediaPipe models\n  const { models } = useMediaPipeModels();\n\n  // Activate hooks - must be called unconditionally at top level\n  // MediaPipe Vision Tasks\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  useFaceLandmarker(videoRef.current!, models.faceLandmarker);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  useHandLandmarker(videoRef.current!, models.handLandmarker);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  useObjectDetector(videoRef.current!, models.objectDetector);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  usePoseLandmarker(videoRef.current!, models.poseLandmarker);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  useImageClassifier(videoRef.current!, models.imageClassifier);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  useGestureRecognizer(videoRef.current!, models.gestureRecognizer);\n  // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n  useImageSegmenter(videoRef.current!, models.imageSegmenter);\n  // Image Embedder is available via hook if needed\n  useImageEmbedder(models.imageEmbedder);\n  \n  // MediaPipe Audio Tasks\n  useAudioClassifier(audioCtx, micStream, models.audioClassifier);\n  useWakeWord(audioCtx, micStream);\n  useSpeechResponder();\n  useVoiceIntent();\n  useAlarmTimerScheduler();\n  useWorkflowManager();\n  useSpeechSynthesis(); // Initialiser le hook de synth├¿se vocale\n\n  // Afficher le loading pendant la v├®rification de l'authentification\n  if (isLoading) {\n    return (\n      <div style={{ \n        display: 'flex', \n        alignItems: 'center', \n        justifyContent: 'center', \n        height: '100vh',\n        background: '#f8f9fa'\n      }}>\n        <div style={{ textAlign: 'center' }}>\n          <h2>­ƒñû Lisa</h2>\n          <p>Chargement...</p>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <ErrorBoundary>\n      <div className=\"relative min-h-screen\">\n        {/* Formulaires d'authentification */}\n        {!isAuthenticated && showAuthForm === 'login' && (\n          <LoginForm\n            onSuccess={() => setShowAuthForm(null)}\n            onSwitchToRegister={() => setShowAuthForm('register')}\n          />\n        )}\n        {!isAuthenticated && showAuthForm === 'register' && (\n          <RegisterForm\n            onSuccess={() => setShowAuthForm(null)}\n            onSwitchToLogin={() => setShowAuthForm('login')}\n          />\n        )}\n\n        {/* Video feed cach├® */}\n        <video\n          ref={videoRef}\n          autoPlay\n          playsInline\n          style={{ position:'absolute', bottom:10, right:10, width:200, borderRadius:8, zIndex: 50 }}\n        />\n        \n        {/* Components syst├¿me en arri├¿re-plan */}\n        <LisaCanvas video={videoRef.current} />\n        <MicIndicator />\n        <PlannerStatus />\n        <Toaster />\n        <ResourceViewer />\n        <PlanExplanationPanel />\n        <MetaHumanCanvas />\n        <ChatInterface />\n\n        {/* Login button si non authentifi├® */}\n        {!isAuthenticated && (\n          <button \n            onClick={() => setShowAuthForm('login')}\n            className=\"fixed bottom-4 left-4 z-50 px-4 py-2 bg-blue-500 hover:bg-blue-600 text-white rounded-lg transition-colors\"\n          >\n            ­ƒöÉ Se connecter\n          </button>\n        )}\n\n        {/* Main content - pages routed */}\n        {isAuthenticated ? (\n          <Outlet />\n        ) : (\n          <div style={{ \n            display: 'flex', \n            alignItems: 'center', \n            justifyContent: 'center', \n            height: '100vh',\n            background: 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',\n            color: 'white'\n          }}>\n            <div style={{ textAlign: 'center' }}>\n              <h1 style={{ fontSize: '48px', marginBottom: '20px' }}>­ƒñû Lisa</h1>\n              <p style={{ fontSize: '18px', marginBottom: '30px' }}>Vision & Hearing Assistant</p>\n              <button \n                onClick={() => setShowAuthForm('login')}\n                style={{\n                  padding: '12px 30px',\n                  fontSize: '16px',\n                  background: 'white',\n                  color: '#667eea',\n                  border: 'none',\n                  borderRadius: '8px',\n                  cursor: 'pointer',\n                  fontWeight: 'bold',\n                  transition: 'transform 0.2s'\n                }}\n                onMouseOver={(e) => (e.currentTarget.style.transform = 'scale(1.05)')}\n                onMouseOut={(e) => (e.currentTarget.style.transform = 'scale(1)')}\n              >\n                Se connecter\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n    </ErrorBoundary>\n  );\n}\n\nexport default App\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\PlannerAgent.test.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'agentRegistry' is defined but never used. Allowed unused vars must match /^_/u.","line":3,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":3,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';\nimport { PlannerAgent } from '../agents/PlannerAgent';\nimport { agentRegistry } from '../agents/registry';\nimport type { WorkflowStep } from '../types/Planner';\nimport { saveToStorage, loadFromStorage } from '../utils/storage';\n\n// Mock all dependencies\nvi.mock('../agents/registry', () => ({\n  agentRegistry: {\n    register: vi.fn(),\n    getAgent: vi.fn(),\n    getAllAgents: vi.fn().mockReturnValue([])\n  }\n}));\n\nvi.mock('../utils/storage', () => ({\n  saveToStorage: vi.fn(),\n  loadFromStorage: vi.fn().mockReturnValue(null)\n}));\n\nvi.mock('../utils/buildPlannerPrompt', () => ({\n  buildPlannerPrompt: vi.fn().mockReturnValue('mock prompt')\n}));\n\nvi.mock('../utils/runWorkflowPlan', () => ({\n  runWorkflowPlan: vi.fn().mockImplementation((plan) => {\n    return Promise.resolve({\n      success: true,\n      plan: plan.map(step => ({ ...step, status: 'completed' })),\n      summary: 'Mock workflow executed successfully',\n      totalDuration: 1000\n    });\n  })\n}));\n\nvi.mock('../utils/logger', () => ({\n  logEvent: vi.fn()\n}));\n\n// Mock fetch for LLM calls\nglobal.fetch = vi.fn();\n\ndescribe('PlannerAgent', () => {\n  let plannerAgent: PlannerAgent;\n  let mockResponse: Response;\n  let mockPlan: WorkflowStep[];\n  \n  beforeEach(() => {\n    // Setup environment variable\n    vi.stubEnv('VITE_OPENAI_API_KEY', 'mock-api-key');\n    \n    // Create agent instance\n    plannerAgent = new PlannerAgent();\n    \n    // Setup mock plan\n    mockPlan = [\n      {\n        id: 1,\n        description: 'Test step',\n        agent: 'TestAgent',\n        command: 'testCommand',\n        args: { param: 'value' },\n        dependencies: [],\n        status: 'pending'\n      }\n    ];\n    \n    // Setup mock fetch response\n    mockResponse = {\n      ok: true,\n      json: vi.fn().mockResolvedValue({\n        choices: [\n          {\n            message: {\n              content: JSON.stringify(mockPlan)\n            }\n          }\n        ]\n      })\n    } as unknown as Response;\n    \n    (global.fetch as vi.Mock).mockResolvedValue(mockResponse);\n  });\n  \n  afterEach(() => {\n    vi.clearAllMocks();\n    vi.unstubAllEnvs();\n  });\n  \n  it('should initialize with templates and checkpoints from storage', () => {\n    // Setup mock storage data\n    const mockTemplates = [['template1', mockPlan]];\n    const mockCheckpoints = [['checkpoint1', mockPlan]];\n    \n    (loadFromStorage as vi.Mock)\n      .mockReturnValueOnce(mockTemplates)\n      .mockReturnValueOnce(mockCheckpoints);\n    \n    const agent = new PlannerAgent();\n    \n    // Verify templates and checkpoints were loaded\n    expect(agent.getTemplates()).toEqual(['template1']);\n    expect(agent.getCheckpoints()).toEqual(['checkpoint1']);\n  });\n  \n  it('should generate and execute a new plan', async () => {\n    const result = await plannerAgent.execute({\n      request: 'Test request'\n    });\n    \n    // Verify successful execution\n    expect(result.success).toBe(true);\n    expect(result.output).toContain('Mock workflow executed successfully');\n    \n    // Verify LLM was called\n    expect(global.fetch).toHaveBeenCalledWith(\n      'https://api.openai.com/v1/chat/completions',\n      expect.objectContaining({\n        method: 'POST',\n        headers: expect.objectContaining({\n          'Authorization': 'Bearer mock-api-key'\n        })\n      })\n    );\n  });\n  \n  it('should save and load templates', () => {\n    // Save template\n    plannerAgent.saveAsTemplate('test-template', mockPlan);\n    \n    // Verify storage was called\n    expect(saveToStorage).toHaveBeenCalledWith(\n      'planner_templates',\n      expect.anything()\n    );\n    \n    // Mock the template retrieval\n    (plannerAgent as any).workflowTemplates = new Map([\n      ['test-template', mockPlan]\n    ]);\n    \n    // Load template\n    const loadedPlan = plannerAgent.loadTemplate('test-template');\n    \n    // Verify deep copy was returned\n    expect(loadedPlan).toEqual(mockPlan);\n    expect(loadedPlan).not.toBe(mockPlan); // Different reference\n  });\n  \n  it('should create and resume from checkpoints', () => {\n    // Create checkpoint\n    const checkpointId = plannerAgent.createCheckpoint(mockPlan);\n    \n    // Verify storage was called\n    expect(saveToStorage).toHaveBeenCalledWith(\n      'planner_checkpoints',\n      expect.anything()\n    );\n    \n    // Mock the checkpoint retrieval\n    (plannerAgent as any).workflowCheckpoints = new Map([\n      [checkpointId, mockPlan]\n    ]);\n    \n    // Resume from checkpoint\n    const resumedPlan = plannerAgent.resumeFromCheckpoint(checkpointId);\n    \n    // Verify deep copy was returned\n    expect(resumedPlan).toEqual(mockPlan);\n    expect(resumedPlan).not.toBe(mockPlan); // Different reference\n  });\n  \n  it('should handle API key configuration errors', async () => {\n    // Remove API key\n    vi.unstubAllEnvs();\n    \n    const result = await plannerAgent.execute({\n      request: 'Test request'\n    });\n    \n    // Verify error was returned\n    expect(result.success).toBe(false);\n    expect(result.error).toContain('OpenAI API key is not configured');\n  });\n  \n  it('should handle template not found errors', () => {\n    expect(() => plannerAgent.loadTemplate('non-existent')).toThrow(/not found/);\n  });\n  \n  it('should handle checkpoint not found errors', () => {\n    expect(() => plannerAgent.resumeFromCheckpoint('non-existent')).toThrow(/not found/);\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\alarmStore.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\buildPlannerPrompt.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\handleAgentError.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\hooksRemaining.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\integration\\appStartup.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\logger.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\robotRoutes.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\rosBridgeService.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\runWorkflowPlan.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\todoStore.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\useFaceLandmarker.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\useSpeechResponder.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\visionAudioStore.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\visionSense.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\__tests__\\zustandSelectors.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\AgentRegistry.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2590,2593],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2590,2593],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2604,2607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2604,2607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * The central registry for all agents in the system.\n * This follows the Singleton pattern to ensure only one instance exists.\n */\nimport type { BaseAgent } from './types';\nimport { lazyAgentLoader } from './LazyAgentLoader.js';\n\nclass AgentRegistry {\n  private static instance: AgentRegistry;\n  private agents: Map<string, BaseAgent> = new Map<string, BaseAgent>();\n\n  // Private constructor to prevent direct instantiation.\n  private constructor() {}\n\n  /**\n   * Returns the singleton instance of the registry.\n   */\n  public static getInstance(): AgentRegistry {\n    if (!AgentRegistry.instance) {\n      AgentRegistry.instance = new AgentRegistry();\n    }\n    return AgentRegistry.instance;\n  }\n\n  /**\n   * Registers a new agent in the registry.\n   * Throws an error if an agent with the same name is already registered.\n   * @param agent - The agent instance to register.\n   */\n  public register(agent: BaseAgent): void {\n    if (this.agents.has(agent.name)) {\n      console.warn(`Agent with name \"${agent.name}\" is already registered.`);\n      return;\n    }\n    this.agents.set(agent.name, agent);\n  }\n\n  /**\n   * Retrieves an agent by its unique name.\n   * Uses lazy loading if agent is not already loaded.\n   * @param name - The name of the agent to retrieve.\n   * @returns The agent instance, or undefined if not found.\n   */\n  public async getAgent(name: string): Promise<BaseAgent | undefined> {\n    // Check if agent is already loaded\n    if (this.agents.has(name)) {\n      return this.agents.get(name);\n    }\n\n    // Try to lazy load the agent\n    try {\n      const agent = await lazyAgentLoader.loadAgent(name);\n      this.agents.set(name, agent);\n      return agent;\n    } catch (error) {\n      console.error(`Failed to load agent ${name}:`, error);\n      return undefined;\n    }\n  }\n\n  /**\n   * Synchronous version - only returns already loaded agents\n   * @param name - The name of the agent to retrieve.\n   * @returns The agent instance, or undefined if not found.\n   */\n  public getLoadedAgent(name: string): BaseAgent | undefined {\n    return this.agents.get(name);\n  }\n\n  /**\n   * Check if an agent exists in the registry.\n   * @param name - The name of the agent to check.\n   * @returns Boolean indicating whether the agent exists.\n   */\n  public hasAgent(name: string): boolean {\n    return this.agents.has(name);\n  }\n\n  /**\n   * Execute a method on an agent.\n   * @param name - The name of the agent to execute.\n   * @param props - The properties to pass to the agent.\n   * @returns The result of the execution.\n   */\n  public async execute(name: string, props: any): Promise<any> {\n    const agent = await this.getAgent(name);\n    if (!agent) {\n      return {\n        success: false,\n        output: null,\n        error: `Agent ${name} not found`\n      };\n    }\n    return await agent.execute(props);\n  }\n\n  /**\n   * Returns an array of all registered agents.\n   */\n  public getAllAgents(): BaseAgent[] {\n    return Array.from(this.agents.values());\n  }\n\n  /**\n   * Returns a list of all registered agents.\n   */\n  public listAgents(): BaseAgent[] {\n    return Array.from(this.agents.values());\n  }\n}\n\n// Export a single instance of the registry for use throughout the application.\nexport const agentRegistry = AgentRegistry.getInstance();\n\n// Note: Agents are now loaded lazily via LazyAgentLoader\n// No need to register them at startup - they'll be loaded on demand\n\nexport default AgentRegistry;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\AudioAnalysisAgent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\CalendarAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":204,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":204,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6480,6483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6480,6483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6586,6589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6586,6589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":237,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":237,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7480,7483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7480,7483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":253,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":253,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7913,7916],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7913,7916],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":294,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":294,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9302,9305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9302,9305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":325,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":325,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10181,10184],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10181,10184],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":463,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":463,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14646,14649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14646,14649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":499,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":499,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15792,15795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15792,15795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":508,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":508,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16002,16005],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16002,16005],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":531,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":531,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16924,16927],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16924,16927],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":540,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":540,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17176,17179],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17176,17179],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":603,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":603,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19333,19336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19333,19336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":612,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":612,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19577,19580],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19577,19580],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":682,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":682,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21963,21966],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21963,21966],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":691,"column":106,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":691,"endColumn":109,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[22240,22243],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[22240,22243],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":754,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":754,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24340,24343],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24340,24343],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":776,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":776,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[24953,24956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[24953,24956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":17,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CalendarAgent - Manages calendar events and scheduling\n * \n * This agent handles calendar operations including creating, listing, and managing events\n * via the Google Calendar API.\n */\n\nimport { AgentDomains } from './types';\nimport { z } from 'zod';\nimport type {\n  AgentCapability,\n  AgentExecuteProps,\n  AgentExecuteResult, \n  AgentParameter,\n  BaseAgent\n} from './types';\nimport { agentRegistry } from './registry';\n\n/**\n * Supported calendar intents\n */\nexport const CreateEventParamsSchema = z.object({\n  summary: z.string().min(1, 'Event summary/title is required'),\n  start: z.object({\n    dateTime: z.string().datetime(),\n    timeZone: z.string().optional(),\n  }).refine(data => new Date(data.dateTime).toString() !== 'Invalid Date', { message: 'Invalid start date/time' }),\n  end: z.object({\n    dateTime: z.string().datetime(),\n    timeZone: z.string().optional(),\n  }).refine(data => new Date(data.dateTime).toString() !== 'Invalid Date', { message: 'Invalid end date/time' }),\n  description: z.string().optional(),\n  location: z.string().optional(),\n  attendees: z.array(z.object({ email: z.string().email(), name: z.string().optional() })).optional(),\n}).refine(data => new Date(data.end.dateTime) > new Date(data.start.dateTime), { message: 'Event end time must be after start time' });\n\nexport const ListEventsParamsSchema = z.object({\n  period: z.enum(['today', 'tomorrow', 'week', 'month', 'custom']).default('today'),\n  startDate: z.string().datetime().optional(),\n  endDate: z.string().datetime().optional(),\n}).refine(data => {\n  if (data.period === 'custom' && (!data.startDate || !data.endDate)) {\n    return false; // Custom period requires both start and end dates\n  }\n  return true;\n}, { message: 'Custom period requires both startDate and endDate' });\n\nexport const DeleteEventParamsSchema = z.object({\n  eventId: z.string().min(1, 'Event ID is required'),\n});\n\nexport const UpdateEventParamsSchema = z.object({\n  eventId: z.string().min(1, 'Event ID is required'),\n  eventData: CreateEventParamsSchema.partial(), // Partial allows updating only some fields\n});\n\nexport const FindAvailableTimeParamsSchema = z.object({\n  duration: z.number().int().positive('Duration must be a positive number of minutes'),\n  date: z.string().datetime().optional(),\n});\n\nexport type CalendarIntent = \n  | 'create_event'\n  | 'list_events'\n  | 'delete_event'\n  | 'update_event'\n  | 'find_available_time';\n  \n/**\n * Time period types\n */\nexport type TimePeriod = 'today' | 'tomorrow' | 'week' | 'month' | 'custom';\n\n/**\n * Calendar event interface\n */\nexport interface CalendarEvent {\n  id?: string;\n  summary: string;\n  description?: string;\n  location?: string;\n  start: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  end: {\n    dateTime: string;\n    timeZone?: string;\n  };\n  attendees?: Array<{ email: string; name?: string }>;\n  reminders?: {\n    useDefault: boolean;\n    overrides?: Array<{\n      method: 'email' | 'popup';\n      minutes: number;\n    }>;\n  };\n}\n\n/**\n * Helper function to get auth token from session storage\n * This is a temporary solution. In the future, the agent should handle its own auth.\n */\nfunction getAuthToken(): string | null {\n  return sessionStorage.getItem('google_access_token');\n}\n\nexport class CalendarAgent implements BaseAgent {\n  name = 'CalendarAgent';\n  description = 'G├¿re les ├®v├®nements du calendrier Google, y compris la cr├®ation, la mise ├á jour et la consultation';\n  version = '1.1.0';\n  domain = AgentDomains.PRODUCTIVITY;\n  capabilities = [\n    'create_calendar_event',\n    'list_calendar_events',\n    'delete_calendar_event',\n    'update_calendar_event',\n    'find_available_time'\n  ];\n  requiresAuthentication = true;\n\n  // Define inputs and outputs for the workflow editor\n  inputs = [\n    { id: 'trigger', type: 'any', label: 'D├®clencheur' },\n  ];\n\n  outputs = [\n    { id: 'result', type: 'object', label: 'R├®sultat' },\n    { id: 'error', type: 'object', label: 'Erreur' },\n  ];\n\n  // Define a combined config schema for all intents\n  configSchema = z.discriminatedUnion('intent', [\n    CreateEventParamsSchema.extend({ intent: z.literal('create_event') }),\n    ListEventsParamsSchema.extend({ intent: z.literal('list_events') }),\n    DeleteEventParamsSchema.extend({ intent: z.literal('delete_event') }),\n    UpdateEventParamsSchema.extend({ intent: z.literal('update_event') }),\n    FindAvailableTimeParamsSchema.extend({ intent: z.literal('find_available_time') }),\n  ]);\n\n  /**\n   * Main execution method for the agent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as CalendarIntent || props.command as CalendarIntent;\n    const parameters = props.parameters || {};\n\n    try {\n      // Validate input using Zod schemas\n      let validationResult;\n      switch (intent) {\n        case 'create_event':\n          validationResult = CreateEventParamsSchema.safeParse(parameters);\n          break;\n        case 'list_events':\n          validationResult = ListEventsParamsSchema.safeParse(parameters);\n          break;\n        case 'delete_event':\n          validationResult = DeleteEventParamsSchema.safeParse(parameters);\n          break;\n        case 'update_event':\n          validationResult = UpdateEventParamsSchema.safeParse(parameters);\n          break;\n        case 'find_available_time':\n          validationResult = FindAvailableTimeParamsSchema.safeParse(parameters);\n          break;\n        default:\n          validationResult = { success: false, error: 'Unsupported intent' };\n      }\n\n      if (!validationResult.success) {\n        return {\n          success: false,\n          error: validationResult.error.errors.map(err => err.message).join(', '),\n          output: null,\n          metadata: {\n            executionTime: Date.now() - startTime\n          }\n        };\n      }\n\n      // Check authentication\n      const token = getAuthToken();\n      if (!token) {\n        return {\n          success: false,\n          error: 'Not authenticated with Google Calendar',\n          output: {\n            authRequired: true,\n            authProvider: 'google',\n            authScope: 'https://www.googleapis.com/auth/calendar'\n          },\n          metadata: {\n            executionTime: Date.now() - startTime\n          }\n        };\n      }\n\n      // Process intent\n      let result;\n      switch (intent) {\n        case 'create_event':\n          result = await this.createEvent(parameters as any);\n          break;\n        case 'list_events':\n          result = await this.listEvents(parameters as any);\n          break;\n        case 'delete_event':\n          result = await this.deleteEvent(parameters.eventId);\n          break;\n        case 'update_event':\n          result = await this.updateEvent(parameters.eventId, parameters.eventData);\n          break;\n        case 'find_available_time':\n          result = await this.findAvailableTime(parameters.duration, parameters.date);\n          break;\n        default:\n          return {\n            success: false,\n            output: `Intent non support├®: ${intent}`,\n            error: new Error('UNSUPPORTED_INTENT'),\n            metadata: {\n              executionTime: Date.now() - startTime\n            }\n          };\n      }\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          source: `calendar-${intent}`\n        }\n      };\n    } catch (error: any) {\n      console.error(`CalendarAgent error executing ${props.intent || props.command}:`, error);\n      return {\n        success: false,\n        error: error.message || 'Unknown error occurred',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime\n        }\n      };\n    }\n  }\n\n  /**\n   * Determines if this agent can handle a specific query\n   */\n  async canHandle(query: string, _context?: any): Promise<number> {\n    const lowerQuery = query.toLowerCase();\n    \n    const calendarKeywords = [\n      'calendar', 'calendrier', 'agenda', 'schedule', 'planifier',\n      'event', '├®v├®nement', 'meeting', 'r├®union', 'appointment', 'rendez-vous',\n      'reminder', 'rappel', 'schedule', 'planifier',\n      'booking', 'r├®servation',\n      'available', 'availability', 'disponible', 'disponibilit├®'\n    ];\n    \n    const calendarRegexes = [\n      /add (an? )?event|create (an? )?event|schedule (an? )?meeting/i,\n      /ajouter (un )?├®v├®nement|cr├®er (un )?├®v├®nement|planifier (une )?r├®union/i,\n      /what('s| is) on my calendar|what do i have scheduled/i,\n      /qu('| )est-ce qu('| )il y a dans mon (calendrier|agenda)/i,\n      /find (an? )?(available|free) (time|slot)/i,\n      /trouver (un )?cr├®neau (disponible|libre)/i\n    ];\n    \n    // Check for keyword matches\n    for (const keyword of calendarKeywords) {\n      if (lowerQuery.includes(keyword)) {\n        return 0.6; // 60% confidence\n      }\n    }\n    \n    // Check for regex patterns\n    for (const regex of calendarRegexes) {\n      if (regex.test(lowerQuery)) {\n        return 0.85; // 85% confidence\n      }\n    }\n    \n    return 0; // Cannot handle\n  }\n  \n  /**\n   * Returns required parameters for a specific task\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    let schema: z.ZodObject<any> | undefined;\n    switch (task) {\n      case 'create_event':\n        schema = CreateEventParamsSchema;\n        break;\n      case 'list_events':\n        schema = ListEventsParamsSchema;\n        break;\n      case 'delete_event':\n        schema = DeleteEventParamsSchema;\n        break;\n      case 'update_event':\n        schema = UpdateEventParamsSchema;\n        break;\n      case 'find_available_time':\n        schema = FindAvailableTimeParamsSchema;\n        break;\n      default:\n        return [];\n    }\n\n    if (!schema) return [];\n\n    const params: AgentParameter[] = [];\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key] as z.ZodAny;\n      const isOptional = fieldSchema.isOptional();\n      const isNullable = fieldSchema.isNullable();\n      const isRequired = !isOptional && !isNullable;\n\n      let type: string;\n      let defaultValue: any;\n      let enumValues: string[] | undefined;\n\n      let baseSchema = fieldSchema;\n      while (baseSchema instanceof z.ZodOptional || baseSchema instanceof z.ZodNullable) {\n        baseSchema = baseSchema.unwrap();\n      }\n\n      switch (baseSchema._def.typeName) {\n        case z.ZodString.name:\n          type = 'string';\n          if (baseSchema instanceof z.ZodEnum) {\n            enumValues = baseSchema._def.values;\n          }\n          break;\n        case z.ZodNumber.name:\n          type = 'number';\n          break;\n        case z.ZodBoolean.name:\n          type = 'boolean';\n          break;\n        case z.ZodObject.name:\n          type = 'object';\n          break;\n        case z.ZodArray.name:\n          type = 'array';\n          break;\n        default:\n          type = 'any';\n      }\n\n      // Extract default value if available\n      if (fieldSchema._def.defaultValue !== undefined) {\n        defaultValue = fieldSchema._def.defaultValue();\n      } else if (fieldSchema._def.typeName === z.ZodEnum.name && fieldSchema._def.default !== undefined) {\n        defaultValue = fieldSchema._def.default;\n      }\n\n      params.push({\n        name: key,\n        type: type,\n        required: isRequired,\n        description: fieldSchema.description || '',\n        defaultValue: defaultValue,\n        enum: enumValues,\n      });\n    }\n    return params;\n  }\n  \n  /**\n   * Returns detailed capability information\n   */\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'Create Calendar Event',\n        description: 'Creates a new event in Google Calendar',\n        requiredParameters: await this.getRequiredParameters('create_event')\n      },\n      {\n        name: 'List Calendar Events',\n        description: 'Lists events from Google Calendar for a specified period',\n        requiredParameters: await this.getRequiredParameters('list_events')\n      },\n      {\n        name: 'Delete Calendar Event',\n        description: 'Deletes an event from Google Calendar',\n        requiredParameters: await this.getRequiredParameters('delete_event')\n      },\n      {\n        name: 'Update Calendar Event',\n        description: 'Updates an existing event in Google Calendar',\n        requiredParameters: await this.getRequiredParameters('update_event')\n      },\n      {\n        name: 'Find Available Time',\n        description: 'Finds available time slots in calendar',\n        requiredParameters: await this.getRequiredParameters('find_available_time')\n      }\n    ];\n  }\n\n  /**\n   * Validates input parameters\n   */\n  async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const intent = props.intent as CalendarIntent || props.command as CalendarIntent;\n    const parameters = props.parameters || {};\n    const errors: string[] = [];\n    \n    switch (intent) {\n      case 'create_event':\n        if (!parameters.summary) {\n          errors.push('Event summary/title is required');\n        }\n        if (!parameters.start?.dateTime) {\n          errors.push('Event start date/time is required');\n        }\n        if (!parameters.end?.dateTime) {\n          errors.push('Event end date/time is required');\n        }\n        // Validate that end time is after start time\n        if (parameters.start?.dateTime && parameters.end?.dateTime) {\n          const startTime = new Date(parameters.start.dateTime);\n          const endTime = new Date(parameters.end.dateTime);\n          if (endTime <= startTime) {\n            errors.push('Event end time must be after start time');\n          }\n        }\n        break;\n      case 'list_events':\n        if (parameters.period && !['today', 'week', 'month', 'custom'].includes(parameters.period)) {\n          errors.push('Invalid period. Must be one of: today, week, month, custom');\n        }\n        break;\n      case 'delete_event':\n      case 'update_event':\n        if (!parameters.eventId) {\n          errors.push('Event ID is required');\n        }\n        break;\n      case 'find_available_time':\n        if (!parameters.duration || isNaN(Number(parameters.duration)) || Number(parameters.duration) <= 0) {\n          errors.push('Valid duration in minutes is required');\n        }\n        break;\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined\n    };\n  }\n\n  /**\n   * Creates a new event in Google Calendar\n   */\n  private async createEvent(props: CalendarEvent): Promise<any> {\n    const token = getAuthToken();\n    if (!token) return { success: false, error: 'Not authenticated', output: null };\n\n    try {\n      // Ensure timezone is set\n      const eventData = {\n        ...props,\n        start: { ...props.start, timeZone: props.start.timeZone || 'Europe/Paris' },\n        end: { ...props.end, timeZone: props.end.timeZone || 'Europe/Paris' },\n      };\n      \n      const response = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {\n        method: 'POST',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(eventData),\n      });\n\n      if (!response.ok) {\n        const error = await response.json();\n        throw new Error(error.error?.message || 'Failed to create event');\n      }\n\n      const newEvent = await response.json();\n      return {\n        id: newEvent.id,\n        summary: newEvent.summary,\n        start: newEvent.start,\n        end: newEvent.end,\n        htmlLink: newEvent.htmlLink,\n        status: 'confirmed',\n        created: true\n      };\n    } catch (error: any) {\n      console.error('Error creating calendar event:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Deletes an event from Google Calendar\n   */\n  private async deleteEvent(eventId: string): Promise<any> {\n    const token = getAuthToken();\n    if (!token) throw new Error('Not authenticated with Google Calendar');\n    \n    try {\n      const response = await fetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`, {\n        method: 'DELETE',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n        }\n      });\n      \n      if (!response.ok) {\n        // For DELETE, if it returns 404, the event might be already deleted\n        if (response.status === 404) {\n          return { deleted: true, status: 'not_found', message: 'Event not found or already deleted' };\n        }\n        \n        const error = await response.json().catch(() => ({ error: { message: 'Unknown error' }}));\n        throw new Error(error.error?.message || `Failed to delete event: ${response.statusText}`);\n      }\n      \n      return { deleted: true, status: 'success', eventId };\n    } catch (error: any) {\n      console.error('Error deleting calendar event:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Updates an existing event in Google Calendar\n   */\n  private async updateEvent(eventId: string, eventData: Partial<CalendarEvent>): Promise<any> {\n    const token = getAuthToken();\n    if (!token) throw new Error('Not authenticated with Google Calendar');\n    \n    try {\n      // First, get the current event to merge with updates\n      const getResponse = await fetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`, {\n        headers: {\n          'Authorization': `Bearer ${token}`,\n        }\n      });\n      \n      if (!getResponse.ok) {\n        if (getResponse.status === 404) {\n          throw new Error('Event not found');\n        }\n        const error = await getResponse.json();\n        throw new Error(error.error?.message || 'Failed to fetch event for updating');\n      }\n      \n      const currentEvent = await getResponse.json();\n      \n      // Merge current event with updates\n      const updatedEvent = {\n        ...currentEvent,\n        ...eventData,\n        // Handle nested objects carefully\n        start: eventData.start ? {\n          ...currentEvent.start,\n          ...eventData.start,\n          timeZone: (eventData.start?.timeZone || currentEvent.start?.timeZone || 'Europe/Paris')\n        } : currentEvent.start,\n        end: eventData.end ? {\n          ...currentEvent.end,\n          ...eventData.end,\n          timeZone: (eventData.end?.timeZone || currentEvent.end?.timeZone || 'Europe/Paris')\n        } : currentEvent.end\n      };\n      \n      // Send update to Google Calendar\n      const updateResponse = await fetch(`https://www.googleapis.com/calendar/v3/calendars/primary/events/${eventId}`, {\n        method: 'PUT',\n        headers: {\n          'Authorization': `Bearer ${token}`,\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(updatedEvent),\n      });\n      \n      if (!updateResponse.ok) {\n        const error = await updateResponse.json();\n        throw new Error(error.error?.message || 'Failed to update event');\n      }\n      \n      const result = await updateResponse.json();\n      return {\n        id: result.id,\n        summary: result.summary,\n        start: result.start,\n        end: result.end,\n        updated: true,\n        htmlLink: result.htmlLink\n      };\n    } catch (error: any) {\n      console.error('Error updating calendar event:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Finds available time slots in the calendar\n   */\n  private async findAvailableTime(durationMinutes: number, date?: string): Promise<any> {\n    const token = getAuthToken();\n    if (!token) throw new Error('Not authenticated with Google Calendar');\n    \n    try {\n      // Parse search date\n      const searchDate = date ? new Date(date) : new Date();\n      const startOfDay = new Date(searchDate);\n      startOfDay.setHours(9, 0, 0, 0); // Default start at 9:00 AM\n      \n      const endOfDay = new Date(searchDate);\n      endOfDay.setHours(18, 0, 0, 0); // Default end at 6:00 PM\n      \n      // Get events for the search date\n      const response = await fetch(\n        `https://www.googleapis.com/calendar/v3/calendars/primary/events` +\n          `?timeMin=${startOfDay.toISOString()}` +\n          `&timeMax=${endOfDay.toISOString()}` +\n          '&singleEvents=true' +\n          '&orderBy=startTime',\n        {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        }\n      );\n      \n      if (!response.ok) {\n        throw new Error('Failed to fetch events for availability check');\n      }\n      \n      const data = await response.json();\n      const events = data.items || [];\n      \n      // Find available slots\n      const availableSlots = [];\n      let currentTime = new Date(startOfDay);\n      \n      // Convert duration from minutes to milliseconds\n      const durationMs = durationMinutes * 60 * 1000;\n      \n      // Loop through events to find gaps\n      for (let i = 0; i <= events.length; i++) {\n        const nextEventStart = i < events.length \n          ? new Date(events[i].start.dateTime || events[i].start.date) \n          : new Date(endOfDay);\n        \n        const gap = nextEventStart.getTime() - currentTime.getTime();\n        \n        // Check if gap is large enough for the requested duration\n        if (gap >= durationMs) {\n          availableSlots.push({\n            start: new Date(currentTime).toISOString(),\n            end: new Date(currentTime.getTime() + durationMs).toISOString(),\n            durationMinutes\n          });\n        }\n        \n        // Move current time to the end of this event\n        if (i < events.length) {\n          currentTime = new Date(events[i].end.dateTime || events[i].end.date);\n        }\n      }\n      \n      return {\n        date: searchDate.toISOString().split('T')[0],\n        durationRequested: durationMinutes,\n        availableSlots,\n        numberOfSlots: availableSlots.length\n      };\n    } catch (error: any) {\n      console.error('Error finding available time:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Lists events from Google Calendar for a specified period\n   */\n  private async listEvents(props: { period: TimePeriod, startDate?: string, endDate?: string }): Promise<any> {\n    const token = getAuthToken();\n    if (!token) throw new Error('Not authenticated with Google Calendar');\n\n    try {\n      const now = new Date();\n      let timeMin = new Date(now);\n      let timeMax = new Date(now);\n      \n      // Set appropriate time range based on period\n      switch(props.period) {\n        case 'today':\n          // Start from now, end at end of today\n          timeMax.setHours(23, 59, 59, 999);\n          break;\n        case 'tomorrow':\n          // Start from start of tomorrow, end at end of tomorrow\n          timeMin.setDate(now.getDate() + 1);\n          timeMin.setHours(0, 0, 0, 0);\n          timeMax.setDate(now.getDate() + 1);\n          timeMax.setHours(23, 59, 59, 999);\n          break;\n        case 'week':\n          // Start from now, end at 7 days from now\n          timeMax.setDate(now.getDate() + 7);\n          break;\n        case 'month':\n          // Start from now, end at 30 days from now\n          timeMax.setDate(now.getDate() + 30);\n          break;\n        case 'custom':\n          // Use custom date range if provided\n          if (props.startDate) {\n            timeMin = new Date(props.startDate);\n          }\n          if (props.endDate) {\n            timeMax = new Date(props.endDate);\n          }\n          break;\n      }\n\n      const response = await fetch(\n        `https://www.googleapis.com/calendar/v3/calendars/primary/events` +\n          `?timeMin=${timeMin.toISOString()}` +\n          `&timeMax=${timeMax.toISOString()}` +\n          '&singleEvents=true' +\n          '&orderBy=startTime',\n        {\n          headers: {\n            Authorization: `Bearer ${token}`,\n          },\n        }\n      );\n\n      if (!response.ok) {\n        const error = await response.json().catch(() => ({ error: { message: 'Failed to parse error response' }}));\n        throw new Error(error.error?.message || `Failed to fetch events: ${response.statusText}`);\n      }\n\n      const data = await response.json();\n      const events = data.items || [];\n      \n      // Format events for cleaner output\n      const formattedEvents = events.map((event: any) => ({\n        id: event.id,\n        summary: event.summary || 'Unnamed event',\n        description: event.description,\n        start: event.start,\n        end: event.end,\n        location: event.location,\n        htmlLink: event.htmlLink,\n        creator: event.creator,\n        attendees: event.attendees,\n        status: event.status\n      }));\n      \n      return {\n        period: props.period,\n        timeRange: {\n          start: timeMin.toISOString(),\n          end: timeMax.toISOString()\n        },\n        events: formattedEvents,\n        count: formattedEvents.length\n      };\n    } catch (error: any) {\n      console.error('Error listing calendar events:', error);\n      throw error;\n    }\n  }\n}\n\n// Register a valid instance of the agent with the registry.\nconst calendarAgent = new CalendarAgent();\n// Add valid property required by BaseAgent interface\nObject.defineProperty(calendarAgent, 'valid', {\n  value: true,\n  writable: false,\n  enumerable: true\n});\nagentRegistry.register(calendarAgent);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\CodeInterpreterAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1175,1178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1175,1178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CodeInterpreterAgent: An agent that uses the CodeInterpreterTool to execute Python code.\n */\nimport { agentRegistry } from './registry';\nimport { CodeInterpreterTool } from '../tools/CodeInterpreterTool';\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult } from './types';\n\nexport class CodeInterpreterAgent implements BaseAgent {\n  name = 'CodeInterpreterAgent';\n  description = 'Executes Python code to perform calculations, data analysis, or other programmatic tasks. Use this for any task that involves running code.';\n  private tool: CodeInterpreterTool;\n\n  constructor() {\n    this.tool = new CodeInterpreterTool();\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { code } = props;\n\n    if (!code || typeof code !== 'string') {\n      return { success: false, error: 'A valid code string must be provided.', output: null };\n    }\n\n    try {\n      const result = await this.tool.execute({ code });\n      if (result.success) {\n        return { success: true, output: result.output };\n      }\n      return { success: false, error: result.error ?? 'An unknown error occurred.', output: null };\n    } catch (error: any) {\n      console.error(`${this.name} execution failed:`, error);\n      return { success: false, error: error.message, output: null };\n    }\n  }\n}\n\nagentRegistry.register(new CodeInterpreterAgent());\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\ConditionAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1127,1130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1127,1130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomains } from \"./types\";\n\nexport class ConditionAgent implements BaseAgent {\n  name = \"ConditionAgent\";\n  description = \"Evaluates conditions in workflows.\";\n  version = \"0.1.0\";\n  domain = AgentDomains.ANALYSIS;\n  capabilities = [\"evaluateCondition\"];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { intent, parameters } = props;\n\n    if (intent !== \"evaluateCondition\") {\n      return { success: false, output: null, error: `Unknown intent: ${intent}` };\n    }\n\n    const { condition, input, context } = parameters;\n\n    try {\n      // This is a placeholder for actual expression evaluation.\n      // In a real system, you'd use a secure sandbox or a dedicated code execution agent.\n      const func = new Function('input', 'context', `with (context) { return Boolean(${condition}); }`);\n      const isTrue = func(input, context);\n\n      return {\n        success: true,\n        output: {\n          result: isTrue,\n          path: isTrue ? 'true' : 'false',\n          original: input\n        }\n      };\n    } catch (error: any) {\n      return { success: false, output: null, error: `Condition evaluation failed: ${error.message}` };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\ContentGeneratorAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3866,3869],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3866,3869],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":384,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":384,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10513,10516],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10513,10516],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":419,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":419,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11640,11643],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11640,11643],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":446,"column":99,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":446,"endColumn":102,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12582,12585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12582,12585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":466,"column":136,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":466,"endColumn":139,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13304,13307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13304,13307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":501,"column":138,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":501,"endColumn":141,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14378,14381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14378,14381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":540,"column":121,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":540,"endColumn":124,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15504,15507],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15504,15507],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ContentGeneratorAgent - Creates textual and creative content\n * \n * This agent handles text generation tasks like summarization, translation,\n * rewriting, and creative content generation using LLM APIs.\n */\n\nimport { AgentDomains } from './types';\nimport type { \n  AgentCapability, \n  AgentExecuteProps,\n  AgentExecuteResult, \n  AgentParameter, \n  BaseAgent \n} from './types';\n\n/**\n * Supported content generation intents\n */\nexport type ContentGenerationIntent = \n  | 'summarize'\n  | 'translate'\n  | 'rewrite'\n  | 'generate'\n  | 'draft_email'\n  | 'draft_message';\n\n/**\n * Style options for text generation\n */\nexport type TextStyle = 'formal' | 'casual' | 'creative' | 'technical' | 'persuasive';\n\n/**\n * Length options for text generation\n */\nexport type TextLength = 'short' | 'medium' | 'long';\n\n/**\n * Agent for generating and manipulating text content\n */\nexport class ContentGeneratorAgent implements BaseAgent {\n  name = 'ContentGeneratorAgent';\n  description = 'G├®n├¿re et manipule du contenu textuel avec diverses options stylistiques';\n  version = '1.0.0';\n  domain = AgentDomains.ANALYSIS;\n  capabilities = [\n    'summarization', \n    'translation', \n    'content_generation',\n    'email_drafting',\n    'text_rewriting'\n  ];\n\n  /**\n   * Main execution method for the agent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as ContentGenerationIntent;\n    const parameters = props.parameters || {};\n    const language = props.language || 'fr';\n\n    try {\n      let result;\n      switch (intent) {\n        case 'summarize':\n          result = await this.summarizeText(\n            parameters.text,\n            parameters.length || 'medium',\n            language\n          );\n          break;\n        case 'translate':\n          result = await this.translateText(\n            parameters.text,\n            parameters.targetLanguage || 'en',\n            parameters.sourceLanguage\n          );\n          break;\n        case 'rewrite':\n          result = await this.rewriteText(\n            parameters.text,\n            parameters.style || 'casual',\n            language\n          );\n          break;\n        case 'generate':\n          result = await this.generateContent(\n            parameters.prompt,\n            parameters.style || 'casual',\n            parameters.length || 'medium',\n            language\n          );\n          break;\n        case 'draft_email':\n          result = await this.draftEmail(\n            parameters.subject,\n            parameters.recipient,\n            parameters.points,\n            parameters.style || 'formal',\n            language\n          );\n          break;\n        case 'draft_message':\n          result = await this.draftMessage(\n            parameters.context,\n            parameters.points,\n            parameters.style || 'casual',\n            language\n          );\n          break;\n        default:\n          return {\n            success: false,\n            output: `Intent non support├®: ${intent}`,\n            error: new Error('UNSUPPORTED_INTENT'),\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          confidence: 0.9,\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error : new Error(String(error)),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Determines if this agent can handle a specific query\n   */\n  async canHandle(query: string, context?: any): Promise<number> {\n    const normalizedQuery = query.toLowerCase();\n    \n    // Keywords related to content generation\n    const contentKeywords = [\n      'r├®sumer', 'r├®sum├®', 'synth├®tiser', 'synth├¿se',\n      'traduire', 'traduction', 'en anglais', 'en espagnol',\n      'r├®├®crire', 'reformuler', 'rephraser',\n      'g├®n├®rer', 'cr├®er un texte', '├®crire',\n      'email', 'courriel', 'mail', 'message'\n    ];\n    \n    // Style keywords\n    const styleKeywords = [\n      'formel', 'professionnel', 'technique',\n      'informel', 'd├®contract├®', 'casual',\n      'cr├®atif', 'original', 'persuasif'\n    ];\n    \n    // Count matches\n    const contentMatches = contentKeywords.filter(keyword => \n      normalizedQuery.includes(keyword)).length;\n      \n    const styleMatches = styleKeywords.filter(keyword => \n      normalizedQuery.includes(keyword)).length;\n    \n    // Calculate confidence score\n    let score = 0;\n    \n    if (contentMatches > 0) {\n      score += Math.min(contentMatches * 0.2, 0.6);\n    }\n    \n    if (styleMatches > 0) {\n      score += Math.min(styleMatches * 0.1, 0.2);\n    }\n    \n    // Additional context boost\n    if (context?.lastAction === 'content_selection' || \n        context?.clipboard?.length > 0) {\n      score += 0.2;\n    }\n    \n    return Math.min(score, 1.0);\n  }\n\n  /**\n   * Returns required parameters for a specific task\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    const normalizedTask = task.toLowerCase();\n    \n    if (normalizedTask.includes('r├®sumer') || normalizedTask.includes('r├®sum├®')) {\n      return [\n        {\n          name: 'text',\n          type: 'string',\n          required: true,\n          description: 'Texte ├á r├®sumer'\n        },\n        {\n          name: 'length',\n          type: 'string',\n          required: false,\n          description: 'Longueur souhait├®e (short, medium, long)',\n          defaultValue: 'medium'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('traduire') || normalizedTask.includes('traduction')) {\n      return [\n        {\n          name: 'text',\n          type: 'string',\n          required: true,\n          description: 'Texte ├á traduire'\n        },\n        {\n          name: 'targetLanguage',\n          type: 'string',\n          required: true,\n          description: 'Langue cible (code ISO)'\n        },\n        {\n          name: 'sourceLanguage',\n          type: 'string',\n          required: false,\n          description: 'Langue source (code ISO, d├®tection automatique si non sp├®cifi├®)'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('email') || normalizedTask.includes('courriel')) {\n      return [\n        {\n          name: 'subject',\n          type: 'string',\n          required: true,\n          description: 'Sujet de l\\'email'\n        },\n        {\n          name: 'recipient',\n          type: 'string',\n          required: true,\n          description: 'Destinataire'\n        },\n        {\n          name: 'points',\n          type: 'array',\n          required: true,\n          description: 'Points cl├®s ├á inclure dans l\\'email'\n        },\n        {\n          name: 'style',\n          type: 'string',\n          required: false,\n          description: 'Style d\\'├®criture',\n          defaultValue: 'formal'\n        }\n      ];\n    }\n    \n    return [];\n  }\n\n  /**\n   * Returns detailed capability information\n   */\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'summarization',\n        description: 'R├®sum├® de textes longs',\n        requiredParameters: [\n          {\n            name: 'text',\n            type: 'string',\n            required: true,\n            description: 'Texte ├á r├®sumer'\n          }\n        ]\n      },\n      {\n        name: 'translation',\n        description: 'Traduction entre diff├®rentes langues',\n        requiredParameters: [\n          {\n            name: 'text',\n            type: 'string',\n            required: true,\n            description: 'Texte ├á traduire'\n          },\n          {\n            name: 'targetLanguage',\n            type: 'string',\n            required: true,\n            description: 'Langue cible'\n          }\n        ]\n      },\n      {\n        name: 'content_generation',\n        description: 'G├®n├®ration de contenu textuel',\n        requiredParameters: [\n          {\n            name: 'prompt',\n            type: 'string',\n            required: true,\n            description: 'Instruction pour la g├®n├®ration'\n          }\n        ]\n      }\n    ];\n  }\n\n  /**\n   * Validates input parameters\n   */\n  async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const errors: string[] = [];\n    const intent = props.intent as ContentGenerationIntent;\n    const parameters = props.parameters || {};\n    \n    switch (intent) {\n      case 'summarize':\n      case 'translate':\n      case 'rewrite':\n        if (!parameters.text || parameters.text.trim().length === 0) {\n          errors.push('Le texte source est requis');\n        }\n        \n        if (intent === 'translate' && !parameters.targetLanguage) {\n          errors.push('La langue cible est requise pour la traduction');\n        }\n        break;\n        \n      case 'generate':\n        if (!parameters.prompt || parameters.prompt.trim().length === 0) {\n          errors.push('Un prompt est requis pour la g├®n├®ration de contenu');\n        }\n        break;\n        \n      case 'draft_email':\n        if (!parameters.subject) {\n          errors.push('Le sujet de l\\'email est requis');\n        }\n        if (!parameters.recipient) {\n          errors.push('Le destinataire de l\\'email est requis');\n        }\n        if (!parameters.points || !Array.isArray(parameters.points) || parameters.points.length === 0) {\n          errors.push('Des points cl├®s sont requis pour r├®diger l\\'email');\n        }\n        break;\n    }\n    \n    // Validate style parameter if provided\n    if (parameters.style && !['formal', 'casual', 'creative', 'technical', 'persuasive'].includes(parameters.style)) {\n      errors.push('Le style doit ├¬tre l\\'un des suivants: formal, casual, creative, technical, persuasive');\n    }\n    \n    // Validate length parameter if provided\n    if (parameters.length && !['short', 'medium', 'long'].includes(parameters.length)) {\n      errors.push('La longueur doit ├¬tre l\\'une des suivantes: short, medium, long');\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined\n    };\n  }\n\n  /**\n   * Summarizes text to a specified length\n   */\n  private async summarizeText(text: string, length: TextLength = 'medium', language: string): Promise<any> {\n    if (!text || text.trim().length === 0) {\n      throw new Error('Texte source requis');\n    }\n    \n    // In a real implementation, this would call an LLM API\n    // Here, we'll simulate a response\n    const wordCount = text.split(/\\s+/).length;\n    let targetWordCount;\n    \n    switch (length) {\n      case 'short':\n        targetWordCount = Math.max(Math.floor(wordCount * 0.1), 50);\n        break;\n      case 'medium':\n        targetWordCount = Math.max(Math.floor(wordCount * 0.25), 100);\n        break;\n      case 'long':\n        targetWordCount = Math.max(Math.floor(wordCount * 0.4), 200);\n        break;\n    }\n\n    const summary = `[Ceci est un r├®sum├® simul├® du texte fourni. Dans une impl├®mentation r├®elle, nous utiliserions un LLM pour g├®n├®rer un r├®sum├® d'environ ${targetWordCount} mots en ${language}.]`;\n    \n    return {\n      originalLength: wordCount,\n      summaryLength: targetWordCount,\n      summary,\n      language\n    };\n  }\n\n  /**\n   * Translates text to the specified target language\n   */\n  private async translateText(text: string, targetLanguage: string, sourceLanguage?: string): Promise<any> {\n    if (!text || text.trim().length === 0) {\n      throw new Error('Texte source requis');\n    }\n    \n    if (!targetLanguage) {\n      throw new Error('Langue cible requise');\n    }\n    \n    // Detect source language if not provided\n    const detectedSourceLanguage = sourceLanguage || this.detectLanguage(text);\n    \n    // In a real implementation, this would call a translation API\n    // Here, we'll simulate a response\n    const translatedText = `[Ceci est une traduction simul├®e de ${detectedSourceLanguage} vers ${targetLanguage}. Dans une impl├®mentation r├®elle, nous utiliserions une API de traduction.]`;\n    \n    return {\n      originalLanguage: detectedSourceLanguage,\n      targetLanguage,\n      translatedText,\n      originalLength: text.split(/\\s+/).length\n    };\n  }\n\n  /**\n   * Rewrites text in the specified style\n   */\n  private async rewriteText(text: string, style: TextStyle = 'casual', language: string): Promise<any> {\n    if (!text || text.trim().length === 0) {\n      throw new Error('Texte source requis');\n    }\n    \n    // In a real implementation, this would call an LLM API\n    // Here, we'll simulate a response\n    const rewrittenText = `[Ceci est une r├®├®criture simul├®e dans un style ${style} en ${language}. Dans une impl├®mentation r├®elle, nous utiliserions un LLM pour reformuler le texte tout en pr├®servant le sens original.]`;\n    \n    return {\n      originalText: text,\n      rewrittenText,\n      style,\n      language\n    };\n  }\n\n  /**\n   * Generates content based on a prompt\n   */\n  private async generateContent(prompt: string, style: TextStyle = 'casual', length: TextLength = 'medium', language: string): Promise<any> {\n    if (!prompt || prompt.trim().length === 0) {\n      throw new Error('Prompt requis');\n    }\n    \n    let targetWordCount;\n    switch (length) {\n      case 'short':\n        targetWordCount = 150;\n        break;\n      case 'medium':\n        targetWordCount = 350;\n        break;\n      case 'long':\n        targetWordCount = 600;\n        break;\n    }\n    \n    // In a real implementation, this would call an LLM API\n    // Here, we'll simulate a response\n    const generatedContent = `[Ceci est un contenu g├®n├®r├® simul├® ├á partir du prompt \"${prompt}\" dans un style ${style} et une longueur ${length} (environ ${targetWordCount} mots) en ${language}. Dans une impl├®mentation r├®elle, nous utiliserions un LLM pour g├®n├®rer du contenu original.]`;\n    \n    return {\n      prompt,\n      generatedContent,\n      style,\n      length,\n      targetWordCount,\n      language\n    };\n  }\n\n  /**\n   * Drafts an email based on key points\n   */\n  private async draftEmail(subject: string, recipient: string, points: string[], style: TextStyle = 'formal', language: string): Promise<any> {\n    if (!subject || subject.trim().length === 0) {\n      throw new Error('Sujet requis');\n    }\n    \n    if (!recipient || recipient.trim().length === 0) {\n      throw new Error('Destinataire requis');\n    }\n    \n    if (!points || !Array.isArray(points) || points.length === 0) {\n      throw new Error('Points cl├®s requis');\n    }\n    \n    // In a real implementation, this would call an LLM API\n    // Here, we'll simulate a response\n    const draftedEmail = `\nObjet: ${subject}\n\nCher/Ch├¿re ${recipient},\n\n[Ceci est un email simul├® ├®crit dans un style ${style} en ${language}, int├®grant les ${points.length} points cl├®s fournis. Dans une impl├®mentation r├®elle, nous utiliserions un LLM pour g├®n├®rer un email professionnel et coh├®rent.]\n\nCordialement,\n[Votre nom]\n    `;\n    \n    return {\n      subject,\n      recipient,\n      email: draftedEmail.trim(),\n      style,\n      pointsIncluded: points.length,\n      language\n    };\n  }\n\n  /**\n   * Drafts a message based on context and key points\n   */\n  private async draftMessage(context: string, points: string[], style: TextStyle = 'casual', language: string): Promise<any> {\n    if (!context || context.trim().length === 0) {\n      throw new Error('Contexte requis');\n    }\n    \n    if (!points || !Array.isArray(points) || points.length === 0) {\n      throw new Error('Points cl├®s requis');\n    }\n    \n    // In a real implementation, this would call an LLM API\n    // Here, we'll simulate a response\n    const draftedMessage = `[Ceci est un message simul├® ├®crit dans un style ${style} en ${language}, bas├® sur le contexte fourni et int├®grant les ${points.length} points cl├®s. Dans une impl├®mentation r├®elle, nous utiliserions un LLM pour g├®n├®rer un message adapt├® au contexte.]`;\n    \n    return {\n      context,\n      message: draftedMessage,\n      style,\n      pointsIncluded: points.length,\n      language\n    };\n  }\n\n  /**\n   * Simple language detection based on text sample\n   * In a real implementation, would use a language detection API or library\n   */\n  private detectLanguage(text: string): string {\n    const normalizedText = text.toLowerCase();\n    \n    // Simple detection based on common words and characters\n    if (/[├®├¿├¬├½├á├ó├ñ├┤├Â├╣├╗├╝├┐├º┼ô├ª]/.test(normalizedText) && \n        (normalizedText.includes(' le ') || normalizedText.includes(' la ') || \n         normalizedText.includes(' un ') || normalizedText.includes(' une '))) {\n      return 'fr';\n    } else if (/[├í├®├¡├│├║├▒├╝├º]/.test(normalizedText) && \n               (normalizedText.includes(' el ') || normalizedText.includes(' la ') || \n                normalizedText.includes(' un ') || normalizedText.includes(' una '))) {\n      return 'es';\n    } else {\n      return 'en';\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\ContextAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1173,1176],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1173,1176],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1322,1325],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1322,1325],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2355,2358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2355,2358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":473,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":473,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12031,12034],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12031,12034],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":495,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":495,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12582,12585],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12582,12585],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * agents/ContextAgent.ts\n * Agent responsable de la gestion du contexte de l'application\n */\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult } from './types';\nimport { AgentDomains } from './types';\nimport { ContextManager } from '../context/ContextManager';\nimport type {\n  ContextItem,\n  ContextQueryOptions,\n  ConversationContextItem,\n  EntityContextItem,\n  IntentHistoryContextItem,\n  ContextType\n} from '../context/types';\n\n/**\n * Types de requ├¬tes pour l'agent de contexte\n */\nexport const ContextRequestType = {\n  ADD_CONTEXT: 'add_context',\n  GET_CONTEXT: 'get_context',\n  UPDATE_CONTEXT: 'update_context',\n  DELETE_CONTEXT: 'delete_context',\n  QUERY_CONTEXT: 'query_context',\n  GET_RELEVANT_CONTEXT: 'get_relevant_context',\n  MERGE_CONTEXTS: 'merge_contexts',\n  PRUNE_CONTEXTS: 'prune_contexts',\n  CLEAR_CONTEXTS: 'clear_contexts',\n  GET_STATS: 'get_stats',\n  EXPORT_CONTEXTS: 'export_contexts',\n  IMPORT_CONTEXTS: 'import_contexts'\n} as const;\nexport type ContextRequestType = typeof ContextRequestType[keyof typeof ContextRequestType];\n\n/**\n * Interface de requ├¬te pour l'agent de contexte\n */\ntype AgentResponse = { success: boolean; data?: any; error?: string; metadata?: { executionTime?: number } };\n\nexport interface ContextAgentRequest {\n  requestType: ContextRequestType;\n  payload?: any;\n}\n\n/**\n * Agent responsable de la gestion du contexte\n */\nexport class ContextAgent implements BaseAgent {\n  readonly type = 'context';\n  readonly name = 'Context Manager';\n  readonly description = 'G├¿re le syst├¿me de contexte avanc├® pour am├®liorer la m├®moire et la coh├®rence des interactions';\n  readonly version = '1.0.0';\n  readonly domain = AgentDomains.KNOWLEDGE;\n  readonly capabilities = ['context_tracking', 'conversation_memory', 'entity_tracking', 'intent_history'];\n  readonly status = 'active';\n  private contextManager: ContextManager;\n\n  constructor() {\n    this.contextManager = new ContextManager();\n  }\n\n  /**\n   * M├®thode principale d'ex├®cution pour les requ├¬tes de contexte\n   * Impl├®mentation de l'interface BaseAgent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    try {\n      // Si l'intent est sp├®cifi├®, nous le traitons comme une action\n      if (props.intent && props.parameters) {\n        const request: ContextAgentRequest = {\n          requestType: props.intent as any,\n          payload: props.parameters\n        };\n        \n        const response = await this.processRequest(request);\n        \n        return {\n          success: response.success,\n          output: response.data,\n          metadata: {\n            executionTime: response.metadata?.executionTime || 0,\n            confidence: 1.0,\n            source: 'ContextAgent',\n            timestamp: Date.now()\n          }\n        };\n      }\n      \n      return {\n        success: false,\n        output: null,\n        error: 'Intent non sp├®cifi├® dans la requ├¬te'\n      };\n    } catch (error) {\n      console.error('Erreur dans l\\'ex├®cution du ContextAgent:', error);\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Traite une requ├¬te sp├®cifique au contexte\n   */\n  async processRequest(request: ContextAgentRequest): Promise<AgentResponse> {\n    switch (request.requestType) {\n      case ContextRequestType.ADD_CONTEXT:\n        return this.handleAddContext(request);\n      case ContextRequestType.GET_CONTEXT:\n        return this.handleGetContext(request);\n      case ContextRequestType.UPDATE_CONTEXT:\n        return this.handleUpdateContext(request);\n      case ContextRequestType.DELETE_CONTEXT:\n        return this.handleDeleteContext(request);\n      case ContextRequestType.QUERY_CONTEXT:\n        return this.handleQueryContext(request);\n      case ContextRequestType.GET_RELEVANT_CONTEXT:\n        return this.handleGetRelevantContext(request);\n      case ContextRequestType.MERGE_CONTEXTS:\n        return this.handleMergeContexts();\n      case ContextRequestType.PRUNE_CONTEXTS:\n        return this.handlePruneContexts();\n      case ContextRequestType.CLEAR_CONTEXTS:\n        return this.handleClearContexts(request);\n      case ContextRequestType.GET_STATS:\n        return this.handleGetStats();\n      case ContextRequestType.EXPORT_CONTEXTS:\n        return this.handleExportContexts();\n      case ContextRequestType.IMPORT_CONTEXTS:\n        return this.handleImportContexts(request);\n      default:\n        return {\n          success: false,\n          error: `Type de requ├¬te inconnu: ${request.requestType}`\n        };\n    }\n  }\n\n  /**\n   * Ajoute un ├®l├®ment de contexte\n   */\n  private handleAddContext(request: ContextAgentRequest): AgentResponse {\n    try {\n      const { contextItem } = request.payload;\n\n      if (!contextItem) {\n        return {\n          success: false,\n          error: '├ël├®ment de contexte manquant'\n        };\n      }\n\n      const newItem = this.contextManager.addContext(contextItem);\n\n      return {\n        success: true,\n        data: { contextItem: newItem }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de l'ajout du contexte: ${error}`\n      };\n    }\n  }\n\n  /**\n   * R├®cup├¿re un ├®l├®ment de contexte\n   */\n  private handleGetContext(request: ContextAgentRequest): AgentResponse {\n    try {\n      const { id } = request.payload;\n\n      if (!id) {\n        return {\n          success: false,\n          error: 'ID de contexte manquant'\n        };\n      }\n\n      const contextItem = this.contextManager.getContextById(id);\n\n      if (!contextItem) {\n        return {\n          success: false,\n          error: `Contexte avec ID ${id} non trouv├®`\n        };\n      }\n\n      return {\n        success: true,\n        data: { contextItem }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la r├®cup├®ration du contexte: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Met ├á jour un ├®l├®ment de contexte\n   */\n  private handleUpdateContext(request: ContextAgentRequest): AgentResponse {\n    try {\n      const { id, updates } = request.payload;\n\n      if (!id || !updates) {\n        return {\n          success: false,\n          error: 'ID de contexte ou mises ├á jour manquants'\n        };\n      }\n\n      const updatedItem = this.contextManager.updateContext(id, updates);\n\n      if (!updatedItem) {\n        return {\n          success: false,\n          error: `Contexte avec ID ${id} non trouv├®`\n        };\n      }\n\n      return {\n        success: true,\n        data: { contextItem: updatedItem }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la mise ├á jour du contexte: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Supprime un ├®l├®ment de contexte\n   */\n  private handleDeleteContext(request: ContextAgentRequest): AgentResponse {\n    try {\n      const { id } = request.payload;\n\n      if (!id) {\n        return {\n          success: false,\n          error: 'ID de contexte manquant'\n        };\n      }\n\n      const deleted = this.contextManager.removeContext(id);\n\n      if (!deleted) {\n        return {\n          success: false,\n          error: `Contexte avec ID ${id} non trouv├®`\n        };\n      }\n\n      return {\n        success: true,\n        data: { deleted: true }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la suppression du contexte: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Recherche des ├®l├®ments de contexte\n   */\n  private handleQueryContext(request: ContextAgentRequest): AgentResponse {\n    try {\n      const options = request.payload?.options || {};\n      const results = this.contextManager.queryContext(options as ContextQueryOptions);\n\n      return {\n        success: true,\n        data: { results }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la recherche de contexte: ${error}`\n      };\n    }\n  }\n\n  /**\n   * R├®cup├¿re le contexte pertinent\n   */\n  private handleGetRelevantContext(request: ContextAgentRequest): AgentResponse {\n    try {\n      const { input, maxItems } = request.payload;\n\n      if (!input) {\n        return {\n          success: false,\n          error: 'Entr├®e manquante'\n        };\n      }\n\n      const relevantContexts = this.contextManager.getRelevantContext(\n        input,\n        maxItems || 10\n      );\n\n      return {\n        success: true,\n        data: { relevantContexts }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la r├®cup├®ration du contexte pertinent: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Fusionne les contextes similaires\n   */\n  private handleMergeContexts(): AgentResponse {\n    try {\n      this.contextManager.mergeContexts();\n\n      return {\n        success: true,\n        data: { merged: true }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la fusion des contextes: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Nettoie les contextes expir├®s\n   */\n  private handlePruneContexts(): AgentResponse {\n    try {\n      this.contextManager.pruneContexts();\n\n      return {\n        success: true,\n        data: { pruned: true }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors du nettoyage des contextes: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Supprime tous les contextes\n   */\n  private handleClearContexts(request: ContextAgentRequest): AgentResponse {\n    try {\n      const { types } = request.payload || {};\n      this.contextManager.clearContexts(types as ContextType[]);\n\n      return {\n        success: true,\n        data: { cleared: true }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la suppression des contextes: ${error}`\n      };\n    }\n  }\n\n  /**\n   * R├®cup├¿re les statistiques du contexte\n   */\n  private handleGetStats(): AgentResponse {\n    try {\n      const stats = this.contextManager.getStats();\n\n      return {\n        success: true,\n        data: { stats }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de la r├®cup├®ration des statistiques: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Exporte tous les ├®l├®ments de contexte\n   */\n  private handleExportContexts(): AgentResponse {\n    try {\n      const contexts = this.contextManager.exportContexts();\n\n      return {\n        success: true,\n        data: { contexts }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de l'exportation des contextes: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Importe des ├®l├®ments de contexte\n   */\n  private handleImportContexts(request: ContextAgentRequest): AgentResponse {\n    try {\n      const { contexts } = request.payload;\n\n      if (!contexts || !Array.isArray(contexts)) {\n        return {\n          success: false,\n          error: 'Contextes manquants ou invalides'\n        };\n      }\n\n      this.contextManager.importContexts(contexts as ContextItem[]);\n\n      return {\n        success: true,\n        data: { imported: true }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: `Erreur lors de l'importation des contextes: ${error}`\n      };\n    }\n  }\n\n  /**\n   * Ajoute un ├®l├®ment de contexte de conversation\n   */\n  async addConversationContext(\n    text: string,\n    role: 'user' | 'assistant',\n    metadata: { intent?: string; sentiment?: string; language?: string } = {}\n  ): Promise<ConversationContextItem | null> {\n    try {\n      const contextItem = this.contextManager.addConversationContext(text, role, metadata) as ConversationContextItem;\n      return contextItem;\n    } catch (error) {\n      console.error('Erreur lors de l\\'ajout du contexte de conversation:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Ajoute un ├®l├®ment de contexte d'entit├®\n   */\n  async addEntityContext(\n    entityType: string,\n    name: string,\n    attributes: Record<string, any> = {},\n    references: string[] = []\n  ): Promise<EntityContextItem | null> {\n    try {\n      const contextItem = this.contextManager.addEntityContext(\n        entityType,\n        name,\n        attributes,\n        references\n      ) as EntityContextItem;\n      return contextItem;\n    } catch (error) {\n      console.error('Erreur lors de l\\'ajout du contexte d\\'entit├®:', error);\n      return null;\n    }\n  }\n\n  /**\n   * Ajoute un ├®l├®ment de contexte d'intention\n   */\n  async addIntentContext(\n    intent: string,\n    parameters: Record<string, any> = {},\n    fulfilled: boolean = false,\n    followUpIntent?: string\n  ): Promise<IntentHistoryContextItem | null> {\n    try {\n      const contextItem = this.contextManager.addIntentContext(\n        intent,\n        parameters,\n        fulfilled,\n        followUpIntent\n      ) as IntentHistoryContextItem;\n      return contextItem;\n    } catch (error) {\n      console.error('Erreur lors de l\\'ajout du contexte d\\'intention:', error);\n      return null;\n    }\n  }\n\n  /**\n   * R├®cup├¿re le contexte pertinent pour une entr├®e\n   */\n  async getContextForInput(input: string, maxItems: number = 10): Promise<ContextItem[]> {\n    return this.contextManager.getRelevantContext(input, maxItems);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\CriticAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'target' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":229,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":229,"endColumn":27}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ­ƒøí´©Å CriticAgent - Gardien de la S├®curit├®\n * Valide toute action potentiellement dangereuse avant ex├®cution\n */\n\nimport type { AgentExecuteProps, AgentExecuteResult, AgentDomains } from './types';\nimport { BaseAgent } from './BaseAgent';\n\nexport interface CriticValidation {\n  approved: boolean;\n  riskLevel: 'low' | 'medium' | 'high' | 'critical';\n  concerns: string[];\n  recommendations: string[];\n  requiresUserApproval: boolean;\n}\n\nexport interface ToolCall {\n  id: string;\n  tool: string;\n  parameters: Record<string, unknown>;\n  sandbox: 'fs' | 'network' | 'safe';\n  reversible: boolean;\n}\n\nexport class CriticAgent extends BaseAgent {\n  name = 'CriticAgent';\n  description = 'Valide la s├®curit├® et la pertinence des actions avant ex├®cution';\n  version = '1.0.0';\n  domain = 'safety' as AgentDomains;\n  capabilities = [\n    'validate_tool_calls',\n    'assess_risk',\n    'check_reversibility',\n    'verify_permissions',\n    'suggest_alternatives'\n  ];\n\n  /**\n   * Patterns d'actions dangereuses ├á surveiller\n   */\n  private dangerousPatterns = {\n    filesystem: [\n      /delete|remove|rm|unlink/i,\n      /format|wipe|clean/i,\n      /chmod|chown/i,\n      /\\/etc\\//i,\n      /system32/i,\n      /registry/i\n    ],\n    network: [\n      /password|pwd|secret|key|token/i,\n      /credit.?card|cc|cvv/i,\n      /ssn|social.?security/i,\n      /localhost|127\\.0\\.0\\.1/i,\n      /admin|root|sudo/i\n    ],\n    commands: [\n      /shutdown|reboot|restart/i,\n      /kill|terminate/i,\n      /fork.?bomb/i,\n      /:(){ :|:& };:/  // Fork bomb pattern\n    ]\n  };\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { intent, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'validate_tool_call':\n          return await this.validateToolCall(parameters.toolCall as ToolCall);\n        \n        case 'assess_risk':\n          return await this.assessRisk(parameters);\n        \n        case 'check_reversibility':\n          return await this.checkReversibility(parameters);\n        \n        default:\n          return {\n            success: false,\n            output: `Intent non reconnu: ${intent}`,\n            error: 'UNKNOWN_INTENT'\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : 'CRITIC_ERROR'\n      };\n    }\n  }\n\n  /**\n   * Valide un appel d'outil avant ex├®cution\n   */\n  async validateToolCall(toolCall: ToolCall): Promise<AgentExecuteResult> {\n    const validation: CriticValidation = {\n      approved: true,\n      riskLevel: 'low',\n      concerns: [],\n      recommendations: [],\n      requiresUserApproval: false\n    };\n\n    // V├®rifier les param├¿tres dangereux\n    const paramStr = JSON.stringify(toolCall.parameters);\n    \n    // V├®rifier les patterns filesystem dangereux\n    if (toolCall.sandbox === 'fs') {\n      for (const pattern of this.dangerousPatterns.filesystem) {\n        if (pattern.test(paramStr) || pattern.test(toolCall.tool)) {\n          validation.concerns.push(`ÔÜá´©Å Op├®ration filesystem potentiellement dangereuse d├®tect├®e: ${pattern}`);\n          validation.riskLevel = 'high';\n          validation.requiresUserApproval = true;\n        }\n      }\n    }\n\n    // V├®rifier les patterns network dangereux\n    if (toolCall.sandbox === 'network') {\n      for (const pattern of this.dangerousPatterns.network) {\n        if (pattern.test(paramStr)) {\n          validation.concerns.push(`­ƒöÆ Donn├®es sensibles d├®tect├®es: ${pattern}`);\n          validation.riskLevel = 'critical';\n          validation.approved = false;\n          validation.recommendations.push('Utiliser des variables d\\'environnement pour les secrets');\n        }\n      }\n    }\n\n    // V├®rifier les commandes dangereuses\n    for (const pattern of this.dangerousPatterns.commands) {\n      if (pattern.test(paramStr) || pattern.test(toolCall.tool)) {\n        validation.concerns.push(`­ƒÜ½ Commande syst├¿me dangereuse d├®tect├®e`);\n        validation.riskLevel = 'critical';\n        validation.approved = false;\n      }\n    }\n\n    // V├®rifier la r├®versibilit├®\n    if (!toolCall.reversible && validation.riskLevel !== 'low') {\n      validation.concerns.push('ÔÜá´©Å Action non r├®versible');\n      validation.requiresUserApproval = true;\n    }\n\n    // Ajouter des recommendations\n    if (validation.riskLevel === 'high' || validation.riskLevel === 'critical') {\n      validation.recommendations.push('Cr├®er une sauvegarde avant l\\'ex├®cution');\n      validation.recommendations.push('Tester dans un environnement sandbox d\\'abord');\n      validation.recommendations.push('Documenter l\\'action dans le journal d\\'audit');\n    }\n\n    // Logger la validation\n    this.logValidation(toolCall, validation);\n\n    return {\n      success: true,\n      output: validation,\n      metadata: {\n        toolCall,\n        timestamp: new Date().toISOString(),\n        validatedBy: this.name\n      }\n    };\n  }\n\n  /**\n   * ├ëvalue le niveau de risque d'une action\n   */\n  async assessRisk(parameters: Record<string, unknown>): Promise<AgentExecuteResult> {\n    let riskScore = 0;\n    const riskFactors: string[] = [];\n\n    // Facteurs de risque\n    if (parameters.irreversible) {\n      riskScore += 30;\n      riskFactors.push('Action irr├®versible');\n    }\n\n    if (parameters.affectsMultipleResources) {\n      riskScore += 20;\n      riskFactors.push('Affecte plusieurs ressources');\n    }\n\n    if (parameters.requiresElevatedPermissions) {\n      riskScore += 25;\n      riskFactors.push('N├®cessite des permissions ├®lev├®es');\n    }\n\n    if (parameters.modifiesSystemFiles) {\n      riskScore += 40;\n      riskFactors.push('Modifie des fichiers syst├¿me');\n    }\n\n    if (parameters.exposesSecrets) {\n      riskScore += 50;\n      riskFactors.push('Peut exposer des secrets');\n    }\n\n    // D├®terminer le niveau de risque\n    let riskLevel: CriticValidation['riskLevel'];\n    if (riskScore >= 70) {\n      riskLevel = 'critical';\n    } else if (riskScore >= 50) {\n      riskLevel = 'high';\n    } else if (riskScore >= 30) {\n      riskLevel = 'medium';\n    } else {\n      riskLevel = 'low';\n    }\n\n    return {\n      success: true,\n      output: {\n        riskScore,\n        riskLevel,\n        riskFactors,\n        recommendation: this.getRiskRecommendation(riskLevel)\n      }\n    };\n  }\n\n  /**\n   * V├®rifie si une action est r├®versible\n   */\n  async checkReversibility(parameters: Record<string, unknown>): Promise<AgentExecuteResult> {\n    const { action, target } = parameters;\n    \n    const reversibleActions = [\n      'create', 'add', 'enable', 'start', 'open',\n      'copy', 'backup', 'save', 'export'\n    ];\n\n    const irreversibleActions = [\n      'delete', 'remove', 'destroy', 'wipe', 'format',\n      'truncate', 'drop', 'purge', 'shred'\n    ];\n\n    let isReversible = false;\n    let method = '';\n\n    if (typeof action === 'string') {\n      const actionLower = action.toLowerCase();\n      \n      if (reversibleActions.some(a => actionLower.includes(a))) {\n        isReversible = true;\n        method = 'Peut ├¬tre annul├® via l\\'action inverse';\n      } else if (irreversibleActions.some(a => actionLower.includes(a))) {\n        isReversible = false;\n        method = 'Action destructive non r├®versible';\n      } else {\n        // Ind├®termin├® - n├®cessite une analyse plus approfondie\n        isReversible = false;\n        method = 'R├®versibilit├® inconnue - prudence recommand├®e';\n      }\n    }\n\n    // Si on a une sauvegarde, l'action devient r├®versible\n    if (parameters.hasBackup) {\n      isReversible = true;\n      method = 'Restauration depuis sauvegarde possible';\n    }\n\n    return {\n      success: true,\n      output: {\n        isReversible,\n        method,\n        requiresBackup: !isReversible,\n        recommendation: isReversible \n          ? 'Action s├╗re, peut ├¬tre annul├®e'\n          : 'ÔÜá´©Å Cr├®er une sauvegarde avant l\\'ex├®cution'\n      }\n    };\n  }\n\n  /**\n   * Obtient une recommandation bas├®e sur le niveau de risque\n   */\n  private getRiskRecommendation(riskLevel: CriticValidation['riskLevel']): string {\n    switch (riskLevel) {\n      case 'low':\n        return 'Ô£à Action s├╗re, peut ├¬tre ex├®cut├®e automatiquement';\n      case 'medium':\n        return 'ÔÜá´©Å V├®rifier les param├¿tres avant ex├®cution';\n      case 'high':\n        return '­ƒö┤ Demander confirmation utilisateur obligatoire';\n      case 'critical':\n        return '­ƒÜ½ Action bloqu├®e - n├®cessite une r├®vision manuelle approfondie';\n    }\n  }\n\n  /**\n   * Enregistre la validation dans le journal d'audit\n   */\n  private logValidation(toolCall: ToolCall, validation: CriticValidation): void {\n    const auditLog = JSON.parse(localStorage.getItem('lisa:critic:audit') || '[]');\n    \n    auditLog.push({\n      timestamp: new Date().toISOString(),\n      toolCall: {\n        id: toolCall.id,\n        tool: toolCall.tool,\n        sandbox: toolCall.sandbox\n      },\n      validation: {\n        approved: validation.approved,\n        riskLevel: validation.riskLevel,\n        concernsCount: validation.concerns.length,\n        requiresUserApproval: validation.requiresUserApproval\n      }\n    });\n\n    // Garder seulement les 100 derni├¿res validations\n    if (auditLog.length > 100) {\n      auditLog.shift();\n    }\n\n    localStorage.setItem('lisa:critic:audit', JSON.stringify(auditLog));\n    \n    // Si l'action est critique, logger aussi dans la console\n    if (validation.riskLevel === 'critical' || !validation.approved) {\n      console.warn('­ƒøí´©Å CRITIC AGENT - Validation:', {\n        toolCall,\n        validation\n      });\n    }\n  }\n\n  /**\n   * Interface pour demander l'approbation utilisateur\n   */\n  async requestUserApproval(\n    toolCall: ToolCall,\n    validation: CriticValidation\n  ): Promise<boolean> {\n    // Cette m├®thode devrait ├¬tre connect├®e ├á une UI de confirmation\n    console.log('­ƒöö Approbation utilisateur requise:', {\n      tool: toolCall.tool,\n      riskLevel: validation.riskLevel,\n      concerns: validation.concerns,\n      recommendations: validation.recommendations\n    });\n\n    // Pour l'instant, simuler une confirmation via window.confirm\n    const message = `\nÔÜá´©Å Action ├á Risque ${validation.riskLevel.toUpperCase()}\n\nOutil: ${toolCall.tool}\nR├®versible: ${toolCall.reversible ? 'Oui' : 'Non'}\n\nPr├®occupations:\n${validation.concerns.join('\\n')}\n\nRecommandations:\n${validation.recommendations.join('\\n')}\n\nAutoriser cette action?\n    `.trim();\n\n    return window.confirm(message);\n  }\n}\n\n// Exporter une instance singleton\nexport const criticAgent = new CriticAgent();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\CriticAgentV2.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\DataAnalysisAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1971,1974],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1971,1974],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'analysisType' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":61,"column":19,"nodeType":null,"messageId":"unusedVar","endLine":61,"endColumn":31},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2520,2523],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2520,2523],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":90,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":90,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2934,2937],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2934,2937],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":104,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":104,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3349,3352],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3349,3352],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":122,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":122,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4019,4022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4019,4022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4464,4467],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4464,4467],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4988,4991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4988,4991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":171,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":171,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5465,5468],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5465,5468],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6953,6956],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6953,6956],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":231,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":231,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":231,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":231,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7515,7518],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7515,7518],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DataAnalysisAgent - Data Analysis and Visualization\n * \n * Performs statistical analysis, generates visualizations, and identifies trends\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\n\nexport class DataAnalysisAgent implements BaseAgent {\n  name = 'DataAnalysisAgent';\n  description = 'Performs data analysis with statistics, visualizations, and trend detection';\n  version = '1.0.0';\n  domain: AgentDomain = AgentDomains.ANALYSIS;\n  capabilities = [\n    'statistical_analysis',\n    'data_visualization',\n    'trend_detection',\n    'correlation_analysis',\n    'data_summarization',\n    'outlier_detection'\n  ];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { intent, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'analyze_data':\n          return await this.analyzeData(parameters);\n        case 'calculate_statistics':\n          return await this.calculateStatistics(parameters);\n        case 'detect_trends':\n          return await this.detectTrends(parameters);\n        case 'find_correlations':\n          return await this.findCorrelations(parameters);\n        case 'detect_outliers':\n          return await this.detectOutliers(parameters);\n        case 'summarize_dataset':\n          return await this.summarizeDataset(parameters);\n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: { executionTime: Date.now() - startTime, timestamp: Date.now() }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: { executionTime: Date.now() - startTime, timestamp: Date.now() }\n      };\n    }\n  }\n\n  private async analyzeData(params: any): Promise<AgentExecuteResult> {\n    const { data, analysisType = 'comprehensive' } = params;\n    if (!data || !Array.isArray(data)) {\n      return { success: false, output: null, error: 'Invalid data array' };\n    }\n\n    const stats = this.calculateBasicStats(data);\n    const trends = this.identifyTrends(data);\n\n    return {\n      success: true,\n      output: { statistics: stats, trends, dataPoints: data.length },\n      metadata: { source: 'DataAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async calculateStatistics(params: any): Promise<AgentExecuteResult> {\n    const { data } = params;\n    if (!data || !Array.isArray(data)) {\n      return { success: false, output: null, error: 'Invalid data array' };\n    }\n\n    const stats = this.calculateBasicStats(data);\n    return {\n      success: true,\n      output: stats,\n      metadata: { source: 'DataAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async detectTrends(params: any): Promise<AgentExecuteResult> {\n    const { data } = params;\n    if (!data || !Array.isArray(data)) {\n      return { success: false, output: null, error: 'Invalid data array' };\n    }\n\n    const trends = this.identifyTrends(data);\n    return {\n      success: true,\n      output: trends,\n      metadata: { source: 'DataAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async findCorrelations(params: any): Promise<AgentExecuteResult> {\n    const { dataX, dataY } = params;\n    if (!dataX || !dataY || dataX.length !== dataY.length) {\n      return { success: false, output: null, error: 'Invalid or mismatched data arrays' };\n    }\n\n    const correlation = this.calculateCorrelation(dataX, dataY);\n    return {\n      success: true,\n      output: {\n        correlation,\n        strength: Math.abs(correlation) > 0.7 ? 'strong' : Math.abs(correlation) > 0.4 ? 'moderate' : 'weak',\n        direction: correlation > 0 ? 'positive' : 'negative'\n      },\n      metadata: { source: 'DataAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async detectOutliers(params: any): Promise<AgentExecuteResult> {\n    const { data } = params;\n    if (!data || !Array.isArray(data)) {\n      return { success: false, output: null, error: 'Invalid data array' };\n    }\n\n    const outliers = this.findOutliers(data);\n    return {\n      success: true,\n      output: { outliers, count: outliers.length },\n      metadata: { source: 'DataAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async summarizeDataset(params: any): Promise<AgentExecuteResult> {\n    const { data } = params;\n    if (!data || !Array.isArray(data)) {\n      return { success: false, output: null, error: 'Invalid data array' };\n    }\n\n    const summary = {\n      count: data.length,\n      ...this.calculateBasicStats(data),\n      distribution: this.analyzeDistribution(data)\n    };\n\n    return {\n      success: true,\n      output: summary,\n      metadata: { source: 'DataAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private calculateBasicStats(data: number[]): any {\n    const sorted = [...data].sort((a, b) => a - b);\n    const sum = data.reduce((a, b) => a + b, 0);\n    const mean = sum / data.length;\n    const variance = data.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / data.length;\n\n    return {\n      min: Math.min(...data),\n      max: Math.max(...data),\n      mean,\n      median: sorted[Math.floor(sorted.length / 2)],\n      stdDev: Math.sqrt(variance),\n      sum\n    };\n  }\n\n  private identifyTrends(data: number[]): any {\n    if (data.length < 2) return { trend: 'insufficient_data' };\n\n    const firstHalf = data.slice(0, Math.floor(data.length / 2));\n    const secondHalf = data.slice(Math.floor(data.length / 2));\n    const avgFirst = firstHalf.reduce((a, b) => a + b, 0) / firstHalf.length;\n    const avgSecond = secondHalf.reduce((a, b) => a + b, 0) / secondHalf.length;\n\n    const change = ((avgSecond - avgFirst) / avgFirst) * 100;\n\n    return {\n      trend: change > 5 ? 'increasing' : change < -5 ? 'decreasing' : 'stable',\n      changePercent: change.toFixed(2)\n    };\n  }\n\n  private calculateCorrelation(dataX: number[], dataY: number[]): number {\n    const n = dataX.length;\n    const meanX = dataX.reduce((a, b) => a + b, 0) / n;\n    const meanY = dataY.reduce((a, b) => a + b, 0) / n;\n\n    let num = 0, denX = 0, denY = 0;\n    for (let i = 0; i < n; i++) {\n      const dx = dataX[i] - meanX;\n      const dy = dataY[i] - meanY;\n      num += dx * dy;\n      denX += dx * dx;\n      denY += dy * dy;\n    }\n\n    return num / Math.sqrt(denX * denY);\n  }\n\n  private findOutliers(data: number[]): number[] {\n    const sorted = [...data].sort((a, b) => a - b);\n    const q1 = sorted[Math.floor(sorted.length * 0.25)];\n    const q3 = sorted[Math.floor(sorted.length * 0.75)];\n    const iqr = q3 - q1;\n    const lowerBound = q1 - 1.5 * iqr;\n    const upperBound = q3 + 1.5 * iqr;\n\n    return data.filter(val => val < lowerBound || val > upperBound);\n  }\n\n  private analyzeDistribution(data: number[]): any {\n    const stats = this.calculateBasicStats(data);\n    const skewness = this.calculateSkewness(data, stats.mean, stats.stdDev);\n\n    return {\n      type: Math.abs(skewness) < 0.5 ? 'normal' : skewness > 0 ? 'right-skewed' : 'left-skewed',\n      skewness\n    };\n  }\n\n  private calculateSkewness(data: number[], mean: number, stdDev: number): number {\n    const n = data.length;\n    const sum = data.reduce((acc, val) => acc + Math.pow((val - mean) / stdDev, 3), 0);\n    return (n / ((n - 1) * (n - 2))) * sum;\n  }\n\n  async canHandle(query: string, context?: any): Promise<number> {\n    const keywords = [\n      'data', 'analyze', 'statistics', 'trend', 'correlation',\n      'chart', 'graph', 'visualization', 'dataset', 'outlier',\n      'donn├®es', 'analyser', 'statistique', 'tendance', 'graphique'\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    const matches = keywords.filter(keyword => lowerQuery.includes(keyword));\n    return matches.length > 0 ? Math.min(matches.length * 0.3, 1.0) : 0.0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\DelayAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[891,894],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[891,894],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomains } from \"./types\";\n\nexport class DelayAgent implements BaseAgent {\n  name = \"DelayAgent\";\n  description = \"Introduces a delay in workflows.\";\n  version = \"0.1.0\";\n  domain = AgentDomains.PRODUCTIVITY;\n  capabilities = [\"delay\"];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { intent, parameters } = props;\n\n    if (intent !== \"delay\") {\n      return { success: false, output: null, error: `Unknown intent: ${intent}` };\n    }\n\n    const { delayMs, input } = parameters;\n\n    try {\n      const delay = parseInt(delayMs) || 1000;\n      await new Promise(resolve => setTimeout(resolve, Math.min(delay, 5000)));\n\n      return {\n        success: true,\n        output: {\n          delayed: true,\n          delayMs: delay,\n          original: input\n        }\n      };\n    } catch (error: any) {\n      return { success: false, output: null, error: `Delay execution failed: ${error.message}` };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\EmailAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":47,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":47,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":99,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":99,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2646,2649],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2646,2649],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":153,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":153,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4172,4175],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4172,4175],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5936,5939],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5936,5939],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":284,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":284,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7587,7590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7587,7590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":322,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":322,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8499,8502],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8499,8502],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":392,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":392,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10304,10307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10304,10307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":434,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":434,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11523,11526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11523,11526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":522,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":522,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":522,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":522,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14480,14483],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14480,14483],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EmailAgent - Email Management and Analysis\n * \n * Assists in email management, classification, and response suggestions\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\n\ninterface Email {\n  id: string;\n  from: string;\n  to: string;\n  subject: string;\n  body: string;\n  timestamp: number;\n  read: boolean;\n  category?: 'personal' | 'work' | 'promotional' | 'social' | 'spam';\n  priority?: 'low' | 'medium' | 'high';\n}\n\ninterface EmailSuggestion {\n  type: 'reply' | 'forward' | 'archive' | 'delete';\n  content?: string;\n  reason: string;\n  confidence: number;\n}\n\nexport class EmailAgent implements BaseAgent {\n  name = 'EmailAgent';\n  description = 'Assists in email management with analysis, classification, and response suggestions';\n  version = '1.0.0';\n  domain: AgentDomain = AgentDomains.PRODUCTIVITY;\n  capabilities = [\n    'email_classification',\n    'response_suggestion',\n    'priority_detection',\n    'spam_detection',\n    'email_summarization',\n    'smart_reply'\n  ];\n\n  private emailCache: Map<string, Email> = new Map();\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { intent, context, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'classify_email':\n          return await this.classifyEmail(parameters);\n        \n        case 'suggest_response':\n          return await this.suggestResponse(parameters);\n        \n        case 'detect_priority':\n          return await this.detectPriority(parameters);\n        \n        case 'summarize_email':\n          return await this.summarizeEmail(parameters);\n        \n        case 'detect_spam':\n          return await this.detectSpam(parameters);\n        \n        case 'generate_reply':\n          return await this.generateReply(parameters);\n        \n        case 'batch_process':\n          return await this.batchProcess(parameters);\n        \n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Classify email into categories\n   */\n  private async classifyEmail(params: any): Promise<AgentExecuteResult> {\n    const { email } = params;\n\n    if (!email) {\n      return {\n        success: false,\n        output: null,\n        error: 'No email provided'\n      };\n    }\n\n    const { subject = '', body = '', from = '' } = email;\n    const text = `${subject} ${body} ${from}`.toLowerCase();\n\n    // Simple keyword-based classification\n    let category: Email['category'] = 'personal';\n    let confidence = 0.5;\n\n    const categories = {\n      work: ['meeting', 'project', 'deadline', 'report', 'client', 'schedule'],\n      promotional: ['offer', 'discount', 'sale', 'buy', 'shop', 'deal', 'promo'],\n      social: ['notification', 'commented', 'liked', 'shared', 'followed'],\n      spam: ['winner', 'prize', 'urgent', 'act now', 'click here', 'free money']\n    };\n\n    for (const [cat, keywords] of Object.entries(categories)) {\n      const matches = keywords.filter(kw => text.includes(kw)).length;\n      if (matches > 0) {\n        const matchConfidence = Math.min(matches * 0.25, 1.0);\n        if (matchConfidence > confidence) {\n          category = cat as Email['category'];\n          confidence = matchConfidence;\n        }\n      }\n    }\n\n    return {\n      success: true,\n      output: {\n        category,\n        confidence,\n        suggestedActions: this.getSuggestedActions(category)\n      },\n      metadata: {\n        source: 'EmailAgent',\n        timestamp: Date.now(),\n        confidence\n      }\n    };\n  }\n\n  /**\n   * Suggest response actions\n   */\n  private async suggestResponse(params: any): Promise<AgentExecuteResult> {\n    const { email } = params;\n\n    if (!email) {\n      return {\n        success: false,\n        output: null,\n        error: 'No email provided'\n      };\n    }\n\n    const suggestions: EmailSuggestion[] = [];\n\n    // Analyze email content for suggestions\n    const { subject = '', body = '' } = email;\n    const text = `${subject} ${body}`.toLowerCase();\n\n    // Check for questions\n    if (text.includes('?')) {\n      suggestions.push({\n        type: 'reply',\n        content: 'This email contains questions that may require a response.',\n        reason: 'Question detected in email',\n        confidence: 0.8\n      });\n    }\n\n    // Check for action items\n    if (text.includes('please') || text.includes('could you') || text.includes('can you')) {\n      suggestions.push({\n        type: 'reply',\n        content: 'Action item detected. Consider responding with your availability or plan.',\n        reason: 'Action request detected',\n        confidence: 0.75\n      });\n    }\n\n    // Check for newsletters/promotions\n    if (text.includes('unsubscribe') || text.includes('newsletter')) {\n      suggestions.push({\n        type: 'archive',\n        reason: 'Newsletter or promotional email',\n        confidence: 0.7\n      });\n    }\n\n    // Default suggestion\n    if (suggestions.length === 0) {\n      suggestions.push({\n        type: 'archive',\n        reason: 'No immediate action required',\n        confidence: 0.5\n      });\n    }\n\n    return {\n      success: true,\n      output: {\n        suggestions,\n        primarySuggestion: suggestions[0]\n      },\n      metadata: {\n        source: 'EmailAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Detect email priority\n   */\n  private async detectPriority(params: any): Promise<AgentExecuteResult> {\n    const { email } = params;\n\n    if (!email) {\n      return {\n        success: false,\n        output: null,\n        error: 'No email provided'\n      };\n    }\n\n    const { subject = '', body = '', from = '' } = email;\n    const text = `${subject} ${body}`.toLowerCase();\n\n    let priority: Email['priority'] = 'medium';\n    let score = 50;\n\n    // High priority indicators\n    const highPriorityKeywords = ['urgent', 'asap', 'important', 'deadline', 'critical'];\n    const highMatches = highPriorityKeywords.filter(kw => text.includes(kw)).length;\n    \n    if (highMatches > 0 || subject.includes('URGENT') || subject.includes('!!!')) {\n      priority = 'high';\n      score = 80 + (highMatches * 5);\n    }\n\n    // Low priority indicators\n    const lowPriorityKeywords = ['newsletter', 'notification', 'fyi', 'no reply'];\n    const lowMatches = lowPriorityKeywords.filter(kw => text.includes(kw)).length;\n    \n    if (lowMatches > 0 && priority === 'medium') {\n      priority = 'low';\n      score = 30;\n    }\n\n    // Check if from important sender\n    const vipDomains = ['boss', 'ceo', 'director', 'client'];\n    if (vipDomains.some(domain => from.toLowerCase().includes(domain))) {\n      priority = 'high';\n      score = Math.min(score + 20, 100);\n    }\n\n    return {\n      success: true,\n      output: {\n        priority,\n        score,\n        reasoning: this.getPriorityReasoning(priority)\n      },\n      metadata: {\n        source: 'EmailAgent',\n        timestamp: Date.now(),\n        confidence: score / 100\n      }\n    };\n  }\n\n  /**\n   * Summarize email content\n   */\n  private async summarizeEmail(params: any): Promise<AgentExecuteResult> {\n    const { email } = params;\n\n    if (!email) {\n      return {\n        success: false,\n        output: null,\n        error: 'No email provided'\n      };\n    }\n\n    const { subject, body, from } = email;\n\n    // Simple summarization (in production, use LLM)\n    const bodyPreview = body ? body.substring(0, 150) + (body.length > 150 ? '...' : '') : '';\n    \n    const summary = {\n      from,\n      subject,\n      preview: bodyPreview,\n      keyPoints: this.extractKeyPoints(body || ''),\n      sentiment: this.analyzeSentiment(body || ''),\n      actionRequired: body?.toLowerCase().includes('please') || body?.toLowerCase().includes('action')\n    };\n\n    return {\n      success: true,\n      output: summary,\n      metadata: {\n        source: 'EmailAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Detect spam emails\n   */\n  private async detectSpam(params: any): Promise<AgentExecuteResult> {\n    const { email } = params;\n\n    if (!email) {\n      return {\n        success: false,\n        output: null,\n        error: 'No email provided'\n      };\n    }\n\n    const { subject = '', body = '', from = '' } = email;\n    const text = `${subject} ${body}`.toLowerCase();\n\n    let spamScore = 0;\n    const spamIndicators: string[] = [];\n\n    // Check for spam keywords\n    const spamKeywords = [\n      'congratulations', 'winner', 'prize', 'click here', 'urgent action',\n      'verify account', 'suspended', 'limited time', 'act now', 'free',\n      'nigeria', 'inheritance', 'lottery', 'viagra'\n    ];\n\n    spamKeywords.forEach(keyword => {\n      if (text.includes(keyword)) {\n        spamScore += 15;\n        spamIndicators.push(keyword);\n      }\n    });\n\n    // Check for suspicious sender\n    if (from.includes('noreply') && spamScore > 0) {\n      spamScore += 10;\n      spamIndicators.push('suspicious sender');\n    }\n\n    // Check for excessive caps\n    if (subject.toUpperCase() === subject && subject.length > 10) {\n      spamScore += 20;\n      spamIndicators.push('excessive capitals');\n    }\n\n    // Check for excessive punctuation\n    if ((subject.match(/!!/g) || []).length > 0) {\n      spamScore += 10;\n      spamIndicators.push('excessive punctuation');\n    }\n\n    const isSpam = spamScore >= 50;\n\n    return {\n      success: true,\n      output: {\n        isSpam,\n        spamScore: Math.min(spamScore, 100),\n        confidence: Math.min(spamScore / 100, 1.0),\n        indicators: spamIndicators,\n        recommendation: isSpam ? 'Move to spam folder' : 'Looks legitimate'\n      },\n      metadata: {\n        source: 'EmailAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Generate email reply\n   */\n  private async generateReply(params: any): Promise<AgentExecuteResult> {\n    const { email, tone = 'professional', language = 'en' } = params;\n\n    if (!email) {\n      return {\n        success: false,\n        output: null,\n        error: 'No email provided'\n      };\n    }\n\n    // TODO: Integrate with LLM for better replies\n    const templates = {\n      professional: 'Thank you for your email. I will review this and get back to you shortly.',\n      casual: 'Thanks for reaching out! I\\'ll take a look and respond soon.',\n      formal: 'Dear Sender,\\n\\nThank you for your correspondence. I acknowledge receipt of your message and will respond appropriately in due course.\\n\\nBest regards'\n    };\n\n    const reply = templates[tone as keyof typeof templates] || templates.professional;\n\n    return {\n      success: true,\n      output: {\n        reply,\n        tone,\n        language,\n        suggestions: [\n          'Consider adding specific timeline',\n          'Personalize with recipient name',\n          'Add relevant details from original email'\n        ]\n      },\n      metadata: {\n        source: 'EmailAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Process multiple emails in batch\n   */\n  private async batchProcess(params: any): Promise<AgentExecuteResult> {\n    const { emails = [] } = params;\n\n    if (!Array.isArray(emails) || emails.length === 0) {\n      return {\n        success: false,\n        output: null,\n        error: 'No emails provided'\n      };\n    }\n\n    const results = await Promise.all(\n      emails.map(async (email) => {\n        const classification = await this.classifyEmail({ email });\n        const priority = await this.detectPriority({ email });\n        const spam = await this.detectSpam({ email });\n\n        return {\n          emailId: email.id,\n          category: classification.output?.category,\n          priority: priority.output?.priority,\n          isSpam: spam.output?.isSpam,\n          spamScore: spam.output?.spamScore\n        };\n      })\n    );\n\n    return {\n      success: true,\n      output: {\n        processed: emails.length,\n        results,\n        summary: {\n          spam: results.filter(r => r.isSpam).length,\n          highPriority: results.filter(r => r.priority === 'high').length,\n          work: results.filter(r => r.category === 'work').length\n        }\n      },\n      metadata: {\n        source: 'EmailAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  // Helper methods\n\n  private getSuggestedActions(category: Email['category']): string[] {\n    const actions: Record<string, string[]> = {\n      work: ['Prioritize', 'Add to task list', 'Schedule time to respond'],\n      promotional: ['Archive', 'Unsubscribe if not interested', 'Mark as read'],\n      social: ['Quick scan', 'Archive', 'Adjust notification settings'],\n      spam: ['Delete', 'Mark as spam', 'Block sender'],\n      personal: ['Read carefully', 'Respond promptly if needed']\n    };\n\n    return actions[category || 'personal'] || actions.personal;\n  }\n\n  private getPriorityReasoning(priority: Email['priority']): string {\n    const reasons: Record<string, string> = {\n      high: 'Contains urgent keywords or from important sender',\n      medium: 'Standard business communication',\n      low: 'Newsletter or informational content'\n    };\n\n    return reasons[priority || 'medium'];\n  }\n\n  private extractKeyPoints(body: string): string[] {\n    // Simple extraction - in production, use NLP\n    const sentences = body.split('.').filter(s => s.trim().length > 20);\n    return sentences.slice(0, 3).map(s => s.trim());\n  }\n\n  private analyzeSentiment(body: string): 'positive' | 'neutral' | 'negative' {\n    const positiveWords = ['thank', 'great', 'excellent', 'happy', 'pleased'];\n    const negativeWords = ['sorry', 'unfortunately', 'problem', 'issue', 'concerned'];\n\n    const text = body.toLowerCase();\n    const positiveCount = positiveWords.filter(w => text.includes(w)).length;\n    const negativeCount = negativeWords.filter(w => text.includes(w)).length;\n\n    if (positiveCount > negativeCount) return 'positive';\n    if (negativeCount > positiveCount) return 'negative';\n    return 'neutral';\n  }\n\n  async canHandle(query: string, context?: any): Promise<number> {\n    const keywords = [\n      'email', 'mail', 'message', 'inbox', 'sender', 'recipient',\n      'reply', 'forward', 'spam', 'courriel', 'courrier',\n      'envoyer', 'r├®pondre', 'transf├®rer'\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    const matches = keywords.filter(keyword => lowerQuery.includes(keyword));\n    \n    return matches.length > 0 ? Math.min(matches.length * 0.3, 1.0) : 0.0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\GeminiCliAgent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\GeminiCodeAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AgentParameter' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AgentCapability' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":18}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AgentDomains } from './types';\nimport type { \n  AgentDomain,\n  AgentParameter,\n  AgentCapability,\n  AgentExecuteProps, \n  AgentExecuteResult, \n  BaseAgent \n} from './types';\n\n/**\n * Agent sp├®cialis├® pour la g├®n├®ration de code via l'API Gemini\n * Fournit une interface pour g├®n├®rer du code ├á partir de prompts textuels\n */\nexport class GeminiCodeAgent implements BaseAgent {\n  // Identit├® et m├®tadonn├®es\n  public name = 'GeminiCodeAgent';\n  public description = 'Agent pour la g├®n├®ration de code via l\\'API Gemini';\n  public version = '1.0.0';\n  public domain: AgentDomain = AgentDomains.KNOWLEDGE;\n  public capabilities = ['generateCode'];\n  public valid = true;\n\n  /**\n   * M├®thode d'ex├®cution principale de l'agent\n   * @param props Propri├®t├®s d'ex├®cution\n   */\n  public async execute(_props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    // Simple stub implementation that returns a success response\n    return Promise.resolve({\n      success: true,\n      output: {\n        content: 'Generated code would appear here',\n        error: null\n      }\n    });\n  }\n}\n\n// Enregistrement de l'agent dans le registre\nimport { agentRegistry } from './AgentRegistry';\nagentRegistry.register(new GeminiCodeAgent());\n\nexport default GeminiCodeAgent;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\GitHubAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2345,2348],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2345,2348],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2359,2362],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2359,2362],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6154,6157],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6154,6157],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'cacheKey' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":181,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":181,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7527,7530],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7527,7530],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8890,8893],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8890,8893],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":292,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":292,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9782,9785],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9782,9785],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":312,"column":115,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":118,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10367,10370],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10367,10370],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":338,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":338,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11008,11011],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11008,11011],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":385,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12448,12451],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12448,12451],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":424,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13772,13775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13772,13775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":453,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":453,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { agentRegistry } from './registry';\nimport { AgentDomains, AgentParameter, BaseAgent } from './types';\nimport { Octokit } from '@octokit/rest';\nimport GitHubCacheService from '../services/GitHubCacheService';\n\nconst logger = console;\n\n/**\n * GitHubAgent - Agent pour interagir avec l'API GitHub\n * \n * Cet agent permet d'acc├®der aux fonctionnalit├®s de GitHub comme :\n * - Lister les d├®p├┤ts\n * - G├®rer les issues\n * - Consulter les pull requests\n * - Afficher les commits r├®cents\n */\nexport class GitHubAgent implements BaseAgent {\n  name = 'GitHubAgent';\n  description = 'Agent pour interagir avec GitHub (repos, issues, PRs, commits)';\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = ['repo-listing', 'issue-management', 'pr-management', 'commit-history'];\n\n  private octokit: Octokit | null = null;\n  private cacheService = GitHubCacheService.getInstance();\n  private useCache = true;\n\n  /**\n   * Initialise l'agent GitHub avec un token d'authentification\n   * @param token Token d'authentification GitHub (optionnel)\n   */\n  constructor(private token?: string) {\n    // Si un token est fourni ├á l'initialisation, cr├®er l'instance Octokit\n    if (token) {\n      this.initOctokit(token);\n    }\n  }\n\n  /**\n   * Initialise l'instance Octokit avec un token d'authentification\n   * @param token Token d'authentification GitHub\n   */\n  private initOctokit(token: string): void {\n    try {\n      this.octokit = new Octokit({ auth: token });\n      logger.info('GitHub Octokit initialis├® avec succ├¿s');\n    } catch (error) {\n      logger.error('Erreur lors de l\\'initialisation d\\'Octokit', error);\n      throw new Error('Impossible d\\'initialiser la connexion GitHub');\n    }\n  }\n\n  /**\n   * V├®rifie si l'agent peut traiter la requ├¬te\n   * @param query Requ├¬te utilisateur\n   * @returns Score de confiance entre 0 et 1\n   */\n  async canHandle(query: string): Promise<number> {\n    const githubKeywords = [\n      'github', 'repo', 'd├®p├┤t', 'repository', 'commit', 'pull request', \n      'pr', 'issue', 'bug', 'branche', 'branch', 'fork', '├®toile', 'star',\n      'git', 'clone', 'push', 'merge'\n    ];\n    \n    return this.calculateKeywordMatch(query, githubKeywords);\n  }\n\n  /**\n   * Ex├®cute une action GitHub\n   * @param params Param├¿tres de l'action\n   * @returns R├®sultat de l'action\n   */\n  async execute(params: any): Promise<any> {\n    const { action, token, useCache = true, ...actionParams } = params;\n    \n    // Configurer l'utilisation du cache\n    this.useCache = useCache;\n    \n    // Si un token est fourni dans les param├¿tres ou pas encore initialis├®\n    if ((token && (!this.octokit || token !== this.token)) || (!this.octokit && import.meta.env.VITE_GITHUB_TOKEN)) {\n      const authToken = token || import.meta.env.VITE_GITHUB_TOKEN;\n      this.initOctokit(authToken);\n      this.token = authToken;\n    }\n    \n    // Nettoyer le cache obsol├¿te de mani├¿re asynchrone\n    this.cacheService.clearStaleCache().catch(error => {\n      logger.warn('Erreur lors du nettoyage du cache obsol├¿te', error);\n    });\n    \n    // V├®rifier que l'Octokit est initialis├®\n    if (!this.octokit) {\n      throw new Error('GitHub non authentifi├®. Veuillez fournir un token d\\'acc├¿s.');\n    }\n    \n    try {\n      switch (action) {\n        case 'listRepositories':\n          return await this.listRepositories(actionParams.username, actionParams.page, actionParams.perPage);\n        case 'getRepository':\n          return await this.getRepository(actionParams.owner, actionParams.repo);\n        case 'listIssues':\n          return await this.listIssues(actionParams.owner, actionParams.repo, actionParams.state);\n        case 'createIssue':\n          return await this.createIssue(\n            actionParams.owner, \n            actionParams.repo, \n            actionParams.title, \n            actionParams.body, \n            actionParams.labels\n          );\n        case 'listPullRequests':\n          return await this.listPullRequests(actionParams.owner, actionParams.repo, actionParams.state);\n        case 'listCommits':\n          return await this.listCommits(actionParams.owner, actionParams.repo, actionParams.branch);\n        case 'getReadme':\n          return await this.getReadme(actionParams.owner, actionParams.repo);\n        default:\n          throw new Error(`Action inconnue: ${action}`);\n      }\n    } catch (error) {\n      logger.error(`Erreur lors de l'ex├®cution de l'action GitHub ${action}:`, error);\n      throw new Error(`Erreur GitHub: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    }\n  }\n\n  /**\n   * Retourne les param├¿tres requis pour une t├óche donn├®e\n   * @param task Description de la t├óche\n   * @returns Liste des param├¿tres requis\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    if (task.toLowerCase().includes('liste') && task.toLowerCase().includes('d├®p├┤t')) {\n      return [{\n        name: 'username',\n        description: 'Nom d\\'utilisateur GitHub',\n        type: 'string',\n        required: true\n      }, {\n        name: 'useCache',\n        description: 'Utiliser le cache (true par d├®faut)',\n        type: 'boolean',\n        required: false\n      }];\n    }\n    \n    // Param├¿tres pour les issues, PRs, etc.\n    if (task.toLowerCase().includes('issue') || task.toLowerCase().includes('pull request') || \n        task.toLowerCase().includes('commit') || task.toLowerCase().includes('readme')) {\n      return [{\n        name: 'owner',\n        description: 'Propri├®taire du d├®p├┤t',\n        type: 'string',\n        required: true\n      }, {\n        name: 'repo',\n        description: 'Nom du d├®p├┤t',\n        type: 'string',\n        required: true\n      }, {\n        name: 'useCache',\n        description: 'Utiliser le cache (true par d├®faut)',\n        type: 'boolean',\n        required: false\n      }];\n    }\n    \n    return [];\n  }\n\n  /**\n   * Liste les d├®p├┤ts d'un utilisateur\n   * @param username Nom d'utilisateur\n   * @param page Num├®ro de page (d├®faut: 1)\n   * @param perPage Nombre de r├®sultats par page (d├®faut: 30)\n   * @returns Liste des d├®p├┤ts\n   */\n  private async listRepositories(username: string, page = 1, perPage = 30): Promise<any> {\n    // V├®rifier le cache si activ├®\n    if (this.useCache) {\n      const cacheKey = { username, page, perPage };\n      const cachedData = await this.cacheService.getRepositories(username);\n      if (cachedData) {\n        logger.info(`Utilisation des donn├®es en cache pour les d├®p├┤ts de ${username}`);\n        return cachedData;\n      }\n    }\n    \n    // R├®cup├®rer les donn├®es depuis l'API si pas en cache ou cache d├®sactiv├®\n    const response = await this.octokit!.repos.listForUser({\n      username,\n      per_page: perPage,\n      page\n    });\n    \n    const repositories = response.data.map(repo => ({\n      id: repo.id,\n      name: repo.name,\n      fullName: repo.full_name,\n      description: repo.description,\n      url: repo.html_url,\n      stars: repo.stargazers_count,\n      forks: repo.forks_count,\n      language: repo.language,\n      isPrivate: repo.private,\n      updatedAt: repo.updated_at,\n      createdAt: repo.created_at\n    }));\n    \n    // Mettre en cache les r├®sultats si le cache est activ├®\n    if (this.useCache) {\n      await this.cacheService.cacheRepositories(username, repositories);\n    }\n    \n    return repositories;\n  }\n\n  /**\n   * Obtient les d├®tails d'un d├®p├┤t\n   * @param owner Propri├®taire du d├®p├┤t\n   * @param repo Nom du d├®p├┤t\n   * @returns D├®tails du d├®p├┤t\n   */\n  private async getRepository(owner: string, repo: string): Promise<any> {\n    // V├®rifier le cache si activ├®\n    if (this.useCache) {\n      const cachedData = await this.cacheService.getRepository(owner, repo);\n      if (cachedData) {\n        logger.info(`Utilisation des donn├®es en cache pour le d├®p├┤t ${owner}/${repo}`);\n        return cachedData;\n      }\n    }\n    \n    // R├®cup├®rer les donn├®es depuis l'API si pas en cache ou cache d├®sactiv├®\n    const response = await this.octokit!.repos.get({ owner, repo });\n    const repoData = response.data;\n    \n    return {\n      id: repoData.id,\n      name: repoData.name,\n      fullName: repoData.full_name,\n      description: repoData.description,\n      url: repoData.html_url,\n      stars: repoData.stargazers_count,\n      forks: repoData.forks_count,\n      language: repoData.language,\n      isPrivate: repoData.private,\n      defaultBranch: repoData.default_branch,\n      createdAt: repoData.created_at,\n      updatedAt: repoData.updated_at,\n      topics: repoData.topics,\n      hasIssues: repoData.has_issues,\n      hasProjects: repoData.has_projects,\n      hasWiki: repoData.has_wiki\n    };\n  }\n\n  /**\n   * Liste les issues d'un d├®p├┤t\n   * @param owner Propri├®taire du d├®p├┤t\n   * @param repo Nom du d├®p├┤t\n   * @param state ├ëtat des issues (all, open, closed)\n   * @returns Liste des issues\n   */\n  private async listIssues(owner: string, repo: string, state = 'open'): Promise<any> {\n    // V├®rifier le cache si activ├®\n    if (this.useCache) {\n      const cachedIssues = await this.cacheService.getIssues(owner, repo, state);\n      if (cachedIssues) {\n        logger.info(`Utilisation des donn├®es en cache pour les issues de ${owner}/${repo}`);\n        return cachedIssues;\n      }\n    }\n    \n    // R├®cup├®rer les donn├®es depuis l'API si pas en cache ou cache d├®sactiv├®\n    const response = await this.octokit!.issues.listForRepo({\n      owner,\n      repo,\n      state: state as 'open' | 'closed' | 'all'\n    });\n    \n    const issues = response.data.map(issue => ({\n      id: issue.id,\n      number: issue.number,\n      title: issue.title,\n      state: issue.state,\n      url: issue.html_url,\n      createdAt: issue.created_at,\n      updatedAt: issue.updated_at,\n      closedAt: issue.closed_at,\n      author: issue.user?.login,\n      labels: issue.labels.map((label: any) => label.name)\n    }));\n    \n    // Mettre en cache les r├®sultats si le cache est activ├®\n    if (this.useCache) {\n      await this.cacheService.cacheIssues(owner, repo, state, issues);\n    }\n    \n    return issues;\n  }\n\n  /**\n   * Cr├®e une nouvelle issue\n   * @param owner Propri├®taire du d├®p├┤t\n   * @param repo Nom du d├®p├┤t\n   * @param title Titre de l'issue\n   * @param body Contenu de l'issue\n   * @param labels Labels ├á appliquer\n   * @returns Issue cr├®├®e\n   */\n  private async createIssue(owner: string, repo: string, title: string, body: string, labels?: string[]): Promise<any> {\n    const response = await this.octokit!.issues.create({\n      owner,\n      repo,\n      title,\n      body,\n      labels\n    });\n    \n    const issue = response.data;\n    return {\n      id: issue.id,\n      number: issue.number,\n      title: issue.title,\n      url: issue.html_url,\n      createdAt: issue.created_at\n    };\n  }\n\n  /**\n   * Liste les pull requests d'un d├®p├┤t\n   * @param owner Propri├®taire du d├®p├┤t\n   * @param repo Nom du d├®p├┤t\n   * @param state ├ëtat des pull requests (all, open, closed)\n   * @returns Liste des pull requests\n   */\n  private async listPullRequests(owner: string, repo: string, state = 'open'): Promise<any> {\n    // V├®rifier le cache si activ├®\n    if (this.useCache) {\n      const cachedPRs = await this.cacheService.getPullRequests(owner, repo, state);\n      if (cachedPRs) {\n        logger.info(`Utilisation des donn├®es en cache pour les pull requests de ${owner}/${repo}`);\n        return cachedPRs;\n      }\n    }\n    \n    // R├®cup├®rer les donn├®es depuis l'API si pas en cache ou cache d├®sactiv├®\n    const response = await this.octokit!.pulls.list({\n      owner,\n      repo,\n      state: state as 'open' | 'closed' | 'all'\n    });\n    \n    const pullRequests = response.data.map(pr => ({\n      id: pr.id,\n      number: pr.number,\n      title: pr.title,\n      state: pr.state,\n      url: pr.html_url,\n      createdAt: pr.created_at,\n      updatedAt: pr.updated_at,\n      closedAt: pr.closed_at,\n      mergedAt: pr.merged_at,\n      author: pr.user?.login,\n      sourceBranch: pr.head.ref,\n      targetBranch: pr.base.ref\n    }));\n    \n    // Mettre en cache les r├®sultats si le cache est activ├®\n    if (this.useCache) {\n      await this.cacheService.cachePullRequests(owner, repo, state, pullRequests);\n    }\n    \n    return pullRequests;\n  }\n\n  /**\n   * Liste les commits d'un d├®p├┤t\n   * @param owner Propri├®taire du d├®p├┤t\n   * @param repo Nom du d├®p├┤t\n   * @param branch Nom de la branche (d├®faut: branche par d├®faut)\n   * @returns Liste des commits\n   */\n  private async listCommits(owner: string, repo: string, branch?: string): Promise<any> {\n    // V├®rifier le cache si activ├®\n    if (this.useCache && !branch) { // Cache uniquement pour la branche par d├®faut\n      const cachedCommits = await this.cacheService.getCommits(owner, repo);\n      if (cachedCommits) {\n        logger.info(`Utilisation des donn├®es en cache pour les commits de ${owner}/${repo}`);\n        return cachedCommits;\n      }\n    }\n    \n    // R├®cup├®rer les donn├®es depuis l'API si pas en cache ou cache d├®sactiv├®\n    const response = await this.octokit!.repos.listCommits({\n      owner,\n      repo,\n      ...(branch ? { sha: branch } : {})\n    });\n    \n    const commits = response.data.map(commit => ({\n      sha: commit.sha,\n      url: commit.html_url,\n      message: commit.commit.message,\n      author: commit.author?.login || commit.commit.author?.name || 'Unknown',\n      date: commit.commit.author?.date\n    }));\n    \n    // Mettre en cache les r├®sultats si le cache est activ├® et qu'il s'agit de la branche par d├®faut\n    if (this.useCache && !branch) {\n      await this.cacheService.cacheCommits(owner, repo, commits);\n    }\n    \n    return commits;\n  }\n\n  /**\n   * R├®cup├¿re le contenu du README d'un d├®p├┤t\n   * @param owner Propri├®taire du d├®p├┤t\n   * @param repo Nom du d├®p├┤t\n   * @returns Contenu du README\n   */\n  private async getReadme(owner: string, repo: string): Promise<any> {\n    try {\n      // V├®rifier le cache si activ├®\n      if (this.useCache) {\n        const cachedReadme = await this.cacheService.getReadme(owner, repo);\n        if (cachedReadme) {\n          logger.info(`Utilisation du README en cache pour ${owner}/${repo}`);\n          return cachedReadme;\n        }\n      }\n      \n      // R├®cup├®rer les donn├®es depuis l'API si pas en cache ou cache d├®sactiv├®\n      const response = await this.octokit!.repos.getReadme({\n        owner,\n        repo\n      });\n      \n      const content = Buffer.from(response.data.content, 'base64').toString('utf-8');\n      const result = {\n        content,\n        url: response.data.html_url\n      };\n      \n      // Mettre en cache les r├®sultats si le cache est activ├®\n      if (this.useCache) {\n        await this.cacheService.cacheReadme(owner, repo, content, response.data.html_url);\n      }\n      \n      return result;\n    } catch (error) {\n      logger.warn(`README non trouv├® pour ${owner}/${repo}`);\n      return { content: null, error: 'README non trouv├®' };\n    }\n  }\n\n  /**\n   * Calcule le score de correspondance entre une requ├¬te et des mots-cl├®s\n   * @param query Requ├¬te utilisateur\n   * @param keywords Liste de mots-cl├®s\n   * @returns Score de correspondance (0-1)\n   */\n  private calculateKeywordMatch(query: string, keywords: string[]): number {\n    const words = query.toLowerCase().split(' ');\n    const matches = keywords.filter(kw => words.some(w => w.includes(kw.toLowerCase())));\n    return matches.length / Math.max(5, 1); // Score normalis├® entre 0 et 1\n  }\n}\n\n// Enregistrer l'agent dans le registre global\nconst githubAgent = new GitHubAgent();\nagentRegistry.register(githubAgent);\n\nexport default githubAgent;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\HealthMonitorAgent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\HearingAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":26,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":26,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":75,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":75,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2098,2101],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2098,2101],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2990,2993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2990,2993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4168,4171],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4168,4171],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":191,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":191,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4825,4828],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4825,4828],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":224,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":224,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5511,5514],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5511,5514],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6177,6180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6177,6180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":280,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":280,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":280,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":280,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6771,6774],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6771,6774],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * HearingAgent - Audio Classification and Speech Recognition\n * \n * Handles audio analysis, speech recognition, and sound classification\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\n\nexport class HearingAgent implements BaseAgent {\n  name = 'HearingAgent';\n  description = 'Handles audio classification, speech recognition, and sound analysis';\n  version = '1.0.0';\n  domain: AgentDomain = AgentDomains.ANALYSIS;\n  capabilities = [\n    'audio_classification',\n    'speech_recognition',\n    'sound_detection',\n    'noise_filtering',\n    'volume_analysis',\n    'audio_transcription'\n  ];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { intent, context, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'classify_audio':\n          return await this.classifyAudio(parameters);\n        \n        case 'recognize_speech':\n          return await this.recognizeSpeech(parameters);\n        \n        case 'detect_sound':\n          return await this.detectSound(parameters);\n        \n        case 'analyze_volume':\n          return await this.analyzeVolume(parameters);\n        \n        case 'transcribe_audio':\n          return await this.transcribeAudio(parameters);\n        \n        case 'filter_noise':\n          return await this.filterNoise(parameters);\n        \n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Classify audio content\n   */\n  private async classifyAudio(params: any): Promise<AgentExecuteResult> {\n    const { audioData, audioBuffer } = params;\n\n    if (!audioData && !audioBuffer) {\n      return {\n        success: false,\n        output: null,\n        error: 'No audio data provided'\n      };\n    }\n\n    // TODO: Integrate with actual audio classification model\n    // For now, return mock classification\n    const classifications = [\n      { label: 'speech', confidence: 0.85 },\n      { label: 'music', confidence: 0.10 },\n      { label: 'background_noise', confidence: 0.05 }\n    ];\n\n    return {\n      success: true,\n      output: {\n        classifications,\n        primaryClass: classifications[0].label,\n        confidence: classifications[0].confidence\n      },\n      metadata: {\n        source: 'HearingAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Recognize speech from audio\n   */\n  private async recognizeSpeech(params: any): Promise<AgentExecuteResult> {\n    const { audioBlob, language = 'fr-FR' } = params;\n\n    if (!audioBlob) {\n      return {\n        success: false,\n        output: null,\n        error: 'No audio blob provided'\n      };\n    }\n\n    try {\n      // Check if Web Speech API is available\n      if (!('webkitSpeechRecognition' in window) && !('SpeechRecognition' in window)) {\n        return {\n          success: false,\n          output: null,\n          error: 'Speech recognition not supported in this browser'\n        };\n      }\n\n      // For now, return a placeholder\n      // In production, this would integrate with Web Speech API or external service\n      return {\n        success: true,\n        output: {\n          transcript: '[Speech recognition in progress]',\n          confidence: 0.0,\n          language\n        },\n        metadata: {\n          source: 'HearingAgent',\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Detect specific sounds\n   */\n  private async detectSound(params: any): Promise<AgentExecuteResult> {\n    const { audioData, targetSound } = params;\n\n    if (!audioData) {\n      return {\n        success: false,\n        output: null,\n        error: 'No audio data provided'\n      };\n    }\n\n    // TODO: Implement actual sound detection\n    const detected = false;\n    const confidence = 0.0;\n\n    return {\n      success: true,\n      output: {\n        detected,\n        targetSound,\n        confidence,\n        timestamp: Date.now()\n      },\n      metadata: {\n        source: 'HearingAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Analyze audio volume levels\n   */\n  private async analyzeVolume(params: any): Promise<AgentExecuteResult> {\n    const { audioData, audioBuffer } = params;\n\n    if (!audioData && !audioBuffer) {\n      return {\n        success: false,\n        output: null,\n        error: 'No audio data provided'\n      };\n    }\n\n    // Calculate volume metrics\n    // This is a placeholder - in production, analyze actual audio buffer\n    const volume = {\n      average: 0.5,\n      peak: 0.8,\n      rms: 0.45,\n      decibels: -20\n    };\n\n    return {\n      success: true,\n      output: volume,\n      metadata: {\n        source: 'HearingAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Transcribe audio to text\n   */\n  private async transcribeAudio(params: any): Promise<AgentExecuteResult> {\n    const { audioFile, language = 'fr-FR' } = params;\n\n    if (!audioFile) {\n      return {\n        success: false,\n        output: null,\n        error: 'No audio file provided'\n      };\n    }\n\n    // TODO: Integrate with Whisper or other transcription service\n    return {\n      success: true,\n      output: {\n        transcript: '[Transcription pending - integrate with Whisper API]',\n        language,\n        duration: 0,\n        words: []\n      },\n      metadata: {\n        source: 'HearingAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Filter noise from audio\n   */\n  private async filterNoise(params: any): Promise<AgentExecuteResult> {\n    const { audioData, noiseLevel = 'medium' } = params;\n\n    if (!audioData) {\n      return {\n        success: false,\n        output: null,\n        error: 'No audio data provided'\n      };\n    }\n\n    // TODO: Implement actual noise filtering\n    return {\n      success: true,\n      output: {\n        filteredAudio: audioData,\n        noiseReduction: noiseLevel,\n        message: 'Noise filtering applied'\n      },\n      metadata: {\n        source: 'HearingAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  async canHandle(query: string, context?: any): Promise<number> {\n    const keywords = [\n      'audio', 'sound', 'hear', 'listen', 'voice', 'speech',\n      'noise', 'volume', 'transcribe', 'recognize', 'classify',\n      'entendre', 'son', 'audio', 'voix', 'bruit', 'parole'\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    const matches = keywords.filter(keyword => lowerQuery.includes(keyword));\n    \n    return matches.length > 0 ? Math.min(matches.length * 0.3, 1.0) : 0.0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\ImageAnalysisAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1940,1943],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1940,1943],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2623,2626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2623,2626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3289,3292],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3289,3292],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3833,3836],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3833,3836],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":143,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4482,4485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4482,4485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":168,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":168,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5247,5250],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5247,5250],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":192,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":192,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":192,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":192,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6000,6003],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6000,6003],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ImageAnalysisAgent - Advanced Image Analysis\n * \n * Performs comprehensive image analysis including object recognition, scene analysis, and OCR\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\n\nexport class ImageAnalysisAgent implements BaseAgent {\n  name = 'ImageAnalysisAgent';\n  description = 'Analyzes images with object recognition, scene understanding, and OCR';\n  version = '1.0.0';\n  domain: AgentDomain = AgentDomains.ANALYSIS;\n  capabilities = [\n    'object_recognition',\n    'scene_analysis',\n    'ocr_extraction',\n    'face_detection',\n    'color_analysis',\n    'image_classification'\n  ];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { intent, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'recognize_objects':\n          return await this.recognizeObjects(parameters);\n        case 'analyze_scene':\n          return await this.analyzeScene(parameters);\n        case 'extract_text':\n          return await this.extractText(parameters);\n        case 'detect_faces':\n          return await this.detectFaces(parameters);\n        case 'analyze_colors':\n          return await this.analyzeColors(parameters);\n        case 'classify_image':\n          return await this.classifyImage(parameters);\n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: { executionTime: Date.now() - startTime, timestamp: Date.now() }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: { executionTime: Date.now() - startTime, timestamp: Date.now() }\n      };\n    }\n  }\n\n  private async recognizeObjects(params: any): Promise<AgentExecuteResult> {\n    const { imageData, imageUrl } = params;\n    if (!imageData && !imageUrl) {\n      return { success: false, output: null, error: 'No image provided' };\n    }\n\n    // TODO: Integrate with actual object detection model (YOLO, EfficientDet)\n    const objects = [\n      { label: 'person', confidence: 0.95, bbox: { x: 100, y: 100, w: 200, h: 300 } },\n      { label: 'chair', confidence: 0.87, bbox: { x: 300, y: 200, w: 150, h: 150 } }\n    ];\n\n    return {\n      success: true,\n      output: { objects, count: objects.length },\n      metadata: { source: 'ImageAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async analyzeScene(params: any): Promise<AgentExecuteResult> {\n    const { imageData, imageUrl } = params;\n    if (!imageData && !imageUrl) {\n      return { success: false, output: null, error: 'No image provided' };\n    }\n\n    // TODO: Integrate with scene understanding model\n    const scene = {\n      environment: 'indoor',\n      setting: 'office',\n      lighting: 'bright',\n      timeOfDay: 'day',\n      weather: 'clear',\n      description: 'Office environment with desk and chair',\n      confidence: 0.85\n    };\n\n    return {\n      success: true,\n      output: scene,\n      metadata: { source: 'ImageAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async extractText(params: any): Promise<AgentExecuteResult> {\n    const { imageData, imageUrl } = params;\n    if (!imageData && !imageUrl) {\n      return { success: false, output: null, error: 'No image provided' };\n    }\n\n    // TODO: Integrate with Tesseract.js or cloud OCR\n    return {\n      success: true,\n      output: {\n        text: '[OCR text extraction pending - integrate OCR engine]',\n        confidence: 0.0,\n        blocks: []\n      },\n      metadata: { source: 'ImageAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async detectFaces(params: any): Promise<AgentExecuteResult> {\n    const { imageData, imageUrl } = params;\n    if (!imageData && !imageUrl) {\n      return { success: false, output: null, error: 'No image provided' };\n    }\n\n    // TODO: Integrate with face detection model\n    const faces = [\n      {\n        bbox: { x: 150, y: 100, w: 120, h: 150 },\n        confidence: 0.98,\n        landmarks: { leftEye: { x: 170, y: 130 }, rightEye: { x: 210, y: 130 } }\n      }\n    ];\n\n    return {\n      success: true,\n      output: { faces, count: faces.length },\n      metadata: { source: 'ImageAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async analyzeColors(params: any): Promise<AgentExecuteResult> {\n    const { imageData, imageUrl } = params;\n    if (!imageData && !imageUrl) {\n      return { success: false, output: null, error: 'No image provided' };\n    }\n\n    // TODO: Implement actual color analysis\n    const colorAnalysis = {\n      dominantColors: [\n        { color: '#3B82F6', percentage: 35, name: 'blue' },\n        { color: '#FFFFFF', percentage: 30, name: 'white' },\n        { color: '#1F2937', percentage: 25, name: 'dark gray' }\n      ],\n      colorScheme: 'cool',\n      brightness: 'medium',\n      saturation: 'moderate'\n    };\n\n    return {\n      success: true,\n      output: colorAnalysis,\n      metadata: { source: 'ImageAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  private async classifyImage(params: any): Promise<AgentExecuteResult> {\n    const { imageData, imageUrl } = params;\n    if (!imageData && !imageUrl) {\n      return { success: false, output: null, error: 'No image provided' };\n    }\n\n    // TODO: Integrate with image classification model\n    const classifications = [\n      { category: 'business', confidence: 0.88 },\n      { category: 'office', confidence: 0.75 },\n      { category: 'workspace', confidence: 0.65 }\n    ];\n\n    return {\n      success: true,\n      output: {\n        classifications,\n        primaryCategory: classifications[0].category,\n        confidence: classifications[0].confidence\n      },\n      metadata: { source: 'ImageAnalysisAgent', timestamp: Date.now() }\n    };\n  }\n\n  async canHandle(query: string, context?: any): Promise<number> {\n    const keywords = [\n      'image', 'picture', 'photo', 'visual', 'object', 'scene',\n      'recognize', 'identify', 'detect', 'analyze',\n      'image', 'photo', 'objet', 'sc├¿ne', 'reconna├«tre', 'd├®tecter'\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    const matches = keywords.filter(keyword => lowerQuery.includes(keyword));\n    return matches.length > 0 ? Math.min(matches.length * 0.3, 1.0) : 0.0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\KnowledgeGraphAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'jsonld' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[498,501],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[498,501],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1241,1244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1241,1244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2827,2830],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2827,2830],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3847,3850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3847,3850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3964,3967],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3964,3967],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AgentDomains } from './types';\nimport type {\n  AgentCapability,\n  AgentExecuteProps,\n  AgentExecuteResult,\n  AgentParameter,\n  BaseAgent\n} from './types';\nimport * as jsonld from 'jsonld';\nimport { Store, DataFactory } from 'n3';\nconst { namedNode, literal, quad } = DataFactory;\n\nexport type KnowledgeGraphAction = 'add_entity' | 'add_relationship' | 'query' | 'delete_entity' | 'delete_relationship';\n\nexport interface Entity {\n  id: string;\n  type: string;\n  properties: Record<string, any>;\n}\n\nexport interface Relationship {\n  subject: string;\n  predicate: string;\n  object: string;\n}\n\nexport class KnowledgeGraphAgent implements BaseAgent {\n  name = 'KnowledgeGraphAgent';\n  description = 'Manages a knowledge graph for Lisa, storing and querying entities and relationships.';\n  version = '1.0.0';\n  domain = AgentDomains.KNOWLEDGE;\n  capabilities = ['add_entity', 'add_relationship', 'query_graph'];\n\n  private store: Store;\n\n  constructor() {\n    this.store = new Store();\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const action = props.action as KnowledgeGraphAction;\n    const parameters = props.parameters || {};\n\n    try {\n      let resultOutput: any;\n\n      switch (action) {\n        case 'add_entity':\n          if (!parameters.entity) {\n            throw new Error('Entity data is required to add an entity.');\n          }\n          resultOutput = this.addEntity(parameters.entity);\n          break;\n\n        case 'add_relationship':\n          if (!parameters.relationship) {\n            throw new Error('Relationship data is required to add a relationship.');\n          }\n          resultOutput = this.addRelationship(parameters.relationship);\n          break;\n\n        case 'query':\n          if (!parameters.query) {\n            throw new Error('Query is required to query the knowledge graph.');\n          }\n          resultOutput = this.queryGraph(parameters.query);\n          break;\n\n        case 'delete_entity':\n          if (!parameters.entityId) {\n            throw new Error('Entity ID is required to delete an entity.');\n          }\n          resultOutput = this.deleteEntity(parameters.entityId);\n          break;\n\n        case 'delete_relationship':\n          if (!parameters.relationship) {\n            throw new Error('Relationship data is required to delete a relationship.');\n          }\n          resultOutput = this.deleteRelationship(parameters.relationship);\n          break;\n\n        default:\n          return { success: false, error: `Unknown KnowledgeGraph action: ${action}`, output: null };\n      }\n\n      return {\n        success: true,\n        output: resultOutput,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          action: action,\n        },\n      };\n    } catch (error: any) {\n      console.error(`${this.name} execution error for action ${action}:`, error);\n      return {\n        success: false,\n        error: error.message || 'An unknown error occurred during KnowledgeGraph action.',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          action: action,\n        },\n      };\n    }\n  }\n\n  private addEntity(entity: Entity): boolean {\n    const subject = namedNode(entity.id);\n    this.store.add(quad(subject, namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'), namedNode(entity.type)));\n    for (const prop in entity.properties) {\n      this.store.add(quad(subject, namedNode(`http://example.org/ontology/${prop}`), literal(entity.properties[prop])));\n    }\n    return true;\n  }\n\n  private addRelationship(relationship: Relationship): boolean {\n    this.store.add(quad(namedNode(relationship.subject), namedNode(relationship.predicate), namedNode(relationship.object)));\n    return true;\n  }\n\n  private queryGraph(query: string): any[] {\n    // This is a very basic query implementation. A full implementation would use SPARQL.\n    const results: any[] = [];\n    this.store.forEach(quad => {\n      if (quad.subject.value.includes(query) || quad.predicate.value.includes(query) || quad.object.value.includes(query)) {\n        results.push({\n          subject: quad.subject.value,\n          predicate: quad.predicate.value,\n          object: quad.object.value,\n        });\n      }\n    });\n    return results;\n  }\n\n  private deleteEntity(entityId: string): boolean {\n    const subject = namedNode(entityId);\n    const quadsToDelete = this.store.getQuads(subject, null, null, null);\n    this.store.removeQuads(quadsToDelete);\n    return quadsToDelete.length > 0;\n  }\n\n  private deleteRelationship(relationship: Relationship): boolean {\n    const quadsToDelete = this.store.getQuads(namedNode(relationship.subject), namedNode(relationship.predicate), namedNode(relationship.object), null);\n    this.store.removeQuads(quadsToDelete);\n    return quadsToDelete.length > 0;\n  }\n\n  async canHandle(query: string): Promise<number> {\n    const lowerQuery = query.toLowerCase();\n    const keywords = ['knowledge graph', 'graph de connaissances', 'entity', 'relation', 'query graph', 'add fact'];\n    const matchCount = keywords.filter(keyword => lowerQuery.includes(keyword)).length;\n    return matchCount > 0 ? 0.7 : 0;\n  }\n\n  async getRequiredParameters(action: string): Promise<AgentParameter[]> {\n    switch (action) {\n      case 'add_entity':\n        return [\n          { name: 'entity', type: 'object', required: true, description: 'The entity object to add (id, type, properties).' },\n        ];\n      case 'add_relationship':\n        return [\n          { name: 'relationship', type: 'object', required: true, description: 'The relationship object to add (subject, predicate, object).' },\n        ];\n      case 'query':\n        return [\n          { name: 'query', type: 'string', required: true, description: 'The query string to search the graph.' },\n        ];\n      case 'delete_entity':\n        return [\n          { name: 'entityId', type: 'string', required: true, description: 'The ID of the entity to delete.' },\n        ];\n      case 'delete_relationship':\n        return [\n          { name: 'relationship', type: 'object', required: true, description: 'The relationship object to delete (subject, predicate, object).' },\n        ];\n      default:\n        return [];\n    }\n  }\n\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'add_entity',\n        description: 'Adds a new entity to the knowledge graph.',\n        requiredParameters: await this.getRequiredParameters('add_entity'),\n      },\n      {\n        name: 'add_relationship',\n        description: 'Adds a new relationship between entities in the knowledge graph.',\n        requiredParameters: await this.getRequiredParameters('add_relationship'),\n      },\n      {\n        name: 'query_graph',\n        description: 'Queries the knowledge graph for entities or relationships.',\n        requiredParameters: await this.getRequiredParameters('query'),\n      },\n      {\n        name: 'delete_entity',\n        description: 'Deletes an entity from the knowledge graph.',\n        requiredParameters: await this.getRequiredParameters('delete_entity'),\n      },\n      {\n        name: 'delete_relationship',\n        description: 'Deletes a relationship from the knowledge graph.',\n        requiredParameters: await this.getRequiredParameters('delete_relationship'),\n      },\n    ];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\LazyAgentLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1521,1524],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1521,1524],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Lazy loader pour les agents - am├®liore les performances de d├®marrage\n */\n\nimport { type BaseAgent } from './types.js';\n\nexport class LazyAgentLoader {\n  private static instance: LazyAgentLoader;\n  private loadedAgents = new Map<string, BaseAgent>();\n  private loadingPromises = new Map<string, Promise<BaseAgent>>();\n\n  static getInstance(): LazyAgentLoader {\n    if (!LazyAgentLoader.instance) {\n      LazyAgentLoader.instance = new LazyAgentLoader();\n    }\n    return LazyAgentLoader.instance;\n  }\n\n  async loadAgent(agentName: string): Promise<BaseAgent> {\n    // Si l'agent est d├®j├á charg├®, le retourner\n    if (this.loadedAgents.has(agentName)) {\n      return this.loadedAgents.get(agentName)!;\n    }\n\n    // Si l'agent est en cours de chargement, attendre la promesse existante\n    if (this.loadingPromises.has(agentName)) {\n      return this.loadingPromises.get(agentName)!;\n    }\n\n    // Charger l'agent de mani├¿re asynchrone\n    const loadingPromise = this.dynamicImportAgent(agentName);\n    this.loadingPromises.set(agentName, loadingPromise);\n\n    try {\n      const agent = await loadingPromise;\n      this.loadedAgents.set(agentName, agent);\n      this.loadingPromises.delete(agentName);\n      return agent;\n    } catch (error) {\n      this.loadingPromises.delete(agentName);\n      throw error;\n    }\n  }\n\n  private async dynamicImportAgent(agentName: string): Promise<BaseAgent> {\n    try {\n      // Mapping des noms d'agents vers leurs fichiers\n      const agentModules: Record<string, () => Promise<any>> = {\n        'PlannerAgent': () => import('./PlannerAgent.js'),\n        'VisionAgent': () => import('./VisionAgent.js'),\n        'RobotAgent': () => import('./RobotAgent.js'),\n        'WeatherAgent': () => import('./WeatherAgent.js'),\n        'TodoAgent': () => import('./TodoAgent.js'),\n        'MemoryAgent': () => import('./MemoryAgent.js'),\n        'OCRAgent': () => import('./OCRAgent.js'),\n        'SystemIntegrationAgent': () => import('./SystemIntegrationAgent.js'),\n        'TransformAgent': () => import('./TransformAgent.js'),\n        'TriggerAgent': () => import('./TriggerAgent.js'),\n        'CalendarAgent': () => import('./CalendarAgent.js'),\n        'CodeInterpreterAgent': () => import('./CodeInterpreterAgent.js'),\n        'ContentGeneratorAgent': () => import('./ContentGeneratorAgent.js'),\n        'WebSearchAgent': () => import('./WebSearchAgent.js'),\n        'SmartHomeAgent': () => import('./SmartHomeAgent.js'),\n        'MetaHumanAgent': () => import('./MetaHumanAgent.js'),\n        'SpeechSynthesisAgent': () => import('./SpeechSynthesisAgent.js'),\n        'NLUAgent': () => import('./NLUAgent.js'),\n        'PersonalizationAgent': () => import('./PersonalizationAgent.js'),\n        'ProactiveSuggestionsAgent': () => import('./ProactiveSuggestionsAgent.js'),\n        'SmallTalkAgent': () => import('./SmallTalkAgent.js'),\n        'UserWorkflowAgent': () => import('./UserWorkflowAgent.js'),\n        'WorkflowCodeAgent': () => import('./WorkflowCodeAgent.js'),\n        'WorkflowHTTPAgent': () => import('./WorkflowHTTPAgent.js'),\n        'WebContentReaderAgent': () => import('./WebContentReaderAgent.js'),\n        'KnowledgeGraphAgent': () => import('./KnowledgeGraphAgent.js'),\n        'MQTTAgent': () => import('./MQTTAgent.js'),\n        'RosAgent': () => import('./RosAgent.js'),\n        'RosPublisherAgent': () => import('./RosPublisherAgent.js'),\n        'GitHubAgent': () => import('./GitHubAgent.js'),\n        'GeminiCliAgent': () => import('./GeminiCliAgent.js'),\n        'GeminiCodeAgent': () => import('./GeminiCodeAgent.js'),\n        'PowerShellAgent': () => import('./PowerShellAgent.js'),\n        'ScreenShareAgent': () => import('./ScreenShareAgent.js'),\n        'ConditionAgent': () => import('./ConditionAgent.js'),\n        'ContextAgent': () => import('./ContextAgent.js'),\n        'DelayAgent': () => import('./DelayAgent.js')\n      };\n\n      const moduleLoader = agentModules[agentName];\n      if (!moduleLoader) {\n        throw new Error(`Agent inconnu: ${agentName}`);\n      }\n\n      console.log(`­ƒöä Chargement lazy de l'agent: ${agentName}`);\n      const module = await moduleLoader();\n      \n      // Chercher la classe d'agent dans le module\n      const AgentClass = module[agentName] || module.default;\n      if (!AgentClass) {\n        throw new Error(`Classe d'agent non trouv├®e dans le module: ${agentName}`);\n      }\n\n      const agent = new AgentClass();\n      console.log(`Ô£à Agent charg├® avec succ├¿s: ${agentName}`);\n      \n      return agent;\n    } catch (error) {\n      console.error(`ÔØî Erreur lors du chargement de l'agent ${agentName}:`, error);\n      throw new Error(`Impossible de charger l'agent ${agentName}: ${error}`);\n    }\n  }\n\n  isAgentLoaded(agentName: string): boolean {\n    return this.loadedAgents.has(agentName);\n  }\n\n  getLoadedAgents(): string[] {\n    return Array.from(this.loadedAgents.keys());\n  }\n\n  unloadAgent(agentName: string): void {\n    this.loadedAgents.delete(agentName);\n    this.loadingPromises.delete(agentName);\n  }\n\n  clearCache(): void {\n    this.loadedAgents.clear();\n    this.loadingPromises.clear();\n  }\n\n  getMemoryUsage(): { loadedCount: number; loadingCount: number } {\n    return {\n      loadedCount: this.loadedAgents.size,\n      loadingCount: this.loadingPromises.size\n    };\n  }\n}\n\nexport const lazyAgentLoader = LazyAgentLoader.getInstance();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\MQTTAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1055,1058],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1055,1058],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":89,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":89,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2910,2913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2910,2913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":84,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":87,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3350,3353],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3350,3353],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":130,"column":113,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":130,"endColumn":116,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4293,4296],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4293,4296],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":143,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":143,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4780,4783],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4780,4783],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5428,5431],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5428,5431],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":172,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":172,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5875,5878],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5875,5878],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AgentDomains } from './types';\nimport type {\n  AgentCapability,\n  AgentExecuteProps,\n  AgentExecuteResult,\n  AgentParameter,\n  BaseAgent\n} from './types';\nimport * as mqtt from 'mqtt';\n\nexport type MQTTAction = 'connect' | 'publish' | 'subscribe' | 'unsubscribe' | 'disconnect';\n\nexport class MQTTAgent implements BaseAgent {\n  name = 'MQTTAgent';\n  description = 'Manages MQTT connections, subscriptions, and publications for IoT integration.';\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = ['mqtt_connect', 'mqtt_publish', 'mqtt_subscribe', 'mqtt_disconnect'];\n\n  private client: mqtt.MqttClient | null = null;\n  private subscriptions: Map<string, (message: Buffer) => void> = new Map();\n\n  constructor() {\n    // No-op constructor, connection is handled via execute method\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const action = props.action as MQTTAction;\n    const parameters = props.parameters || {};\n\n    try {\n      let resultOutput: any;\n\n      switch (action) {\n        case 'connect':\n          if (!parameters.brokerUrl) {\n            throw new Error('Broker URL is required for connection.');\n          }\n          resultOutput = await this.connect(parameters.brokerUrl, parameters.options);\n          break;\n\n        case 'publish':\n          if (!this.client || !this.client.connected) {\n            throw new Error('Not connected to MQTT broker.');\n          }\n          if (!parameters.topic || !parameters.message) {\n            throw new Error('Topic and message are required for publishing.');\n          }\n          resultOutput = await this.publish(parameters.topic, parameters.message, parameters.options);\n          break;\n\n        case 'subscribe':\n          if (!this.client || !this.client.connected) {\n            throw new Error('Not connected to MQTT broker.');\n          }\n          if (!parameters.topic) {\n            throw new Error('Topic is required for subscription.');\n          }\n          resultOutput = await this.subscribe(parameters.topic, parameters.options);\n          break;\n\n        case 'unsubscribe':\n          if (!this.client || !this.client.connected) {\n            throw new Error('Not connected to MQTT broker.');\n          }\n          if (!parameters.topic) {\n            throw new Error('Topic is required for unsubscription.');\n          }\n          resultOutput = await this.unsubscribe(parameters.topic);\n          break;\n\n        case 'disconnect':\n          resultOutput = await this.disconnect();\n          break;\n\n        default:\n          return { success: false, error: `Unknown MQTT action: ${action}`, output: null };\n      }\n\n      return {\n        success: true,\n        output: resultOutput,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          action: action,\n        },\n      };\n    } catch (error: any) {\n      console.error(`${this.name} execution error for action ${action}:`, error);\n      return {\n        success: false,\n        error: error.message || 'An unknown error occurred during MQTT action.',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          action: action,\n        },\n      };\n    }\n  }\n\n  private async connect(brokerUrl: string, options?: mqtt.IClientOptions): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.client = mqtt.connect(brokerUrl, options);\n\n      this.client.on('connect', () => {\n        console.log('MQTT Agent: Connected to broker.');\n        resolve({ connected: true, brokerUrl });\n      });\n\n      this.client.on('error', (error) => {\n        console.error('MQTT Agent: Connection error:', error);\n        this.client?.end();\n        this.client = null;\n        reject(new Error(`MQTT connection failed: ${error.message}`));\n      });\n\n      this.client.on('message', (topic, message) => {\n        const callback = this.subscriptions.get(topic);\n        if (callback) {\n          callback(message);\n        } else {\n          console.log(`MQTT Agent: Received message on unsubscribed topic ${topic}: ${message.toString()}`);\n        }\n      });\n    });\n  }\n\n  private async publish(topic: string, message: string | Buffer, options?: mqtt.IClientPublishOptions): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.client?.publish(topic, message, options, (error) => {\n        if (error) {\n          console.error('MQTT Agent: Publish error:', error);\n          reject(new Error(`MQTT publish failed: ${error.message}`));\n        } else {\n          resolve({ published: true, topic, message: message.toString() });\n        }\n      });\n    });\n  }\n\n  private async subscribe(topic: string, options?: mqtt.IClientSubscribeOptions): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.client?.subscribe(topic, options, (error, granted) => {\n        if (error) {\n          console.error('MQTT Agent: Subscribe error:', error);\n          reject(new Error(`MQTT subscribe failed: ${error.message}`));\n        } else {\n          // Store a generic callback for the topic, actual handling will be external\n          this.subscriptions.set(topic, (msg) => console.log(`MQTT Agent: Default handler for ${topic}: ${msg.toString()}`));\n          resolve({ subscribed: true, topic, granted });\n        }\n      });\n    });\n  }\n\n  private async unsubscribe(topic: string): Promise<any> {\n    return new Promise((resolve, reject) => {\n      this.client?.unsubscribe(topic, (error) => {\n        if (error) {\n          console.error('MQTT Agent: Unsubscribe error:', error);\n          reject(new Error(`MQTT unsubscribe failed: ${error.message}`));\n        } else {\n          this.subscriptions.delete(topic);\n          resolve({ unsubscribed: true, topic });\n        }\n      });\n    });\n  }\n\n  private async disconnect(): Promise<any> {\n    return new Promise((resolve) => {\n      if (this.client) {\n        this.client.end(false, () => {\n          console.log('MQTT Agent: Disconnected from broker.');\n          this.client = null;\n          this.subscriptions.clear();\n          resolve({ disconnected: true });\n        });\n      } else {\n        resolve({ disconnected: false, message: 'Not connected.' });\n      }\n    });\n  }\n\n  async canHandle(query: string): Promise<number> {\n    const lowerQuery = query.toLowerCase();\n    const keywords = ['mqtt', 'iot', 'broker', 'publish', 'subscribe', 'connect', 'sensor'];\n    const matchCount = keywords.filter(keyword => lowerQuery.includes(keyword)).length;\n    return matchCount > 0 ? 0.7 : 0;\n  }\n\n  async getRequiredParameters(action: string): Promise<AgentParameter[]> {\n    switch (action) {\n      case 'connect':\n        return [{ name: 'brokerUrl', type: 'string', required: true, description: 'URL of the MQTT broker (e.g., mqtt://broker.hivemq.com)' }];\n      case 'publish':\n        return [\n          { name: 'topic', type: 'string', required: true, description: 'MQTT topic to publish to.' },\n          { name: 'message', type: 'string', required: true, description: 'Message content to publish.' },\n        ];\n      case 'subscribe':\n        return [{ name: 'topic', type: 'string', required: true, description: 'MQTT topic to subscribe to.' }];\n      case 'unsubscribe':\n        return [{ name: 'topic', type: 'string', required: true, description: 'MQTT topic to unsubscribe from.' }];\n      default:\n        return [];\n    }\n  }\n\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'mqtt_connect',\n        description: 'Connects to an MQTT broker.',\n        requiredParameters: await this.getRequiredParameters('connect'),\n      },\n      {\n        name: 'mqtt_publish',\n        description: 'Publishes a message to a specified MQTT topic.',\n        requiredParameters: await this.getRequiredParameters('publish'),\n      },\n      {\n        name: 'mqtt_subscribe',\n        description: 'Subscribes to a specified MQTT topic to receive messages.',\n        requiredParameters: await this.getRequiredParameters('subscribe'),\n      },\n      {\n        name: 'mqtt_unsubscribe',\n        description: 'Unsubscribes from a specified MQTT topic.',\n        requiredParameters: await this.getRequiredParameters('unsubscribe'),\n      },\n      {\n        name: 'mqtt_disconnect',\n        description: 'Disconnects from the MQTT broker.',\n        requiredParameters: [],\n      },\n    ];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\MemoryAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[728,731],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[728,731],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":315,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":315,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8491,8494],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8491,8494],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MemoryAgent.ts\n * \n * Agent responsible for episodic and long-term memory management.\n * Handles memory storage, retrieval, and contextual recall to enhance\n * the assistant's ability to remember previous interactions and user preferences.\n */\n\nimport { AgentDomains, type AgentExecuteProps, type AgentExecuteResult, type BaseAgent } from './types';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n\n// Types for memory management\nexport interface Memory {\n  id: string;\n  type: 'fact' | 'preference' | 'interaction' | 'context';\n  content: string;\n  timestamp: number;\n  tags: string[];\n  source: string;\n  confidence: number;\n  lastAccessed?: number;\n  accessCount?: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface MemoryQuery {\n  text?: string;\n  type?: Memory['type'];\n  tags?: string[];\n  timeRange?: {\n    start?: number;\n    end?: number;\n  };\n  limit?: number;\n  includeMetadata?: boolean;\n  sortBy?: 'relevance' | 'timestamp' | 'accessCount';\n}\n\n/**\n * Memory Manager for storing and retrieving memories\n */\nexport class MemoryAgent implements BaseAgent {\n  // Identity properties\n  public name = 'MemoryAgent';\n  public description = 'Manages episodic and long-term memory, enabling recall of past interactions and user preferences';\n  public version = '1.0.0';\n  public domain = AgentDomains.KNOWLEDGE;\n  public capabilities = [\n    'memory_storage',\n    'memory_retrieval',\n    'preference_tracking',\n    'context_recall',\n    'memory_summarization'\n  ];\n\n  // Internal memory store\n  private memories: Memory[] = [];\n  private initialized = false;\n\n  constructor() {\n    this.loadMemories();\n  }\n\n  /**\n   * Load memories from persistent storage\n   */\n  private loadMemories(): void {\n    try {\n      const storedMemories = localStorage.getItem('lisa_memories');\n      if (storedMemories) {\n        this.memories = JSON.parse(storedMemories);\n      }\n      this.initialized = true;\n      console.log(`[MemoryAgent] Loaded ${this.memories.length} memories from storage`);\n    } catch (error) {\n      console.error('[MemoryAgent] Error loading memories:', error);\n      this.memories = [];\n      this.initialized = true;\n    }\n  }\n\n  /**\n   * Save memories to persistent storage\n   */\n  private saveMemories(): void {\n    try {\n      localStorage.setItem('lisa_memories', JSON.stringify(this.memories));\n    } catch (error) {\n      console.error('[MemoryAgent] Error saving memories:', error);\n    }\n  }\n\n  /**\n   * Store a new memory\n   */\n  public storeMemory(memory: Omit<Memory, 'id' | 'timestamp'>): Memory {\n    const newMemory: Memory = {\n      ...memory,\n      id: `mem_${Date.now()}_${Math.floor(Math.random() * 1000)}`,\n      timestamp: Date.now(),\n      accessCount: 0\n    };\n\n    this.memories.push(newMemory);\n    this.saveMemories();\n\n    // Update conversation context with relevant recent memories\n    this.updateConversationContext();\n\n    return newMemory;\n  }\n\n  /**\n   * Retrieve memories based on a query\n   */\n  public retrieveMemories(query: MemoryQuery): Memory[] {\n    if (!this.initialized) {\n      this.loadMemories();\n    }\n\n    let results = [...this.memories];\n\n    // Filter by type\n    if (query.type) {\n      results = results.filter(mem => mem.type === query.type);\n    }\n\n    // Filter by tags\n    if (query.tags && query.tags.length > 0) {\n      results = results.filter(mem => \n        query.tags!.some(tag => mem.tags.includes(tag))\n      );\n    }\n\n    // Filter by time range\n    if (query.timeRange) {\n      if (query.timeRange.start) {\n        results = results.filter(mem => mem.timestamp >= query.timeRange!.start!);\n      }\n      if (query.timeRange.end) {\n        results = results.filter(mem => mem.timestamp <= query.timeRange!.end!);\n      }\n    }\n\n    // Filter by text search (basic keyword matching)\n    if (query.text) {\n      const searchTerms = query.text.toLowerCase().split(' ');\n      results = results.filter(mem => {\n        const content = mem.content.toLowerCase();\n        return searchTerms.some(term => content.includes(term));\n      });\n    }\n\n    // Sort results\n    switch (query.sortBy) {\n      case 'timestamp':\n        results.sort((a, b) => b.timestamp - a.timestamp);\n        break;\n      case 'accessCount':\n        results.sort((a, b) => (b.accessCount || 0) - (a.accessCount || 0));\n        break;\n      case 'relevance':\n      default:\n        // For now, relevance is based on a combination of recency and access count\n        results.sort((a, b) => {\n          const recencyScore = (b.timestamp - a.timestamp) / 86400000; // Normalized by days\n          const accessScore = ((b.accessCount || 0) - (a.accessCount || 0)) * 0.1;\n          return (recencyScore + accessScore);\n        });\n    }\n\n    // Apply limit\n    if (query.limit && query.limit > 0) {\n      results = results.slice(0, query.limit);\n    }\n\n    // Update access metrics for retrieved memories\n    results.forEach(mem => {\n      const memoryIndex = this.memories.findIndex(m => m.id === mem.id);\n      if (memoryIndex >= 0) {\n        this.memories[memoryIndex] = {\n          ...this.memories[memoryIndex],\n          lastAccessed: Date.now(),\n          accessCount: (this.memories[memoryIndex].accessCount || 0) + 1\n        };\n      }\n    });\n\n    this.saveMemories();\n\n    // If includeMetadata is false, filter out metadata\n    if (query.includeMetadata === false) {\n      results = results.map(mem => {\n        const { metadata, ...rest } = mem;\n        return rest;\n      });\n    }\n\n    return results;\n  }\n\n  /**\n   * Update a memory by ID\n   */\n  public updateMemory(id: string, updates: Partial<Memory>): Memory | null {\n    const index = this.memories.findIndex(mem => mem.id === id);\n    if (index === -1) {\n      return null;\n    }\n\n    // Don't allow updating immutable fields\n    const { id: _, timestamp: __, ...validUpdates } = updates;\n\n    this.memories[index] = {\n      ...this.memories[index],\n      ...validUpdates,\n    };\n\n    this.saveMemories();\n    return this.memories[index];\n  }\n\n  /**\n   * Delete a memory by ID\n   */\n  public deleteMemory(id: string): boolean {\n    const initialLength = this.memories.length;\n    this.memories = this.memories.filter(mem => mem.id !== id);\n    \n    const deleted = this.memories.length < initialLength;\n    if (deleted) {\n      this.saveMemories();\n    }\n    \n    return deleted;\n  }\n\n  /**\n   * Get a summary of memories related to a specific context\n   */\n  public summarizeMemories(context: string, limit = 5): string {\n    const relevantMemories = this.retrieveMemories({\n      text: context,\n      limit,\n      sortBy: 'relevance'\n    });\n\n    if (relevantMemories.length === 0) {\n      return \"No relevant memories found.\";\n    }\n\n    // Create a simple summary\n    return relevantMemories\n      .map(mem => `- ${mem.content} (${new Date(mem.timestamp).toLocaleDateString()})`)\n      .join('\\n');\n  }\n\n  /**\n   * Update the conversation context with relevant memories\n   */\n  private updateConversationContext(): void {\n    // Get recent or frequently accessed memories\n    const recentMemories = this.retrieveMemories({\n      limit: 5,\n      sortBy: 'timestamp'\n    });\n\n    // Add memories to conversation context for other agents to access\n    const { setState } = useVisionAudioStore.getState();\n    setState(state => ({\n      conversationContext: {\n        ...(state.conversationContext || {}),\n        relevantMemories: recentMemories\n      }\n    }));\n  }\n\n  /**\n   * Validates the input properties before execution\n   */\n  public async validateInput(props: AgentExecuteProps): Promise<{valid: boolean, errors?: string[]}> {\n    const action = props.action || props.intent;\n    \n    if (!action) {\n      return { valid: false, errors: ['No action or intent specified'] };\n    }\n\n    if (action === 'store' && !props.content) {\n      return { valid: false, errors: ['Content is required for storing memories'] };\n    }\n\n    if (action === 'retrieve' && !props.query) {\n      return { valid: false, errors: ['Query is required for retrieving memories'] };\n    }\n\n    return { valid: true };\n  }\n\n  /**\n   * Execute the memory agent functionality\n   */\n  public async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    try {\n      const startTime = Date.now();\n      const action = props.action || props.intent;\n\n      if (!action) {\n        return {\n          success: false,\n          output: \"No action specified\",\n          error: \"Missing required 'action' parameter\"\n        };\n      }\n\n      let result: any;\n      \n      switch (action) {\n        case 'store':\n          if (!props.content) {\n            return {\n              success: false,\n              output: \"Cannot store memory without content\",\n              error: \"Missing required 'content' parameter\"\n            };\n          }\n          \n          result = this.storeMemory({\n            type: props.type as Memory['type'] || 'fact',\n            content: props.content,\n            tags: props.tags || [],\n            source: props.source || 'user_interaction',\n            confidence: props.confidence || 0.9\n          });\n          \n          break;\n          \n        case 'retrieve':\n          result = this.retrieveMemories(props.query || {});\n          break;\n          \n        case 'update':\n          if (!props.id || !props.updates) {\n            return {\n              success: false,\n              output: \"Cannot update memory without ID and updates\",\n              error: \"Missing required 'id' or 'updates' parameters\"\n            };\n          }\n          \n          result = this.updateMemory(props.id, props.updates);\n          \n          if (result === null) {\n            return {\n              success: false,\n              output: `Memory with ID ${props.id} not found`,\n              error: \"Memory not found\"\n            };\n          }\n          \n          break;\n          \n        case 'delete':\n          if (!props.id) {\n            return {\n              success: false,\n              output: \"Cannot delete memory without ID\",\n              error: \"Missing required 'id' parameter\"\n            };\n          }\n          \n          result = this.deleteMemory(props.id);\n          break;\n          \n        case 'summarize':\n          if (!props.context) {\n            return {\n              success: false,\n              output: \"Cannot summarize memories without context\",\n              error: \"Missing required 'context' parameter\"\n            };\n          }\n          \n          result = this.summarizeMemories(props.context, props.limit);\n          break;\n          \n        default:\n          return {\n            success: false,\n            output: `Unknown action: ${action}`,\n            error: `Action '${action}' is not supported`\n          };\n      }\n\n      const executionTime = Date.now() - startTime;\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime,\n          source: 'MemoryAgent',\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      console.error('[MemoryAgent] Error during execution:', error);\n      \n      return {\n        success: false,\n        output: \"Error processing memory operation\",\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Check if this agent can handle the given query\n   */\n  public async canHandle(query: string): Promise<number> {\n    const lowerQuery = query.toLowerCase();\n    \n    // Check for memory-related keywords\n    const memoryKeywords = [\n      'remember', 'forget', 'recall', 'memory', 'remembered', 'remind', 'reminded',\n      'preference', 'like', 'dislike', 'favorite', 'preferred',\n      'last time', 'previous', 'before', 'history', 'past'\n    ];\n    \n    const memoryPhrases = [\n      'do you remember', 'can you remember', 'did i tell you', \n      'what did i say about', 'what do i like', 'what do i prefer',\n      'what did we discuss', 'the last time we talked about'\n    ];\n    \n    // Check for direct memory commands\n    if (lowerQuery.startsWith('remember that') || \n        lowerQuery.startsWith('forget that') || \n        lowerQuery.startsWith('remind me')) {\n      return 0.9;\n    }\n    \n    // Check for memory phrases\n    for (const phrase of memoryPhrases) {\n      if (lowerQuery.includes(phrase)) {\n        return 0.85;\n      }\n    }\n    \n    // Check for memory keywords\n    for (const keyword of memoryKeywords) {\n      if (lowerQuery.includes(keyword)) {\n        return 0.7;\n      }\n    }\n    \n    // Default low confidence\n    return 0.2;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\MetaHumanAgent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\NLUAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[807,810],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[807,810],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":25,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":25,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[846,849],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[846,849],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":57,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":57,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2018,2021],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2018,2021],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3695,3698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3695,3698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { AgentDomains } from './types';\nimport type {\n  AgentCapability,\n  AgentExecuteProps,\n  AgentExecuteResult,\n  AgentParameter,\n  BaseAgent\n} from './types';\nimport { pipeline, env } from '@xenova/transformers';\n\n// Disable local model caching\nenv.useFSCache = false;\n\n// Define the NLU tasks\nexport type NLUTask = 'sentiment_analysis' | 'zero_shot_classification' | 'feature_extraction' | 'emotion_detection';\n\nexport class NLUAgent implements BaseAgent {\n  name = 'NLUAgent';\n  description = 'Performs various Natural Language Understanding (NLU) tasks like sentiment analysis and emotion detection.';\n  version = '1.0.0';\n  domain = AgentDomains.ANALYSIS;\n  capabilities = ['sentiment_analysis', 'zero_shot_classification', 'feature_extraction', 'emotion_detection'];\n\n  private sentimentPipeline: any = null;\n  private emotionPipeline: any = null;\n\n  constructor() {\n    this.initializePipelines();\n  }\n\n  private async initializePipelines() {\n    try {\n      // Load the sentiment analysis pipeline\n      this.sentimentPipeline = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finetuned-sst2');\n      console.log('NLUAgent: Sentiment analysis pipeline initialized.');\n\n      // Load the emotion detection pipeline (using an audio classification model for speech emotion)\n      // This model is a placeholder, a more specific SER model might be needed.\n      this.emotionPipeline = await pipeline('audio-classification', 'Xenova/wav2vec2-base-960h-finetuned-emotion');\n      console.log('NLUAgent: Emotion detection pipeline initialized.');\n\n    } catch (error) {\n      console.error('NLUAgent: Failed to initialize NLU pipelines:', error);\n    }\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const task = props.task as NLUTask;\n    const parameters = props.parameters || {};\n\n    if (!task) {\n      return { success: false, error: 'NLU task not specified.', output: null };\n    }\n\n    try {\n      let resultOutput: any;\n\n      switch (task) {\n        case 'sentiment_analysis': {\n          if (!this.sentimentPipeline) {\n            throw new Error('Sentiment analysis pipeline not initialized.');\n          }\n          if (!parameters.text) {\n            throw new Error('Text is required for sentiment analysis.');\n          }\n          const sentimentResult = await this.sentimentPipeline(parameters.text);\n          resultOutput = sentimentResult;\n          break;\n        }\n\n        case 'emotion_detection': {\n          if (!this.emotionPipeline) {\n            throw new Error('Emotion detection pipeline not initialized.');\n          }\n          if (!parameters.audio) {\n            throw new Error('Audio data is required for emotion detection.');\n          }\n          // Assuming parameters.audio is a Blob or AudioBuffer\n          const emotionResult = await this.emotionPipeline(parameters.audio);\n          resultOutput = emotionResult;\n          break;\n        }\n\n        case 'zero_shot_classification':\n          // Placeholder for zero-shot classification\n          resultOutput = { message: 'Zero-shot classification not yet implemented.' };\n          break;\n\n        case 'feature_extraction':\n          // Placeholder for feature extraction\n          resultOutput = { message: 'Feature extraction not yet implemented.' };\n          break;\n\n        default:\n          return { success: false, error: `Unknown NLU task: ${task}`, output: null };\n      }\n\n      return {\n        success: true,\n        output: resultOutput,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          source: `${this.name}:${task}`,\n        },\n      };\n    } catch (error: any) {\n      console.error(`${this.name} execution error for task ${task}:`, error);\n      return {\n        success: false,\n        error: error.message || 'An unknown error occurred during NLU task.',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          source: `${this.name}:${task}`,\n        },\n      };\n    }\n  }\n\n  async canHandle(query: string): Promise<number> {\n    const lowerQuery = query.toLowerCase();\n    const keywords = ['sentiment', 'analyse de sentiment', 'emotion', 'classification', 'nlu', 'language understanding', 'tonalit├®', 'humeur'];\n    const matchCount = keywords.filter(keyword => lowerQuery.includes(keyword)).length;\n    return matchCount > 0 ? 0.7 : 0;\n  }\n\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    switch (task) {\n      case 'sentiment_analysis':\n        return [{ name: 'text', type: 'string', required: true, description: 'The text to analyze for sentiment.' }];\n      case 'emotion_detection':\n        return [{ name: 'audio', type: 'object', required: true, description: 'The audio data (Blob or AudioBuffer) to analyze for emotion.' }];\n      case 'zero_shot_classification':\n        return [\n          { name: 'text', type: 'string', required: true, description: 'The text to classify.' },\n          { name: 'candidate_labels', type: 'array', required: true, description: 'A list of candidate labels.' },\n        ];\n      case 'feature_extraction':\n        return [{ name: 'text', type: 'string', required: true, description: 'The text to extract features from.' }];\n      default:\n        return [];\n    }\n  }\n\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'sentiment_analysis',\n        description: 'Analyzes the sentiment of a given text (positive, negative, neutral).',\n        requiredParameters: await this.getRequiredParameters('sentiment_analysis'),\n      },\n      {\n        name: 'emotion_detection',\n        description: 'Detects emotions from speech audio.',\n        requiredParameters: await this.getRequiredParameters('emotion_detection'),\n      },\n      {\n        name: 'zero_shot_classification',\n        description: 'Classifies text into categories without explicit training data.',\n        requiredParameters: await this.getRequiredParameters('zero_shot_classification'),\n      },\n      {\n        name: 'feature_extraction',\n        description: 'Extracts numerical features from text for use in other models.',\n        requiredParameters: await this.getRequiredParameters('feature_extraction'),\n      },\n    ];\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\OCRAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'OEM' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":27},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":290,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":290,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9220,9223],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9220,9223],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OCRAgent: Agent sp├®cialis├® pour la reconnaissance optique de caract├¿res.\n * \n * Cet agent permet ├á Lisa de lire et d'extraire du texte ├á partir d'images,\n * captures d'├®cran, ou zones s├®lectionn├®es ├á l'├®cran.\n */\n\n// L'import de agentRegistry est supprim├® car il n'est pas utilis├® directement dans ce fichier\nimport { createWorker, OEM } from 'tesseract.js';\nimport type { \n  AgentCapability, \n  AgentDomain,\n  AgentExecuteProps, \n  AgentExecuteResult, \n  BaseAgent\n} from './types';\nimport { AgentDomains } from './types';\n\n// Types sp├®cifiques ├á l'OCR\nexport type OCRSource = 'screenshot' | 'webcam' | 'file' | 'clipboard' | 'selection';\nexport type OCRIntent = 'extract_text' | 'recognize_text' | 'get_capabilities';\nexport type OCRLanguage = 'auto' | 'en' | 'fr' | 'es' | 'de' | string;\n\nexport interface OCROptions {\n  language?: OCRLanguage;\n  enhanceImage?: boolean;\n  confidence?: number; // Seuil de confiance minimum (0-1)\n  region?: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}\n\nexport interface OCRResult {\n  text: string;\n  confidence?: number;\n  regions?: Array<{\n    text: string;\n    confidence: number;\n    boundingBox: {\n      x: number;\n      y: number;\n      width: number;\n      height: number;\n    };\n  }>;\n  language?: string;\n  processingTimeMs?: number;\n}\n\n/**\n * Agent pour la reconnaissance optique de caract├¿res (OCR)\n */\nexport class OCRAgent implements BaseAgent {\n  name = 'OCRAgent';\n  description = 'Reads and extracts text from images, screenshots, or selected areas on screen';\n  version = '1.0.0';\n  domain = AgentDomains.ANALYSIS as AgentDomain;\n  capabilities = ['text_recognition', 'text_extraction', 'image_analysis'];\n  valid = true;\n  \n  // V├®rifie si l'OCR est disponible\n  private checkAvailability(): boolean {\n    // Dans une vraie impl├®mentation, v├®rifier si les APIs n├®cessaires sont disponibles\n    // Par exemple Tesseract.js ou une API cloud comme Google Vision\n    \n    // Pour cette d├®mo, on va simplement retourner true\n    return true;\n  }\n\n  private worker: Tesseract.Worker | null = null;\n  private isInitialized = false;\n\n  constructor() {\n    this.initializeWorker();\n  }\n\n  private async initializeWorker() {\n    try {\n      const worker = await createWorker({\n        logger: m => console.log(m), // Optional: log progress\n      });\n      await worker.loadLanguage('eng+fra');\n      await worker.initialize('eng+fra');\n      this.worker = worker;\n      this.isInitialized = true;\n      console.log('Tesseract worker initialized.');\n    } catch (error) {\n      console.error('Failed to initialize Tesseract worker:', error);\n    }\n  }\n\n  // Extrait du texte d'une image\n  private async extractTextFromImage(\n    _imageSource: OCRSource,\n    imageData: string | Blob | File,\n    options?: OCROptions\n  ): Promise<OCRResult> {\n    if (!this.isInitialized || !this.worker) {\n      throw new Error('Tesseract worker is not initialized.');\n    }\n\n    const lang = options?.language === 'fr' ? 'fra' : 'eng';\n\n    const { data } = await this.worker.recognize(imageData, {\n      tessedit_char_whitelist: '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',\n    }, { imageColor: true, imageGrey: true, imageBinary: true });\n\n    return {\n      text: data.text,\n      confidence: data.confidence,\n      regions: data.words.map(w => ({\n        text: w.text,\n        confidence: w.confidence,\n        boundingBox: {\n          x: w.bbox.x0,\n          y: w.bbox.y0,\n          width: w.bbox.x1 - w.bbox.x0,\n          height: w.bbox.y1 - w.bbox.y0,\n        },\n      })),\n      language: lang,\n    };\n  }\n\n  // Prendre une capture d'├®cran\n  private async captureScreenshot(\n    region?: { x: number; y: number; width: number; height: number }\n  ): Promise<string> {\n    try {\n      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });\n      const track = stream.getVideoTracks()[0];\n      const imageCapture = new ImageCapture(track);\n      const bitmap = await imageCapture.grabFrame();\n      track.stop(); // Stop the screen sharing\n\n      const canvas = document.createElement('canvas');\n      canvas.width = bitmap.width;\n      canvas.height = bitmap.height;\n      const context = canvas.getContext('2d');\n      if (!context) {\n        throw new Error('Could not get canvas context');\n      }\n\n      if (region) {\n        context.drawImage(bitmap, region.x, region.y, region.width, region.height, 0, 0, region.width, region.height);\n        canvas.width = region.width;\n        canvas.height = region.height;\n      } else {\n        context.drawImage(bitmap, 0, 0);\n      }\n\n      return canvas.toDataURL();\n    } catch (error) {\n      console.error('Error capturing screenshot:', error);\n      throw new Error('Failed to capture screenshot.');\n    }\n  }\n\n  // Capture an image from the webcam\n  private async captureWebcamImage(): Promise<string> {\n    const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n    return new Promise((resolve, reject) => {\n      const video = document.createElement('video');\n      video.srcObject = stream;\n      video.onloadedmetadata = () => {\n        video.play();\n        const canvas = document.createElement('canvas');\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        const context = canvas.getContext('2d');\n        if (!context) {\n          stream.getTracks().forEach(track => track.stop());\n          return reject(new Error('Could not get canvas context'));\n        }\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\n        stream.getTracks().forEach(track => track.stop());\n        resolve(canvas.toDataURL('image/png'));\n      };\n      video.onerror = (err) => {\n        stream.getTracks().forEach(track => track.stop());\n        reject(new Error(`Video error: ${err}`));\n      };\n    });\n  }\n\n  // Read image data from clipboard\n  private async readClipboardImage(): Promise<Blob> {\n    try {\n      const clipboardItems = await navigator.clipboard.read();\n      for (const clipboardItem of clipboardItems) {\n        for (const type of clipboardItem.types) {\n          if (type.startsWith('image/')) {\n            return await clipboardItem.getType(type);\n          }\n        }\n      }\n      throw new Error('No image found in clipboard.');\n    } catch (error) {\n      console.error('Error reading clipboard image:', error);\n      throw new Error('Failed to read image from clipboard.');\n    }\n  }\n\n  // Read image data from a File object\n  private async readFileImage(file: File): Promise<string> {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => resolve(reader.result as string);\n      reader.onerror = reject;\n      reader.readAsDataURL(file);\n    });\n  }\n\n  // Ex├®cution de l'agent\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as OCRIntent;\n    const parameters = props.parameters || {};\n\n    // Si l'OCR n'est pas disponible, on retourne une erreur\n    if (!this.checkAvailability()) {\n      return {\n        success: false,\n        error: \"OCR capabilities are not available in this environment\",\n        output: null\n      };\n    }\n\n    try {\n      // Traiter les diff├®rentes intentions\n      switch (intent) {\n        case 'extract_text': {\n          const source = parameters.source as OCRSource || 'screenshot';\n          const options = parameters.options as OCROptions || {};\n          let imageData: string | Blob | File;\n          \n          // Obtenir l'image selon la source\n          if (source === 'screenshot') {\n            imageData = await this.captureScreenshot(options.region);\n          } else if (source === 'webcam') {\n            imageData = await this.captureWebcamImage();\n          } else if (source === 'clipboard') {\n            imageData = await this.readClipboardImage();\n          } else if (source === 'file') {\n            if (!parameters.file) throw new Error('File object is required for file source.');\n            imageData = await this.readFileImage(parameters.file as File);\n          } else {\n            return {\n              success: false,\n              error: `Unknown OCR source: ${source}`,\n              output: null\n            };\n          }\n          \n          // Extraire le texte de l'image\n          const result = await this.extractTextFromImage(source, imageData, options);\n          \n          return {\n            success: true,\n            output: result,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              confidence: result.confidence,\n              source: source\n            }\n          };\n        }\n        \n        case 'get_capabilities': {\n          return {\n            success: true,\n            output: {\n              availableSources: ['screenshot'],\n              availableLanguages: ['auto', 'en', 'fr', 'es', 'de'],\n              imageEnhancementAvailable: true\n            }\n          };\n        }\n        \n        default:\n          return {\n            success: false,\n            error: `Unknown intent: ${intent}`,\n            output: null\n          };\n      }\n    } catch (error: any) {\n      console.error(`${this.name} execution error:`, error);\n      return {\n        success: false,\n        error: error.message || 'An unknown error occurred',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime\n        }\n      };\n    }\n  }\n\n  // V├®rifier si l'agent peut traiter une requ├¬te\n  async canHandle(query: string): Promise<number> {\n    // Mots-cl├®s li├®s ├á l'OCR\n    const ocrKeywords = [\n      'ocr', 'text recognition', 'extract text', 'read text', \n      'recognize text', 'text from image', 'image text', 'scan text',\n      'capture text', 'screen text'\n    ];\n    \n    // V├®rifier la pr├®sence de mots-cl├®s dans la requ├¬te\n    const lowerQuery = query.toLowerCase();\n    const matchCount = ocrKeywords.filter(keyword => \n      lowerQuery.includes(keyword.toLowerCase())\n    ).length;\n    \n    // Calculer un score de confiance basique\n    if (matchCount > 2) return 0.9;  // Tr├¿s forte probabilit├®\n    if (matchCount > 0) return 0.7;  // Probabilit├® moyenne ├á forte\n    \n    // V├®rifier les mod├¿les de requ├¬tes courants\n    if (lowerQuery.match(/what (does|do|is) .* say/)) return 0.8;\n    if (lowerQuery.match(/read .* (screen|image|picture|photo)/)) return 0.8;\n    \n    return 0.2; // Faible probabilit├® par d├®faut\n  }\n\n  // Obtenir les capacit├®s de l'agent\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: \"extract_text\",\n        description: \"Extract text from images, screenshots, or selected areas\",\n        requiredParameters: [\n          {\n            name: \"source\",\n            type: \"string\",\n            required: false,\n            description: \"Source of the image (screenshot, webcam, file, clipboard, selection)\",\n            defaultValue: \"screenshot\"\n          },\n          {\n            name: \"options\",\n            type: \"object\",\n            required: false,\n            description: \"OCR options including language, region, etc.\"\n          }\n        ]\n      },\n      {\n        name: \"get_capabilities\",\n        description: \"Get available OCR capabilities\",\n        requiredParameters: []\n      }\n    ];\n  }\n}\n\n// Enregistrer l'agent dans le registre\n// L'enregistrement centralis├® se fait via src/agents/index.ts\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\PersonalizationAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[919,922],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[919,922],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2767,2770],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2767,2770],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":200,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":200,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5371,5374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5371,5374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":327,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":327,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8847,8850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8847,8850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":351,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":351,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9391,9394],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9391,9394],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":353,"column":6,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":353,"endColumn":9,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9463,9466],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9463,9466],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10035,10038],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10035,10038],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10041,10044],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10041,10044],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":386,"column":69,"nodeType":null,"messageId":"unusedVar","endLine":386,"endColumn":76},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":386,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":386,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10263,10266],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10263,10266],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":386,"column":93,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":386,"endColumn":96,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10277,10280],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10277,10280],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":442,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11784,11787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11784,11787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":442,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":442,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11790,11793],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11790,11793],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":474,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":474,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12486,12489],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12486,12489],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":498,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":498,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13248,13251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13248,13251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":498,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":498,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13280,13283],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13280,13283],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":544,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":544,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14575,14578],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14575,14578],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":18,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * PersonalizationAgent - Adapts the user experience based on preferences and behavior\n * \n * This agent learns from user interactions and customizes the experience\n * by tracking preferences, adapting recommendations, and tailoring responses.\n */\n\nimport { \n  AgentCapability, \n  AgentDomains, \n  AgentExecuteProps, \n  AgentExecuteResult, \n  AgentParameter, \n  BaseAgent \n} from './types';\n\n/**\n * User preference category\n */\nexport type PreferenceCategory = \n  | 'ui'            // UI preferences (theme, layout)\n  | 'notification'  // Notification preferences\n  | 'language'      // Language preferences\n  | 'content'       // Content preferences (topics of interest)\n  | 'privacy'       // Privacy preferences\n  | 'interaction';  // Interaction preferences (voice, text, etc.)\n\n/**\n * User preference data structure\n */\nexport interface UserPreference {\n  category: PreferenceCategory;\n  key: string;\n  value: any;\n  confidence: number;  // 0-1 indicating how confident we are in this preference\n  source: 'explicit' | 'implicit' | 'default';  // How this preference was determined\n  timestamp: number;   // When this preference was last updated\n}\n\n/**\n * Supported personalization intents\n */\nexport type PersonalizationIntent = \n  | 'get_preferences'\n  | 'set_preference'\n  | 'get_recommendations'\n  | 'track_interaction'\n  | 'get_user_profile'\n  | 'adapt_response';\n\n/**\n * Agent for personalizing user experience\n */\nexport class PersonalizationAgent implements BaseAgent {\n  name = 'PersonalizationAgent';\n  description = \"Adapte l'exp├®rience utilisateur en fonction des pr├®f├®rences et comportements\";\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = [\n    'preference_management',\n    'behavioral_tracking',\n    'content_recommendation',\n    'response_adaptation'\n  ];\n\n  // In a real implementation, this would be stored in a persistent store\n  private preferences: Record<string, UserPreference> = {\n    'ui.theme': {\n      category: 'ui',\n      key: 'theme',\n      value: 'auto',\n      confidence: 1.0,\n      source: 'default',\n      timestamp: Date.now()\n    },\n    'ui.fontSize': {\n      category: 'ui',\n      key: 'fontSize',\n      value: 'medium',\n      confidence: 1.0,\n      source: 'default',\n      timestamp: Date.now()\n    },\n    'language.primary': {\n      category: 'language',\n      key: 'primary',\n      value: 'fr',\n      confidence: 1.0,\n      source: 'default',\n      timestamp: Date.now()\n    },\n    'notification.allowVoice': {\n      category: 'notification',\n      key: 'allowVoice',\n      value: true,\n      confidence: 1.0,\n      source: 'default',\n      timestamp: Date.now()\n    }\n  };\n\n  // Track user interactions for behavioral analysis\n  private interactions: Array<{\n    type: string;\n    data: any;\n    timestamp: number;\n  }> = [];\n\n  // Topics of interest with confidence scores\n  private interests: Record<string, number> = {\n    'technology': 0.8,\n    'news': 0.6,\n    'weather': 0.7,\n    'calendar': 0.5\n  };\n\n  /**\n   * Main execution method for the agent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as PersonalizationIntent;\n    const parameters = props.parameters || {};\n    const language = props.language || this.getPreferenceValue('language.primary', 'fr');\n\n    try {\n      let result;\n      switch (intent) {\n        case 'get_preferences':\n          result = this.getPreferences(parameters.category as PreferenceCategory);\n          break;\n        case 'set_preference':\n          result = this.setPreference(\n            parameters.category as PreferenceCategory,\n            parameters.key,\n            parameters.value,\n            parameters.source || 'explicit'\n          );\n          break;\n        case 'get_recommendations':\n          result = await this.getRecommendations(\n            parameters.type,\n            parameters.count || 5,\n            parameters.context\n          );\n          break;\n        case 'track_interaction':\n          result = this.trackInteraction(\n            parameters.type,\n            parameters.data\n          );\n          break;\n        case 'get_user_profile':\n          result = this.getUserProfile();\n          break;\n        case 'adapt_response':\n          result = await this.adaptResponse(\n            parameters.content,\n            parameters.context,\n            language\n          );\n          break;\n        default:\n          return {\n            success: false,\n            output: `Intent non support├®: ${intent}`,\n            error: new Error('UNSUPPORTED_INTENT'),\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          confidence: 0.9,\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error : new Error(String(error)),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Determines if this agent can handle a specific query\n   */\n  async canHandle(query: string, context?: any): Promise<number> {\n    const normalizedQuery = query.toLowerCase();\n    \n    // Keywords related to personalization\n    const personalizationKeywords = [\n      'pr├®f├®rence', 'pr├®f├®rences', 'personnaliser', 'personnalisation',\n      'profil', 'param├¿tre', 'param├¿tres', 'configurer', 'configuration',\n      'th├¿me', 'langue', 'notification', 'recommandation'\n    ];\n    \n    // Count matches\n    const matches = personalizationKeywords.filter(keyword => \n      normalizedQuery.includes(keyword)).length;\n    \n    // Calculate confidence score\n    let score = matches > 0 ? 0.3 + Math.min(matches * 0.15, 0.6) : 0;\n    \n    // Add more confidence if the query explicitly mentions preferences or settings\n    if (normalizedQuery.includes('pr├®f├®rence') || normalizedQuery.includes('param├¿tre')) {\n      score += 0.2;\n    }\n    \n    return Math.min(score, 1.0);\n  }\n\n  /**\n   * Returns required parameters for a specific task\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    const normalizedTask = task.toLowerCase();\n    \n    if (normalizedTask.includes('pr├®f├®rence') && normalizedTask.includes('d├®finir')) {\n      return [\n        {\n          name: 'category',\n          type: 'string',\n          required: true,\n          description: 'Cat├®gorie de pr├®f├®rence (ui, notification, language, content, privacy, interaction)'\n        },\n        {\n          name: 'key',\n          type: 'string',\n          required: true,\n          description: 'Cl├® de la pr├®f├®rence'\n        },\n        {\n          name: 'value',\n          type: 'string',\n          required: true,\n          description: 'Valeur ├á d├®finir'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('pr├®f├®rence') && normalizedTask.includes('obtenir')) {\n      return [\n        {\n          name: 'category',\n          type: 'string',\n          required: false,\n          description: 'Cat├®gorie de pr├®f├®rence ├á r├®cup├®rer (optionnel)'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('recommandation')) {\n      return [\n        {\n          name: 'type',\n          type: 'string',\n          required: true,\n          description: 'Type de recommandations (content, feature, etc.)'\n        },\n        {\n          name: 'count',\n          type: 'number',\n          required: false,\n          description: 'Nombre de recommandations',\n          defaultValue: 5\n        }\n      ];\n    }\n    \n    return [];\n  }\n\n  /**\n   * Returns detailed capability information\n   */\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'preference_management',\n        description: 'Gestion des pr├®f├®rences utilisateur',\n        requiredParameters: [\n          {\n            name: 'category',\n            type: 'string',\n            required: true,\n            description: 'Cat├®gorie de pr├®f├®rence'\n          },\n          {\n            name: 'key',\n            type: 'string',\n            required: true,\n            description: 'Cl├® de la pr├®f├®rence'\n          }\n        ]\n      },\n      {\n        name: 'content_recommendation',\n        description: 'Recommandations de contenu personnalis├®es',\n        requiredParameters: [\n          {\n            name: 'type',\n            type: 'string',\n            required: true,\n            description: 'Type de recommandation'\n          }\n        ]\n      }\n    ];\n  }\n\n  /**\n   * Get user preferences, optionally filtered by category\n   */\n  private getPreferences(category?: PreferenceCategory): any {\n    if (category) {\n      const filteredPreferences = Object.values(this.preferences)\n        .filter(pref => pref.category === category);\n      \n      return {\n        category,\n        preferences: filteredPreferences,\n        count: filteredPreferences.length\n      };\n    }\n    \n    return {\n      preferences: Object.values(this.preferences),\n      count: Object.keys(this.preferences).length\n    };\n  }\n\n  /**\n   * Set a user preference\n   */\n  private setPreference(\n    category: PreferenceCategory, \n    key: string, \n    value: any, \n    source: 'explicit' | 'implicit' | 'default' = 'explicit'\n  ): any {\n    const prefKey = `${category}.${key}`;\n    const existing = this.preferences[prefKey];\n    \n    // Update or create preference\n    this.preferences[prefKey] = {\n      category,\n      key,\n      value,\n      confidence: source === 'explicit' ? 1.0 : (existing?.confidence || 0.5),\n      source,\n      timestamp: Date.now()\n    };\n    \n    return {\n      category,\n      key,\n      value,\n      source,\n      updated: true\n    };\n  }\n\n  /**\n   * Get the value of a specific preference with fallback\n   */\n  private getPreferenceValue(prefKey: string, defaultValue: any): any {\n    return this.preferences[prefKey]?.value ?? defaultValue;\n  }\n\n  /**\n   * Get personalized recommendations based on user profile\n   */\n  private async getRecommendations(type: string, count: number = 5, context?: any): Promise<any> {\n    // In a real implementation, this would use a recommendation algorithm\n    // Here, we'll return mock recommendations based on interests\n    \n    if (type === 'content') {\n      // Sort interests by confidence score\n      const sortedInterests = Object.entries(this.interests)\n        .sort(([, a], [, b]) => b - a)\n        .map(([topic]) => topic);\n      \n      const recommendations = sortedInterests.slice(0, count).map(topic => ({\n        topic,\n        confidence: this.interests[topic],\n        reason: `Bas├® sur votre historique d'interactions et pr├®f├®rences`\n      }));\n      \n      return {\n        type,\n        count: recommendations.length,\n        recommendations\n      };\n    }\n    \n    if (type === 'feature') {\n      // Recommend features based on usage patterns\n      const recommendations = [\n        {\n          feature: 'voice_commands',\n          priority: 'high',\n          reason: 'Utilisation fr├®quente des commandes vocales'\n        },\n        {\n          feature: 'weather_dashboard',\n          priority: 'medium',\n          reason: 'Consultation r├®guli├¿re de la m├®t├®o'\n        }\n      ].slice(0, count);\n      \n      return {\n        type,\n        count: recommendations.length,\n        recommendations\n      };\n    }\n    \n    return {\n      type,\n      count: 0,\n      recommendations: [],\n      message: 'Type de recommandation non support├®'\n    };\n  }\n\n  /**\n   * Track a user interaction for behavioral analysis\n   */\n  private trackInteraction(type: string, data: any): any {\n    const interaction = {\n      type,\n      data,\n      timestamp: Date.now()\n    };\n    \n    this.interactions.push(interaction);\n    \n    // Limit history size\n    if (this.interactions.length > 100) {\n      this.interactions.shift();\n    }\n    \n    // Update interests based on interaction\n    if (data.topic) {\n      this.updateInterest(data.topic, 0.1);\n    }\n    \n    // In a real implementation, we would analyze the interaction\n    // to implicitly learn preferences\n    this.analyzeInteraction(type, data);\n    \n    return {\n      tracked: true,\n      interactionCount: this.interactions.length\n    };\n  }\n\n  /**\n   * Get user profile information\n   */\n  private getUserProfile(): any {\n    const interactionsByType = this.interactions.reduce((acc, interaction) => {\n      acc[interaction.type] = (acc[interaction.type] || 0) + 1;\n      return acc;\n    }, {} as Record<string, number>);\n    \n    const sortedInterests = Object.entries(this.interests)\n      .sort(([, a], [, b]) => b - a)\n      .reduce((acc, [topic, score]) => {\n        acc[topic] = score;\n        return acc;\n      }, {} as Record<string, number>);\n    \n    return {\n      preferences: Object.values(this.preferences),\n      interactionCounts: interactionsByType,\n      interests: sortedInterests,\n      interactionCount: this.interactions.length\n    };\n  }\n\n  /**\n   * Adapt a response based on user preferences\n   */\n  private async adaptResponse(content: string, context: any, language: string): Promise<any> {\n    if (!content) {\n      throw new Error('Contenu requis pour adaptation');\n    }\n    \n    // In a real implementation, this would adapt the content based on:\n    // - User language preference\n    // - Tone preference (formal vs casual)\n    // - Level of detail preference\n    // - Visual vs textual preference\n    \n    const fontSize = this.getPreferenceValue('ui.fontSize', 'medium');\n    const theme = this.getPreferenceValue('ui.theme', 'auto');\n    \n    // Mock response adaptation\n    const adaptedContent = content;\n    \n    return {\n      originalContent: content,\n      adaptedContent,\n      adaptations: {\n        language,\n        fontSize,\n        theme\n      }\n    };\n  }\n\n  /**\n   * Update user interest in a topic\n   */\n  private updateInterest(topic: string, increment: number): void {\n    const currentScore = this.interests[topic] || 0;\n    this.interests[topic] = Math.min(Math.max(currentScore + increment, 0), 1);\n    \n    // Decay other interests slightly to maintain relative importance\n    Object.keys(this.interests).forEach(t => {\n      if (t !== topic) {\n        this.interests[t] = Math.max(this.interests[t] - 0.01, 0);\n      }\n    });\n  }\n\n  /**\n   * Analyze interaction to derive implicit preferences\n   */\n  private analyzeInteraction(type: string, data: any): void {\n    // In a real implementation, this would analyze the interaction\n    // to derive implicit preferences\n    \n    if (type === 'voice_command' && data.success) {\n      // User successfully used voice command, they might prefer voice interactions\n      this.setPreference('interaction', 'preferVoice', true, 'implicit');\n    }\n    \n    if (type === 'notification_click' && data.type) {\n      // User clicked on a notification, they might be interested in this type\n      this.setPreference('notification', `interest.${data.type}`, true, 'implicit');\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\PlannerAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PromptOptions' is defined but never used. Allowed unused vars must match /^_/u.","line":12,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":12,"endColumn":71}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * PlannerAgent.ts\n *\n * A lightweight, modular orchestrator that coordinates complex workflows using\n * separate utilities for planning, execution, error handling and logging.\n */\nimport { agentRegistry } from './registry';\nimport { v4 as uuidv4 } from 'uuid';\nimport { saveToStorage, loadFromStorage } from '../utils/storage';\n\n// Import refactored utilities\nimport { buildPlannerPrompt, buildPlanExplanationPrompt, PromptOptions } from '../utils/buildPlannerPrompt';\nimport { runWorkflowPlan } from '../utils/runWorkflowPlan';\nimport { logEvent } from '../utils/logger';\nimport { revisePlan } from '../utils/revisePlan';\nimport { planTracer } from '../utils/planTracer';\n// Import types\nimport type { BaseAgent, AgentExecuteResult } from './types';\nimport type { WorkflowStep, PlannerAgentExecuteProps, PlannerResult } from '../types/Planner';\n\n// Constants\nconst OPENAI_API_KEY = import.meta.env.VITE_OPENAI_API_KEY;\nconst MAX_REVISIONS = 3;\nconst PLANNER_TEMPLATES_KEY = 'planner_templates';\nconst PLANNER_CHECKPOINTS_KEY = 'planner_checkpoints';\n\n/**\n * PlannerAgent: Orchestrates multi-step workflows using a modular architecture\n */\nexport class PlannerAgent implements BaseAgent {\n  name = 'PlannerAgent';\n  description = 'Generates and executes complex, resilient, and efficient multi-step workflows.';\n  capabilities = ['planning', 'orchestration', 'workflow'];\n  version = '2.0.0';\n  domain = 'workflow';\n\n  private workflowTemplates: Map<string, WorkflowStep[]>;\n  private workflowCheckpoints: Map<string, WorkflowStep[]>;\n\n  constructor() {\n    // Load saved templates and checkpoints from storage\n    const savedTemplates = loadFromStorage<[string, WorkflowStep[]][]>(PLANNER_TEMPLATES_KEY);\n    this.workflowTemplates = savedTemplates ? new Map(savedTemplates) : new Map();\n\n    const savedCheckpoints = loadFromStorage<[string, WorkflowStep[]][]>(PLANNER_CHECKPOINTS_KEY);\n    this.workflowCheckpoints = savedCheckpoints ? new Map(savedCheckpoints) : new Map();\n  }\n\n  /**\n   * Main execution method - generates and runs a plan to fulfill a request\n   */\n  async execute(props: PlannerAgentExecuteProps): Promise<AgentExecuteResult> {\n    if (!OPENAI_API_KEY) {\n      return { success: false, error: 'OpenAI API key is not configured.', output: null };\n    }\n\n    // Initialiser le tra├ºage pour cette ex├®cution\n    const traceId = planTracer.startTrace(props.request);\n    logEvent('plan_execution_started', { requestId: props.request.substring(0, 50) }, 'PlannerAgent execution started');\n    \n    let plan: WorkflowStep[] = [];\n    let revisionCount = 0;\n    const checkpointId: string | null = null;\n    let explanation: string | null = null;\n\n    try {\n      // Phase 1: Get the plan (from template, checkpoint, or generate new)\n      planTracer.addStep(traceId, 'plan_generation', {\n        metadata: { \n          fromTemplate: Boolean(props.loadFromTemplate),\n          fromCheckpoint: Boolean(props.resumeFromCheckpointId)\n        }\n      });\n      \n      plan = await this.getPlan(props);\n      \n      // G├®n├®rer une explication du plan pour l'utilisateur\n      try {\n        const explainPrompt = buildPlanExplanationPrompt(plan, props.request, {\n          detailLevel: 'concise',\n          language: 'fr'\n        });\n        const explainResponse = await this.callLLM(explainPrompt);\n        explanation = explainResponse.trim();\n        \n        // Ajouter l'explication ├á la trace\n        planTracer.addStep(traceId, 'plan_generation', {\n          explanation,\n          result: plan,\n        });\n      } catch (explainError) {\n        // Si l'explication ├®choue, on continue sans\n        logEvent('plan_explanation_failed', \n          { error: String(explainError) },\n          'Failed to generate plan explanation');\n      }\n      \n      // Phase 2: Execute the plan\n      planTracer.addStep(traceId, 'plan_execution', {\n        metadata: { planSize: plan.length }\n      });\n      \n      let result = await this.executePlan(plan, props);\n      \n      // Phase 3: Handle revisions if needed\n      while (!result.success && revisionCount < MAX_REVISIONS) {\n        revisionCount++;\n        \n        planTracer.addStep(traceId, 'plan_revision', {\n          metadata: { \n            attempt: revisionCount,\n            error: result.error?.message \n          }\n        });\n        \n        plan = await this.revisePlan(\n          props.request, \n          plan, \n          result.error?.message, \n          revisionCount,\n          traceId\n        );\n        \n        result = await this.executePlan(plan, props);\n        \n        if (result.success) {\n          planTracer.addStep(traceId, 'plan_execution', {\n            metadata: { success: true, revisionCount },\n            result: result.summary\n          });\n          break;\n        }\n      }\n      \n      // Phase 4: Finalize (save template, cleanup)\n      const finalResult = this.finalizePlan(result, plan, props, checkpointId);\n      \n      // Terminer la trace avec le r├®sultat final\n      planTracer.endTrace(traceId, finalResult.output as string || finalResult.error);\n      \n      // Ajouter l'explication au r├®sultat si disponible\n      if (explanation && finalResult.success) {\n        return {\n          ...finalResult,\n          explanation,\n          traceId\n        };\n      }\n      \n      return {\n        ...finalResult,\n        traceId\n      };\n      \n    } catch (error: unknown) {\n      const message = error instanceof Error ? error.message : String(error);\n      \n      // Enregistrer l'erreur dans la trace\n      planTracer.addStep(traceId, 'plan_execution', {\n        error: message\n      });\n      planTracer.endTrace(traceId, `Execution failed: ${message}`);\n      \n      logEvent('plan_failed', { error: message }, `PlannerAgent execution failed: ${message}`);\n      return { success: false, error: message, output: null, traceId };\n    }\n  }\n\n  /**\n   * Get initial plan from template, checkpoint or generate new one\n   */\n  private async getPlan(props: PlannerAgentExecuteProps): Promise<WorkflowStep[]> {\n    let plan: WorkflowStep[];\n    \n    if (props.resumeFromCheckpointId) {\n      plan = this.resumeFromCheckpoint(props.resumeFromCheckpointId);\n      logEvent('checkpoint_resumed', { checkpointId: props.resumeFromCheckpointId }, \n              `Resumed from checkpoint ${props.resumeFromCheckpointId}`);\n    } \n    else if (props.loadFromTemplate) {\n      plan = this.loadTemplate(props.loadFromTemplate);\n      logEvent('template_loaded', { templateName: props.loadFromTemplate }, \n              `Loaded template: ${props.loadFromTemplate}`);\n    } \n    else {\n      // Generate new plan\n      const prompt = buildPlannerPrompt(props.request);\n      const planJson = await this.callLLM(prompt);\n      \n      try {\n        const parsedPlan = JSON.parse(planJson);\n        if (!Array.isArray(parsedPlan)) {\n          throw new Error('LLM response is not a valid plan array');\n        }\n        \n        plan = parsedPlan.map(step => ({\n          ...step,\n          status: 'pending',\n          dependencies: Array.isArray(step.dependencies) ? step.dependencies : [],\n          args: step.args || {},\n        }));\n        \n        logEvent('plan_generated', { plan }, `Generated new plan with ${plan.length} steps`);\n      } catch (error) {\n        console.error('Failed to parse LLM plan:', error);\n        throw new Error(`Failed to generate workflow plan: ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n    \n    if (props.onPlanUpdate) {\n      props.onPlanUpdate([...plan]);\n    }\n    \n    return plan;\n  }\n\n  /**\n   * Execute a plan using the runWorkflowPlan utility\n   */\n  private async executePlan(\n    plan: WorkflowStep[],\n    props: PlannerAgentExecuteProps\n  ): Promise<PlannerResult> {\n    // Create checkpoint before execution\n    const checkpointId = this.createCheckpoint(plan);\n    logEvent('checkpoint_created', { checkpointId }, `Created execution checkpoint ${checkpointId}`);\n    \n    // Execute the plan\n    return runWorkflowPlan(plan, props.onPlanUpdate);\n  }\n\n  /**\n   * Revise a failed plan using the revisePlan utility\n   */\n  private async revisePlan(\n    request: string, \n    failedPlan: WorkflowStep[],\n    errorMessage?: string,\n    attempt?: number,\n    traceId?: string\n  ): Promise<WorkflowStep[]> {\n    try {\n      const attemptNumber = attempt || 1;\n      if (attemptNumber > MAX_REVISIONS) {\n        throw new Error(`Maximum revision attempts (${MAX_REVISIONS}) exceeded`);\n      }\n      \n      // Pr├®parer les options pour la r├®vision\n      const revisionOptions: Parameters<typeof revisePlan>[4] = {\n        apiKey: OPENAI_API_KEY,\n        traceId,\n        onExplanation: (explanation) => {\n          // Journal pour l'explication (sera utilis├® pour l'interface utilisateur)\n          logEvent('plan_explanation', { attempt: attemptNumber }, explanation);\n        }\n      };\n      \n      // Utiliser l'utilitaire revisePlan\n      const result = await revisePlan(\n        request,\n        failedPlan,\n        errorMessage,\n        attemptNumber,\n        revisionOptions\n      );\n      \n      return result.plan;\n    } catch (error) {\n      const message = error instanceof Error ? error.message : String(error);\n      logEvent('plan_revision_failed', { error: message }, `Plan revision failed: ${message}`);\n    }\n  }\n\n  /**\n   * Finalize plan execution, save templates, and clean up checkpoints.\n   */\n  private finalizePlan(\n    result: { success: boolean; error?: string; summary?: string },\n    plan: WorkflowStep[],\n    props: PlannerAgentExecuteProps,\n    checkpointId?: string | null,\n    explanation?: string | null,\n    traceId?: string\n  ): PlannerResult {\n    // Mettre ├á jour le store avec l'explication du plan et l'ID de trace\n    const store = agentRegistry.getStore();\n    if (store && explanation) {\n      store.setLastPlanExplanation(explanation, traceId);\n    }\n    \n    // Get API request ID if one was used\n    if (result.success) {\n      // Save as template if specified\n      if (props.saveAsTemplate && typeof props.saveAsTemplate === 'string') {\n        this.saveAsTemplate(props.saveAsTemplate, plan);\n        logEvent('plan_template_saved', { name: props.saveAsTemplate }, `Saved plan as template: ${props.saveAsTemplate}`);\n      }\n      \n      // Clean up checkpoint if we succeeded\n      if (checkpointId) {\n        this.workflowCheckpoints.delete(checkpointId);\n        saveToStorage(PLANNER_CHECKPOINTS_KEY, Array.from(this.workflowCheckpoints.entries()));\n        logEvent('checkpoint_deleted', { id: checkpointId }, `Deleted checkpoint ${checkpointId} after successful execution`);\n      }\n      \n      logEvent('plan_succeeded', { request: props.request }, `Plan executed successfully`);\n      return { \n        success: true, \n        output: result.summary || 'Plan executed successfully', \n        plan,\n        explanation,\n        traceId\n      };\n    } else {\n      // Add checkpoint for failed plan\n      const errorMessage = result.error || 'Unknown error';\n      \n      if (!props.preventCheckpoint) {\n        const id = checkpointId || uuidv4();\n        this.workflowCheckpoints.set(id, plan);\n        saveToStorage(PLANNER_CHECKPOINTS_KEY, Array.from(this.workflowCheckpoints.entries()));\n        logEvent('checkpoint_saved', { id }, `Saved checkpoint for failed plan: ${id}`);\n      }\n      \n      logEvent('plan_failed', { error: errorMessage }, `Plan failed: ${errorMessage}`);\n      return { \n        success: false, \n        error: errorMessage, \n        plan,\n        explanation,\n        traceId\n      };\n    }\n  }\n\n  private async callLLM(prompt: string): Promise<string> {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${OPENAI_API_KEY}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-4-turbo', // ou un autre mod├¿le puissant\n        messages: [{ role: 'user', content: prompt }],\n        temperature: 0.2,\n        response_format: { type: 'json_object' }\n      }),\n    });\n    \n    if (!response.ok) {\n      throw new Error(`LLM API request failed: ${response.status} ${await response.text()}`);\n    }\n    \n    const result = await response.json();\n    return result.choices[0].message.content;\n  }\n\n  // --- Template & Checkpoint Methods ---\n  \n  public saveAsTemplate(name: string, plan: WorkflowStep[]): void {\n    // Create a clean copy without execution details\n    const templatePlan = plan.map(step => ({\n      ...step,\n      status: 'pending' as const,\n      result: undefined,\n      startTime: undefined,\n      endTime: undefined,\n      duration: undefined\n    }));\n    \n    this.workflowTemplates.set(name, templatePlan);\n    saveToStorage(PLANNER_TEMPLATES_KEY, Array.from(this.workflowTemplates.entries()));\n  }\n\n  public loadTemplate(name: string): WorkflowStep[] {\n    const template = this.workflowTemplates.get(name);\n    if (!template) {\n      throw new Error(`Template '${name}' not found`);\n    }\n    return JSON.parse(JSON.stringify(template)); // Deep copy to prevent mutation\n  }\n\n  public createCheckpoint(plan: WorkflowStep[]): string {\n    const checkpointId = uuidv4();\n    this.workflowCheckpoints.set(checkpointId, JSON.parse(JSON.stringify(plan)));\n    saveToStorage(PLANNER_CHECKPOINTS_KEY, Array.from(this.workflowCheckpoints.entries()));\n    return checkpointId;\n  }\n\n  public resumeFromCheckpoint(checkpointId: string): WorkflowStep[] {\n    const plan = this.workflowCheckpoints.get(checkpointId);\n    if (!plan) {\n      throw new Error(`Checkpoint '${checkpointId}' not found`);\n    }\n    return JSON.parse(JSON.stringify(plan)); // Deep copy to prevent mutation\n  }\n\n  public getTemplates(): string[] {\n    return Array.from(this.workflowTemplates.keys());\n  }\n\n  public getCheckpoints(): string[] {\n    return Array.from(this.workflowCheckpoints.keys());\n  }\n}\n\n// Register the agent\nagentRegistry.register(new PlannerAgent());\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\PowerShellAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4604,4607],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4604,4607],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4618,4621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4618,4621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":154,"column":98,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":154,"endColumn":101,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5358,5361],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5358,5361],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":239,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":239,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8535,8538],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8535,8538],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":380,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":380,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13888,13891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13888,13891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":399,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14733,14736],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14733,14736],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { agentRegistry } from './registry';\nimport { AgentDomains } from './types';\nimport type { AgentParameter, BaseAgent } from './types';\nimport { createLogger } from '../utils/logger';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Interface pour les r├®sultats d'ex├®cution PowerShell\n */\ninterface PowerShellResult {\n  id: string;\n  command: string;\n  output: string;\n  error: string | null;\n  exitCode: number;\n  startTime: number;\n  endTime: number;\n  executionTime: number;\n  success: boolean;\n}\n\n/**\n * Interface pour les options d'ex├®cution PowerShell\n */\ninterface PowerShellOptions {\n  timeout?: number;\n  maxOutputLength?: number;\n  workingDirectory?: string;\n  hidden?: boolean;\n  allowedCommands?: string[];\n}\n\n/**\n * PowerShellAgent - Agent pour ex├®cuter des commandes PowerShell de fa├ºon s├®curis├®e\n * \n * Cet agent permet de:\n * - Ex├®cuter des commandes PowerShell avec v├®rification de s├®curit├®\n * - Obtenir des informations syst├¿me via PowerShell\n * - G├®rer un historique des commandes ex├®cut├®es\n * - Limiter les commandes aux seules autoris├®es\n */\nexport class PowerShellAgent implements BaseAgent {\n  name = 'PowerShellAgent';\n  description = 'Agent pour ex├®cuter des commandes PowerShell de fa├ºon s├®curis├®e';\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = ['command-execution', 'system-info', 'file-operations', 'network-operations'];\n\n  // Liste blanche des commandes autoris├®es (pour la s├®curit├®)\n  private allowedCommandPrefixes: string[] = [\n    'Get-', // Commandes de lecture (Get-Process, Get-Service, etc.)\n    'Select-', // Filtrage (Select-Object)\n    'Sort-', // Tri (Sort-Object)\n    'Where-', // Filtrage (Where-Object)\n    'Format-', // Formatage (Format-Table, Format-List)\n    'Measure-', // Mesure (Measure-Object)\n    'Group-', // Groupement (Group-Object)\n    'ConvertTo-', // Conversion (ConvertTo-Json, ConvertTo-Csv)\n    'Export-', // Export (Export-Csv)\n    'Test-', // Test (Test-Connection, Test-Path)\n    'Invoke-RestMethod', // Appels API REST\n    'Invoke-WebRequest', // Requ├¬tes web\n    'ping', // Ping\n    'ipconfig', // Configuration r├®seau\n    'systeminfo', // Informations syst├¿me\n    'dir', // Liste de r├®pertoire\n    'ls', // Alias pour Get-ChildItem\n    'hostname', // Nom d'h├┤te\n    'echo', // Affichage\n    'whoami', // Utilisateur actuel\n    'netstat', // Statistiques r├®seau\n  ];\n\n  // Commandes explicitement interdites pour des raisons de s├®curit├®\n  private blockedCommands: string[] = [\n    'Remove-', // Suppression (Remove-Item, etc.)\n    'Delete', // Suppression\n    'Set-', // Modification (Set-Content, etc.)\n    'New-', // Cr├®ation (New-Item, etc.)\n    'Start-Process', // Lancement de processus\n    'Start-Job', // Lancement de job\n    'Invoke-Expression', // Ex├®cution dynamique (danger)\n    'Invoke-Command', // Ex├®cution ├á distance\n    'iex', // Alias pour Invoke-Expression\n    'IEX', // Variation\n    '&', // Appel d'op├®rateur\n    'del', // Suppression\n    'rmdir', // Suppression de r├®pertoire\n    'rm', // Suppression\n    'wget', // T├®l├®chargement\n    'curl', // T├®l├®chargement (si pas utilis├® pour de la consultation)\n    'Compress-', // Compression\n    'Expand-', // D├®compression\n    'shutdown', // Arr├¬t du syst├¿me\n    'restart', // Red├®marrage du syst├¿me\n    'Stop-', // Arr├¬t (Stop-Process, etc.)\n    'kill', // Arr├¬t de processus\n    'taskkill', // Arr├¬t de t├óche\n    'format', // Formatage\n    'reg', // Registre Windows\n    'runas', // Ex├®cution en tant que\n    'attrib', // Attributs de fichier\n    'move', // D├®placement de fichier\n  ];\n\n  private commandHistory: PowerShellResult[] = [];\n  private defaultOptions: PowerShellOptions = {\n    timeout: 10000, // 10 secondes par d├®faut\n    maxOutputLength: 5000, // Limite la taille de sortie\n    workingDirectory: undefined, // R├®pertoire courant du processus\n    hidden: false, // Affiche la console PowerShell\n    allowedCommands: [] // Pas de restriction suppl├®mentaire\n  };\n\n  private logger = createLogger('PowerShellAgent');\n\n  /**\n   * V├®rifie si l'agent peut traiter la requ├¬te\n   * @param query Requ├¬te utilisateur\n   * @returns Score de confiance entre 0 et 1\n   */\n  async canHandle(query: string): Promise<number> {\n    const powershellKeywords = [\n      'powershell', 'commande', 'cmd', 'terminal', 'console', 'ex├®cuter',\n      'lancer', 'run', 'execute', 'shell', 'ps', 'pwsh', 'system', 'admin'\n    ];\n    \n    return this.calculateKeywordMatch(query, powershellKeywords);\n  }\n\n  /**\n   * Ex├®cute une action PowerShell\n   * @param params Param├¿tres de l'action\n   * @returns R├®sultat de l'action\n   */\n  async execute(params: any): Promise<any> {\n    const { action, ...actionParams } = params;\n    \n    try {\n      switch (action) {\n        case 'executeCommand':\n          return await this.executeCommand(actionParams.command, actionParams.options);\n        case 'getSystemInfo':\n          return await this.getSystemInfo();\n        case 'getCommandHistory':\n          return this.getCommandHistory(actionParams.limit);\n        case 'getLastResult':\n          return this.getLastResult();\n        default:\n          throw new Error(`Action inconnue: ${action}`);\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Erreur inconnue';\n      this.logger.error(`Erreur lors de l'ex├®cution de l'action PowerShell ${action}:`, error as any);\n      \n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Retourne les param├¿tres requis pour une t├óche donn├®e\n   * @param task Description de la t├óche\n   * @returns Liste des param├¿tres requis\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    const isCommandExecution = task.includes('ex├®cuter') || task.includes('lancer') || \n                              task.includes('run') || task.includes('execute') ||\n                              task.includes('powershell') || task.includes('commande');\n    \n    if (isCommandExecution) {\n      return [\n        { name: 'action', type: 'string', required: true, description: 'Type d\\'action PowerShell (executeCommand)' },\n        { name: 'command', type: 'string', description: 'Commande PowerShell ├á ex├®cuter', required: true },\n        { name: 'options', type: 'object', description: 'Options d\\'ex├®cution', required: false }\n      ];\n    }\n    \n    if (task.includes('syst├¿me') || task.includes('system') || task.includes('info')) {\n      return [\n        { name: 'action', type: 'string', required: true, description: 'Type d\\'action PowerShell (getSystemInfo)' }\n      ];\n    }\n    \n    return [\n      { name: 'action', type: 'string', description: 'Action PowerShell ├á ex├®cuter', required: true }\n    ];\n  }\n\n  /**\n   * Ex├®cute une commande PowerShell\n   * @param command Commande ├á ex├®cuter\n   * @param options Options d'ex├®cution\n   * @returns R├®sultat de l'ex├®cution\n   */\n  private async executeCommand(command: string, options: PowerShellOptions = {}): Promise<PowerShellResult> {\n    const startTime = Date.now();\n    const executionId = uuidv4();\n    \n    // V├®rification de s├®curit├®\n    this.validateCommand(command, options);\n    \n    // Fusion des options par d├®faut et fournies\n    const mergedOptions = { ...this.defaultOptions, ...options };\n    \n    try {\n      // Dans un environnement web, nous ne pouvons pas ex├®cuter directement PowerShell\n      // Mais nous pouvons utiliser un service web ou un backend qui expose cette fonctionnalit├®\n      \n      // Simulons l'ex├®cution d'une commande PowerShell (dans une vraie impl├®mentation,\n      // nous ferions un appel ├á un backend ou utiliserions Node.js pour ex├®cuter la commande)\n      const result = await this.simulateCommandExecution(command, mergedOptions);\n      \n      // Enregistrer dans l'historique\n      const commandResult: PowerShellResult = {\n        id: executionId,\n        command,\n        output: result.output,\n        error: result.error,\n        exitCode: result.exitCode,\n        startTime,\n        endTime: Date.now(),\n        executionTime: Date.now() - startTime,\n        success: result.exitCode === 0\n      };\n      \n      this.commandHistory.push(commandResult);\n      \n      // Limiter la taille de l'historique\n      if (this.commandHistory.length > 50) {\n        this.commandHistory.shift();\n      }\n      \n      return commandResult;\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Erreur inconnue';\n      this.logger.error(`Erreur lors de l'ex├®cution de la commande PowerShell: ${command}`, error as any);\n      \n      // Enregistrer l'erreur dans l'historique\n      const commandResult: PowerShellResult = {\n        id: executionId,\n        command,\n        output: '',\n        error: errorMessage,\n        exitCode: -1,\n        startTime,\n        endTime: Date.now(),\n        executionTime: Date.now() - startTime,\n        success: false\n      };\n      \n      this.commandHistory.push(commandResult);\n      \n      return commandResult;\n    }\n  }\n\n  /**\n   * Simule l'ex├®cution d'une commande PowerShell\n   * Dans un vrai environnement, nous utiliserions une API backend ou Node.js\n   * @param command Commande ├á ex├®cuter\n   * @param options Options d'ex├®cution\n   * @returns R├®sultat simul├®\n   */\n  private async simulateCommandExecution(command: string, _options: PowerShellOptions): Promise<{ output: string; error: string | null; exitCode: number }> {\n    // Cette m├®thode simule l'ex├®cution de commandes PowerShell\n    // Dans une impl├®mentation r├®elle, elle appellerait un backend ou un service\n    \n    this.logger.info(`Simulation d'ex├®cution de commande PowerShell: ${command}`);\n    \n    // Cr├®er un d├®lai simul├® bas├® sur la complexit├® de la commande\n    const delay = Math.min(Math.max(command.length * 10, 200), 1000);\n    \n    return new Promise((resolve) => {\n      setTimeout(() => {\n        // Simulation de r├®ponses pour certaines commandes\n        if (command.toLowerCase().includes('get-process')) {\n          resolve({\n            output: `\nHandle  NPM(K)    PM(K)      WS(K)     CPU(s)     Id  SI ProcessName\n------  ------    -----      -----     ------     --  -- -----------\n    564      28     4520      13456       0.58   3856   1 chrome\n    892      51    18952      52640       2.31   7920   1 msedge\n    452      19     3700       9120       0.14   2120   1 explorer\n    188      14     1820       5640       0.06   1024   1 powershell\n            `,\n            error: null,\n            exitCode: 0\n          });\n        } else if (command.toLowerCase().includes('get-service')) {\n          resolve({\n            output: `\nStatus   Name               DisplayName\n------   ----               -----------\nRunning  AudioEndpointBu... Windows Audio Endpoint Builder\nRunning  Audiosrv           Windows Audio\nRunning  BFE                Base Filtering Engine\nStopped  BITS               Background Intelligent Transfer Ser...\nRunning  BrokerInfrastru... Background Tasks Infrastructure Ser...\n            `,\n            error: null,\n            exitCode: 0\n          });\n        } else if (command.toLowerCase().includes('systeminfo')) {\n          resolve({\n            output: `\nHost Name:                 DESKTOP-ABC123\nOS Name:                   Microsoft Windows 10 Pro\nOS Version:                10.0.19044 N/A Build 19044\nOS Manufacturer:           Microsoft Corporation\nOS Configuration:          Standalone Workstation\nOS Build Type:             Multiprocessor Free\nSystem Manufacturer:       Dell Inc.\nSystem Model:              XPS 15 9500\nSystem Type:               x64-based PC\nProcessor(s):              1 Processor(s) Installed, Intel64 Family 6 Model 165 Stepping 2\nBIOS Version:              Dell Inc. 1.5.0, 10/12/2020\nWindows Directory:         C:\\\\Windows\nSystem Directory:          C:\\\\Windows\\\\system32\nBoot Device:               \\\\Device\\\\HarddiskVolume1\nTotal Physical Memory:     16,384 MB\nAvailable Physical Memory: 8,214 MB\nVirtual Memory: Max Size:  32,768 MB\nVirtual Memory: Available: 20,125 MB\n            `,\n            error: null,\n            exitCode: 0\n          });\n        } else if (command.toLowerCase().includes('get-childitem') || command.toLowerCase() === 'dir' || command.toLowerCase() === 'ls') {\n          resolve({\n            output: `\n    Directory: C:\\\\Users\\\\patri\\\\Documents\n\nMode                LastWriteTime         Length Name\n----                -------------         ------ ----\nd-----        7/10/2025   9:30 AM                Projects\nd-----        7/10/2025  10:15 AM                Reports\n-a----        7/10/2025   8:45 AM          12588 budget.xlsx\n-a----        7/10/2025   9:10 AM          45621 presentation.pptx\n-a----        7/10/2025  10:05 AM           8954 report.docx\n            `,\n            error: null,\n            exitCode: 0\n          });\n        } else if (command.toLowerCase().includes('ping')) {\n          resolve({\n            output: `\nEnvoi d'une requ├¬te 'ping' sur google.com [142.250.179.78] avec 32 octets de donn├®es :\nR├®ponse de 142.250.179.78 : octets=32 temps=14 ms TTL=128\nR├®ponse de 142.250.179.78 : octets=32 temps=15 ms TTL=128\nR├®ponse de 142.250.179.78 : octets=32 temps=12 ms TTL=128\nR├®ponse de 142.250.179.78 : octets=32 temps=13 ms TTL=128\n\nStatistiques Ping pour 142.250.179.78:\n    Paquets : envoy├®s = 4, re├ºus = 4, perdus = 0 (perte 0%),\nDur├®e approximative des boucles en millisecondes :\n    Minimum = 12ms, Maximum = 15ms, Moyenne = 13ms\n            `,\n            error: null,\n            exitCode: 0\n          });\n        } else {\n          // Commande non reconnue, simulation d'une sortie g├®n├®rique\n          resolve({\n            output: `Ex├®cution simul├®e de: ${command}`,\n            error: null,\n            exitCode: 0\n          });\n        }\n      }, delay);\n    });\n  }\n\n  /**\n   * Obtient des informations syst├¿me via PowerShell\n   * @returns Informations syst├¿me\n   */\n  private async getSystemInfo(): Promise<any> {\n    // Cette m├®thode combine plusieurs commandes PowerShell pour obtenir des informations syst├¿me compl├¿tes\n    const systemInfoResult = await this.executeCommand('systeminfo');\n    const processesResult = await this.executeCommand('Get-Process | Sort-Object -Property CPU -Descending | Select-Object -First 5');\n    const servicesResult = await this.executeCommand('Get-Service | Where-Object {$_.Status -eq \"Running\"} | Select-Object -First 5');\n    \n    return {\n      systemInfo: systemInfoResult,\n      topProcesses: processesResult,\n      runningServices: servicesResult,\n      timestamp: new Date().toISOString()\n    };\n  }\n\n  /**\n   * Obtient l'historique des commandes ex├®cut├®es\n   * @param limit Limite le nombre de r├®sultats (optionnel)\n   * @returns Historique des commandes\n   */\n  private getCommandHistory(limit?: number): any {\n    let history = [...this.commandHistory];\n    \n    if (limit && limit > 0) {\n      history = history.slice(-limit);\n    }\n    \n    return {\n      count: history.length,\n      commands: history\n    };\n  }\n\n  /**\n   * Obtient le r├®sultat de la derni├¿re commande ex├®cut├®e\n   * @returns Dernier r├®sultat\n   */\n  private getLastResult(): PowerShellResult | null {\n    if (this.commandHistory.length === 0) {\n      return null;\n    }\n    \n    return this.commandHistory[this.commandHistory.length - 1];\n  }\n\n  /**\n   * Valide si une commande est autoris├®e ├á ├¬tre ex├®cut├®e\n   * @param command Commande ├á valider\n   * @param options Options d'ex├®cution\n   * @throws Error si la commande est interdite\n   */\n  private validateCommand(command: string, options: PowerShellOptions): void {\n    const normalizedCommand = command.trim().toLowerCase();\n    \n    // V├®rifier d'abord les commandes bloqu├®es\n    for (const blockedCmd of this.blockedCommands) {\n      if (normalizedCommand.includes(blockedCmd.toLowerCase())) {\n        throw new Error(`Commande non autoris├®e: ${command} (contient ${blockedCmd})`);\n      }\n    }\n    \n    // Si des commandes sp├®cifiques sont autoris├®es dans les options, v├®rifier uniquement celles-l├á\n    if (options.allowedCommands && options.allowedCommands.length > 0) {\n      const isExplicitlyAllowed = options.allowedCommands.some(allowed => \n        normalizedCommand.startsWith(allowed.toLowerCase())\n      );\n      \n      if (!isExplicitlyAllowed) {\n        throw new Error(`Commande non autoris├®e: ${command}`);\n      }\n      \n      return; // La commande est explicitement autoris├®e\n    }\n    \n    // Sinon, v├®rifier les pr├®fixes autoris├®s par d├®faut\n    const isAllowed = this.allowedCommandPrefixes.some(prefix => \n      normalizedCommand.startsWith(prefix.toLowerCase())\n    );\n    \n    if (!isAllowed) {\n      throw new Error(`Commande non autoris├®e: ${command}`);\n    }\n  }\n\n  /**\n   * Calcule le score de correspondance entre une requ├¬te et des mots-cl├®s\n   * @param query Requ├¬te utilisateur\n   * @param keywords Liste de mots-cl├®s\n   * @returns Score de correspondance (0-1)\n   */\n  private calculateKeywordMatch(query: string, keywords: string[]): number {\n    const words = query.toLowerCase().split(' ');\n    const matches = keywords.filter(kw => words.some(w => w.includes(kw.toLowerCase())));\n    return Math.min(matches.length / 2, 1); // Score normalis├® entre 0 et 1\n  }\n}\n\n// Enregistrer l'agent dans le registre global\nconst powershellAgent = new PowerShellAgent();\nagentRegistry.register(powershellAgent);\n\nexport default powershellAgent;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\ProactiveSuggestionsAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[435,438],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[435,438],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'now' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":113,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":113,"endColumn":14}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ProactiveSuggestionsAgent.ts\n * Agent sp├®cialis├® pour les suggestions proactives bas├®es sur le contexte\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\nimport type { ContextItem } from '../context/types';\n\nexport interface Suggestion {\n  id: string;\n  title: string;\n  description: string;\n  intent: string;\n  parameters: Record<string, any>;\n  contextSource: string;\n  confidence: number;\n  icon?: string;\n  timestamp: number;\n  category: 'task' | 'reminder' | 'info' | 'action';\n  expiresAt?: number;\n  dismissed?: boolean;\n}\n\n/**\n * Agent sp├®cialis├® pour g├®n├®rer des suggestions proactives\n * bas├®es sur le contexte utilisateur actuel\n */\nexport class ProactiveSuggestionsAgent implements BaseAgent {\n  public readonly name = 'Proactive Suggestions';\n  public readonly description = 'G├®n├¿re des suggestions proactives bas├®es sur le contexte utilisateur';\n  public readonly domain: AgentDomain = AgentDomains.PRODUCTIVITY;\n  public readonly version = '1.0.0';\n  public readonly capabilities = ['suggestions', 'context_analysis', 'proactive_recommendations'];\n\n  private currentSuggestions: Suggestion[] = [];\n\n  /**\n   * M├®thode principale pour ex├®cuter l'agent\n   */\n  public async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    try {\n      switch (props.intent) {\n        case 'generate_suggestions':\n          return await this.generateSuggestions(props.parameters?.context);\n        case 'get_suggestions':\n          return this.getSuggestions();\n        case 'dismiss_suggestion':\n          return this.dismissSuggestion(props.parameters?.suggestionId);\n        case 'clear_suggestions':\n          return this.clearSuggestions();\n        case 'execute_suggestion':\n          return this.executeSuggestion(props.parameters?.suggestionId);\n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Intent inconnu: ${props.intent}`\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * G├®n├¿re des suggestions proactives bas├®es sur le contexte actuel\n   */\n  private async generateSuggestions(contextItems?: ContextItem[]): Promise<AgentExecuteResult> {\n    try {\n      if (!contextItems || contextItems.length === 0) {\n        return {\n          success: false,\n          output: null,\n          error: 'Aucun contexte fourni pour g├®n├®rer des suggestions',\n        };\n      }\n\n      // Analyse le contexte pour g├®n├®rer des suggestions\n      const suggestions = await this.analyzeContextForSuggestions(contextItems);\n\n      // Met ├á jour les suggestions actuelles\n      this.currentSuggestions = [\n        ...this.currentSuggestions.filter(s => !s.dismissed && (!s.expiresAt || s.expiresAt > Date.now())),\n        ...suggestions\n      ];\n\n      return {\n        success: true,\n        output: {\n          suggestions: this.currentSuggestions,\n          count: this.currentSuggestions.length,\n        },\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n      };\n    }\n  }\n\n  /**\n   * Analyse le contexte pour g├®n├®rer des suggestions pertinentes\n   */\n  private async analyzeContextForSuggestions(contextItems: ContextItem[]): Promise<Suggestion[]> {\n    const suggestions: Suggestion[] = [];\n    const now = Date.now();\n\n    // Traite les diff├®rents types de contexte\n    for (const item of contextItems) {\n      switch (item.type) {\n        case 'conversation':\n          suggestions.push(...this.generateConversationSuggestions(item));\n          break;\n        case 'entity':\n          suggestions.push(...this.generateEntitySuggestions(item));\n          break;\n        case 'intent_history':\n          suggestions.push(...this.generateIntentHistorySuggestions(item));\n          break;\n        case 'user_preference':\n          suggestions.push(...this.generatePreferenceSuggestions(item));\n          break;\n        case 'system_state':\n          suggestions.push(...this.generateSystemStateSuggestions(item));\n          break;\n      }\n    }\n\n    // Filtre et ordonne les suggestions par pertinence (confiance)\n    return suggestions\n      .filter(s => s.confidence > 0.5)\n      .sort((a, b) => b.confidence - a.confidence)\n      .slice(0, 5); // Limite ├á 5 suggestions maximum\n  }\n\n  /**\n   * G├®n├¿re des suggestions bas├®es sur les conversations r├®centes\n   */\n  private generateConversationSuggestions(context: ContextItem): Suggestion[] {\n    const suggestions: Suggestion[] = [];\n    \n    // Si la conversation contient des mots-cl├®s li├®s ├á des t├óches\n    if (context.content?.text?.toLowerCase().includes('rappel') || \n        context.content?.text?.toLowerCase().includes('rappelle-moi')) {\n      suggestions.push({\n        id: `reminder-${Date.now()}`,\n        title: 'Cr├®er un rappel',\n        description: 'Voulez-vous cr├®er un rappel bas├® sur votre conversation?',\n        intent: 'create_reminder',\n        parameters: {\n          source: context.id,\n          text: context.content?.text\n        },\n        contextSource: context.id,\n        confidence: 0.85,\n        icon: 'alarm',\n        timestamp: Date.now(),\n        category: 'reminder',\n        expiresAt: Date.now() + 1800000, // 30 minutes\n      });\n    }\n\n    // Si la conversation mentionne la m├®t├®o\n    if (context.content?.text?.toLowerCase().includes('m├®t├®o') ||\n        context.content?.text?.toLowerCase().includes('temps')) {\n      suggestions.push({\n        id: `weather-${Date.now()}`,\n        title: 'V├®rifier la m├®t├®o',\n        description: 'Consulter les pr├®visions m├®t├®o actuelles',\n        intent: 'check_weather',\n        parameters: {},\n        contextSource: context.id,\n        confidence: 0.75,\n        icon: 'cloud',\n        timestamp: Date.now(),\n        category: 'info',\n      });\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * G├®n├¿re des suggestions bas├®es sur les entit├®s reconnues\n   */\n  private generateEntitySuggestions(context: ContextItem): Suggestion[] {\n    const suggestions: Suggestion[] = [];\n    const entity = context.content;\n\n    // Si l'entit├® est une date future\n    if (entity?.type === 'date' && entity.value && new Date(entity.value).getTime() > Date.now()) {\n      suggestions.push({\n        id: `calendar-${Date.now()}`,\n        title: 'Consulter l\\'agenda',\n        description: `Voir vos ├®v├®nements pour ${new Date(entity.value).toLocaleDateString()}`,\n        intent: 'check_calendar',\n        parameters: {\n          date: entity.value\n        },\n        contextSource: context.id,\n        confidence: 0.8,\n        icon: 'calendar',\n        timestamp: Date.now(),\n        category: 'action',\n      });\n    }\n\n    // Si l'entit├® est un lieu\n    if (entity?.type === 'location') {\n      suggestions.push({\n        id: `location-${Date.now()}`,\n        title: `Informations sur ${entity.value}`,\n        description: `Rechercher des informations sur ${entity.value}`,\n        intent: 'search_location',\n        parameters: {\n          location: entity.value\n        },\n        contextSource: context.id,\n        confidence: 0.7,\n        icon: 'place',\n        timestamp: Date.now(),\n        category: 'info',\n      });\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * G├®n├¿re des suggestions bas├®es sur l'historique des intentions\n   */\n  private generateIntentHistorySuggestions(context: ContextItem): Suggestion[] {\n    const suggestions: Suggestion[] = [];\n    const intentHistory = context.content;\n\n    // Si l'utilisateur a r├®cemment v├®rifi├® la m├®t├®o plusieurs fois\n    if (intentHistory?.intent === 'check_weather' && intentHistory.count && intentHistory.count > 2) {\n      suggestions.push({\n        id: `weather-shortcut-${Date.now()}`,\n        title: 'Ajouter un raccourci m├®t├®o',\n        description: 'Ajouter un raccourci m├®t├®o ├á votre ├®cran d\\'accueil',\n        intent: 'create_shortcut',\n        parameters: {\n          type: 'weather'\n        },\n        contextSource: context.id,\n        confidence: 0.65,\n        icon: 'add_to_home_screen',\n        timestamp: Date.now(),\n        category: 'action',\n      });\n    }\n\n    return suggestions;\n  }\n\n  /**\n   * G├®n├¿re des suggestions bas├®es sur les pr├®f├®rences utilisateur\n   */\n  private generatePreferenceSuggestions(_context: ContextItem): Suggestion[] {\n    return []; // ├Ç impl├®menter\n  }\n\n  /**\n   * G├®n├¿re des suggestions bas├®es sur l'├®tat du syst├¿me\n   */\n  private generateSystemStateSuggestions(_context: ContextItem): Suggestion[] {\n    return []; // ├Ç impl├®menter\n  }\n\n  /**\n   * R├®cup├¿re les suggestions actuelles\n   */\n  private getSuggestions(): AgentExecuteResult {\n    // Filtre les suggestions p├®rim├®es ou ignor├®es\n    this.currentSuggestions = this.currentSuggestions.filter(\n      s => !s.dismissed && (!s.expiresAt || s.expiresAt > Date.now())\n    );\n\n    return {\n      success: true,\n      output: {\n        suggestions: this.currentSuggestions,\n        count: this.currentSuggestions.length,\n      },\n    };\n  }\n\n  /**\n   * Marque une suggestion comme ignor├®e\n   */\n  private dismissSuggestion(suggestionId?: string): AgentExecuteResult {\n    if (!suggestionId) {\n      return {\n        success: false,\n        output: null,\n        error: 'ID de suggestion non fourni',\n      };\n    }\n\n    const suggestionIndex = this.currentSuggestions.findIndex(s => s.id === suggestionId);\n    if (suggestionIndex === -1) {\n      return {\n        success: false,\n        output: null,\n        error: `Suggestion non trouv├®e: ${suggestionId}`,\n      };\n    }\n\n    this.currentSuggestions[suggestionIndex].dismissed = true;\n\n    return {\n      success: true,\n      output: {\n        dismissed: suggestionId,\n        remainingCount: this.currentSuggestions.filter(s => !s.dismissed).length,\n      },\n    };\n  }\n\n  /**\n   * Supprime toutes les suggestions\n   */\n  private clearSuggestions(): AgentExecuteResult {\n    const previousCount = this.currentSuggestions.filter(s => !s.dismissed).length;\n    this.currentSuggestions = [];\n\n    return {\n      success: true,\n      output: {\n        clearedCount: previousCount,\n      },\n    };\n  }\n\n  /**\n   * Ex├®cute une suggestion\n   */\n  private executeSuggestion(suggestionId?: string): AgentExecuteResult {\n    if (!suggestionId) {\n      return {\n        success: false,\n        output: null,\n        error: 'ID de suggestion non fourni',\n      };\n    }\n\n    const suggestion = this.currentSuggestions.find(s => s.id === suggestionId);\n    if (!suggestion) {\n      return {\n        success: false,\n        output: null,\n        error: `Suggestion non trouv├®e: ${suggestionId}`,\n      };\n    }\n\n    // Marque la suggestion comme trait├®e\n    suggestion.dismissed = true;\n\n    return {\n      success: true,\n      output: {\n        executed: suggestionId,\n        intent: suggestion.intent,\n        parameters: suggestion.parameters,\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\RobotAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1761,1764],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1761,1764],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3185,3188],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3185,3188],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomains } from \"./types\";\nimport { RosService } from \"../services/RosService\";\n\nexport class RobotAgent implements BaseAgent {\n  name = \"RobotAgent\";\n  description = \"Manages robot control and interaction.\";\n  version = \"0.1.0\";\n  domain = AgentDomains.INTEGRATION;\n  capabilities = [\"move\", \"turn\", \"pickUp\"];\n\n  private rosService: RosService;\n\n  constructor() {\n    // TODO: Make ROS Bridge URL configurable (e.g., via environment variable)\n    this.rosService = new RosService(import.meta.env.VITE_ROS_BRIDGE_URL || \"ws://localhost:9090\"); \n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { intent, parameters } = props;\n\n    try {\n      await this.rosService.ensureConnection();\n\n      switch (intent) {\n        case \"move\":\n          if (parameters && typeof parameters.distance === \"number\") {\n            return this.move(parameters.distance);\n          }\n          return { success: false, output: null, error: \"Missing or invalid 'distance' parameter for move intent.\" };\n        case \"turn\":\n          if (parameters && typeof parameters.angle === \"number\") {\n            return this.turn(parameters.angle);\n          }\n          return { success: false, output: null, error: \"Missing or invalid 'angle' parameter for turn intent.\" };\n        case \"pickUp\":\n          if (parameters && typeof parameters.objectId === \"string\") {\n            return this.pickUp(parameters.objectId);\n          }\n          return { success: false, output: null, error: \"Missing or invalid 'objectId' parameter for pickUp intent.\" };\n        default:\n          return { success: false, output: null, error: `Unknown intent: ${intent}` };\n      }\n    } catch (error: any) {\n      return { success: false, output: null, error: `ROS communication error: ${error.message}` };\n    }\n  }\n\n  private async move(distance: number): Promise<AgentExecuteResult> {\n    console.log(`Robot moving by ${distance} units.`);\n    // Example: Publish to a ROS topic for movement\n    this.rosService.publish(\"/cmd_vel\", \"geometry_msgs/Twist\", {\n      linear: { x: distance, y: 0, z: 0 },\n      angular: { x: 0, y: 0, z: 0 }\n    });\n    return { success: true, output: `Moved by ${distance} units.` };\n  }\n\n  private async turn(angle: number): Promise<AgentExecuteResult> {\n    console.log(`Robot turning by ${angle} degrees.`);\n    // Example: Publish to a ROS topic for turning\n    this.rosService.publish(\"/cmd_vel\", \"geometry_msgs/Twist\", {\n      linear: { x: 0, y: 0, z: 0 },\n      angular: { x: 0, y: 0, z: angle }\n    });\n    return { success: true, output: `Turned by ${angle} degrees.` };\n  }\n\n  private async pickUp(objectId: string): Promise<AgentExecuteResult> {\n    console.log(`Robot attempting to pick up object: ${objectId}.`);\n    // Example: Call a ROS service for picking up an object\n    try {\n      const response = await this.rosService.callService(\"/pick_up_object\", \"my_robot_msgs/PickUpObject\", {\n        object_id: objectId\n      });\n      return { success: true, output: `Attempted to pick up object: ${objectId}. Service response: ${JSON.stringify(response)}` };\n    } catch (error: any) {\n      return { success: false, output: null, error: `Failed to pick up object: ${error.message}` };\n    }\n  }\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\RosAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1274,1277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1274,1277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":8,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":8,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[330,333],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[330,333],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { Ros, Topic, Service } from 'roslib';\nimport { AgentDomains } from './types';\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult } from './types';\nimport { z } from 'zod';\n\n// Message type is not exported by roslib, use any for now\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\ntype Message = any;\n\nexport const RosAgentConfigSchema = z.object({\n  url: z.string().url('URL must be a valid URL').describe('URL du rosbridge WebSocket (ex: ws://localhost:9090)'),\n  topic: z.string().min(1, 'Topic name is required').describe('Nom du topic ou service ROS'),\n  messageType: z.string().min(1, 'Message type is required').describe('Type du message ou service ROS (ex: std_msgs/String, geometry_msgs/Twist)'),\n  mode: z.enum(['publish', 'subscribe', 'service']).describe('Mode d\\'op├®ration ROS'),\n  payload: z.record(z.string(), z.any()).optional().describe('Contenu du message ou de la requ├¬te en JSON (pour Publish/Service)'),\n  timeout: z.number().int().positive('Timeout must be a positive number').default(5000).optional().describe('D├®lai d\\'attente en ms (d├®faut: 5000)'),\n});\n\nexport type RosAgentParams = {\n  url: string;\n  topic: string;\n  messageType: string;\n  mode: 'publish' | 'subscribe' | 'service';\n  payload?: { [key: string]: any };\n  timeout?: number;\n};\n\nexport class RosAgent implements BaseAgent {\n  name = 'RosAgent';\n  description = 'Interacts with ROS topics and services via rosbridge_suite.';\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = ['publish', 'subscribe', 'service'];\n\n  private ros: Ros | null = null;\n  private currentTopic: Topic | null = null;\n  private subscriptionCallback: ((message: Message) => void) | null = null;\n\n  private async connect(url: string): Promise<void> {\n    return new Promise((resolve, reject) => {\n      if (this.ros) {\n        resolve();\n        return;\n      }\n\n      this.ros = new Ros({\n        url: url\n      });\n\n      this.ros.on('connection', () => {\n        resolve();\n      });\n\n      this.ros.on('error', (error: unknown) => {\n        reject(error instanceof Error ? error : new Error(String(error)));\n      });\n\n      this.ros.on('close', () => {\n        this.ros = null;\n      });\n    });\n  }\n\n  private disconnect(): void {\n    if (this.ros) {\n      if (this.currentTopic && this.subscriptionCallback) {\n        this.currentTopic.unsubscribe(this.subscriptionCallback);\n        this.subscriptionCallback = null;\n      }\n      this.ros.close();\n      this.ros = null;\n    }\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { url, topic: topicName, messageType, mode, payload, timeout = 5000 } = props.parameters as RosAgentParams;\n\n    if (!url || !topicName || !messageType || !mode) {\n      return { success: false, output: null, error: 'Missing required ROS agent parameters: url, topic, messageType, mode.' };\n    }\n\n    try {\n      await this.connect(url);\n\n      if (!this.ros) {\n        throw new Error('ROS connection not established.');\n      }\n\n      switch (mode) {\n        case 'publish': {\n          if (!payload) {\n            throw new Error('Payload is required for publish mode.');\n          }\n          const publishTopic = new Topic({\n            ros: this.ros,\n            name: topicName,\n            messageType: messageType\n          });\n          // Create a simple object as message since Message constructor is not available\n          publishTopic.publish(payload);\n          return { success: true, output: { ok: true, message: 'Published successfully.' } };\n        }\n        case 'subscribe': {\n          return new Promise((resolve, reject) => {\n            const subscribeTopic = new Topic({\n              ros: this.ros as Ros,\n              name: topicName,\n              messageType: messageType\n            });\n\n            const subscriptionCallback = (message: Message) => {\n              console.log(`Received message on ${topicName}:`, message);\n              subscribeTopic.unsubscribe(subscriptionCallback);\n              this.disconnect();\n              resolve({ success: true, output: message });\n            };\n\n            subscribeTopic.subscribe(subscriptionCallback);\n\n            setTimeout(() => {\n              subscribeTopic.unsubscribe(subscriptionCallback);\n              this.disconnect();\n              reject(new Error(`Subscription to ${topicName} timed out after ${timeout}ms.`));\n            }, timeout);\n          });\n        }\n        case 'service': {\n          if (!payload) {\n            throw new Error('Payload is required for service mode.');\n          }\n          const rosService = new Service({\n            ros: this.ros,\n            name: topicName,\n            serviceType: messageType\n          });\n\n          return new Promise((resolve, reject) => {\n            rosService.callService(payload, (response: Message) => {\n              this.disconnect();\n              resolve({ success: true, output: response });\n            }, (error: Message) => {\n              this.disconnect();\n              reject(new Error(`Service call to ${topicName} failed: ${error}`));\n            });\n\n            setTimeout(() => {\n              this.disconnect();\n              reject(new Error(`Service call to ${topicName} timed out after ${timeout}ms.`));\n            }, timeout);\n          });\n        }\n        default:\n          throw new Error(`Unsupported ROS mode: ${mode}`);\n      }\n    } catch (error: unknown) {\n      this.disconnect();\n      const errorMessage = error instanceof Error ? error.message : 'Unknown ROS agent error';\n      return { success: false, output: null, error: errorMessage };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\RosPublisherAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":35,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":35,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1302,1305],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1302,1305],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomains } from \"../agents/types\";\nimport { RosService } from \"../services/RosService\";\n\nexport class RosPublisherAgent implements BaseAgent {\n  name = \"RosPublisherAgent\";\n  description = \"Publishes messages to ROS topics.\";\n  version = \"0.1.0\";\n  domain = AgentDomains.INTEGRATION;\n  capabilities = [\"publish\"];\n\n  private rosService: RosService;\n\n  constructor() {\n    this.rosService = new RosService(import.meta.env.VITE_ROS_BRIDGE_URL || \"ws://localhost:9090\");\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { intent, parameters } = props;\n\n    if (intent !== \"publish\") {\n      return { success: false, output: null, error: `Unknown intent: ${intent}` };\n    }\n\n    const { topicName, messageType, messageContent } = parameters;\n\n    if (!topicName || !messageType || !messageContent) {\n      return { success: false, output: null, error: \"Missing required parameters: topicName, messageType, messageContent.\" };\n    }\n\n    try {\n      await this.rosService.ensureConnection();\n      const message = JSON.parse(messageContent);\n      this.rosService.publish(topicName, messageType, message);\n      return { success: true, output: `Message published to ${topicName}.` };\n    } catch (error: any) {\n      return { success: false, output: null, error: `Failed to publish ROS message: ${error.message}` };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\SchedulerAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":86,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":86,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2364,2367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2364,2367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'participants' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":87,"column":48,"nodeType":null,"messageId":"unusedVar","endLine":87,"endColumn":60},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3116,3119],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3116,3119],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'purpose' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":118,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":118,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":170,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":170,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4668,4671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4668,4671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":181,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":181,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4909,4912],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4909,4912],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5039,5042],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5039,5042],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":215,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":215,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5884,5887],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5884,5887],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'preferences' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":216,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":216,"endColumn":37},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":218,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":218,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6000,6003],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6000,6003],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":221,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":221,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6095,6098],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6095,6098],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":263,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":263,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7421,7424],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7421,7424],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":266,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":266,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7571,7574],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7571,7574],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":296,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":296,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8457,8460],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8457,8460],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'preferences' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":297,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":297,"endColumn":65},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":413,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":413,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11587,11590],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11587,11590],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":413,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":413,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11600,11603],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11600,11603],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":430,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":430,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12296,12299],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12296,12299],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":430,"column":51,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":430,"endColumn":54,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12304,12307],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12304,12307],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":449,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":449,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":449,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":449,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12791,12794],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12791,12794],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SchedulerAgent - Intelligent Scheduling and Availability Management\n * \n * Optimizes scheduling by analyzing availability and suggesting optimal time slots\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\n\ninterface TimeSlot {\n  start: Date;\n  end: Date;\n  available: boolean;\n  score: number; // 0-100 optimization score\n}\n\ninterface ScheduleSuggestion {\n  timeSlot: TimeSlot;\n  reason: string;\n  confidence: number;\n  alternatives: TimeSlot[];\n}\n\nexport class SchedulerAgent implements BaseAgent {\n  name = 'SchedulerAgent';\n  description = 'Optimizes scheduling with availability analysis and smart time slot suggestions';\n  version = '1.0.0';\n  domain: AgentDomain = AgentDomains.PRODUCTIVITY;\n  capabilities = [\n    'availability_analysis',\n    'time_optimization',\n    'meeting_scheduling',\n    'conflict_detection',\n    'smart_suggestions',\n    'calendar_integration'\n  ];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { intent, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'find_availability':\n          return await this.findAvailability(parameters);\n        \n        case 'suggest_time':\n          return await this.suggestTime(parameters);\n        \n        case 'detect_conflicts':\n          return await this.detectConflicts(parameters);\n        \n        case 'optimize_schedule':\n          return await this.optimizeSchedule(parameters);\n        \n        case 'analyze_workload':\n          return await this.analyzeWorkload(parameters);\n        \n        case 'schedule_meeting':\n          return await this.scheduleMeeting(parameters);\n        \n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  private async findAvailability(params: any): Promise<AgentExecuteResult> {\n    const { startDate, endDate, duration = 60, participants = [] } = params;\n\n    if (!startDate || !endDate) {\n      return {\n        success: false,\n        output: null,\n        error: 'Start and end dates are required'\n      };\n    }\n\n    const slots: TimeSlot[] = this.generateTimeSlots(\n      new Date(startDate),\n      new Date(endDate),\n      duration\n    );\n\n    return {\n      success: true,\n      output: {\n        availableSlots: slots.filter(s => s.available),\n        totalSlots: slots.length,\n        bestSlot: slots.sort((a, b) => b.score - a.score)[0]\n      },\n      metadata: {\n        source: 'SchedulerAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async suggestTime(params: any): Promise<AgentExecuteResult> {\n    const { purpose, duration = 60, preferredTimeOfDay, urgency = 'normal' } = params;\n\n    const now = new Date();\n    const suggestions: ScheduleSuggestion[] = [];\n\n    // Generate suggestions based on preferences\n    if (preferredTimeOfDay === 'morning') {\n      suggestions.push(this.createSuggestion(\n        new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 9, 0),\n        duration,\n        'Optimal morning time for focused work',\n        0.9\n      ));\n    } else if (preferredTimeOfDay === 'afternoon') {\n      suggestions.push(this.createSuggestion(\n        new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 14, 0),\n        duration,\n        'Good afternoon slot after lunch',\n        0.85\n      ));\n    } else {\n      // Default suggestions\n      suggestions.push(\n        this.createSuggestion(\n          new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 10, 0),\n          duration,\n          'Mid-morning - high productivity time',\n          0.9\n        ),\n        this.createSuggestion(\n          new Date(now.getFullYear(), now.getMonth(), now.getDate() + 1, 14, 30),\n          duration,\n          'Early afternoon - good for collaboration',\n          0.8\n        )\n      );\n    }\n\n    return {\n      success: true,\n      output: {\n        suggestions,\n        primarySuggestion: suggestions[0],\n        urgency\n      },\n      metadata: {\n        source: 'SchedulerAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async detectConflicts(params: any): Promise<AgentExecuteResult> {\n    const { events = [], newEvent } = params;\n\n    if (!newEvent) {\n      return {\n        success: false,\n        output: null,\n        error: 'New event is required'\n      };\n    }\n\n    const conflicts: any[] = [];\n    const newStart = new Date(newEvent.start);\n    const newEnd = new Date(newEvent.end);\n\n    events.forEach((event: any) => {\n      const eventStart = new Date(event.start);\n      const eventEnd = new Date(event.end);\n\n      if (this.hasTimeOverlap(newStart, newEnd, eventStart, eventEnd)) {\n        conflicts.push({\n          event,\n          overlapDuration: this.calculateOverlap(newStart, newEnd, eventStart, eventEnd),\n          severity: this.calculateConflictSeverity(newEvent, event)\n        });\n      }\n    });\n\n    return {\n      success: true,\n      output: {\n        hasConflicts: conflicts.length > 0,\n        conflicts,\n        conflictCount: conflicts.length,\n        resolution: conflicts.length > 0 \n          ? 'Reschedule one of the conflicting events' \n          : 'No conflicts detected'\n      },\n      metadata: {\n        source: 'SchedulerAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async optimizeSchedule(params: any): Promise<AgentExecuteResult> {\n    const { events = [], preferences = {} } = params;\n\n    const optimizations: any[] = [];\n\n    // Analyze schedule for optimization opportunities\n    events.forEach((event: any, index: number) => {\n      // Check for back-to-back meetings\n      if (index > 0) {\n        const prevEvent = events[index - 1];\n        const timeBetween = new Date(event.start).getTime() - new Date(prevEvent.end).getTime();\n        \n        if (timeBetween < 15 * 60 * 1000) { // Less than 15 minutes\n          optimizations.push({\n            type: 'add_buffer',\n            event,\n            suggestion: 'Add 15-minute buffer between meetings',\n            impact: 'Reduces fatigue and allows for transitions'\n          });\n        }\n      }\n\n      // Check for long meetings\n      const duration = new Date(event.end).getTime() - new Date(event.start).getTime();\n      if (duration > 90 * 60 * 1000) { // More than 90 minutes\n        optimizations.push({\n          type: 'split_meeting',\n          event,\n          suggestion: 'Consider splitting into multiple sessions',\n          impact: 'Maintains attention and productivity'\n        });\n      }\n    });\n\n    return {\n      success: true,\n      output: {\n        optimizations,\n        optimizationScore: Math.max(0, 100 - (optimizations.length * 10)),\n        suggestions: optimizations.map(o => o.suggestion)\n      },\n      metadata: {\n        source: 'SchedulerAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async analyzeWorkload(params: any): Promise<AgentExecuteResult> {\n    const { events = [], period = 'week' } = params;\n\n    const totalMinutes = events.reduce((sum: number, event: any) => {\n      const duration = new Date(event.end).getTime() - new Date(event.start).getTime();\n      return sum + (duration / 60000);\n    }, 0);\n\n    const hours = totalMinutes / 60;\n    const avgPerDay = period === 'week' ? hours / 5 : hours / 30;\n\n    let status: 'light' | 'moderate' | 'heavy' | 'overloaded';\n    if (avgPerDay < 4) status = 'light';\n    else if (avgPerDay < 6) status = 'moderate';\n    else if (avgPerDay < 8) status = 'heavy';\n    else status = 'overloaded';\n\n    return {\n      success: true,\n      output: {\n        totalHours: hours,\n        averagePerDay: avgPerDay,\n        status,\n        recommendation: this.getWorkloadRecommendation(status),\n        distribution: this.analyzeTimeDistribution(events)\n      },\n      metadata: {\n        source: 'SchedulerAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async scheduleMeeting(params: any): Promise<AgentExecuteResult> {\n    const { title, duration = 60, participants = [], preferences = {} } = params;\n\n    if (!title) {\n      return {\n        success: false,\n        output: null,\n        error: 'Meeting title is required'\n      };\n    }\n\n    // Find best time slot\n    const availabilityResult = await this.findAvailability({\n      startDate: new Date(),\n      endDate: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // Next 7 days\n      duration,\n      participants\n    });\n\n    if (!availabilityResult.success) {\n      return availabilityResult;\n    }\n\n    const bestSlot = availabilityResult.output.bestSlot;\n\n    return {\n      success: true,\n      output: {\n        meeting: {\n          title,\n          start: bestSlot.start,\n          end: bestSlot.end,\n          duration,\n          participants\n        },\n        alternatives: availabilityResult.output.availableSlots.slice(0, 3),\n        confidence: bestSlot.score / 100\n      },\n      metadata: {\n        source: 'SchedulerAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  // Helper methods\n\n  private generateTimeSlots(start: Date, end: Date, duration: number): TimeSlot[] {\n    const slots: TimeSlot[] = [];\n    const current = new Date(start);\n\n    while (current < end) {\n      const slotEnd = new Date(current.getTime() + duration * 60000);\n      \n      slots.push({\n        start: new Date(current),\n        end: slotEnd,\n        available: this.isWorkingHours(current),\n        score: this.calculateSlotScore(current)\n      });\n\n      current.setMinutes(current.getMinutes() + 30); // 30-minute intervals\n    }\n\n    return slots;\n  }\n\n  private isWorkingHours(date: Date): boolean {\n    const hour = date.getHours();\n    const day = date.getDay();\n    \n    // Monday to Friday, 9 AM to 6 PM\n    return day >= 1 && day <= 5 && hour >= 9 && hour < 18;\n  }\n\n  private calculateSlotScore(date: Date): number {\n    let score = 50;\n\n    // Prefer morning slots\n    const hour = date.getHours();\n    if (hour >= 9 && hour < 12) score += 30;\n    else if (hour >= 14 && hour < 16) score += 20;\n    else if (hour >= 16 && hour < 18) score += 10;\n\n    // Prefer mid-week\n    const day = date.getDay();\n    if (day >= 2 && day <= 4) score += 20;\n\n    return Math.min(score, 100);\n  }\n\n  private createSuggestion(start: Date, duration: number, reason: string, confidence: number): ScheduleSuggestion {\n    const end = new Date(start.getTime() + duration * 60000);\n    \n    return {\n      timeSlot: {\n        start,\n        end,\n        available: true,\n        score: confidence * 100\n      },\n      reason,\n      confidence,\n      alternatives: []\n    };\n  }\n\n  private hasTimeOverlap(start1: Date, end1: Date, start2: Date, end2: Date): boolean {\n    return start1 < end2 && end1 > start2;\n  }\n\n  private calculateOverlap(start1: Date, end1: Date, start2: Date, end2: Date): number {\n    const overlapStart = Math.max(start1.getTime(), start2.getTime());\n    const overlapEnd = Math.min(end1.getTime(), end2.getTime());\n    return Math.max(0, overlapEnd - overlapStart) / 60000; // in minutes\n  }\n\n  private calculateConflictSeverity(event1: any, event2: any): 'low' | 'medium' | 'high' {\n    // Simple severity calculation\n    if (event1.priority === 'high' || event2.priority === 'high') return 'high';\n    if (event1.priority === 'medium' || event2.priority === 'medium') return 'medium';\n    return 'low';\n  }\n\n  private getWorkloadRecommendation(status: string): string {\n    const recommendations: Record<string, string> = {\n      light: 'You have capacity for additional tasks',\n      moderate: 'Well-balanced schedule',\n      heavy: 'Consider delegating or rescheduling some tasks',\n      overloaded: 'Urgent: Reduce commitments to avoid burnout'\n    };\n    return recommendations[status] || '';\n  }\n\n  private analyzeTimeDistribution(events: any[]): any {\n    const categories: Record<string, number> = {\n      meetings: 0,\n      focus: 0,\n      breaks: 0,\n      other: 0\n    };\n\n    events.forEach(event => {\n      const duration = new Date(event.end).getTime() - new Date(event.start).getTime();\n      const hours = duration / 3600000;\n      \n      const category = event.type || 'other';\n      categories[category] = (categories[category] || 0) + hours;\n    });\n\n    return categories;\n  }\n\n  async canHandle(query: string, context?: any): Promise<number> {\n    const keywords = [\n      'schedule', 'meeting', 'calendar', 'appointment', 'availability',\n      'time', 'slot', 'book', 'reserve', 'plan', 'organize',\n      'planifier', 'rendez-vous', 'disponibilit├®', 'r├®union', 'horaire'\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    const matches = keywords.filter(keyword => lowerQuery.includes(keyword));\n    \n    return matches.length > 0 ? Math.min(matches.length * 0.3, 1.0) : 0.0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\ScreenShareAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2214,2217],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2214,2217],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":76,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":76,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2228,2231],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2228,2231],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":106,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":109,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3057,3060],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3057,3060],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":138,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":138,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4579,4582],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4579,4582],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5186,5189],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5186,5189],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":83,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":86,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6865,6868],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6865,6868],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":217,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":217,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7153,7156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7153,7156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":265,"column":82,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":265,"endColumn":85,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8581,8584],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8581,8584],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":288,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":288,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9069,9072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9069,9072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10069,10072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10069,10072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":343,"column":100,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":343,"endColumn":103,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11047,11050],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11047,11050],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":356,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":356,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11307,11310],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11307,11310],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":12,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { agentRegistry } from './registry';\nimport { AgentDomains } from './types';\nimport type { AgentParameter, BaseAgent } from './types';\nimport { createLogger } from '../utils/logger';\n\n/**\n * Interface pour les options de partage d'├®cran\n */\ninterface ScreenShareOptions {\n  audio?: boolean;\n  video?: boolean;\n  displaySurface?: 'browser' | 'window' | 'monitor';\n  selfBrowserSurface?: 'include' | 'exclude';\n  systemAudio?: 'include' | 'exclude';\n}\n\n/**\n * ├ëtat de la session de partage d'├®cran\n */\ninterface ScreenShareState {\n  isActive: boolean;\n  stream: MediaStream | null;\n  startTime: number | null;\n  options: ScreenShareOptions | null;\n  sessionId: string | null;\n  error: string | null;\n}\n\n/**\n * ScreenShareAgent - Agent pour g├®rer le partage d'├®cran\n * \n * Cet agent permet de:\n * - D├®marrer une session de partage d'├®cran\n * - Arr├¬ter une session de partage d'├®cran\n * - V├®rifier l'├®tat du partage d'├®cran\n * - Modifier les options de partage en cours de session\n */\nexport class ScreenShareAgent implements BaseAgent {\n  name = 'ScreenShareAgent';\n  description = 'Agent pour g├®rer le partage d\\'├®cran';\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = ['screen-sharing', 'window-sharing', 'monitor-sharing', 'audio-sharing'];\n\n  private state: ScreenShareState = {\n    isActive: false,\n    stream: null,\n    startTime: null,\n    options: null,\n    sessionId: null,\n    error: null\n  };\n  private logger = createLogger('ScreenShareAgent');\n\n  /**\n   * V├®rifie si l'agent peut traiter la requ├¬te\n   * @param query Requ├¬te utilisateur\n   * @returns Score de confiance entre 0 et 1\n   */\n  async canHandle(query: string): Promise<number> {\n    const screenShareKeywords = [\n      'partage d\\'├®cran', 'partager ├®cran', 'partage ├®cran', 'screen share', \n      'partager mon ├®cran', 'voir mon ├®cran', 'afficher mon ├®cran',\n      'screen sharing', 'partage de fen├¬tre', 'partager fen├¬tre',\n      'capturer ├®cran', 'capture d\\'├®cran'\n    ];\n    \n    return this.calculateKeywordMatch(query, screenShareKeywords);\n  }\n\n  /**\n   * Ex├®cute une action de partage d'├®cran\n   * @param params Param├¿tres de l'action\n   * @returns R├®sultat de l'action\n   */\n  async execute(params: any): Promise<any> {\n    const { action, ...actionParams } = params;\n    \n    try {\n      switch (action) {\n        case 'startScreenShare':\n          return await this.startScreenShare(actionParams);\n        case 'stopScreenShare':\n          return await this.stopScreenShare();\n        case 'getScreenShareState':\n          return this.getScreenShareState();\n        case 'updateScreenShareOptions':\n          return await this.updateScreenShareOptions(actionParams);\n        case 'checkCapabilities':\n          return this.checkCapabilities();\n        default:\n          throw new Error(`Action inconnue: ${action}`);\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Erreur inconnue';\n      this.logger.error(`Erreur lors de l'ex├®cution de l'action de partage d'├®cran ${action}:`, error as any);\n      \n      this.state.error = errorMessage;\n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Retourne les param├¿tres requis pour une t├óche donn├®e\n   * @param task Description de la t├óche\n   * @returns Liste des param├¿tres requis\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    if (task.includes('partage') && task.includes('├®cran') && \n       (task.includes('commencer') || task.includes('d├®marrer') || task.includes('lancer'))) {\n      return [\n        { name: 'action', type: 'string', required: true, description: 'Action (startScreenShare)' },\n        { name: 'audio', type: 'boolean', description: 'Inclure l\\'audio?', required: false },\n        { name: 'displaySurface', type: 'string', description: 'Type de surface (browser, window, monitor)', required: false }\n      ];\n    }\n    \n    if (task.includes('partage') && task.includes('├®cran') && \n       (task.includes('arr├¬ter') || task.includes('stopper') || task.includes('terminer'))) {\n      return [\n        { name: 'action', type: 'string', required: true, description: 'Action (stopScreenShare)' }\n      ];\n    }\n    \n    return [\n      { name: 'action', type: 'string', description: 'Action de partage d\\'├®cran ├á ex├®cuter', required: true }\n    ];\n  }\n\n  /**\n   * D├®marre une session de partage d'├®cran\n   * @param options Options de partage d'├®cran\n   * @returns ├ëtat de la session\n   */\n  private async startScreenShare(options: ScreenShareOptions = {}): Promise<any> {\n    // V├®rifier si un partage est d├®j├á actif\n    if (this.state.isActive && this.state.stream) {\n      return {\n        success: false,\n        error: 'Une session de partage d\\'├®cran est d├®j├á active',\n        state: this.getScreenShareState()\n      };\n    }\n\n    try {\n      // V├®rifier si l'API getDisplayMedia est disponible\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {\n        throw new Error('L\\'API de partage d\\'├®cran n\\'est pas disponible dans ce navigateur');\n      }\n\n      // Configuration des options de partage d'├®cran\n      const displayMediaOptions: any = {\n        video: {\n          cursor: \"always\",\n          displaySurface: options.displaySurface || 'monitor'\n        },\n        audio: options.audio === true ? {\n          echoCancellation: true,\n          noiseSuppression: true,\n          sampleRate: 44100\n        } : false,\n        selfBrowserSurface: options.selfBrowserSurface || 'exclude',\n        systemAudio: options.systemAudio || 'exclude'\n      };\n\n      // Demander ├á l'utilisateur de partager son ├®cran\n      const stream = await navigator.mediaDevices.getDisplayMedia(displayMediaOptions);\n      \n      // Mettre ├á jour l'├®tat\n      this.state = {\n        isActive: true,\n        stream: stream,\n        startTime: Date.now(),\n        options: options,\n        sessionId: `share-${Date.now()}`,\n        error: null\n      };\n\n      // ├ëcouter l'├®v├®nement de fin de partage (quand l'utilisateur arr├¬te manuellement)\n      stream.getVideoTracks()[0].addEventListener('ended', () => {\n        this.logger.info('Utilisateur a arr├¬t├® le partage d\\'├®cran');\n        this.stopScreenShare();\n      });\n\n      this.logger.info('Session de partage d\\'├®cran d├®marr├®e avec succ├¿s');\n      \n      return {\n        success: true,\n        message: 'Session de partage d\\'├®cran d├®marr├®e avec succ├¿s',\n        state: this.getScreenShareState(),\n        streamId: this.state.sessionId\n      };\n    } catch (error) {\n      // L'utilisateur a probablement annul├® le partage d'├®cran ou une erreur est survenue\n      const errorMessage = error instanceof Error \n        ? error.message \n        : 'Impossible de d├®marrer le partage d\\'├®cran';\n      \n      this.logger.error('Erreur lors du d├®marrage du partage d\\'├®cran:', error as any);\n      \n      this.state.error = errorMessage;\n      \n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Arr├¬te la session de partage d'├®cran active\n   * @returns R├®sultat de l'op├®ration\n   */\n  private async stopScreenShare(): Promise<any> {\n    if (!this.state.isActive || !this.state.stream) {\n      return {\n        success: false,\n        error: 'Aucune session de partage d\\'├®cran active',\n      };\n    }\n\n    try {\n      // Arr├¬ter toutes les pistes du stream\n      this.state.stream.getTracks().forEach(track => {\n        track.stop();\n      });\n\n      // Calculer la dur├®e de la session\n      const duration = this.state.startTime ? Math.floor((Date.now() - this.state.startTime) / 1000) : 0;\n      \n      // Enregistrer les infos de la session termin├®e\n      const sessionSummary = {\n        sessionId: this.state.sessionId,\n        duration: duration, // dur├®e en secondes\n        startTime: this.state.startTime,\n        endTime: Date.now(),\n        options: this.state.options\n      };\n\n      // R├®initialiser l'├®tat\n      this.state = {\n        isActive: false,\n        stream: null,\n        startTime: null,\n        options: null,\n        sessionId: null,\n        error: null\n      };\n\n      this.logger.info('Session de partage d\\'├®cran arr├¬t├®e avec succ├¿s');\n      \n      return {\n        success: true,\n        message: 'Session de partage d\\'├®cran arr├¬t├®e avec succ├¿s',\n        sessionSummary\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error \n        ? error.message \n        : 'Erreur lors de l\\'arr├¬t du partage d\\'├®cran';\n      \n      this.logger.error('Erreur lors de l\\'arr├¬t du partage d\\'├®cran:', error as any);\n      \n      // M├¬me en cas d'erreur, on tente de r├®initialiser l'├®tat\n      this.state = {\n        isActive: false,\n        stream: null,\n        startTime: null,\n        options: null,\n        sessionId: null,\n        error: errorMessage\n      };\n      \n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * Retourne l'├®tat actuel de la session de partage d'├®cran\n   * @returns ├ëtat de la session\n   */\n  private getScreenShareState(): any {\n    // Cr├®er un objet d'├®tat sans la r├®f├®rence stream qui n'est pas s├®rialisable\n    const safeState = {\n      isActive: this.state.isActive,\n      startTime: this.state.startTime,\n      options: this.state.options,\n      sessionId: this.state.sessionId,\n      error: this.state.error,\n      duration: this.state.startTime ? Math.floor((Date.now() - this.state.startTime) / 1000) : 0,\n      trackInfo: this.state.stream ? {\n        videoTracks: this.state.stream.getVideoTracks().length,\n        audioTracks: this.state.stream.getAudioTracks().length,\n        videoEnabled: this.state.stream.getVideoTracks().length > 0 ? \n                     this.state.stream.getVideoTracks()[0].enabled : false\n      } : null\n    };\n    \n    return safeState;\n  }\n\n  /**\n   * Met ├á jour les options de la session de partage active\n   * @param options Nouvelles options\n   * @returns ├ëtat mis ├á jour de la session\n   */\n  private async updateScreenShareOptions(options: Partial<ScreenShareOptions>): Promise<any> {\n    if (!this.state.isActive || !this.state.stream) {\n      return {\n        success: false,\n        error: 'Aucune session de partage d\\'├®cran active'\n      };\n    }\n\n    try {\n      // Mettre ├á jour les options audio si sp├®cifi├®es\n      if (options.audio !== undefined) {\n        const audioTracks = this.state.stream.getAudioTracks();\n        audioTracks.forEach(track => {\n          track.enabled = options.audio || false;\n        });\n      }\n\n      // Mettre ├á jour les options\n      this.state.options = { ...this.state.options, ...options };\n\n      return {\n        success: true,\n        message: 'Options de partage d\\'├®cran mises ├á jour avec succ├¿s',\n        state: this.getScreenShareState()\n      };\n    } catch (error) {\n      const errorMessage = error instanceof Error \n        ? error.message \n        : 'Erreur lors de la mise ├á jour des options';\n      \n      this.logger.error('Erreur lors de la mise ├á jour des options de partage d\\'├®cran:', error as any);\n      \n      return {\n        success: false,\n        error: errorMessage\n      };\n    }\n  }\n\n  /**\n   * V├®rifie les capacit├®s de partage d'├®cran du navigateur\n   * @returns Informations sur les capacit├®s disponibles\n   */\n  private checkCapabilities(): any {\n    const supported = (navigator.mediaDevices && 'getSupportedConstraints' in navigator.mediaDevices)\n      ? (navigator.mediaDevices.getSupportedConstraints() as Record<string, unknown>)\n      : {};\n    return {\n      screenShareSupported: !!(navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia),\n      browserName: this.getBrowserName(),\n      constraints: {\n        video: 'displaySurface' in supported,\n        audio: 'systemAudio' in supported,\n      }\n    };\n  }\n\n  /**\n   * D├®termine le nom du navigateur\n   * @returns Nom du navigateur\n   */\n  private getBrowserName(): string {\n    const userAgent = navigator.userAgent;\n    \n    if (userAgent.indexOf(\"Firefox\") > -1) return \"Firefox\";\n    else if (userAgent.indexOf(\"Chrome\") > -1) return \"Chrome\";\n    else if (userAgent.indexOf(\"Safari\") > -1) return \"Safari\";\n    else if (userAgent.indexOf(\"Edge\") > -1) return \"Edge\";\n    else if (userAgent.indexOf(\"MSIE\") > -1 || userAgent.indexOf(\"Trident/\") > -1) return \"Internet Explorer\";\n    else return \"Unknown\";\n  }\n\n  /**\n   * Calcule le score de correspondance entre une requ├¬te et des mots-cl├®s\n   * @param query Requ├¬te utilisateur\n   * @param keywords Liste de mots-cl├®s\n   * @returns Score de correspondance (0-1)\n   */\n  private calculateKeywordMatch(query: string, keywords: string[]): number {\n    const words = query.toLowerCase().split(' ');\n    const matches = keywords.filter(kw => {\n      // G├®rer les mots-cl├®s compos├®s (ex: \"partage d'├®cran\")\n      const kwParts = kw.toLowerCase().split(' ');\n      if (kwParts.length === 1) {\n        return words.some(w => w.includes(kw.toLowerCase()));\n      } else {\n        // Pour les expressions, v├®rifier si la requ├¬te contient toutes les parties\n        return kwParts.every(part => words.some(w => w.includes(part)));\n      }\n    });\n    \n    return Math.min(matches.length / 2, 1); // Score normalis├® entre 0 et 1\n  }\n}\n\n// Enregistrer l'agent dans le registre global\nconst screenShareAgent = new ScreenShareAgent();\nagentRegistry.register(screenShareAgent);\n\nexport default screenShareAgent;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\SecurityAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":44,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":44,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used. Allowed unused args must match /^_/u.","line":96,"column":30,"nodeType":null,"messageId":"unusedVar","endLine":96,"endColumn":36},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2593,2596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2593,2596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5023,5026],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5023,5026],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":174,"column":13,"nodeType":null,"messageId":"unusedVar","endLine":174,"endColumn":20},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":216,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":216,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6198,6201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6198,6201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":217,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":217,"endColumn":28},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used. Allowed unused args must match /^_/u.","line":250,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":250,"endColumn":42},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6990,6993],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6990,6993],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":306,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":306,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8694,8697],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8694,8697],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":347,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":347,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10206,10209],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10206,10209],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used. Allowed unused args must match /^_/u.","line":371,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":371,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":371,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":371,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10824,10827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10824,10827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":402,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":402,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11756,11759],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11756,11759],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":407,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":407,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11910,11913],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11910,11913],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threat' is defined but never used. Allowed unused args must match /^_/u.","line":417,"column":28,"nodeType":null,"messageId":"unusedVar","endLine":417,"endColumn":34},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12254,12257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12254,12257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'threat' is defined but never used. Allowed unused args must match /^_/u.","line":421,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":421,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":421,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":421,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12382,12385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12382,12385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":457,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":457,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":457,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":457,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13545,13548],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13545,13548],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SecurityAgent - Security Monitoring and Risk Detection\n * \n * Monitors security risks, detects threats, and provides security recommendations\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\n\ninterface SecurityRisk {\n  level: 'low' | 'medium' | 'high' | 'critical';\n  type: string;\n  description: string;\n  recommendation: string;\n  timestamp: number;\n}\n\ninterface SecurityScan {\n  passed: number;\n  failed: number;\n  warnings: number;\n  risks: SecurityRisk[];\n  score: number; // 0-100\n}\n\nexport class SecurityAgent implements BaseAgent {\n  name = 'SecurityAgent';\n  description = 'Monitors security, detects risks, and provides security recommendations';\n  version = '1.0.0';\n  domain: AgentDomain = AgentDomains.ANALYSIS;\n  capabilities = [\n    'risk_detection',\n    'security_scanning',\n    'threat_analysis',\n    'security_recommendations',\n    'vulnerability_assessment',\n    'compliance_checking'\n  ];\n\n  private securityLogs: SecurityRisk[] = [];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { intent, context, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'scan_security':\n          return await this.scanSecurity(parameters);\n        \n        case 'detect_risks':\n          return await this.detectRisks(parameters);\n        \n        case 'analyze_threat':\n          return await this.analyzeThreat(parameters);\n        \n        case 'get_recommendations':\n          return await this.getRecommendations(parameters);\n        \n        case 'check_compliance':\n          return await this.checkCompliance(parameters);\n        \n        case 'get_security_score':\n          return await this.getSecurityScore(parameters);\n        \n        case 'audit_permissions':\n          return await this.auditPermissions(parameters);\n        \n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Perform comprehensive security scan\n   */\n  private async scanSecurity(params: any): Promise<AgentExecuteResult> {\n    const risks: SecurityRisk[] = [];\n\n    // Check HTTPS\n    if (window.location.protocol !== 'https:' && window.location.hostname !== 'localhost') {\n      risks.push({\n        level: 'high',\n        type: 'insecure_connection',\n        description: 'Application is not running on HTTPS',\n        recommendation: 'Enable HTTPS to secure communications',\n        timestamp: Date.now()\n      });\n    }\n\n    // Check for sensitive data in localStorage\n    const sensitiveKeys = ['password', 'secret', 'apikey', 'token'];\n    Object.keys(localStorage).forEach(key => {\n      if (sensitiveKeys.some(sensitive => key.toLowerCase().includes(sensitive))) {\n        risks.push({\n          level: 'medium',\n          type: 'sensitive_data_storage',\n          description: `Potential sensitive data in localStorage: ${key}`,\n          recommendation: 'Use secure storage mechanisms for sensitive data',\n          timestamp: Date.now()\n        });\n      }\n    });\n\n    // Check for CSP headers\n    const cspMeta = document.querySelector('meta[http-equiv=\"Content-Security-Policy\"]');\n    if (!cspMeta) {\n      risks.push({\n        level: 'medium',\n        type: 'missing_csp',\n        description: 'No Content Security Policy detected',\n        recommendation: 'Implement CSP headers to prevent XSS attacks',\n        timestamp: Date.now()\n      });\n    }\n\n    // Check for session timeout\n    const sessionTimeout = sessionStorage.getItem('session_timeout');\n    if (!sessionTimeout) {\n      risks.push({\n        level: 'low',\n        type: 'no_session_timeout',\n        description: 'No session timeout configured',\n        recommendation: 'Implement session timeout for inactive users',\n        timestamp: Date.now()\n      });\n    }\n\n    // Store risks in log\n    this.securityLogs.push(...risks);\n\n    const scanResult: SecurityScan = {\n      passed: Math.max(0, 10 - risks.length),\n      failed: risks.filter(r => r.level === 'critical' || r.level === 'high').length,\n      warnings: risks.filter(r => r.level === 'medium' || r.level === 'low').length,\n      risks,\n      score: Math.max(0, 100 - (risks.length * 15))\n    };\n\n    return {\n      success: true,\n      output: scanResult,\n      metadata: {\n        source: 'SecurityAgent',\n        timestamp: Date.now(),\n        confidence: 0.95\n      }\n    };\n  }\n\n  /**\n   * Detect security risks in real-time\n   */\n  private async detectRisks(params: any): Promise<AgentExecuteResult> {\n    const { context } = params;\n    const risks: SecurityRisk[] = [];\n\n    // Check for suspicious activities\n    const recentLogs = this.securityLogs.filter(\n      log => Date.now() - log.timestamp < 3600000 // Last hour\n    );\n\n    // Check for repeated failed attempts\n    const failedAttempts = recentLogs.filter(\n      log => log.type.includes('failed_attempt')\n    );\n\n    if (failedAttempts.length > 5) {\n      risks.push({\n        level: 'high',\n        type: 'suspicious_activity',\n        description: `Multiple failed attempts detected: ${failedAttempts.length}`,\n        recommendation: 'Review logs and consider implementing rate limiting',\n        timestamp: Date.now()\n      });\n    }\n\n    return {\n      success: true,\n      output: {\n        risksDetected: risks.length,\n        risks,\n        summary: risks.length === 0 \n          ? 'No immediate security risks detected' \n          : `${risks.length} security risk(s) detected`\n      },\n      metadata: {\n        source: 'SecurityAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Analyze a specific threat\n   */\n  private async analyzeThreat(params: any): Promise<AgentExecuteResult> {\n    const { threat, context } = params;\n\n    if (!threat) {\n      return {\n        success: false,\n        output: null,\n        error: 'No threat data provided'\n      };\n    }\n\n    // Analyze threat severity\n    const analysis = {\n      threatType: threat.type || 'unknown',\n      severity: this.calculateSeverity(threat),\n      impact: this.assessImpact(threat),\n      likelihood: this.assessLikelihood(threat),\n      recommendations: this.generateRecommendations(threat)\n    };\n\n    return {\n      success: true,\n      output: analysis,\n      metadata: {\n        source: 'SecurityAgent',\n        timestamp: Date.now(),\n        confidence: 0.85\n      }\n    };\n  }\n\n  /**\n   * Get security recommendations\n   */\n  private async getRecommendations(params: any): Promise<AgentExecuteResult> {\n    const recommendations = [\n      {\n        priority: 'high',\n        category: 'authentication',\n        title: 'Enable Two-Factor Authentication',\n        description: 'Add an extra layer of security to user accounts',\n        impact: 'Significantly reduces unauthorized access risk'\n      },\n      {\n        priority: 'high',\n        category: 'encryption',\n        title: 'Encrypt Sensitive Data',\n        description: 'Encrypt sensitive data at rest and in transit',\n        impact: 'Protects data from unauthorized access'\n      },\n      {\n        priority: 'medium',\n        category: 'monitoring',\n        title: 'Enable Security Monitoring',\n        description: 'Set up real-time security event monitoring',\n        impact: 'Early detection of security incidents'\n      },\n      {\n        priority: 'medium',\n        category: 'updates',\n        title: 'Keep Dependencies Updated',\n        description: 'Regularly update all software dependencies',\n        impact: 'Reduces vulnerability exposure'\n      },\n      {\n        priority: 'low',\n        category: 'training',\n        title: 'Security Awareness Training',\n        description: 'Train users on security best practices',\n        impact: 'Reduces human error risks'\n      }\n    ];\n\n    return {\n      success: true,\n      output: {\n        recommendations,\n        totalRecommendations: recommendations.length,\n        highPriority: recommendations.filter(r => r.priority === 'high').length\n      },\n      metadata: {\n        source: 'SecurityAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Check compliance with security standards\n   */\n  private async checkCompliance(params: any): Promise<AgentExecuteResult> {\n    const { standard = 'OWASP' } = params;\n\n    const complianceChecks = {\n      OWASP: [\n        { check: 'Injection Prevention', passed: true, score: 95 },\n        { check: 'Broken Authentication', passed: false, score: 60 },\n        { check: 'Sensitive Data Exposure', passed: true, score: 85 },\n        { check: 'XML External Entities', passed: true, score: 100 },\n        { check: 'Broken Access Control', passed: true, score: 90 },\n        { check: 'Security Misconfiguration', passed: false, score: 70 },\n        { check: 'Cross-Site Scripting', passed: true, score: 95 },\n        { check: 'Insecure Deserialization', passed: true, score: 100 },\n        { check: 'Using Known Vulnerable Components', passed: false, score: 65 },\n        { check: 'Insufficient Logging & Monitoring', passed: true, score: 80 }\n      ]\n    };\n\n    const checks = complianceChecks[standard as keyof typeof complianceChecks] || [];\n    const averageScore = checks.reduce((sum, c) => sum + c.score, 0) / checks.length;\n\n    return {\n      success: true,\n      output: {\n        standard,\n        checks,\n        overallScore: Math.round(averageScore),\n        passed: checks.filter(c => c.passed).length,\n        failed: checks.filter(c => !c.passed).length,\n        compliant: averageScore >= 80\n      },\n      metadata: {\n        source: 'SecurityAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Get overall security score\n   */\n  private async getSecurityScore(params: any): Promise<AgentExecuteResult> {\n    const scanResult = await this.scanSecurity(params);\n    \n    if (!scanResult.success) {\n      return scanResult;\n    }\n\n    return {\n      success: true,\n      output: {\n        score: (scanResult.output as SecurityScan).score,\n        grade: this.getScoreGrade((scanResult.output as SecurityScan).score),\n        summary: this.getScoreSummary((scanResult.output as SecurityScan).score)\n      },\n      metadata: {\n        source: 'SecurityAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  /**\n   * Audit user permissions\n   */\n  private async auditPermissions(params: any): Promise<AgentExecuteResult> {\n    // Check browser permissions\n    const permissions = {\n      camera: await this.checkPermission('camera'),\n      microphone: await this.checkPermission('microphone'),\n      notifications: await this.checkPermission('notifications'),\n      geolocation: await this.checkPermission('geolocation')\n    };\n\n    const grantedCount = Object.values(permissions).filter(p => p === 'granted').length;\n    const deniedCount = Object.values(permissions).filter(p => p === 'denied').length;\n\n    return {\n      success: true,\n      output: {\n        permissions,\n        summary: {\n          granted: grantedCount,\n          denied: deniedCount,\n          prompt: Object.values(permissions).filter(p => p === 'prompt').length\n        }\n      },\n      metadata: {\n        source: 'SecurityAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  // Helper methods\n  \n  private calculateSeverity(threat: any): 'low' | 'medium' | 'high' | 'critical' {\n    // Basic severity calculation\n    return threat.level || 'medium';\n  }\n\n  private assessImpact(threat: any): string {\n    const impacts = {\n      low: 'Minimal impact on operations',\n      medium: 'Moderate impact on operations',\n      high: 'Significant impact on operations',\n      critical: 'Severe impact on operations'\n    };\n    return impacts[threat.level as keyof typeof impacts] || impacts.medium;\n  }\n\n  private assessLikelihood(threat: any): string {\n    return 'Medium likelihood based on current threat landscape';\n  }\n\n  private generateRecommendations(threat: any): string[] {\n    return [\n      'Monitor system logs for unusual activity',\n      'Review and update security policies',\n      'Implement additional access controls if needed'\n    ];\n  }\n\n  private getScoreGrade(score: number): string {\n    if (score >= 90) return 'A';\n    if (score >= 80) return 'B';\n    if (score >= 70) return 'C';\n    if (score >= 60) return 'D';\n    return 'F';\n  }\n\n  private getScoreSummary(score: number): string {\n    if (score >= 90) return 'Excellent security posture';\n    if (score >= 80) return 'Good security with minor improvements needed';\n    if (score >= 70) return 'Adequate security with some concerns';\n    if (score >= 60) return 'Poor security requiring immediate attention';\n    return 'Critical security issues detected';\n  }\n\n  private async checkPermission(name: string): Promise<string> {\n    try {\n      if (!navigator.permissions) return 'unknown';\n      \n      const permissionName = name as PermissionName;\n      const result = await navigator.permissions.query({ name: permissionName });\n      return result.state;\n    } catch {\n      return 'unknown';\n    }\n  }\n\n  async canHandle(query: string, context?: any): Promise<number> {\n    const keywords = [\n      'security', 'secure', 'risk', 'threat', 'vulnerability',\n      'safe', 'protect', 'audit', 'compliance', 'permission',\n      's├®curit├®', 's├╗r', 'risque', 'menace', 'vuln├®rabilit├®',\n      'protection', 'audit'\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    const matches = keywords.filter(keyword => lowerQuery.includes(keyword));\n    \n    return matches.length > 0 ? Math.min(matches.length * 0.3, 1.0) : 0.0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\SmallTalkAgent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\SmartHomeAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[835,838],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[835,838],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1549,1552],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1549,1552],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4751,4754],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4751,4754],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":339,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":339,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9882,9885],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9882,9885],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":385,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":385,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11118,11121],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11118,11121],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":409,"column":75,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":78,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11684,11687],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11684,11687],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":409,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":409,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11698,11701],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11698,11701],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":432,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":432,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12239,12242],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12239,12242],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":439,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":439,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12429,12432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12429,12432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":467,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":467,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13144,13147],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13144,13147],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":485,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":485,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13542,13545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13542,13545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SmartHomeAgent - Controls and manages smart home devices\n * \n * This agent handles interactions with smart home devices and systems,\n * allowing control of lights, heating, and other connected devices.\n */\n\nimport { AgentDomains } from './types';\nimport type { \n  AgentCapability, \n  AgentExecuteProps,\n  AgentExecuteResult, \n  AgentParameter, \n  BaseAgent \n} from './types';\n\n/**\n * Supported device types for smart home control\n */\nexport type SmartDeviceType = 'light' | 'thermostat' | 'speaker' | 'tv' | 'blinds' | 'lock' | 'camera' | 'outlet';\n\n/**\n * Device control actions\n */\nexport type DeviceAction = 'toggle' | 'on' | 'off' | 'increase' | 'decrease' | 'set';\n\n/**\n * Smart home scene definition\n */\nexport interface SmartHomeScene {\n  id: string;\n  name: string;\n  description: string;\n  deviceStates: Record<string, any>;\n}\n\n/**\n * Supported intents for SmartHomeAgent\n */\nexport type SmartHomeIntent = \n  | 'toggle_device'\n  | 'get_device_status'\n  | 'set_device_value'\n  | 'run_scene'\n  | 'list_devices'\n  | 'list_scenes';\n\n/**\n * Agent for controlling and managing smart home devices\n */\nexport class SmartHomeAgent implements BaseAgent {\n  name = 'SmartHomeAgent';\n  description = 'Contr├┤le les appareils connect├®s et g├¿re les sc├®narios domotiques';\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = [\n    'device_control',\n    'scene_management',\n    'status_monitoring',\n    'device_discovery'\n  ];\n\n  // Mock data for demo purposes\n  private devices: Record<string, {type: SmartDeviceType, status: any}> = {\n    'salon_lumiere': { type: 'light', status: { on: false, brightness: 80, color: 'warm' } },\n    'salon_thermostat': { type: 'thermostat', status: { on: true, temperature: 21, mode: 'heat' } },\n    'cuisine_lumiere': { type: 'light', status: { on: true, brightness: 100, color: 'cool' } },\n    'chambre_lumiere': { type: 'light', status: { on: false, brightness: 50, color: 'warm' } },\n    'entree_lock': { type: 'lock', status: { locked: true } }\n  };\n\n  private scenes: SmartHomeScene[] = [\n    {\n      id: 'film',\n      name: 'Mode Film',\n      description: 'Configure les lumi├¿res et le thermostat pour regarder un film',\n      deviceStates: {\n        'salon_lumiere': { on: true, brightness: 30, color: 'warm' },\n        'salon_thermostat': { on: true, temperature: 22, mode: 'heat' }\n      }\n    },\n    {\n      id: 'nuit',\n      name: 'Mode Nuit',\n      description: '├ëteint les lumi├¿res principales et laisse des veilleuses',\n      deviceStates: {\n        'salon_lumiere': { on: false },\n        'cuisine_lumiere': { on: false },\n        'chambre_lumiere': { on: true, brightness: 10, color: 'warm' },\n        'entree_lock': { locked: true }\n      }\n    }\n  ];\n\n  /**\n   * Main execution method for the agent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as SmartHomeIntent;\n    const parameters = props.parameters || {};\n\n    try {\n      let result;\n      switch (intent) {\n        case 'toggle_device':\n          result = await this.toggleDevice(\n            parameters.deviceId,\n            parameters.action || 'toggle'\n          );\n          break;\n        case 'get_device_status':\n          result = await this.getDeviceStatus(parameters.deviceId);\n          break;\n        case 'set_device_value':\n          result = await this.setDeviceValue(\n            parameters.deviceId, \n            parameters.property, \n            parameters.value\n          );\n          break;\n        case 'run_scene':\n          result = await this.activateScene(parameters.sceneId);\n          break;\n        case 'list_devices':\n          result = await this.listDevices(parameters.type);\n          break;\n        case 'list_scenes':\n          result = await this.listScenes();\n          break;\n        default:\n          return {\n            success: false,\n            output: `Intent non support├®: ${intent}`,\n            error: new Error('UNSUPPORTED_INTENT'),\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error : new Error(String(error)),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Determines if this agent can handle a specific query\n   */\n  async canHandle(query: string, _context?: any): Promise<number> {\n    const normalizedQuery = query.toLowerCase();\n    \n    // Keywords related to smart home control\n    const deviceKeywords = ['lumi├¿re', 'lumiere', 'thermostat', 'chauffage', 'temp├®rature', \n      'porte', 'serrure', 'volet', 't├®l├®', 't├®l├®vision', 'tv', 'prise'];\n    \n    const actionKeywords = ['allumer', '├®teindre', 'augmenter', 'diminuer', 'ouvrir', 'fermer',\n      'verrouiller', 'd├®verrouiller', 'r├®gler', 'mettre', 'activer', 'configurer'];\n    \n    const sceneKeywords = ['mode', 'sc├¿ne', 'scene', 'ambiance', 'sc├®nario'];\n    \n    // Check for device keywords\n    const hasDeviceKeyword = deviceKeywords.some(keyword => \n      normalizedQuery.includes(keyword));\n    \n    // Check for action keywords\n    const hasActionKeyword = actionKeywords.some(keyword => \n      normalizedQuery.includes(keyword));\n      \n    // Check for scene keywords\n    const hasSceneKeyword = sceneKeywords.some(keyword => \n      normalizedQuery.includes(keyword));\n    \n    // Calculate score\n    let score = 0;\n    if (hasDeviceKeyword) score += 0.4;\n    if (hasActionKeyword) score += 0.3;\n    if (hasSceneKeyword) score += 0.3;\n    \n    // Additional bonus for specific device mentions\n    Object.keys(this.devices).forEach(deviceId => {\n      const deviceName = deviceId.replace('_', ' ');\n      if (normalizedQuery.includes(deviceName)) {\n        score += 0.2;\n      }\n    });\n    \n    // Cap at 1.0\n    return Math.min(score, 1.0);\n  }\n\n  /**\n   * Returns required parameters for a specific task\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    const normalizedTask = task.toLowerCase();\n    \n    if (normalizedTask.includes('allumer') || normalizedTask.includes('├®teindre') || \n        normalizedTask.includes('augmenter') || normalizedTask.includes('diminuer')) {\n      return [\n        {\n          name: 'deviceId',\n          type: 'string',\n          required: true,\n          description: 'Identifiant de l\\'appareil ├á contr├┤ler'\n        },\n        {\n          name: 'action',\n          type: 'string',\n          required: false,\n          description: 'Action ├á effectuer (toggle, on, off, increase, decrease)',\n          defaultValue: 'toggle'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('statut') || normalizedTask.includes('├®tat')) {\n      return [\n        {\n          name: 'deviceId',\n          type: 'string',\n          required: true,\n          description: 'Identifiant de l\\'appareil'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('sc├¿ne') || normalizedTask.includes('scene') || \n        normalizedTask.includes('mode') || normalizedTask.includes('sc├®nario')) {\n      return [\n        {\n          name: 'sceneId',\n          type: 'string',\n          required: true,\n          description: 'Identifiant de la sc├¿ne ├á activer'\n        }\n      ];\n    }\n    \n    return [];\n  }\n\n  /**\n   * Returns detailed capability information\n   */\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'device_control',\n        description: 'Contr├┤le des appareils domotiques (allumer/├®teindre)',\n        requiredParameters: [\n          {\n            name: 'deviceId',\n            type: 'string',\n            required: true,\n            description: 'Identifiant de l\\'appareil'\n          },\n          {\n            name: 'action',\n            type: 'string',\n            required: false,\n            description: 'Action ├á effectuer'\n          }\n        ]\n      },\n      {\n        name: 'scene_management',\n        description: 'Gestion des sc├®narios domotiques',\n        requiredParameters: [\n          {\n            name: 'sceneId',\n            type: 'string',\n            required: true,\n            description: 'Identifiant de la sc├¿ne'\n          }\n        ]\n      }\n    ];\n  }\n\n  /**\n   * Validates input parameters\n   */\n  async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const errors: string[] = [];\n    const intent = props.intent as SmartHomeIntent;\n    const parameters = props.parameters || {};\n    \n    switch (intent) {\n      case 'toggle_device':\n      case 'get_device_status':\n      case 'set_device_value':\n        if (!parameters.deviceId) {\n          errors.push('deviceId est requis');\n        } else if (!this.devices[parameters.deviceId]) {\n          errors.push(`L'appareil ${parameters.deviceId} n'existe pas`);\n        }\n        \n        if (intent === 'set_device_value' && !parameters.property) {\n          errors.push('property est requis pour set_device_value');\n        }\n        break;\n        \n      case 'run_scene':\n        if (!parameters.sceneId) {\n          errors.push('sceneId est requis');\n        } else if (!this.scenes.find(s => s.id === parameters.sceneId)) {\n          errors.push(`La sc├¿ne ${parameters.sceneId} n'existe pas`);\n        }\n        break;\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined\n    };\n  }\n\n  /**\n   * Toggle or control a specific device\n   */\n  private async toggleDevice(deviceId: string, action: DeviceAction): Promise<any> {\n    if (!this.devices[deviceId]) {\n      throw new Error(`Appareil non trouv├®: ${deviceId}`);\n    }\n    \n    const device = this.devices[deviceId];\n    \n    switch (action) {\n      case 'toggle':\n        device.status.on = !device.status.on;\n        break;\n      case 'on':\n        device.status.on = true;\n        break;\n      case 'off':\n        device.status.on = false;\n        break;\n      case 'increase':\n        if ('brightness' in device.status) {\n          device.status.brightness = Math.min(100, device.status.brightness + 10);\n        } else if ('temperature' in device.status) {\n          device.status.temperature++;\n        }\n        break;\n      case 'decrease':\n        if ('brightness' in device.status) {\n          device.status.brightness = Math.max(0, device.status.brightness - 10);\n        } else if ('temperature' in device.status) {\n          device.status.temperature--;\n        }\n        break;\n      default:\n        throw new Error(`Action non support├®e: ${action}`);\n    }\n    \n    return {\n      deviceId,\n      type: device.type,\n      status: device.status,\n      action\n    };\n  }\n\n  /**\n   * Get the status of a specific device\n   */\n  private async getDeviceStatus(deviceId: string): Promise<any> {\n    if (!deviceId) {\n      return Object.entries(this.devices).map(([id, data]) => ({\n        deviceId: id,\n        type: data.type,\n        status: data.status\n      }));\n    }\n    \n    if (!this.devices[deviceId]) {\n      throw new Error(`Appareil non trouv├®: ${deviceId}`);\n    }\n    \n    const device = this.devices[deviceId];\n    return {\n      deviceId,\n      type: device.type,\n      status: device.status\n    };\n  }\n\n  /**\n   * Set a specific value for a device property\n   */\n  private async setDeviceValue(deviceId: string, property: string, value: any): Promise<any> {\n    if (!this.devices[deviceId]) {\n      throw new Error(`Appareil non trouv├®: ${deviceId}`);\n    }\n    \n    const device = this.devices[deviceId];\n    \n    if (!(property in device.status)) {\n      throw new Error(`Propri├®t├® non trouv├®e: ${property}`);\n    }\n    \n    device.status[property] = value;\n    \n    return {\n      deviceId,\n      type: device.type,\n      status: device.status\n    };\n  }\n\n  /**\n   * Activate a scene (applies multiple device settings at once)\n   */\n  private async activateScene(sceneId: string): Promise<any> {\n    const scene = this.scenes.find(s => s.id === sceneId);\n    \n    if (!scene) {\n      throw new Error(`Sc├¿ne non trouv├®e: ${sceneId}`);\n    }\n    \n    const results: Record<string, any> = {};\n    \n    // Apply all device states defined in the scene\n    for (const [deviceId, state] of Object.entries(scene.deviceStates)) {\n      if (this.devices[deviceId]) {\n        // Update device state\n        this.devices[deviceId].status = {\n          ...this.devices[deviceId].status,\n          ...state\n        };\n        \n        results[deviceId] = {\n          type: this.devices[deviceId].type,\n          status: this.devices[deviceId].status\n        };\n      }\n    }\n    \n    return {\n      sceneId,\n      sceneName: scene.name,\n      deviceResults: results\n    };\n  }\n\n  /**\n   * List available devices, optionally filtered by type\n   */\n  private async listDevices(type?: SmartDeviceType): Promise<any> {\n    const deviceList = Object.entries(this.devices)\n      .filter(([_, data]) => !type || data.type === type)\n      .map(([id, data]) => ({\n        deviceId: id,\n        type: data.type,\n        status: data.status\n      }));\n    \n    return {\n      count: deviceList.length,\n      devices: deviceList\n    };\n  }\n\n  /**\n   * List available scenes\n   */\n  private async listScenes(): Promise<any> {\n    return {\n      count: this.scenes.length,\n      scenes: this.scenes.map(scene => ({\n        id: scene.id,\n        name: scene.name,\n        description: scene.description\n      }))\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\SpeechSynthesisAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":212,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":212,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5744,5747],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5744,5747],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":381,"column":116,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":381,"endColumn":119,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10431,10434],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10431,10434],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":390,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":390,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10697,10700],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10697,10700],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":459,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":459,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12762,12765],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12762,12765],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":486,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":486,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13436,13439],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13436,13439],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":535,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":535,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14674,14677],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14674,14677],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":550,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":550,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14976,14979],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14976,14979],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":567,"column":115,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":567,"endColumn":118,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15540,15543],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15540,15543],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SpeechSynthesisAgent - Enables voice output for Lisa\n * \n * This agent handles text-to-speech conversion, allowing Lisa to communicate\n * verbally with users and other voice-enabled systems like Alexa and Gemini.\n */\n\nimport { AgentDomains } from './types';\nimport type { \n  AgentCapability, \n  AgentExecuteProps, \n  AgentExecuteResult, \n  AgentParameter, \n  BaseAgent \n} from './types';\n\n/**\n * Voice settings for speech synthesis\n */\nexport interface VoiceSettings {\n  voice: string;      // Voice identifier\n  rate: number;       // Speech rate (0.1 to 10)\n  pitch: number;      // Speech pitch (0 to 2)\n  volume: number;     // Speech volume (0 to 1)\n  lang: string;       // Language code (e.g., 'fr-FR', 'en-US')\n}\n\n/**\n * Speech synthesis formats\n */\nexport type SpeechFormat = 'ssml' | 'text';\n\n/**\n * Supported intents for SpeechSynthesisAgent\n */\nexport type SpeechSynthesisIntent = \n  | 'speak'\n  | 'get_voices'\n  | 'update_settings'\n  | 'stop_speaking'\n  | 'is_speaking'\n  | 'convert_to_audio';\n\n/**\n * Agent for text-to-speech synthesis\n */\nexport class SpeechSynthesisAgent implements BaseAgent {\n  name = 'SpeechSynthesisAgent';\n  description = 'Convertit du texte en parole pour communiquer verbalement';\n  version = '1.0.0';\n  domain = AgentDomains.INTEGRATION;\n  capabilities = [\n    'text_to_speech',\n    'voice_management',\n    'audio_export'\n  ];\n\n  // Default voice settings\n  private defaultSettings: VoiceSettings = {\n    voice: '',        // Will be set during initialization\n    rate: 1.0,\n    pitch: 1.0,\n    volume: 1.0,\n    lang: 'fr-FR'\n  };\n\n  // Current voice settings\n  private settings: VoiceSettings;\n  \n  // Keep track of available voices\n  private availableVoices: SpeechSynthesisVoice[] = [];\n  \n  // Is the agent initialized?\n  private initialized = false;\n  \n  // Is speech synthesis supported?\n  private supported = false;\n\n  constructor() {\n    this.settings = {...this.defaultSettings};\n    this.initSynthesis();\n  }\n\n  /**\n   * Initialize speech synthesis and load available voices\n   */\n  private async initSynthesis(): Promise<void> {\n    // Check if speech synthesis is supported\n    if (typeof window !== 'undefined' && 'speechSynthesis' in window) {\n      this.supported = true;\n      \n      // Get available voices\n      this.loadVoices();\n      \n      // If voices aren't loaded immediately, wait for the voiceschanged event\n      if (window.speechSynthesis.getVoices().length === 0) {\n        window.speechSynthesis.addEventListener('voiceschanged', () => {\n          this.loadVoices();\n        });\n      }\n      \n      this.initialized = true;\n    } else {\n      console.warn('Speech synthesis is not supported in this browser');\n      this.supported = false;\n      this.initialized = false;\n    }\n  }\n  \n  /**\n   * Load available voices and set default voice\n   */\n  private loadVoices(): void {\n    if (!this.supported) return;\n    \n    this.availableVoices = window.speechSynthesis.getVoices();\n    \n    // Try to find a French voice\n    const frenchVoice = this.availableVoices.find(voice => \n      voice.lang.startsWith('fr') || voice.name.toLowerCase().includes('french'));\n    \n    if (frenchVoice) {\n      this.settings.voice = frenchVoice.name;\n    } else if (this.availableVoices.length > 0) {\n      // Default to first available voice if no French voice is found\n      this.settings.voice = this.availableVoices[0].name;\n    }\n  }\n\n  /**\n   * Main execution method for the agent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as SpeechSynthesisIntent;\n    const parameters = props.parameters || {};\n    const _language = props.language || 'fr'; // Prefixed with underscore as it's not used\n\n    try {\n      if (!this.supported) {\n        throw new Error('La synth├¿se vocale n\\'est pas support├®e par ce navigateur');\n      }\n      \n      if (!this.initialized) {\n        await this.initSynthesis();\n      }\n\n      let result;\n      switch (intent) {\n        case 'speak':\n          result = await this.speakText(\n            parameters.text,\n            parameters.settings || this.settings,\n            parameters.format || 'text'\n          );\n          break;\n        case 'get_voices':\n          result = this.getAvailableVoices(parameters.lang);\n          break;\n        case 'update_settings':\n          result = this.updateSettings(parameters.settings);\n          break;\n        case 'stop_speaking':\n          result = this.stopSpeaking();\n          break;\n        case 'is_speaking':\n          result = this.isSpeaking();\n          break;\n        case 'convert_to_audio':\n          result = await this.convertToAudio(\n            parameters.text,\n            parameters.settings || this.settings,\n            parameters.format || 'mp3'\n          );\n          break;\n        default:\n          return {\n            success: false,\n            output: `Intent non support├®: ${intent}`,\n            error: new Error('UNSUPPORTED_INTENT'),\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error : new Error(String(error)),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Determines if this agent can handle a specific query\n   */\n  async canHandle(query: string, context?: any): Promise<number> {\n    const normalizedQuery = query.toLowerCase();\n    \n    // Keywords related to speech synthesis\n    const speechKeywords = [\n      'parle', 'parler', 'dire', 'prononcer', 'lire', 'voix',\n      'synth├¿se vocale', 'text-to-speech', 'tts', 'audio',\n      '├á voix haute', 'alexa', 'gemini'\n    ];\n    \n    // Count matches\n    const matches = speechKeywords.filter(keyword => \n      normalizedQuery.includes(keyword)).length;\n    \n    // Calculate score\n    let score = 0;\n    if (matches > 0) score += 0.3 + Math.min(matches * 0.2, 0.6);\n    \n    // Additional boost for direct commands\n    if (normalizedQuery.startsWith('dis ') || \n        normalizedQuery.startsWith('parle ') || \n        normalizedQuery.startsWith('lis ')) {\n      score += 0.2;\n    }\n    \n    // Context boost if we're expecting a voice response\n    if (context?.expectVoiceResponse || context?.lastAction === 'listen') {\n      score += 0.2;\n    }\n    \n    return Math.min(score, 1.0);\n  }\n\n  /**\n   * Returns required parameters for a specific task\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    const normalizedTask = task.toLowerCase();\n    \n    if (normalizedTask.includes('parler') || normalizedTask.includes('dire') || \n        normalizedTask.includes('lire') || normalizedTask.startsWith('dis ')) {\n      return [\n        {\n          name: 'text',\n          type: 'string',\n          required: true,\n          description: 'Texte ├á lire ├á voix haute'\n        },\n        {\n          name: 'settings',\n          type: 'object',\n          required: false,\n          description: 'Param├¿tres de voix (optionnel)'\n        },\n        {\n          name: 'format',\n          type: 'string',\n          required: false,\n          description: 'Format du texte (text ou ssml)',\n          defaultValue: 'text'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('voix') && \n       (normalizedTask.includes('liste') || normalizedTask.includes('disponible'))) {\n      return [\n        {\n          name: 'lang',\n          type: 'string',\n          required: false,\n          description: 'Filtrer par langue (optionnel)'\n        }\n      ];\n    }\n    \n    if (normalizedTask.includes('param├¿tre') || normalizedTask.includes('configurer')) {\n      return [\n        {\n          name: 'settings',\n          type: 'object',\n          required: true,\n          description: 'Nouveaux param├¿tres de voix'\n        }\n      ];\n    }\n    \n    return [];\n  }\n\n  /**\n   * Returns detailed capability information\n   */\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'text_to_speech',\n        description: 'Lit du texte ├á voix haute',\n        requiredParameters: [\n          {\n            name: 'text',\n            type: 'string',\n            required: true,\n            description: 'Texte ├á lire'\n          }\n        ]\n      },\n      {\n        name: 'voice_management',\n        description: 'Gestion des voix et param├¿tres',\n        requiredParameters: []\n      },\n      {\n        name: 'audio_export',\n        description: 'Conversion de texte en fichier audio',\n        requiredParameters: [\n          {\n            name: 'text',\n            type: 'string',\n            required: true,\n            description: 'Texte ├á convertir'\n          },\n          {\n            name: 'format',\n            type: 'string',\n            required: false,\n            description: 'Format audio (mp3, wav)'\n          }\n        ]\n      }\n    ];\n  }\n\n  /**\n   * Validates input parameters\n   */\n  async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const errors: string[] = [];\n    const intent = props.intent as SpeechSynthesisIntent;\n    const parameters = props.parameters || {};\n    \n    switch (intent) {\n      case 'speak':\n      case 'convert_to_audio':\n        if (!parameters.text || parameters.text.trim().length === 0) {\n          errors.push('Le texte ├á prononcer est requis');\n        }\n        \n        if (parameters.format && !['text', 'ssml'].includes(parameters.format)) {\n          errors.push('Le format doit ├¬tre \"text\" ou \"ssml\"');\n        }\n        break;\n        \n      case 'update_settings':\n        if (!parameters.settings || Object.keys(parameters.settings).length === 0) {\n          errors.push('Les param├¿tres de voix sont requis');\n        }\n        break;\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined\n    };\n  }\n\n  /**\n   * Speaks the provided text using speech synthesis\n   */\n  private async speakText(text: string, settings?: Partial<VoiceSettings>, format: SpeechFormat = 'text'): Promise<any> {\n    if (!this.supported) {\n      throw new Error('La synth├¿se vocale n\\'est pas support├®e par ce navigateur');\n    }\n    \n    if (!text || text.trim().length === 0) {\n      throw new Error('Le texte ├á prononcer est requis');\n    }\n    \n    return new Promise<any>((resolve, reject) => {\n      try {\n        // Stop any current speech\n        window.speechSynthesis.cancel();\n        \n        // Create utterance\n        const utterance = new SpeechSynthesisUtterance(text);\n        \n        // Apply settings\n        const mergedSettings = { ...this.settings, ...settings };\n        \n        // Set voice\n        if (mergedSettings.voice) {\n          const selectedVoice = this.availableVoices.find(v => v.name === mergedSettings.voice);\n          if (selectedVoice) {\n            utterance.voice = selectedVoice;\n          }\n        }\n        \n        // Apply other settings\n        utterance.rate = mergedSettings.rate;\n        utterance.pitch = mergedSettings.pitch;\n        utterance.volume = mergedSettings.volume;\n        utterance.lang = mergedSettings.lang;\n        \n        // Handle SSML if specified\n        if (format === 'ssml') {\n          // Simple SSML parsing\n          // Note: Web Speech API doesn't natively support SSML,\n          // so this is a very basic implementation\n          const textWithoutTags = text\n            .replace(/<[^>]*>/g, '')  // Remove all XML tags\n            .replace(/\\s+/g, ' ')     // Normalize whitespace\n            .trim();\n          \n          utterance.text = textWithoutTags;\n        }\n        \n        // Set up event handlers\n        utterance.onend = () => {\n          resolve({\n            completed: true,\n            text,\n            settings: mergedSettings\n          });\n        };\n        \n        utterance.onerror = (event) => {\n          reject(new Error(`Erreur de synth├¿se vocale: ${event.error}`));\n        };\n        \n        // Start speaking\n        window.speechSynthesis.speak(utterance);\n        \n        // Also resolve with information about the speech\n        resolve({\n          started: true,\n          text,\n          settings: mergedSettings\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * Get available voices, optionally filtered by language\n   */\n  private getAvailableVoices(lang?: string): any {\n    if (!this.supported) {\n      throw new Error('La synth├¿se vocale n\\'est pas support├®e par ce navigateur');\n    }\n    \n    let voices = this.availableVoices;\n    \n    // Filter by language if specified\n    if (lang) {\n      voices = voices.filter(voice => voice.lang.startsWith(lang));\n    }\n    \n    return {\n      count: voices.length,\n      currentVoice: this.settings.voice,\n      voices: voices.map(voice => ({\n        name: voice.name,\n        lang: voice.lang,\n        default: voice.default,\n        localService: voice.localService\n      }))\n    };\n  }\n\n  /**\n   * Update voice settings\n   */\n  private updateSettings(newSettings: Partial<VoiceSettings>): any {\n    if (!newSettings) {\n      throw new Error('Les param├¿tres de voix sont requis');\n    }\n    \n    // Validate voice if provided\n    if (newSettings.voice) {\n      const voiceExists = this.availableVoices.some(v => v.name === newSettings.voice);\n      if (!voiceExists) {\n        throw new Error(`La voix \"${newSettings.voice}\" n'existe pas`);\n      }\n    }\n    \n    // Validate rate\n    if (newSettings.rate !== undefined) {\n      if (newSettings.rate < 0.1 || newSettings.rate > 10) {\n        throw new Error('La vitesse doit ├¬tre entre 0.1 et 10');\n      }\n    }\n    \n    // Validate pitch\n    if (newSettings.pitch !== undefined) {\n      if (newSettings.pitch < 0 || newSettings.pitch > 2) {\n        throw new Error('La hauteur doit ├¬tre entre 0 et 2');\n      }\n    }\n    \n    // Validate volume\n    if (newSettings.volume !== undefined) {\n      if (newSettings.volume < 0 || newSettings.volume > 1) {\n        throw new Error('Le volume doit ├¬tre entre 0 et 1');\n      }\n    }\n    \n    // Update settings\n    this.settings = {\n      ...this.settings,\n      ...newSettings\n    };\n    \n    return {\n      updated: true,\n      settings: this.settings\n    };\n  }\n\n  /**\n   * Stop any ongoing speech\n   */\n  private stopSpeaking(): any {\n    if (!this.supported) {\n      throw new Error('La synth├¿se vocale n\\'est pas support├®e par ce navigateur');\n    }\n    \n    window.speechSynthesis.cancel();\n    \n    return {\n      stopped: true\n    };\n  }\n\n  /**\n   * Check if speech synthesis is currently active\n   */\n  private isSpeaking(): any {\n    if (!this.supported) {\n      throw new Error('La synth├¿se vocale n\\'est pas support├®e par ce navigateur');\n    }\n    \n    const speaking = window.speechSynthesis.speaking;\n    \n    return {\n      speaking\n    };\n  }\n\n  /**\n   * Convert text to an audio file (MP3/WAV)\n   * Note: Web Speech API doesn't natively support exporting to audio files\n   * This is a placeholder for future implementation that would require a server-side API\n   */\n  private async convertToAudio(text: string, _settings?: Partial<VoiceSettings>, format: string = 'mp3'): Promise<any> {\n    // This would require a server-side TTS service with an API\n    // Here we'll just return a placeholder response\n    \n    return {\n      message: \"La conversion en fichier audio n├®cessite une API de synth├¿se vocale externe. Cette fonctionnalit├® n'est pas encore impl├®ment├®e.\",\n      text,\n      format,\n      supported: false\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\SystemIntegrationAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[933,936],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[933,936],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":39,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":39,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1007,1010],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1007,1010],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1309,1312],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1309,1312],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":110,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":113,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4096,4099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4096,4099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5534,5537],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5534,5537],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":219,"column":61,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":219,"endColumn":64,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6164,6167],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6164,6167],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6842,6845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6842,6845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":450,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":450,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12420,12423],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12420,12423],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":451,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":451,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12438,12441],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12438,12441],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":477,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":477,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13102,13105],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13102,13105],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":478,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":478,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13120,13123],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13120,13123],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":500,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":500,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13675,13678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13675,13678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":501,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":501,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13693,13696],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13693,13696],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":521,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":521,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14224,14227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14224,14227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":522,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":522,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14242,14245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14242,14245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":548,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":548,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14889,14892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14889,14892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":549,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":549,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14907,14910],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14907,14910],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":595,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":595,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16175,16178],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16175,16178],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":596,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":596,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[16193,16196],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[16193,16196],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":644,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":644,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17546,17549],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17546,17549],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":645,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":645,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17564,17567],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17564,17567],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":21,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SystemIntegrationAgent.ts\n * \n * Agent responsable de l'int├®gration profonde avec les syst├¿mes externes\n * Permet ├á Lisa d'interagir avec des API externes, des services web,\n * et d'autres syst├¿mes pour ├®tendre ses capacit├®s d'automatisation.\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { agentRegistry } from './registry';\nimport { v4 as uuidv4 } from 'uuid';\n\n/**\n * Type pour les int├®grations syst├¿me disponibles\n */\nexport const SYSTEM_INTEGRATION_TYPES = [\n  'api',\n  'webhook',\n  'mqtt',\n  'socket',\n  'http',\n  'database',\n  'file',\n  'shell'\n] as const;\n\nexport type SystemIntegrationType = typeof SYSTEM_INTEGRATION_TYPES[number];\n\n/**\n * Interface pour les configurations d'int├®gration syst├¿me\n */\nexport interface SystemIntegrationConfig {\n  id: string;\n  name: string;\n  type: SystemIntegrationType;\n  enabled: boolean;\n  configuration: Record<string, any>;\n  credentials?: Record<string, string>;\n  metadata?: Record<string, any>;\n}\n\n/**\n * Interface pour les op├®rations d'int├®gration syst├¿me\n */\nexport interface SystemIntegrationAction {\n  intent: 'register_integration' | 'execute_integration' | 'list_integrations' | \n          'update_integration' | 'delete_integration' | 'test_integration';\n  parameters: Record<string, any>;\n}\n\n/**\n * Agent d'int├®gration syst├¿me\n * Responsable de g├®rer les int├®grations avec des syst├¿mes externes\n */\nexport class SystemIntegrationAgent implements BaseAgent {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  domain: AgentDomain;\n  capabilities: string[];\n  valid: boolean = true;\n  errors?: string[];\n  integrations: Map<string, SystemIntegrationConfig>;\n\n  constructor() {\n    this.id = 'system-integration-agent';\n    this.name = 'System Integration Agent';\n    this.description = 'Agent responsable de l\\'int├®gration avec des syst├¿mes externes';\n    this.version = '1.0.0';\n    this.domain = 'integration' as AgentDomain;\n    this.capabilities = [\n      'api-integration',\n      'webhook-handling',\n      'mqtt-communication',\n      'socket-management',\n      'http-requests',\n      'database-access',\n      'file-operations',\n      'shell-execution'\n    ];\n    this.integrations = new Map();\n    \n    // Charger les int├®grations existantes (simul├® ici)\n    this.loadIntegrations();\n  }\n\n  /**\n   * Charger les int├®grations existantes\n   * Note: Dans une impl├®mentation r├®elle, cela chargerait depuis un stockage persistant\n   */\n  private loadIntegrations(): void {\n    // Exemple d'int├®grations par d├®faut\n    const defaultIntegrations: SystemIntegrationConfig[] = [\n      {\n        id: uuidv4(),\n        name: 'Exemple API M├®t├®o',\n        type: 'api',\n        enabled: true,\n        configuration: {\n          baseUrl: 'https://api.weatherapi.com/v1',\n          endpoints: {\n            current: '/current.json',\n            forecast: '/forecast.json'\n          }\n        },\n        metadata: {\n          description: 'Int├®gration exemple avec API m├®t├®o',\n          tags: ['weather', 'demo']\n        }\n      },\n      {\n        id: uuidv4(),\n        name: 'Webhook Notification',\n        type: 'webhook',\n        enabled: true,\n        configuration: {\n          url: 'https://hooks.example.com/services/T00000000/B00000000/XXXXXXXXXXXXXXXXXXXXXXXX',\n          method: 'POST',\n          headers: {\n            'Content-Type': 'application/json'\n          }\n        }\n      }\n    ];\n\n    // Ajouter les int├®grations ├á la map\n    defaultIntegrations.forEach(integration => {\n      this.integrations.set(integration.id, integration);\n    });\n  }\n\n  /**\n   * Ex├®cuter une action d'int├®gration syst├¿me\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { intent, parameters = {} } = props;\n\n    try {\n      switch (intent) {\n        case 'register_integration':\n          return await this.registerIntegration(parameters as { config: SystemIntegrationConfig });\n\n        case 'execute_integration':\n          return await this.executeIntegration(parameters as { integrationId: string; params: Record<string, any> });\n\n        case 'list_integrations':\n          return await this.listIntegrations(parameters as { type?: SystemIntegrationType });\n\n        case 'update_integration':\n          return await this.updateIntegration(parameters as { \n            integrationId: string; \n            updates: Partial<SystemIntegrationConfig> \n          });\n\n        case 'delete_integration':\n          return await this.deleteIntegration(parameters as { integrationId: string });\n\n        case 'test_integration':\n          return await this.testIntegration(parameters as { integrationId: string });\n\n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Action non support├®e: ${intent}`\n          };\n      }\n    } catch (error) {\n      console.error(`Erreur lors de l'ex├®cution de l'intent ${intent}:`, error);\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Enregistrer une nouvelle int├®gration syst├¿me\n   */\n  private async registerIntegration(\n    params: { config: SystemIntegrationConfig }\n  ): Promise<AgentExecuteResult> {\n    const { config } = params;\n\n    // V├®rifier que l'int├®gration a un identifiant\n    if (!config.id) {\n      config.id = uuidv4();\n    }\n\n    // V├®rifier que le type d'int├®gration est valide\n    if (!SYSTEM_INTEGRATION_TYPES.includes(config.type as any)) {\n      return {\n        success: false,\n        output: null,\n        error: `Type d'int├®gration non support├®: ${config.type}`\n      };\n    }\n\n    // Ajouter l'int├®gration\n    this.integrations.set(config.id, config);\n\n    console.log(`Nouvelle int├®gration enregistr├®e: ${config.name} (${config.type})`);\n\n    return {\n      success: true,\n      output: {\n        integration: config,\n        message: `Int├®gration \"${config.name}\" enregistr├®e avec succ├¿s`\n      }\n    };\n  }\n\n  /**\n   * Ex├®cuter une int├®gration syst├¿me\n   */\n  private async executeIntegration(\n    params: { integrationId: string; params: Record<string, any> }\n  ): Promise<AgentExecuteResult> {\n    const { integrationId, params: executionParams } = params;\n\n    // V├®rifier que l'int├®gration existe\n    const integration = this.integrations.get(integrationId);\n    if (!integration) {\n      return {\n        success: false,\n        error: `Int├®gration non trouv├®e avec l'ID: ${integrationId}`,\n        input: params\n      };\n    }\n\n    // V├®rifier que l'int├®gration est activ├®e\n    if (!integration.enabled) {\n      return {\n        success: false,\n        error: `L'int├®gration \"${integration.name}\" est d├®sactiv├®e`,\n        input: params\n      };\n    }\n\n    try {\n      // Simulation d'ex├®cution selon le type\n      let result: any;\n      console.log(`Ex├®cution de l'int├®gration ${integration.name} (${integration.type})...`);\n\n      switch (integration.type) {\n        case 'api':\n          result = await this.simulateApiCall(integration, executionParams);\n          break;\n        case 'webhook':\n          result = await this.simulateWebhookCall(integration, executionParams);\n          break;\n        case 'mqtt':\n          result = await this.simulateMqttOperation(integration, executionParams);\n          break;\n        case 'http':\n          result = await this.simulateHttpRequest(integration, executionParams);\n          break;\n        case 'database':\n          result = await this.simulateDatabaseOperation(integration, executionParams);\n          break;\n        case 'file':\n          result = await this.simulateFileOperation(integration, executionParams);\n          break;\n        case 'shell':\n          result = await this.simulateShellExecution(integration, executionParams);\n          break;\n        default:\n          throw new Error(`Type d'int├®gration non impl├®ment├®: ${integration.type}`);\n      }\n\n      return {\n        success: true,\n        output: {\n          result,\n          message: `Int├®gration \"${integration.name}\" ex├®cut├®e avec succ├¿s`\n        },\n        input: params\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        input: params\n      };\n    }\n  }\n\n  /**\n   * Lister les int├®grations syst├¿me\n   */\n  private async listIntegrations(\n    params: { type?: SystemIntegrationType }\n  ): Promise<AgentExecuteResult> {\n    const { type } = params;\n    \n    let integrationsList = Array.from(this.integrations.values());\n\n    // Filtrer par type si sp├®cifi├®\n    if (type) {\n      integrationsList = integrationsList.filter(integration => integration.type === type);\n    }\n\n    // Ne pas exposer les informations sensibles\n    const safeIntegrations = integrationsList.map(integration => {\n      const { credentials, ...safeIntegration } = integration;\n      return safeIntegration;\n    });\n\n    return {\n      success: true,\n      output: {\n        integrations: safeIntegrations,\n        count: safeIntegrations.length\n      },\n      input: params\n    };\n  }\n\n  /**\n   * Mettre ├á jour une int├®gration syst├¿me\n   */\n  private async updateIntegration(\n    params: { integrationId: string; updates: Partial<SystemIntegrationConfig> }\n  ): Promise<AgentExecuteResult> {\n    const { integrationId, updates } = params;\n\n    // V├®rifier que l'int├®gration existe\n    const integration = this.integrations.get(integrationId);\n    if (!integration) {\n      return {\n        success: false,\n        error: `Int├®gration non trouv├®e avec l'ID: ${integrationId}`,\n        input: params\n      };\n    }\n\n    // Appliquer les mises ├á jour\n    const updatedIntegration = {\n      ...integration,\n      ...updates,\n      // Ne pas permettre la modification de l'ID\n      id: integration.id\n    };\n\n    // Mettre ├á jour l'int├®gration\n    this.integrations.set(integrationId, updatedIntegration);\n\n    console.log(`Int├®gration mise ├á jour: ${updatedIntegration.name}`);\n\n    return {\n      success: true,\n      output: {\n        integrationId,\n        message: `Int├®gration \"${updatedIntegration.name}\" mise ├á jour avec succ├¿s`\n      },\n      input: params\n    };\n  }\n\n  /**\n   * Supprimer une int├®gration syst├¿me\n   */\n  private async deleteIntegration(\n    params: { integrationId: string }\n  ): Promise<AgentExecuteResult> {\n    const { integrationId } = params;\n\n    // V├®rifier que l'int├®gration existe\n    const integration = this.integrations.get(integrationId);\n    if (!integration) {\n      return {\n        success: false,\n        error: `Int├®gration non trouv├®e avec l'ID: ${integrationId}`,\n        input: params\n      };\n    }\n\n    // Supprimer l'int├®gration\n    this.integrations.delete(integrationId);\n\n    console.log(`Int├®gration supprim├®e: ${integration.name}`);\n\n    return {\n      success: true,\n      output: {\n        message: `Int├®gration \"${integration.name}\" supprim├®e avec succ├¿s`\n      },\n      input: params\n    };\n  }\n\n  /**\n   * Tester une int├®gration syst├¿me\n   */\n  private async testIntegration(\n    params: { integrationId: string }\n  ): Promise<AgentExecuteResult> {\n    const { integrationId } = params;\n\n    // V├®rifier que l'int├®gration existe\n    const integration = this.integrations.get(integrationId);\n    if (!integration) {\n      return {\n        success: false,\n        error: `Int├®gration non trouv├®e avec l'ID: ${integrationId}`,\n        input: params\n      };\n    }\n\n    try {\n      // Simuler un test d'int├®gration\n      console.log(`Test de l'int├®gration ${integration.name} (${integration.type})...`);\n\n      // Simulation de test selon le type\n      const testResult = {\n        status: 'success',\n        latency: Math.floor(Math.random() * 1000),\n        timestamp: new Date().toISOString(),\n        details: {\n          connectionSuccessful: true,\n          responseReceived: true,\n          validResponse: true\n        }\n      };\n\n      return {\n        success: true,\n        output: {\n          testResult,\n          message: `Test de l'int├®gration \"${integration.name}\" r├®ussi`\n        },\n        input: params\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error),\n        input: params\n      };\n    }\n  }\n\n  /**\n   * Simuler un appel d'API\n   */\n  private async simulateApiCall(\n    integration: SystemIntegrationConfig, \n    params: Record<string, any>\n  ): Promise<any> {\n    console.log(`Simulation d'appel API pour ${integration.name}...`);\n    console.log(`Param├¿tres: ${JSON.stringify(params)}`);\n    \n    // Simuler un d├®lai\n    await new Promise(resolve => setTimeout(resolve, 500));\n    \n    // Simuler une r├®ponse\n    return {\n      status: 200,\n      data: {\n        success: true,\n        results: [\n          { id: 1, name: 'Donn├®e simul├®e 1' },\n          { id: 2, name: 'Donn├®e simul├®e 2' }\n        ],\n        timestamp: new Date().toISOString()\n      }\n    };\n  }\n\n  /**\n   * Simuler un appel de webhook\n   */\n  private async simulateWebhookCall(\n    integration: SystemIntegrationConfig,\n    params: Record<string, any>\n  ): Promise<any> {\n    console.log(`Simulation d'appel webhook pour ${integration.name}...`);\n    console.log(`Param├¿tres: ${JSON.stringify(params)}`);\n    \n    // Simuler un d├®lai\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    // Simuler une r├®ponse\n    return {\n      status: 200,\n      body: {\n        received: true,\n        message: 'Notification envoy├®e avec succ├¿s'\n      }\n    };\n  }\n\n  /**\n   * Simuler une op├®ration MQTT\n   */\n  private async simulateMqttOperation(\n    integration: SystemIntegrationConfig,\n    params: Record<string, any>\n  ): Promise<any> {\n    console.log(`Simulation d'op├®ration MQTT pour ${integration.name}...`);\n    console.log(`Param├¿tres: ${JSON.stringify(params)}`);\n    \n    // Simuler un d├®lai\n    await new Promise(resolve => setTimeout(resolve, 200));\n    \n    // Simuler une r├®ponse\n    return {\n      published: true,\n      topic: params.topic || 'default/topic',\n      qos: params.qos || 0\n    };\n  }\n\n  /**\n   * Simuler une requ├¬te HTTP\n   */\n  private async simulateHttpRequest(\n    integration: SystemIntegrationConfig,\n    params: Record<string, any>\n  ): Promise<any> {\n    console.log(`Simulation de requ├¬te HTTP pour ${integration.name}...`);\n    console.log(`Param├¿tres: ${JSON.stringify(params)}`);\n    \n    // Simuler un d├®lai\n    await new Promise(resolve => setTimeout(resolve, 400));\n    \n    // Simuler une r├®ponse\n    return {\n      status: 200,\n      headers: {\n        'content-type': 'application/json',\n        'server': 'nginx'\n      },\n      data: {\n        result: 'Succ├¿s',\n        requestId: uuidv4()\n      }\n    };\n  }\n\n  /**\n   * Simuler une op├®ration de base de donn├®es\n   */\n  private async simulateDatabaseOperation(\n    integration: SystemIntegrationConfig,\n    params: Record<string, any>\n  ): Promise<any> {\n    console.log(`Simulation d'op├®ration de base de donn├®es pour ${integration.name}...`);\n    console.log(`Param├¿tres: ${JSON.stringify(params)}`);\n    \n    // Simuler un d├®lai\n    await new Promise(resolve => setTimeout(resolve, 600));\n    \n    // Simuler une r├®ponse selon l'op├®ration\n    const operation = params.operation || 'query';\n    \n    switch (operation) {\n      case 'query':\n        return {\n          rows: [\n            { id: 1, name: 'Donn├®e 1', value: 100 },\n            { id: 2, name: 'Donn├®e 2', value: 200 }\n          ],\n          rowCount: 2,\n          fields: ['id', 'name', 'value']\n        };\n      case 'insert':\n        return {\n          insertId: Math.floor(Math.random() * 1000),\n          affectedRows: 1\n        };\n      case 'update':\n        return {\n          affectedRows: params.id ? 1 : Math.floor(Math.random() * 5)\n        };\n      case 'delete':\n        return {\n          affectedRows: params.id ? 1 : Math.floor(Math.random() * 3)\n        };\n      default:\n        return {\n          success: true,\n          message: 'Op├®ration ex├®cut├®e'\n        };\n    }\n  }\n\n  /**\n   * Simuler une op├®ration de fichier\n   */\n  private async simulateFileOperation(\n    integration: SystemIntegrationConfig,\n    params: Record<string, any>\n  ): Promise<any> {\n    console.log(`Simulation d'op├®ration de fichier pour ${integration.name}...`);\n    console.log(`Param├¿tres: ${JSON.stringify(params)}`);\n    \n    // Simuler un d├®lai\n    await new Promise(resolve => setTimeout(resolve, 300));\n    \n    // Simuler une r├®ponse selon l'op├®ration\n    const operation = params.operation || 'read';\n    \n    switch (operation) {\n      case 'read':\n        return {\n          content: 'Contenu simul├® du fichier',\n          size: 1024,\n          lastModified: new Date().toISOString()\n        };\n      case 'write':\n        return {\n          bytesWritten: params.content ? params.content.length : 512,\n          path: params.path || '/path/to/file.txt'\n        };\n      case 'delete':\n        return {\n          deleted: true,\n          path: params.path || '/path/to/file.txt'\n        };\n      case 'list':\n        return {\n          files: [\n            { name: 'file1.txt', size: 1024, type: 'file' },\n            { name: 'file2.jpg', size: 2048, type: 'file' },\n            { name: 'directory1', type: 'directory' }\n          ]\n        };\n      default:\n        return {\n          success: true,\n          message: 'Op├®ration ex├®cut├®e'\n        };\n    }\n  }\n\n  /**\n   * Simuler une ex├®cution shell\n   */\n  private async simulateShellExecution(\n    integration: SystemIntegrationConfig,\n    params: Record<string, any>\n  ): Promise<any> {\n    console.log(`Simulation d'ex├®cution shell pour ${integration.name}...`);\n    console.log(`Param├¿tres: ${JSON.stringify(params)}`);\n    \n    // Simuler un d├®lai\n    await new Promise(resolve => setTimeout(resolve, 700));\n    \n    // Simuler une r├®ponse\n    return {\n      stdout: 'Sortie simul├®e de la commande',\n      stderr: '',\n      exitCode: 0\n    };\n  }\n}\n\n// Enregistrer l'agent dans le registre\nagentRegistry.register(new SystemIntegrationAgent() as BaseAgent);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\TodoAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":207,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":207,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6261,6264],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6261,6264],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":223,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":223,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6690,6693],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6690,6693],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":264,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":264,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8019,8022],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8019,8022],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":299,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":299,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8991,8994],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8991,8994],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":411,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":411,"endColumn":21},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":440,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":440,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13369,13372],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13369,13372],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":570,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":570,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17299,17302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17299,17302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":594,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":594,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17988,17991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17988,17991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":635,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":635,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19274,19277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19274,19277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":675,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":675,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20354,20357],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20354,20357],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":699,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":699,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[21096,21099],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[21096,21099],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Agent responsible for managing the to-do list.\n * This agent interacts directly with the Zustand store to manage state.\n * Implements the BaseAgent interface for integration with PlannerAgent.\n */\nimport { agentRegistry } from './registry';\nimport { z } from 'zod';\nimport {\n  AgentDomains\n} from './types';\nimport type {\n  AgentCapability,\n  AgentExecuteProps,\n  AgentExecuteResult,\n  AgentParameter,\n  BaseAgent\n} from './types';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n\n/**\n * Supported todo intents\n */\nexport const AddItemParamsSchema = z.object({\n  text: z.string().min(1, 'Todo item text is required'),\n  priority: z.enum(['low', 'medium', 'high']).optional(),\n  dueDate: z.string().datetime().optional(),\n});\n\nexport const RemoveItemParamsSchema = z.object({\n  id: z.string().min(1, 'Todo ID is required'),\n});\n\nexport const ListItemsParamsSchema = z.object({\n  filter: z.enum(['all', 'active', 'completed']).default('all'),\n});\n\nexport const UpdateItemParamsSchema = z.object({\n  id: z.string().min(1, 'Todo ID is required'),\n  text: z.string().min(1, 'Todo item text is required').optional(),\n  priority: z.enum(['low', 'medium', 'high']).optional(),\n  dueDate: z.string().datetime().optional(),\n});\n\nexport const MarkStatusParamsSchema = z.object({\n  id: z.string().min(1, 'Todo ID is required'),\n});\n\nexport const ClearCompletedParamsSchema = z.object({});\n\nexport type TodoIntent =\n  | 'add_item'\n  | 'remove_item'\n  | 'list_items'\n  | 'update_item'\n  | 'mark_complete'\n  | 'mark_incomplete'\n  | 'clear_completed';\n\n/**\n * Base Todo interface from the store\n */\nimport type { Todo as StoreTodo } from '../store/visionAudioStore';\n\n/**\n * Extended Todo item interface with additional fields\n */\nexport interface TodoItem extends StoreTodo {\n  completed?: boolean;\n  priority?: 'low' | 'medium' | 'high';\n  dueDate?: string;\n  createdAt?: string;\n  updatedAt?: string;\n}\n\nexport class TodoAgent implements BaseAgent {\n  name = 'TodoAgent';\n  description = 'Manages a to-do list, including adding, removing, updating, and listing items.';\n  version = '1.1.0';\n  domain = AgentDomains.PRODUCTIVITY;\n  capabilities = [\n    'add_todo_item',\n    'remove_todo_item',\n    'list_todo_items',\n    'update_todo_item',\n    'mark_todo_complete',\n    'mark_todo_incomplete',\n    'clear_completed_todos'\n  ];\n\n  // Define inputs and outputs for the workflow editor\n  inputs = [\n    { id: 'trigger', type: 'any', label: 'D├®clencheur' },\n  ];\n\n  outputs = [\n    { id: 'result', type: 'object', label: 'R├®sultat' },\n    { id: 'error', type: 'object', label: 'Erreur' },\n  ];\n\n  // Define a combined config schema for all intents\n  configSchema = z.discriminatedUnion('intent', [\n    AddItemParamsSchema.extend({ intent: z.literal('add_item') }),\n    RemoveItemParamsSchema.extend({ intent: z.literal('remove_item') }),\n    ListItemsParamsSchema.extend({ intent: z.literal('list_items') }),\n    UpdateItemParamsSchema.extend({ intent: z.literal('update_item') }),\n    MarkStatusParamsSchema.extend({ intent: z.literal('mark_complete') }),\n    MarkStatusParamsSchema.extend({ intent: z.literal('mark_incomplete') }),\n    ClearCompletedParamsSchema.extend({ intent: z.literal('clear_completed') }),\n  ]);\n\n  /**\n   * Main execution method for the TodoAgent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as TodoIntent || props.command as TodoIntent;\n    const parameters = props.parameters || {};\n\n    try {\n      // Validate input using Zod schemas\n      let validationResult;\n      switch (intent) {\n        case 'add_item':\n          validationResult = AddItemParamsSchema.safeParse(parameters);\n          break;\n        case 'remove_item':\n          validationResult = RemoveItemParamsSchema.safeParse(parameters);\n          break;\n        case 'list_items':\n          validationResult = ListItemsParamsSchema.safeParse(parameters);\n          break;\n        case 'update_item':\n          validationResult = UpdateItemParamsSchema.safeParse(parameters);\n          break;\n        case 'mark_complete':\n        case 'mark_incomplete':\n          validationResult = MarkStatusParamsSchema.safeParse(parameters);\n          break;\n        case 'clear_completed':\n          validationResult = ClearCompletedParamsSchema.safeParse(parameters);\n          break;\n        default:\n          validationResult = { success: false, error: 'Unsupported intent' };\n      }\n\n      if (!validationResult.success) {\n        return {\n          success: false,\n          error: validationResult.error.errors.map(err => err.message).join(', '),\n          output: null,\n          metadata: {\n            executionTime: Date.now() - startTime\n          }\n        };\n      }\n      \n      // Process intent\n      let result;\n      switch (intent) {\n        case 'add_item':\n          result = this.addItem(parameters.text as string, parameters.priority, parameters.dueDate);\n          break;\n          \n        case 'remove_item':\n          result = this.removeItem(parameters.id as string);\n          break;\n          \n        case 'list_items':\n          result = this.listItems(parameters.filter as string);\n          break;\n          \n        case 'update_item':\n          result = this.updateItem(parameters.id as string, parameters.text, parameters.priority, parameters.dueDate);\n          break;\n          \n        case 'mark_complete':\n          result = this.markItemStatus(parameters.id as string, true);\n          break;\n          \n        case 'mark_incomplete':\n          result = this.markItemStatus(parameters.id as string, false);\n          break;\n          \n        case 'clear_completed':\n          result = this.clearCompleted();\n          break;\n          \n        default:\n          return {\n            success: false,\n            output: `Intent non support├®: ${intent}`,\n            error: new Error('UNSUPPORTED_INTENT'),\n            metadata: {\n              executionTime: Date.now() - startTime\n            }\n          };\n      }\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          source: `todo-${intent}`\n        }\n      };\n    } catch (error: any) {\n      console.error(`TodoAgent error executing ${props.intent || props.command}:`, error);\n      return {\n        success: false,\n        error: error.message || 'Unknown error occurred',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime\n        }\n      };\n    }\n  }\n\n  /**\n   * Determines if this agent can handle a specific query\n   */\n  async canHandle(query: string, _context?: any): Promise<number> {\n    const lowerQuery = query.toLowerCase();\n    \n    const todoKeywords = [\n      'todo', 'to do', 'to-do', 'task', 't├óche', 'lista', 'liste',\n      'reminder', 'rappel', 'add', 'ajouter', 'remove', 'supprimer',\n      'list', 'lister', 'show', 'montrer', 'afficher',\n      'complete', 'compl├¿te', 'completed', 'termin├®', 'done', 'fini',\n      'item', '├®l├®ment', 'pending', 'en attente'\n    ];\n    \n    const todoRegexes = [\n      /add (a )?((new )?todo|task|item|reminder)/i,\n      /ajouter (une? )?(nouvelle? )?(t├óche|├®l├®ment|rappel|todo)/i,\n      /show( my)? (todo|task)s/i,\n      /afficher|montrer (mes )?(t├óches|todos)/i,\n      /mark (task|todo|item) (as )?(complete|done)/i,\n      /marquer (la |une )?(t├óche|todo) (comme )?(termin├®e|compl├¿te)/i\n    ];\n    \n    // Check for keyword matches\n    for (const keyword of todoKeywords) {\n      if (lowerQuery.includes(keyword)) {\n        return 0.6; // 60% confidence\n      }\n    }\n    \n    // Check for regex patterns\n    for (const regex of todoRegexes) {\n      if (regex.test(lowerQuery)) {\n        return 0.85; // 85% confidence\n      }\n    }\n    \n    return 0; // Cannot handle\n  }\n  \n  /**\n   * Returns required parameters for a specific task\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    let schema: z.ZodObject<any> | undefined;\n    switch (task) {\n      case 'add_item':\n        schema = AddItemParamsSchema;\n        break;\n      case 'remove_item':\n        schema = RemoveItemParamsSchema;\n        break;\n      case 'list_items':\n        schema = ListItemsParamsSchema;\n        break;\n      case 'update_item':\n        schema = UpdateItemParamsSchema;\n        break;\n      case 'mark_complete':\n      case 'mark_incomplete':\n        schema = MarkStatusParamsSchema;\n        break;\n      case 'clear_completed':\n        schema = ClearCompletedParamsSchema;\n        break;\n      default:\n        return [];\n    }\n\n    if (!schema) return [];\n\n    const params: AgentParameter[] = [];\n    for (const key in schema.shape) {\n      const fieldSchema = schema.shape[key] as z.ZodAny;\n      const isOptional = fieldSchema.isOptional();\n      const isNullable = fieldSchema.isNullable();\n      const isRequired = !isOptional && !isNullable;\n\n      let type: string;\n      let defaultValue: any;\n      let enumValues: string[] | undefined;\n\n      let baseSchema = fieldSchema;\n      while (baseSchema instanceof z.ZodOptional || baseSchema instanceof z.ZodNullable) {\n        baseSchema = baseSchema.unwrap();\n      }\n\n      switch (baseSchema._def.typeName) {\n        case z.ZodString.name:\n          type = 'string';\n          if (baseSchema instanceof z.ZodEnum) {\n            enumValues = baseSchema._def.values;\n          }\n          break;\n        case z.ZodNumber.name:\n          type = 'number';\n          break;\n        case z.ZodBoolean.name:\n          type = 'boolean';\n          break;\n        case z.ZodObject.name:\n          type = 'object';\n          break;\n        case z.ZodArray.name:\n          type = 'array';\n          break;\n        default:\n          type = 'any';\n      }\n\n      // Extract default value if available\n      if (fieldSchema._def.defaultValue !== undefined) {\n        defaultValue = fieldSchema._def.defaultValue();\n      } else if (fieldSchema._def.typeName === z.ZodEnum.name && fieldSchema._def.default !== undefined) {\n        defaultValue = fieldSchema._def.default;\n      }\n\n      params.push({\n        name: key,\n        type: type,\n        required: isRequired,\n        description: fieldSchema.description || '',\n        defaultValue: defaultValue,\n        enum: enumValues,\n      });\n    }\n    return params;\n  }\n  \n  /**\n   * Returns detailed capability information\n   */\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'Add Todo Item',\n        description: 'Adds a new item to the todo list',\n        requiredParameters: await this.getRequiredParameters('add_item')\n      },\n      {\n        name: 'Remove Todo Item',\n        description: 'Removes an item from the todo list',\n        requiredParameters: await this.getRequiredParameters('remove_item')\n      },\n      {\n        name: 'List Todo Items',\n        description: 'Lists all items in the todo list with optional filtering',\n        requiredParameters: await this.getRequiredParameters('list_items')\n      },\n      {\n        name: 'Update Todo Item',\n        description: 'Updates an existing item in the todo list',\n        requiredParameters: await this.getRequiredParameters('update_item')\n      },\n      {\n        name: 'Mark Todo Complete',\n        description: 'Marks a todo item as completed',\n        requiredParameters: await this.getRequiredParameters('mark_complete')\n      },\n      {\n        name: 'Mark Todo Incomplete',\n        description: 'Marks a todo item as incomplete',\n        requiredParameters: await this.getRequiredParameters('mark_incomplete')\n      },\n      {\n        name: 'Clear Completed Todos',\n        description: 'Removes all completed todos from the list',\n        requiredParameters: await this.getRequiredParameters('clear_completed')\n      }\n    ];\n  }\n\n  /**\n   * Validates input parameters\n   */\n  async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const intent = props.intent as TodoIntent || props.command as TodoIntent;\n    const parameters = props.parameters || {};\n    const errors: string[] = [];\n    \n    switch (intent) {\n      case 'add_item':\n        if (!parameters.text) {\n          errors.push('Todo item text is required');\n        }\n        if (parameters.priority && !['low', 'medium', 'high'].includes(parameters.priority as string)) {\n          errors.push('Priority must be low, medium, or high');\n        }\n        if (parameters.dueDate) {\n          try {\n            new Date(parameters.dueDate as string);\n          } catch (e) {\n            errors.push('Due date must be a valid date');\n          }\n        }\n        break;\n      case 'remove_item':\n      case 'mark_complete':\n      case 'mark_incomplete':\n      case 'update_item':\n        if (!parameters.id) {\n          errors.push('Todo item ID is required');\n        }\n        break;\n      case 'list_items':\n        if (parameters.filter && !['all', 'active', 'completed'].includes(parameters.filter as string)) {\n          errors.push('Filter must be all, active, or completed');\n        }\n        break;\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined\n    };\n  }\n\n  /**\n   * Adds a new item to the todo list\n   */\n  private addItem(text: string, priority?: string, dueDate?: string): any {\n    if (!text) throw new Error('Todo text is required');\n    \n    const { getState, setState } = useVisionAudioStore;\n    \n    // Create basic Todo object compatible with the store\n    const baseTodo = {\n      id: Date.now().toString(),\n      text\n    };\n    \n    // Add metadata for UI/functionality via data attributes\n    // Store extra properties in the text field using a special format that can be parsed later\n    // Format: text #meta:completed=false,priority=medium,dueDate=2025-07-10\n    const metaData = [];\n    metaData.push(`completed=false`);\n    if (priority) {\n      metaData.push(`priority=${priority}`);\n    }\n    if (dueDate) {\n      metaData.push(`dueDate=${dueDate}`);\n    }\n    metaData.push(`createdAt=${new Date().toISOString()}`);\n    \n    // Construct the full text with metadata\n    const todoWithMeta = {\n      ...baseTodo,\n      text: `${text} #meta:${metaData.join(',')}`\n    };\n    \n    setState({ todos: [...getState().todos, todoWithMeta] });\n    \n    // For the return value, parse the metadata back into proper fields\n    const todoItem = this.convertToTodoItem(todoWithMeta);\n    \n    return {\n      added: true,\n      item: todoItem,\n      totalItems: getState().todos.length\n    };\n  }\n\n  /**\n   * Helper method to convert a basic Todo to a TodoItem with metadata\n   */\n  private convertToTodoItem(todo: StoreTodo): TodoItem {\n    // Start with the base Todo properties\n    const todoItem: TodoItem = {\n      id: todo.id,\n      text: todo.text\n    };\n    \n    // Check if there's metadata in the text\n    const metaMatch = todo.text.match(/#meta:([^\\s]+)/);\n    if (metaMatch && metaMatch[1]) {\n      // Extract the original text without the metadata\n      todoItem.text = todo.text.replace(/#meta:[^\\s]+/, '').trim();\n      \n      // Parse the metadata\n      const metaParts = metaMatch[1].split(',');\n      metaParts.forEach(part => {\n        const [key, value] = part.split('=');\n        if (key && value) {\n          switch(key) {\n            case 'completed':\n              todoItem.completed = value === 'true';\n              break;\n            case 'priority':\n              todoItem.priority = value as 'low' | 'medium' | 'high';\n              break;\n            case 'dueDate':\n              todoItem.dueDate = value;\n              break;\n            case 'createdAt':\n              todoItem.createdAt = value;\n              break;\n            case 'updatedAt':\n              todoItem.updatedAt = value;\n              break;\n          }\n        }\n      });\n    }\n    \n    return todoItem;\n  }\n  \n  /**\n   * Helper method to convert a TodoItem back to a basic Todo with metadata in text\n   */\n  private convertToStoreTodo(todoItem: Partial<TodoItem>, originalTodo?: StoreTodo): StoreTodo {\n    // Start with the original text without metadata if it exists\n    let baseText = '';\n    if (originalTodo) {\n      baseText = originalTodo.text.replace(/#meta:[^\\s]+/, '').trim();\n    }\n    \n    // Use the new text if provided, otherwise use the cleaned base text\n    const text = todoItem.text || baseText;\n    \n    // Build metadata\n    const metaData = [];\n    \n    // Add all metadata properties\n    if (todoItem.completed !== undefined) {\n      metaData.push(`completed=${todoItem.completed}`);\n    }\n    if (todoItem.priority) {\n      metaData.push(`priority=${todoItem.priority}`);\n    }\n    if (todoItem.dueDate) {\n      metaData.push(`dueDate=${todoItem.dueDate}`);\n    }\n    if (todoItem.createdAt) {\n      metaData.push(`createdAt=${todoItem.createdAt}`);\n    }\n    \n    // Add updatedAt timestamp\n    metaData.push(`updatedAt=${new Date().toISOString()}`);\n    \n    // Create the todo with metadata\n    return {\n      id: todoItem.id || (originalTodo ? originalTodo.id : Date.now().toString()),\n      text: metaData.length > 0 ? `${text} #meta:${metaData.join(',')}` : text\n    };\n  }\n\n  /**\n   * Removes an item from the todo list\n   */\n  private removeItem(id: string): any {\n    if (!id) throw new Error('Todo ID is required');\n    \n    const { getState, setState } = useVisionAudioStore;\n    const currentTodos = getState().todos;\n    const todoToRemove = currentTodos.find(t => t.id === id);\n    \n    if (!todoToRemove) {\n      throw new Error('Todo item not found');\n    }\n    \n    const todoItem = this.convertToTodoItem(todoToRemove);\n    setState({ todos: currentTodos.filter(t => t.id !== id) });\n    \n    return {\n      removed: true,\n      item: todoItem,\n      remainingItems: getState().todos.length\n    };\n  }\n  \n  /**\n   * Updates an existing todo item\n   */\n  private updateItem(id: string, text?: string, priority?: string, dueDate?: string): any {\n    if (!id) throw new Error('Todo ID is required');\n    \n    const { getState, setState } = useVisionAudioStore;\n    const currentTodos = getState().todos;\n    const todoIndex = currentTodos.findIndex(t => t.id === id);\n    \n    if (todoIndex === -1) {\n      throw new Error('Todo item not found');\n    }\n    \n    // Get the current todo and convert to TodoItem\n    const currentTodo = currentTodos[todoIndex];\n    const currentTodoItem = this.convertToTodoItem(currentTodo);\n    \n    // Create updated TodoItem\n    const updatedTodoItem: Partial<TodoItem> = {\n      ...currentTodoItem,\n      id,\n      text: text || currentTodoItem.text,\n      priority: (priority as 'low' | 'medium' | 'high') || currentTodoItem.priority,\n      dueDate: dueDate !== undefined ? dueDate : currentTodoItem.dueDate\n    };\n    \n    // Convert back to store format\n    const updatedTodo = this.convertToStoreTodo(updatedTodoItem, currentTodo);\n    \n    // Update state\n    const newTodos = [...currentTodos];\n    newTodos[todoIndex] = updatedTodo;\n    setState({ todos: newTodos });\n    \n    return {\n      updated: true,\n      item: this.convertToTodoItem(updatedTodo)\n    };\n  }\n  \n  /**\n   * Marks an item as complete or incomplete\n   */\n  private markItemStatus(id: string, completed: boolean): any {\n    if (!id) throw new Error('Todo ID is required');\n    \n    const { getState, setState } = useVisionAudioStore;\n    const currentTodos = getState().todos;\n    const todoIndex = currentTodos.findIndex(t => t.id === id);\n    \n    if (todoIndex === -1) {\n      throw new Error('Todo item not found');\n    }\n    \n    // Get the current todo and convert to TodoItem\n    const currentTodo = currentTodos[todoIndex];\n    const currentTodoItem = this.convertToTodoItem(currentTodo);\n    \n    // Update the completed status\n    const updatedTodoItem: Partial<TodoItem> = {\n      ...currentTodoItem,\n      id,\n      completed\n    };\n    \n    // Convert back to store format\n    const updatedTodo = this.convertToStoreTodo(updatedTodoItem, currentTodo);\n    \n    // Update state\n    const newTodos = [...currentTodos];\n    newTodos[todoIndex] = updatedTodo;\n    setState({ todos: newTodos });\n    \n    return {\n      updated: true,\n      item: this.convertToTodoItem(updatedTodo),\n      completed\n    };\n  }\n  \n  /**\n   * Clears all completed todos\n   */\n  private clearCompleted(): any {\n    const { getState, setState } = useVisionAudioStore;\n    const currentTodos = getState().todos;\n    \n    // Convert all todos to TodoItems to check completion status\n    const todoItems = currentTodos.map(todo => this.convertToTodoItem(todo));\n    const completedTodos = todoItems.filter(t => t.completed);\n    const activeTodos = currentTodos.filter(t => {\n      const todoItem = this.convertToTodoItem(t);\n      return !todoItem.completed;\n    });\n    \n    setState({ todos: activeTodos });\n    \n    return {\n      cleared: true,\n      removedCount: completedTodos.length,\n      remainingCount: activeTodos.length\n    };\n  }\n\n  /**\n   * Returns the todo list, optionally filtered\n   */\n  private listItems(filter: string = 'all'): any {\n    const todos = useVisionAudioStore.getState().todos;\n    const todoItems = todos.map(todo => this.convertToTodoItem(todo));\n    \n    let filteredTodos;\n    switch(filter) {\n      case 'active':\n        filteredTodos = todoItems.filter(t => !t.completed);\n        break;\n      case 'completed':\n        filteredTodos = todoItems.filter(t => t.completed);\n        break;\n      case 'all':\n      default:\n        filteredTodos = todoItems;\n        break;\n    }\n    \n    return {\n      filter,\n      items: filteredTodos,\n      count: filteredTodos.length,\n      totalCount: todos.length\n    };\n  }\n}\n\n// Register a valid instance of the agent with the registry.\nconst todoAgent = new TodoAgent();\n\n// Add valid property required by BaseAgent interface\nObject.defineProperty(todoAgent, 'valid', {\n  value: true,\n  writable: false,\n  enumerable: true\n});\n\nagentRegistry.register(todoAgent);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\TransformAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[852,855],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[852,855],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1637,1640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1637,1640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1932,1935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1932,1935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1938,1941],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1938,1941],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":69,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":69,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2572,2575],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2572,2575],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomains } from \"./types\";\n\nexport class TransformAgent implements BaseAgent {\n  name = \"TransformAgent\";\n  description = \"Handles data transformation nodes in workflows.\";\n  version = \"0.1.0\";\n  domain = AgentDomains.ANALYSIS;\n  capabilities = [\"transform\"];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { intent, parameters } = props;\n\n    if (intent !== \"transform\") {\n      return { success: false, output: null, error: `Unknown intent: ${intent}` };\n    }\n\n    const { template, expression, input, context } = parameters;\n\n    if (template && template.includes('{{')) {\n      // Template-based transformation\n      try {\n        const output = this.applyTemplate(template, input);\n        return { success: true, output };\n      } catch (error: any) {\n        return { success: false, output: null, error: `Template application failed: ${error.message}` };\n      }\n    } else if (expression) {\n      // Expression evaluation (requires WorkflowCodeAgent or similar for safe execution)\n      // For now, we'll simulate or require an external code execution agent\n      // In a real scenario, this would delegate to a secure code execution environment.\n      try {\n        // This is a placeholder for actual expression evaluation.\n        // In a real system, you'd use a secure sandbox or a dedicated code execution agent.\n        const func = new Function('input', 'context', `with (context) { return ${expression}; }`);\n        const output = func(input, context);\n        return { success: true, output };\n      } catch (error: any) {\n        return { success: false, output: null, error: `Expression evaluation failed: ${error.message}` };\n      }\n    } else {\n      // Passthrough if no transformation defined\n      return { success: true, output: input };\n    }\n  }\n\n  private applyTemplate(template: string, inputData: any): any {\n    if (!template.includes('{{')) {\n      return template;\n    }\n\n    return template.replace(/\\{\\{([^}]+)\\}\\}/g, (match, path) => {\n      try {\n        const parts = path.trim().split('.');\n        let value = inputData;\n\n        for (const part of parts) {\n          if (part === 'input') {\n            value = inputData;\n          } else {\n            value = value?.[part];\n          }\n\n          if (value === undefined) {\n            return match; // Keep the template if the value is undefined\n          }\n        }\n\n        return typeof value === 'object' ? JSON.stringify(value) : String(value);\n      } catch (error: any) {\n        throw new Error(`Template path evaluation error for '${path}': ${error.message}`);\n      }\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\TranslationAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2126,2129],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2126,2129],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":69,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":69,"endColumn":50},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":95,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":95,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2824,2827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2824,2827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":123,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":123,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3440,3443],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3440,3443],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'params' is defined but never used. Allowed unused args must match /^_/u.","line":155,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":155,"endColumn":45},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4203,4206],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4203,4206],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'context' is defined but never used. Allowed unused args must match /^_/u.","line":186,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":186,"endColumn":41},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":186,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":186,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5090,5093],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5090,5093],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TranslationAgent - Multi-language Translation\n * \n * Provides contextual translation with cultural adaptation\n */\n\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult, AgentDomain } from './types';\nimport { AgentDomains } from './types';\n\nexport class TranslationAgent implements BaseAgent {\n  name = 'TranslationAgent';\n  description = 'Translates content between languages with contextual and cultural adaptation';\n  version = '1.0.0';\n  domain: AgentDomain = AgentDomains.PRODUCTIVITY;\n  capabilities = [\n    'text_translation',\n    'language_detection',\n    'cultural_adaptation',\n    'contextual_translation',\n    'batch_translation',\n    'terminology_management'\n  ];\n\n  private supportedLanguages = [\n    { code: 'en', name: 'English' },\n    { code: 'fr', name: 'Fran├ºais' },\n    { code: 'es', name: 'Espa├▒ol' },\n    { code: 'de', name: 'Deutsch' },\n    { code: 'it', name: 'Italiano' },\n    { code: 'pt', name: 'Portugu├¬s' },\n    { code: 'zh', name: 'õ©¡µûç' },\n    { code: 'ja', name: 'µùÑµ£¼Þ¬×' },\n    { code: 'ar', name: 'Ïº┘äÏ╣Ï▒Ï¿┘èÏ®' }\n  ];\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { intent, parameters } = props;\n\n    try {\n      switch (intent) {\n        case 'translate':\n          return await this.translate(parameters);\n        case 'detect_language':\n          return await this.detectLanguage(parameters);\n        case 'batch_translate':\n          return await this.batchTranslate(parameters);\n        case 'get_languages':\n          return await this.getSupportedLanguages(parameters);\n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: { executionTime: Date.now() - startTime, timestamp: Date.now() }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: { executionTime: Date.now() - startTime, timestamp: Date.now() }\n      };\n    }\n  }\n\n  private async translate(params: any): Promise<AgentExecuteResult> {\n    const { text, sourceLang, targetLang, context } = params;\n\n    if (!text || !targetLang) {\n      return {\n        success: false,\n        output: null,\n        error: 'Text and target language are required'\n      };\n    }\n\n    // TODO: Integrate with translation API (Google Translate, DeepL)\n    return {\n      success: true,\n      output: {\n        translatedText: `[Translation to ${targetLang}: ${text}]`,\n        sourceLang: sourceLang || 'auto-detected',\n        targetLang,\n        confidence: 0.85\n      },\n      metadata: {\n        source: 'TranslationAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async detectLanguage(params: any): Promise<AgentExecuteResult> {\n    const { text } = params;\n\n    if (!text) {\n      return {\n        success: false,\n        output: null,\n        error: 'Text is required'\n      };\n    }\n\n    // Simple language detection based on common words\n    const detectedLang = this.simpleLanguageDetection(text);\n\n    return {\n      success: true,\n      output: {\n        language: detectedLang.code,\n        languageName: detectedLang.name,\n        confidence: 0.75\n      },\n      metadata: {\n        source: 'TranslationAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async batchTranslate(params: any): Promise<AgentExecuteResult> {\n    const { texts, sourceLang, targetLang } = params;\n\n    if (!texts || !Array.isArray(texts) || !targetLang) {\n      return {\n        success: false,\n        output: null,\n        error: 'Texts array and target language are required'\n      };\n    }\n\n    const translations = texts.map((text, index) => ({\n      original: text,\n      translated: `[Translation ${index + 1}]`,\n      index\n    }));\n\n    return {\n      success: true,\n      output: {\n        translations,\n        count: translations.length,\n        sourceLang: sourceLang || 'auto',\n        targetLang\n      },\n      metadata: {\n        source: 'TranslationAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private async getSupportedLanguages(params: any): Promise<AgentExecuteResult> {\n    return {\n      success: true,\n      output: {\n        languages: this.supportedLanguages,\n        count: this.supportedLanguages.length\n      },\n      metadata: {\n        source: 'TranslationAgent',\n        timestamp: Date.now()\n      }\n    };\n  }\n\n  private simpleLanguageDetection(text: string): { code: string; name: string } {\n    const lowerText = text.toLowerCase();\n\n    // Simple keyword-based detection\n    if (lowerText.match(/\\b(the|and|is|in|to|of)\\b/)) {\n      return { code: 'en', name: 'English' };\n    }\n    if (lowerText.match(/\\b(le|la|les|et|est|dans|de)\\b/)) {\n      return { code: 'fr', name: 'Fran├ºais' };\n    }\n    if (lowerText.match(/\\b(el|la|los|y|es|en|de)\\b/)) {\n      return { code: 'es', name: 'Espa├▒ol' };\n    }\n\n    return { code: 'en', name: 'English' }; // default\n  }\n\n  async canHandle(query: string, context?: any): Promise<number> {\n    const keywords = [\n      'translate', 'translation', 'language', 'translate',\n      'traduire', 'traduction', 'langue',\n      'traducir', 'traducci├│n', 'idioma'\n    ];\n\n    const lowerQuery = query.toLowerCase();\n    const matches = keywords.filter(keyword => lowerQuery.includes(keyword));\n    return matches.length > 0 ? Math.min(matches.length * 0.3, 1.0) : 0.0;\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\TriggerAgent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\UserWorkflowAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AgentExecuteResult' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":57},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":26,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":29,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[701,704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[701,704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[856,859],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[856,859],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2208,2211],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2208,2211],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":185,"column":27,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":185,"endColumn":30,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5461,5464],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5461,5464],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-useless-escape","severity":2,"message":"Unnecessary escape character: \\..","line":378,"column":65,"nodeType":"Literal","messageId":"unnecessaryEscape","endLine":378,"endColumn":66,"suggestions":[{"messageId":"removeEscape","fix":{"range":[11204,11205],"text":""},"desc":"Remove the `\\`. This maintains the current functionality."},{"messageId":"escapeBackslash","fix":{"range":[11204,11204],"text":"\\"},"desc":"Replace the `\\` with `\\\\` to include the actual backslash character."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * agents/UserWorkflowAgent.ts\n * \n * Agent sp├®cialis├® pour la gestion des workflows d├®finis par l'utilisateur.\n * Permet aux utilisateurs de cr├®er, ex├®cuter et g├®rer des workflows personnalis├®s\n * via des commandes en langage naturel.\n */\n\nimport type { BaseAgent, AgentDomain, AgentExecuteResult } from './types';\nimport { AgentDomains } from './types';\nimport { workflowEngine, type WorkflowTemplate } from '../utils/WorkflowEngine';\nimport { agentRegistry } from './registry';\nimport { v4 as uuidv4 } from 'uuid';\n\nexport interface WorkflowDefinition {\n  name: string;\n  description: string;\n  trigger: string;\n  steps: Array<{\n    agent: string;\n    command: string;\n    args: Record<string, any>;\n    description: string;\n    dependencies?: number[];\n  }>;\n}\n\nexport interface UserWorkflowAction {\n  intent: string;\n  parameters?: Record<string, any>;\n}\n\nexport class UserWorkflowAgent implements BaseAgent {\n  id: string;\n  name: string;\n  description: string;\n  version: string;\n  domain: AgentDomain;\n  capabilities: string[];\n  userWorkflows: Map<string, WorkflowDefinition>;\n  triggerMap: Map<string, string>; // Map trigger phrases to workflow IDs\n\n  constructor() {\n    this.id = 'user-workflow-agent';\n    this.name = 'User Workflow Agent';\n    this.description = 'Agent pour la gestion des workflows personnalis├®s d├®finis par l\\'utilisateur';\n    this.version = '1.0.0';\n    this.domain = AgentDomains.PRODUCTIVITY;\n    this.capabilities = [\n      'workflow-creation', \n      'workflow-execution', \n      'workflow-management'\n    ];\n    this.userWorkflows = new Map();\n    this.triggerMap = new Map();\n\n    // Charger les workflows existants depuis le stockage\n    this.loadUserWorkflows();\n  }\n\n  /**\n   * Ex├®cute une action demand├®e en fonction de l'intention\n   */\n  async execute(props: UserWorkflowAction): Promise<IntentResult> {\n    const { intent, parameters = {} } = props;\n\n    try {\n      switch (intent) {\n        case 'create_workflow':\n          return await this.createWorkflow(parameters as { definition: WorkflowDefinition });\n        \n        case 'execute_workflow':\n          return await this.executeWorkflow(parameters as { workflowId: string, args?: Record<string, any> });\n\n        case 'get_workflows':\n          return await this.getWorkflows();\n\n        case 'delete_workflow':\n          return await this.deleteWorkflow(parameters as { workflowId: string });\n\n        case 'update_workflow':\n          return await this.updateWorkflow(parameters as { workflowId: string, updates: Partial<WorkflowDefinition> });\n\n        case 'parse_natural_language_workflow':\n          return await this.parseNaturalLanguageWorkflow(parameters as { instruction: string });\n          \n        case 'check_trigger_match':\n          return await this.checkTriggerMatch(parameters as { phrase: string });\n\n        default:\n          return {\n            success: false,\n            error: `Intent \"${intent}\" non pris en charge par l'UserWorkflowAgent`\n          };\n      }\n    } catch (error) {\n      console.error('Erreur dans UserWorkflowAgent:', error);\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Cr├®e un nouveau workflow d├®fini par l'utilisateur\n   */\n  private async createWorkflow(params: {\n    definition: WorkflowDefinition\n  }): Promise<IntentResult> {\n    try {\n      const { definition } = params;\n      \n      // Valider la d├®finition\n      this.validateWorkflowDefinition(definition);\n      \n      // Cr├®er un ID unique pour ce workflow\n      const workflowId = uuidv4();\n      \n      // Enregistrer dans la map locale\n      this.userWorkflows.set(workflowId, definition);\n      \n      // Mapper le d├®clencheur au workflow\n      this.triggerMap.set(definition.trigger.toLowerCase(), workflowId);\n\n      // Sauvegarder dans le stockage\n      this.saveUserWorkflows();\n      \n      // Cr├®er un template correspondant dans le WorkflowEngine\n      const template = this.convertToTemplate(workflowId, definition);\n      \n      return {\n        success: true,\n        message: `Workflow \"${definition.name}\" cr├®├® avec succ├¿s`,\n        output: {\n          workflowId,\n          definition,\n          template\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Convertit une d├®finition de workflow en template pour le WorkflowEngine\n   */\n  private convertToTemplate(workflowId: string, definition: WorkflowDefinition): WorkflowTemplate {\n    const steps = definition.steps.map((step, index) => {\n      return {\n        id: index + 1,\n        description: step.description,\n        agent: step.agent,\n        command: step.command,\n        args: step.args || {},\n        dependencies: step.dependencies || []\n      };\n    });\n\n    const template: WorkflowTemplate = {\n      id: workflowId,\n      name: definition.name,\n      description: definition.description,\n      steps,\n      tags: ['user-defined'],\n      createdAt: Date.now(),\n      updatedAt: Date.now()\n    };\n\n    // Enregistrer le template dans le WorkflowEngine\n    workflowEngine.saveAsTemplate(workflowId, definition.name, definition.description, ['user-defined']);\n    \n    return template;\n  }\n\n  /**\n   * Ex├®cute un workflow existant\n   */\n  private async executeWorkflow(params: {\n    workflowId: string,\n    args?: Record<string, any>\n  }): Promise<IntentResult> {\n    try {\n      const { workflowId, args = {} } = params;\n      \n      // V├®rifier si le workflow existe\n      if (!this.userWorkflows.has(workflowId)) {\n        return {\n          success: false,\n          error: `Workflow avec ID ${workflowId} non trouv├®`\n        };\n      }\n      \n      // R├®cup├®rer la d├®finition\n      const definition = this.userWorkflows.get(workflowId)!;\n      \n      // Cr├®er un workflow ├á partir du template et l'ex├®cuter\n      const workflow = workflowEngine.createWorkflow({\n        name: definition.name,\n        description: definition.description,\n        templateId: workflowId\n      });\n      \n      // Mettre ├á jour les arguments avec ceux fournis\n      workflow.steps.forEach(step => {\n        if (args[step.id]) {\n          step.args = { ...step.args, ...args[step.id] };\n        }\n      });\n      \n      // Ex├®cuter le workflow\n      const result = await workflowEngine.executeWorkflow(workflow.id);\n      \n      return {\n        success: true,\n        message: `Workflow \"${definition.name}\" ex├®cut├® avec succ├¿s`,\n        output: { result }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * R├®cup├¿re la liste des workflows d├®finis par l'utilisateur\n   */\n  private async getWorkflows(): Promise<IntentResult> {\n    try {\n      const workflows = Array.from(this.userWorkflows.entries()).map(([id, def]) => ({\n        id,\n        name: def.name,\n        description: def.description,\n        trigger: def.trigger,\n        stepCount: def.steps.length\n      }));\n      \n      return {\n        success: true,\n        output: { workflows }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Supprime un workflow existant\n   */\n  private async deleteWorkflow(params: { workflowId: string }): Promise<IntentResult> {\n    try {\n      const { workflowId } = params;\n      \n      if (!this.userWorkflows.has(workflowId)) {\n        return {\n          success: false,\n          error: `Workflow avec ID ${workflowId} non trouv├®`\n        };\n      }\n      \n      const definition = this.userWorkflows.get(workflowId)!;\n      \n      // Supprimer le mapping du trigger\n      this.triggerMap.delete(definition.trigger.toLowerCase());\n      \n      // Supprimer le workflow\n      this.userWorkflows.delete(workflowId);\n      \n      // Sauvegarder les changements\n      this.saveUserWorkflows();\n      \n      return {\n        success: true,\n        message: `Workflow \"${definition.name}\" supprim├® avec succ├¿s`\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Met ├á jour un workflow existant\n   */\n  private async updateWorkflow(params: {\n    workflowId: string,\n    updates: Partial<WorkflowDefinition>\n  }): Promise<IntentResult> {\n    try {\n      const { workflowId, updates } = params;\n      \n      if (!this.userWorkflows.has(workflowId)) {\n        return {\n          success: false,\n          error: `Workflow avec ID ${workflowId} non trouv├®`\n        };\n      }\n      \n      const definition = this.userWorkflows.get(workflowId)!;\n      \n      // Si le d├®clencheur change, mettre ├á jour le mapping\n      if (updates.trigger && updates.trigger !== definition.trigger) {\n        this.triggerMap.delete(definition.trigger.toLowerCase());\n        this.triggerMap.set(updates.trigger.toLowerCase(), workflowId);\n      }\n      \n      // Mettre ├á jour la d├®finition\n      const updatedDefinition: WorkflowDefinition = {\n        ...definition,\n        ...updates,\n        steps: updates.steps || definition.steps\n      };\n      \n      // Valider la d├®finition mise ├á jour\n      this.validateWorkflowDefinition(updatedDefinition);\n      \n      // Mettre ├á jour le workflow\n      this.userWorkflows.set(workflowId, updatedDefinition);\n      \n      // Sauvegarder les changements\n      this.saveUserWorkflows();\n      \n      // Mettre ├á jour le template dans WorkflowEngine\n      this.convertToTemplate(workflowId, updatedDefinition);\n      \n      return {\n        success: true,\n        message: `Workflow \"${updatedDefinition.name}\" mis ├á jour avec succ├¿s`,\n        output: { updatedDefinition }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Analyse une instruction en langage naturel pour cr├®er un workflow\n   */\n  private async parseNaturalLanguageWorkflow(params: {\n    instruction: string\n  }): Promise<IntentResult> {\n    try {\n      const { instruction } = params;\n      \n      // Analyser l'instruction pour extraire:\n      // 1. Le d├®clencheur (phrase qui activera le workflow)\n      // 2. Les ├®tapes ├á ex├®cuter\n      \n      // Exemple: \"Lisa, quand je dis 'commencer ma journ├®e de travail', je veux que tu ouvres VS Code, lances mon serveur et joues ma playlist\"\n      \n      // Cette fonction serait normalement impl├®ment├®e avec un LLM pour interpr├®ter le langage naturel\n      // Simulation d'analyse simple (├á remplacer par appel ├á un mod├¿le LLM)\n      const triggerMatch = instruction.match(/quand je dis ['\"]([^'\"]+)['\"]/i);\n      const trigger = triggerMatch ? triggerMatch[1] : '';\n      \n      if (!trigger) {\n        return {\n          success: false,\n          error: \"Impossible de d├®terminer la phrase d├®clencheur dans l'instruction\"\n        };\n      }\n\n      // Trouver les actions ├á effectuer (apr├¿s \"je veux que tu\")\n      const actionsMatch = instruction.match(/je veux que tu ([^\\.]+)/i);\n      const actionsText = actionsMatch ? actionsMatch[1] : '';\n      \n      if (!actionsText) {\n        return {\n          success: false,\n          error: \"Impossible de d├®terminer les actions ├á effectuer dans l'instruction\"\n        };\n      }\n      \n      // Diviser les actions (s├®par├®es par \"et\" ou des virgules)\n      const actionsList = actionsText\n        .split(/,|\\set\\s/)\n        .map(a => a.trim())\n        .filter(a => a.length > 0);\n      \n      // Cr├®er un nom pour le workflow bas├® sur le trigger\n      const name = `Workflow: ${trigger}`;\n      \n      // Simuler la g├®n├®ration de steps (dans une impl├®mentation r├®elle, on utiliserait un LLM pour d├®terminer\n      // quels agents et commandes utiliser pour chaque action)\n      const steps = actionsList.map((action, index) => {\n        // Version tr├¿s simplifi├®e - dans une impl├®mentation r├®elle,\n        // on analyserait chaque action pour d├®terminer l'agent et la commande appropri├®s\n        return {\n          agent: 'PlannerAgent', // Par d├®faut, on utilise le PlannerAgent\n          command: 'execute_plan',\n          args: { instruction: action },\n          description: `Ex├®cuter: ${action}`,\n          dependencies: index > 0 ? [index] : [] // Chaque ├®tape d├®pend de la pr├®c├®dente\n        };\n      });\n      \n      // Cr├®er une d├®finition de workflow\n      const definition: WorkflowDefinition = {\n        name,\n        description: `Workflow cr├®├® ├á partir de l'instruction: \"${instruction}\"`,\n        trigger,\n        steps\n      };\n      \n      return {\n        success: true,\n        message: `Workflow analys├® avec succ├¿s ├á partir de l'instruction`,\n        output: { definition }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * V├®rifie si une phrase correspond ├á un d├®clencheur de workflow\n   */\n  private async checkTriggerMatch(params: { phrase: string }): Promise<IntentResult> {\n    try {\n      const { phrase } = params;\n      const lowercasePhrase = phrase.toLowerCase();\n      \n      // Chercher une correspondance exacte\n      if (this.triggerMap.has(lowercasePhrase)) {\n        const workflowId = this.triggerMap.get(lowercasePhrase)!;\n        const workflow = this.userWorkflows.get(workflowId)!;\n        \n        return {\n          success: true,\n          output: {\n            matched: true,\n            workflowId,\n            workflow\n          }\n        };\n      }\n      \n      // Chercher une correspondance partielle\n      let bestMatch: { workflowId: string; workflow: WorkflowDefinition; score: number } | null = null;\n      \n      for (const [trigger, workflowId] of this.triggerMap.entries()) {\n        // Calculer un score de similarit├® simple\n        // (une impl├®mentation plus avanc├®e utiliserait des algorithmes comme Levenshtein)\n        const words = trigger.split(' ');\n        const phraseWords = lowercasePhrase.split(' ');\n        \n        let matchingWords = 0;\n        for (const word of words) {\n          if (phraseWords.includes(word)) {\n            matchingWords++;\n          }\n        }\n        \n        const score = matchingWords / words.length;\n        \n        // Si le score est sup├®rieur ├á un seuil et meilleur que le pr├®c├®dent\n        if (score > 0.7 && (!bestMatch || score > bestMatch.score)) {\n          bestMatch = {\n            workflowId,\n            workflow: this.userWorkflows.get(workflowId)!,\n            score\n          };\n        }\n      }\n      \n      if (bestMatch) {\n        return {\n          success: true,\n          output: {\n            matched: true,\n            partialMatch: true,\n            confidence: bestMatch.score,\n            workflowId: bestMatch.workflowId,\n            workflow: bestMatch.workflow\n          }\n        };\n      }\n      \n      return {\n        success: true,\n        output: {\n          matched: false\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : String(error)\n      };\n    }\n  }\n\n  /**\n   * Valide la structure d'une d├®finition de workflow\n   */\n  private validateWorkflowDefinition(definition: WorkflowDefinition): void {\n    if (!definition.name || definition.name.trim() === '') {\n      throw new Error('Le workflow doit avoir un nom');\n    }\n    \n    if (!definition.trigger || definition.trigger.trim() === '') {\n      throw new Error('Le workflow doit avoir une phrase d├®clencheur');\n    }\n    \n    if (!definition.steps || definition.steps.length === 0) {\n      throw new Error('Le workflow doit avoir au moins une ├®tape');\n    }\n    \n    // V├®rifier que chaque ├®tape a un agent et une commande\n    definition.steps.forEach((step, index) => {\n      if (!step.agent) {\n        throw new Error(`L'├®tape ${index + 1} doit sp├®cifier un agent`);\n      }\n      \n      if (!step.command) {\n        throw new Error(`L'├®tape ${index + 1} doit sp├®cifier une commande`);\n      }\n      \n      // V├®rifier que les d├®pendances font r├®f├®rence ├á des ├®tapes valides\n      if (step.dependencies) {\n        step.dependencies.forEach(depId => {\n          if (depId < 1 || depId > definition.steps.length) {\n            throw new Error(`L'├®tape ${index + 1} a une d├®pendance invalide: ${depId}`);\n          }\n        });\n      }\n    });\n  }\n\n  /**\n   * Sauvegarde les workflows dans le stockage local\n   */\n  private saveUserWorkflows(): void {\n    try {\n      // Convertir la Map en objet pour le stockage\n      const workflowsObj = Object.fromEntries(this.userWorkflows.entries());\n      const triggerMapObj = Object.fromEntries(this.triggerMap.entries());\n      \n      localStorage.setItem('lisa_user_workflows', JSON.stringify(workflowsObj));\n      localStorage.setItem('lisa_workflow_triggers', JSON.stringify(triggerMapObj));\n    } catch (error) {\n      console.error('Erreur lors de la sauvegarde des workflows utilisateur:', error);\n    }\n  }\n\n  /**\n   * Charge les workflows depuis le stockage local\n   */\n  private loadUserWorkflows(): void {\n    try {\n      const workflowsJson = localStorage.getItem('lisa_user_workflows');\n      const triggersJson = localStorage.getItem('lisa_workflow_triggers');\n      \n      if (workflowsJson) {\n        const workflowsObj = JSON.parse(workflowsJson);\n        this.userWorkflows = new Map(Object.entries(workflowsObj));\n      }\n      \n      if (triggersJson) {\n        const triggerMapObj = JSON.parse(triggersJson);\n        this.triggerMap = new Map(Object.entries(triggerMapObj));\n      }\n    } catch (error) {\n      console.error('Erreur lors du chargement des workflows utilisateur:', error);\n    }\n  }\n}\n\n// Enregistrer l'agent dans le registry\nagentRegistry.register(new UserWorkflowAgent() as BaseAgent);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\VisionAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4396,4399],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4396,4399],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":166,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":166,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5450,5453],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5450,5453],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5493,5496],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5493,5496],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'e' is defined but never used.","line":206,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":206,"endColumn":17},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'options' is defined but never used. Allowed unused args must match /^_/u.","line":226,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":226,"endColumn":12},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":240,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":240,"endColumn":69,"suggestions":[{"messageId":"addBrackets","fix":{"range":[8222,8819],"text":"{ if (!this.objectDetector) throw new Error('Object Detector not initialized.');\n        const detections = this.objectDetector.detect(imageElement);\n        return {\n          objects: detections.detections.map(d => ({\n            name: d.categories[0].categoryName,\n            confidence: d.categories[0].score,\n            boundingBox: {\n              x: d.boundingBox.originX,\n              y: d.boundingBox.originY,\n              width: d.boundingBox.width,\n              height: d.boundingBox.height,\n            },\n          })),\n          processingTimeMs: Date.now() - startTime\n        }; }"},"desc":"Add {} brackets around the case block."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":286,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":286,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10219,10222],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10219,10222],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":318,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11229,11232],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11229,11232],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":566,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":566,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19653,19656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19653,19656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * VisionAgent: Agent sp├®cialis├® pour la vision par ordinateur\n * \n * Cet agent permet ├á Lisa d'analyser et de d├®crire ce qu'elle voit\n * via la webcam ou ├á partir d'images fournies.\n */\n\n// L'import de agentRegistry est supprim├® car il n'est pas utilis├® directement dans ce fichier\nimport * as tf from '@tensorflow/tfjs';\nimport { ObjectDetector, FilesetResolver, FaceLandmarker } from '@mediapipe/tasks-vision';\nimport type { \n  AgentCapability, \n  AgentDomain,\n  AgentExecuteProps, \n  AgentExecuteResult, \n  BaseAgent\n} from './types';\nimport { AgentDomains } from './types';\n\n// Types sp├®cifiques ├á la Vision\nexport type VisionSource = 'webcam' | 'screenshot' | 'file' | 'url';\nexport type VisionIntent = 'describe_scene' | 'detect_objects' | 'analyze_image' | 'get_capabilities';\nexport type VisionTask = 'general_description' | 'object_detection' | 'face_detection' | 'landmark_detection' | 'color_analysis' | 'semantic_segmentation';\n\nexport interface VisionOptions {\n  maxResults?: number;\n  confidenceThreshold?: number; // Seuil de confiance minimum (0-1)\n  includeAttributes?: boolean;\n  language?: string;\n  region?: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n}\n\nexport interface DetectedObject {\n  name: string;\n  confidence: number;\n  boundingBox?: {\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n  };\n  attributes?: Record<string, string | number>;\n}\n\nexport interface VisionResult {\n  description?: string;\n  objects?: DetectedObject[];\n  sceneCategories?: Array<{category: string, confidence: number}>;\n  faceCount?: number;\n  dominantColors?: Array<{color: string, percentage: number}>;\n  emotions?: Record<string, number>[];\n  segmentationMap?: number[][];\n  processingTimeMs?: number;\n}\n\n/**\n * Agent pour la vision par ordinateur\n */\nexport class VisionAgent implements BaseAgent {\n  name = 'VisionAgent';\n  description = 'Analyzes and describes visual content from webcam, screenshots, or images';\n  version = '1.0.0';\n  domain = AgentDomains.ANALYSIS as AgentDomain;\n  capabilities = ['scene_description', 'object_detection', 'image_analysis'];\n  valid = true;\n  \n  // V├®rifie si la vision est disponible\n  private checkAvailability(): boolean {\n    // Dans une vraie impl├®mentation, v├®rifier si les APIs n├®cessaires sont disponibles\n    // Par exemple MediaDevices API et un mod├¿le de vision ML\n    \n    // Pour cette d├®mo, on va simplement retourner true\n    return true;\n  }\n\n  // Acc├®der ├á la webcam\n  private async getWebcamStream(): Promise<MediaStream | null> {\n    try {\n      // Tentative d'acc├¿s ├á la webcam via l'API MediaDevices\n      const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n      return stream;\n    } catch (error) {\n      console.error('Failed to access webcam:', error);\n      return null;\n    }\n  }\n\n  // Capturer une image depuis la webcam\n  private async captureWebcamImage(): Promise<string | null> {\n    const stream = await this.getWebcamStream();\n    if (!stream) return null;\n\n    return new Promise((resolve, reject) => {\n      const video = document.createElement('video');\n      video.srcObject = stream;\n      video.onloadedmetadata = () => {\n        video.play();\n        const canvas = document.createElement('canvas');\n        canvas.width = video.videoWidth;\n        canvas.height = video.videoHeight;\n        const context = canvas.getContext('2d');\n        \n        if (!context) {\n          stream.getTracks().forEach(track => track.stop());\n          reject(new Error('Could not get canvas context'));\n          return;\n        }\n\n        // Draw video frame to canvas\n        context.drawImage(video, 0, 0, canvas.width, canvas.height);\n        \n        // Stop the stream\n        stream.getTracks().forEach(track => track.stop());\n        \n        // Resolve with base64 encoded image\n        resolve(canvas.toDataURL('image/png'));\n      };\n      video.onerror = (err) => {\n        stream.getTracks().forEach(track => track.stop());\n        reject(new Error(`Video error: ${err}`));\n      };\n    });\n  }\n\n  // Capturer une capture d'├®cran\n  private async captureScreenshot(): Promise<string | null> {\n    try {\n      const stream = await navigator.mediaDevices.getDisplayMedia({ video: true });\n      return await new Promise((resolve, reject) => {\n        const video = document.createElement('video');\n        video.srcObject = stream as any;\n        video.onloadedmetadata = () => {\n          video.play();\n          const canvas = document.createElement('canvas');\n          canvas.width = video.videoWidth;\n          canvas.height = video.videoHeight;\n          const context = canvas.getContext('2d');\n          if (!context) {\n            stream.getTracks().forEach(t => t.stop());\n            reject(new Error('Could not get canvas context'));\n            return;\n          }\n          context.drawImage(video, 0, 0, canvas.width, canvas.height);\n          stream.getTracks().forEach(t => t.stop());\n          resolve(canvas.toDataURL());\n        };\n        video.onerror = (err) => {\n          stream.getTracks().forEach(t => t.stop());\n          reject(new Error(`Video error: ${err}`));\n        };\n      });\n    } catch (error) {\n      console.error('Error capturing screenshot:', error);\n      return null;\n    }\n  }\n\n  private objectDetector: ObjectDetector | null = null;\n  private faceLandmarker: FaceLandmarker | null = null;\n  private isInitialized = false;\n  private faceapi: any | null = null;\n  private deeplabModel: any = null;\n\n  constructor() {\n    this.initializeDetectors();\n  }\n\n  private async initializeDetectors() {\n    try {\n      const vision = await FilesetResolver.forVisionTasks(\n        'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'\n      );\n      this.objectDetector = await ObjectDetector.createFromOptions(vision, {\n        baseOptions: {\n          modelAssetPath: `https://storage.googleapis.com/mediapipe-models/object_detector/efficientdet_lite0/float16/1/efficientdet_lite0.tflite`,\n        },\n        scoreThreshold: 0.5,\n        runningMode: 'IMAGE',\n      });\n      this.faceLandmarker = await FaceLandmarker.createFromOptions(vision, {\n        baseOptions: {\n          modelAssetPath: `https://storage.googleapis.com/mediapipe-models/face_landmarker/face_landmarker_with_blendshapes.task`,\n        },\n        runningMode: 'IMAGE',\n        outputFaceBlendshapes: true,\n        outputFacialTransformationMatrixes: true,\n      });\n\n      // Load face-api.js models (dynamically, optional)\n      try {\n        const modName = 'face-api.js';\n        const faceapi = await import(/* @vite-ignore */ modName);\n        this.faceapi = faceapi;\n        const MODEL_URL = '/models'; // Assuming models are served from /public/models\n        await faceapi.nets.tinyFaceDetector.load(MODEL_URL);\n        await faceapi.nets.faceLandmark68Net.load(MODEL_URL);\n        await faceapi.nets.faceExpressionNet.load(MODEL_URL);\n        await faceapi.nets.ssdMobilenetv1.load(MODEL_URL);\n        await faceapi.nets.tinyYolov2.load(MODEL_URL);\n        await faceapi.nets.mtcnn.load(MODEL_URL);\n      } catch (e) {\n        console.warn('face-api.js not available, skipping face-api initialization');\n        this.faceapi = null;\n      }\n\n      // Load DeepLab v3 model for semantic segmentation\n      this.deeplabModel = await tf.loadGraphModel('https://tfhub.dev/tensorflow/deeplabv3/1/lite/1');\n\n      this.isInitialized = true;\n\n      console.log('MediaPipe Object Detector, Face Landmarker, face-api.js models, and DeepLab v3 initialized.');\n    } catch (error) {\n      console.error('Failed to initialize MediaPipe detectors and face-api.js models:', error);\n    }\n  }\n\n  // Analyser une image\n  private async analyzeImage(\n    imageData: string, \n    task: VisionTask,\n    options?: VisionOptions\n  ): Promise<VisionResult> {\n    const startTime = Date.now();\n    if (!this.isInitialized || (!this.objectDetector && !this.faceLandmarker)) {\n      throw new Error('MediaPipe detectors are not initialized.');\n    }\n\n    const imageElement = new Image();\n    imageElement.src = imageData;\n    await new Promise(resolve => { imageElement.onload = resolve; });\n\n    switch (task) {\n      case 'object_detection':\n        if (!this.objectDetector) throw new Error('Object Detector not initialized.');\n        const detections = this.objectDetector.detect(imageElement);\n        return {\n          objects: detections.detections.map(d => ({\n            name: d.categories[0].categoryName,\n            confidence: d.categories[0].score,\n            boundingBox: {\n              x: d.boundingBox.originX,\n              y: d.boundingBox.originY,\n              width: d.boundingBox.width,\n              height: d.boundingBox.height,\n            },\n          })),\n          processingTimeMs: Date.now() - startTime\n        };\n      case 'general_description': {\n        let description = \"\";\n        let objectsDetected: DetectedObject[] = [];\n        let faceCount = 0;\n        let emotions: Record<string, number>[] = [];\n\n        if (this.objectDetector) {\n          const objDetections = this.objectDetector.detect(imageElement);\n          objectsDetected = objDetections.detections.map(d => ({\n            name: d.categories?.[0]?.categoryName ?? 'unknown',\n            confidence: d.categories?.[0]?.score ?? 0,\n            ...(d.boundingBox ? { boundingBox: {\n              x: d.boundingBox.originX,\n              y: d.boundingBox.originY,\n              width: d.boundingBox.width,\n              height: d.boundingBox.height,\n            }} : {})\n          }));\n          if (objectsDetected.length > 0) {\n            description += `I see ${objectsDetected.length} objects including ${objectsDetected.map(o => o.name).join(', ')}. `;\n          }\n        }\n\n        if (this.faceapi) {\n          const faceapi = this.faceapi;\n          const faceapiDetections = await faceapi\n            .detectAllFaces(imageElement, new faceapi.TinyFaceDetectorOptions())\n            .withFaceLandmarks()\n            .withFaceExpressions();\n          faceCount = faceapiDetections.length;\n          if (faceCount > 0) {\n            description += `I also see ${faceCount} face(s). `;\n            emotions = faceapiDetections.map((d: any) => d.expressions as Record<string, number>);\n          }\n        }\n\n        if (!description) {\n          description = \"I don't see anything specific, but it's an image.\";\n        }\n\n        return {\n          description,\n          objects: objectsDetected,\n          faceCount,\n          emotions,\n          processingTimeMs: Date.now() - startTime\n        };\n      }\n      case 'face_detection': {\n        if (!this.faceapi) {\n          return {\n            description: 'Face detection unavailable (face-api.js not loaded)',\n            faceCount: 0,\n            objects: [],\n            processingTimeMs: Date.now() - startTime\n          };\n        }\n        const faceapi = this.faceapi;\n        const fullFaceDescriptions = await faceapi\n          .detectAllFaces(imageElement, new faceapi.TinyFaceDetectorOptions())\n          .withFaceLandmarks()\n          .withFaceExpressions();\n        return {\n          faceCount: fullFaceDescriptions.length,\n          objects: fullFaceDescriptions.map((d: any) => ({\n            name: \"face\",\n            confidence: d.detection.score,\n            boundingBox: {\n              x: d.detection.box.x,\n              y: d.detection.box.y,\n              width: d.detection.box.width,\n              height: d.detection.box.height,\n            },\n            attributes: {\n              expressions: d.expressions,\n              age: d.age,\n              gender: d.gender\n            }\n          })),\n          processingTimeMs: Date.now() - startTime\n        };\n      }\n      case 'color_analysis': {\n        const canvas = document.createElement('canvas');\n        const ctx = canvas.getContext('2d');\n        if (!ctx) throw new Error('Could not get canvas context for color analysis.');\n\n        canvas.width = imageElement.width;\n        canvas.height = imageElement.height;\n        ctx.drawImage(imageElement, 0, 0, canvas.width, canvas.height);\n\n        const imageDataPixels = ctx.getImageData(0, 0, canvas.width, canvas.height).data;\n        const colorMap: { [key: string]: number } = {};\n        const step = 10; // Analyze every 10th pixel to speed up\n\n        for (let i = 0; i < imageDataPixels.length; i += 4 * step) {\n          const r = imageDataPixels[i];\n          const g = imageDataPixels[i + 1];\n          const b = imageDataPixels[i + 2];\n          const rgb = `${r},${g},${b}`;\n          colorMap[rgb] = (colorMap[rgb] || 0) + 1;\n        }\n\n        const sortedColors = Object.entries(colorMap).sort(([, countA], [, countB]) => countB - countA);\n        const totalPixels = (canvas.width * canvas.height) / (step * step);\n\n        const dominantColors = sortedColors.slice(0, 5).map(([rgb, count]) => {\n          const [r, g, b] = rgb.split(',').map(Number);\n          return {\n            color: `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`,\n            percentage: count / totalPixels\n          };\n        });\n\n        return {\n          dominantColors,\n          processingTimeMs: Date.now() - startTime\n        };\n      }\n      case 'semantic_segmentation': {\n        if (!this.deeplabModel) throw new Error('DeepLab v3 model not initialized.');\n        const segmentationResult = tf.tidy(() => {\n          const tfImage = tf.browser.fromPixels(imageElement);\n          const resized = tf.image.resizeBilinear(tfImage, [257, 257]);\n          const normalized = resized.div(255);\n          const batched = normalized.expandDims(0);\n          const prediction = this.deeplabModel.predict(batched) as tf.Tensor;\n          const result = tf.argMax(prediction.squeeze(), 2);\n          return result.arraySync() as number[][];\n        });\n        return {\n          segmentationMap: segmentationResult,\n          processingTimeMs: Date.now() - startTime\n        };\n      }\n      default:\n        return {\n          description: \"Image analysis complete, but no specific insights available for the requested task.\",\n          processingTimeMs: Date.now() - startTime\n        };\n    }\n  }\n\n  // Ex├®cution de l'agent\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as VisionIntent;\n    const parameters = props.parameters || {};\n\n    // Si la vision n'est pas disponible, on retourne une erreur\n    if (!this.checkAvailability()) {\n      return {\n        success: false,\n        error: \"Vision capabilities are not available in this environment\",\n        output: null\n      };\n    }\n\n    try {\n      // Traiter les diff├®rentes intentions\n      switch (intent) {\n        case 'describe_scene': {\n          const source = parameters.source as VisionSource || 'webcam';\n          const options = parameters.options as VisionOptions || {};\n          let imageData: string | null;\n          \n          // Obtenir l'image selon la source\n          if (source === 'webcam') {\n            imageData = await this.captureWebcamImage();\n          } else if (source === 'screenshot') {\n            imageData = await this.captureScreenshot();\n          } else if (source === 'file' || source === 'url') {\n            // Impl├®mentation future: chargement d'un fichier ou d'une URL\n            return {\n              success: false,\n              error: `Source '${source}' not implemented yet`,\n              output: null\n            };\n          } else {\n            return {\n              success: false,\n              error: `Unknown vision source: ${source}`,\n              output: null\n            };\n          }\n          \n          if (!imageData) {\n            return {\n              success: false,\n              error: `Failed to capture image from ${source}`,\n              output: null\n            };\n          }\n          \n          // Analyser l'image pour une description g├®n├®rale\n          const result = await this.analyzeImage(imageData, 'general_description', options);\n          \n          return {\n            success: true,\n            output: result,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              source: source\n            }\n          };\n        }\n        \n        case 'detect_objects': {\n          const source = parameters.source as VisionSource || 'webcam';\n          const options = parameters.options as VisionOptions || {};\n          let imageData: string | null;\n          \n          // Obtenir l'image selon la source\n          if (source === 'webcam') {\n            imageData = await this.captureWebcamImage();\n          } else if (source === 'screenshot') {\n            imageData = await this.captureScreenshot();\n          } else {\n            // Source non support├®e\n            return {\n              success: false,\n              error: `Source '${source}' not implemented yet`,\n              output: null\n            };\n          }\n          \n          if (!imageData) {\n            return {\n              success: false,\n              error: `Failed to capture image from ${source}`,\n              output: null\n            };\n          }\n          \n          // Analyser l'image pour d├®tecter des objets\n          const result = await this.analyzeImage(imageData, 'object_detection', options);\n          \n          return {\n            success: true,\n            output: result,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              source: source\n            }\n          };\n        }\n        \n        case 'analyze_image': {\n          const source = parameters.source as VisionSource || 'webcam';\n          const task = parameters.task as VisionTask || 'general_description';\n          const options = parameters.options as VisionOptions || {};\n          let imageData: string | null;\n          \n          // Obtenir l'image selon la source\n          if (source === 'webcam') {\n            imageData = await this.captureWebcamImage();\n          } else if (source === 'screenshot') {\n            imageData = await this.captureScreenshot();\n          } else {\n            // Source non support├®e\n            return {\n              success: false,\n              error: `Source '${source}' not implemented yet`,\n              output: null\n            };\n          }\n          \n          if (!imageData) {\n            return {\n              success: false,\n              error: `Failed to capture image from ${source}`,\n              output: null\n            };\n          }\n          \n          // Analyser l'image selon la t├óche demand├®e\n          const result = await this.analyzeImage(imageData, task, options);\n          \n          return {\n            success: true,\n            output: result,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              source: source\n              // La propri├®t├® task n'est pas d├®finie dans le type des m├®tadonn├®es\n            }\n          };\n        }\n        \n        case 'get_capabilities': {\n          return {\n            success: true,\n            output: {\n              availableSources: ['webcam', 'screenshot'],\n              availableTasks: [\n                'general_description',\n                'object_detection',\n                'face_detection',\n                'color_analysis',\n                'semantic_segmentation'\n              ]\n            }\n          };\n        }\n        \n        default:\n          return {\n            success: false,\n            error: `Unknown intent: ${intent}`,\n            output: null\n          };\n      }\n    } catch (error: any) {\n      console.error(`${this.name} execution error:`, error);\n      return {\n        success: false,\n        error: error.message || 'An unknown error occurred',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime\n        }\n      };\n    }\n  }\n\n  // V├®rifier si l'agent peut traiter une requ├¬te\n  async canHandle(query: string): Promise<number> {\n    // Mots-cl├®s li├®s ├á la vision\n    const visionKeywords = [\n      'see', 'look', 'describe', 'identify', 'what is', 'what are', \n      'camera', 'webcam', 'objects', 'image', 'picture', 'photo',\n      'detect', 'recognize', 'scene', 'visual',\n      'segmentation', 'segment'\n    ];\n    \n    // V├®rifier la pr├®sence de mots-cl├®s dans la requ├¬te\n    const lowerQuery = query.toLowerCase();\n    const matchCount = visionKeywords.filter(keyword => \n      lowerQuery.includes(keyword.toLowerCase())\n    ).length;\n    \n    // Calculer un score de confiance basique\n    if (matchCount > 2) return 0.9;  // Tr├¿s forte probabilit├®\n    if (matchCount > 0) return 0.7;  // Probabilit├® moyenne ├á forte\n    \n    // V├®rifier les mod├¿les de requ├¬tes courants\n    if (lowerQuery.match(/what (do you|can you|is) see/)) return 0.95;\n    if (lowerQuery.match(/what('s| is) (in|on) (the|my) (screen|camera)/)) return 0.9;\n    if (lowerQuery.match(/show me what (you see|is there)/)) return 0.9;\n    \n    return 0.2; // Faible probabilit├® par d├®faut\n  }\n\n  // Obtenir les capacit├®s de l'agent\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: \"describe_scene\",\n        description: \"Provides a general description of what is visible in the webcam or on screen\",\n        requiredParameters: [\n          {\n            name: \"source\",\n            type: \"string\",\n            required: false,\n            description: \"Source of the image (webcam, screenshot, file, url)\",\n            defaultValue: \"webcam\"\n          },\n          {\n            name: \"options\",\n            type: \"object\",\n            required: false,\n            description: \"Vision options including language, region, etc.\"\n          }\n        ]\n      },\n      {\n        name: \"detect_objects\",\n        description: \"Identifies and locates objects in the webcam or on screen\",\n        requiredParameters: [\n          {\n            name: \"source\",\n            type: \"string\",\n            required: false,\n            description: \"Source of the image (webcam, screenshot, file, url)\",\n            defaultValue: \"webcam\"\n          },\n          {\n            name: \"options\",\n            type: \"object\",\n            required: false,\n            description: \"Detection options including confidence threshold, max results, etc.\"\n          }\n        ]\n      },\n      {\n        name: \"analyze_image\",\n        description: \"Performs various analyses on the image based on the specified task\",\n        requiredParameters: [\n          {\n            name: \"source\",\n            type: \"string\",\n            required: false,\n            description: \"Source of the image (webcam, screenshot, file, url)\",\n            defaultValue: \"webcam\"\n          },\n          {\n            name: \"task\",\n            type: \"string\",\n            required: false,\n            description: \"Analysis task (general_description, object_detection, face_detection, color_analysis, semantic_segmentation)\",\n            defaultValue: \"general_description\"\n          },\n          {\n            name: \"options\",\n            type: \"object\",\n            required: false,\n            description: \"Analysis options including confidence threshold, region, etc.\"\n          }\n        ]\n      },\n      {\n        name: \"get_capabilities\",\n        description: \"Get available vision capabilities\",\n        requiredParameters: []\n      }\n    ];\n  }\n}\n\n// Enregistrer l'agent dans le registre\n// L'enregistrement centralis├® se fait via src/agents/index.ts\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\WeatherAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'language' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":141,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":141,"endColumn":19},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":193,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":193,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5292,5295],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5292,5295],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":209,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":209,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5703,5706],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5703,5706],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":372,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":372,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10821,10824],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10821,10824],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12495,12498],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12495,12498],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":470,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":470,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14225,14228],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14225,14228],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":507,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":507,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15468,15471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15468,15471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WeatherAgent - Fetches and processes weather data\n * \n * This agent handles weather-related queries including current conditions,\n * forecasts, and weather alerts using the Open-Meteo API.\n */\n\nimport { AgentDomains } from './types';\nimport type { \n  AgentCapability, \n  AgentExecuteProps,\n  AgentExecuteResult, \n  AgentParameter, \n  BaseAgent \n} from './types';\nimport { agentRegistry } from './registry';\n\n/**\n * Interface for geolocation data\n */\ninterface GeolocationPosition {\n  coords: {\n    latitude: number;\n    longitude: number;\n  };\n}\n\n/**\n * Supported weather intents\n */\nexport type WeatherIntent = \n  | 'get_current' \n  | 'get_forecast' \n  | 'get_alerts' \n  | 'get_hourly'\n  | 'search_location';\n  \n/**\n * Weather condition types\n */\nexport type WeatherCondition =\n  | 'clear'\n  | 'partly_cloudy'\n  | 'cloudy'\n  | 'rain'\n  | 'snow'\n  | 'thunderstorm'\n  | 'fog'\n  | 'drizzle'\n  | 'hail';\n  \n/**\n * Interface for formatted weather data\n */\nexport interface FormattedWeatherData {\n  location: string;\n  temperature?: number;\n  condition?: WeatherCondition;\n  humidity?: number;\n  wind_speed?: number;\n  wind_direction?: string;\n  forecast?: Array<{\n    day: string;\n    min_temp: number;\n    max_temp: number;\n    condition: WeatherCondition;\n  }>;\n}\n\n/**\n * Agent for fetching and processing weather data\n */\nexport class WeatherAgent implements BaseAgent {\n  name = 'WeatherAgent';\n  description = 'R├®cup├¿re et analyse les donn├®es m├®t├®orologiques actuelles et les pr├®visions';\n  version = '1.1.0';\n  domain = AgentDomains.KNOWLEDGE; // Utilisation du domaine KNOWLEDGE au lieu de INFORMATION\n  capabilities = [\n    'current_weather',\n    'weather_forecast',\n    'weather_alerts',\n    'hourly_forecast',\n    'location_search'\n  ];\n\n  /**\n   * Get the current geolocation position\n   */\n  private async getCurrentPosition(): Promise<GeolocationPosition> {\n    return new Promise((resolve, reject) => {\n      if (!navigator.geolocation) {\n        return reject('Geolocation is not supported by your browser.');\n      }\n      navigator.geolocation.getCurrentPosition(resolve, reject, {\n        enableHighAccuracy: false,\n        timeout: 5000,\n        maximumAge: 600000 // Cache position for 10 minutes\n      });\n    });\n  }\n  \n  /**\n   * Search for a location by name\n   */\n  private async searchLocation(query: string): Promise<{latitude: number, longitude: number, name: string}> {\n    try {\n      // This would normally use a geocoding API, but we'll simulate it for now\n      // In a real implementation, you would use something like Google Places API or OpenStreetMap Nominatim\n      const mockLocations: Record<string, {lat: number, lon: number, name: string}> = {\n        'paris': {lat: 48.8566, lon: 2.3522, name: 'Paris, France'},\n        'london': {lat: 51.5074, lon: -0.1278, name: 'London, UK'},\n        'new york': {lat: 40.7128, lon: -74.0060, name: 'New York, USA'},\n        'tokyo': {lat: 35.6762, lon: 139.6503, name: 'Tokyo, Japan'},\n      };\n      \n      const lowerQuery = query.toLowerCase();\n      const location = Object.entries(mockLocations).find(([key]) => key.includes(lowerQuery))?.[1];\n      \n      if (location) {\n        return {\n          latitude: location.lat,\n          longitude: location.lon,\n          name: location.name\n        };\n      }\n      \n      throw new Error(`Location not found: ${query}`);\n    } catch (error) {\n      console.error('Error searching location:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Main execution method for the agent\n   */\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const intent = props.intent as WeatherIntent || props.command as WeatherIntent;\n    const parameters = props.parameters || {};\n    const language = props.language || 'en';\n\n    try {\n      // Input validation\n      const validation = await this.validateInput(props);\n      if (!validation.valid) {\n        return {\n          success: false,\n          error: validation.errors?.join(', '),\n          output: null,\n          metadata: {\n            executionTime: Date.now() - startTime\n          }\n        };\n      }\n\n      let result;\n      switch (intent) {\n        case 'get_current':\n          result = await this.getCurrentWeather(parameters.location);\n          break;\n        case 'get_forecast':\n          result = await this.getForecast(parameters.location, parameters.days || 3);\n          break;\n        case 'get_hourly':\n          result = await this.getHourlyForecast(parameters.location, parameters.hours || 12);\n          break;\n        case 'get_alerts':\n          result = await this.getWeatherAlerts(parameters.location);\n          break;\n        case 'search_location':\n          result = await this.searchLocation(parameters.query);\n          break;\n        default:\n          return {\n            success: false,\n            output: `Intent non support├®: ${intent}`,\n            error: new Error('UNSUPPORTED_INTENT'),\n            metadata: {\n              executionTime: Date.now() - startTime\n            }\n          };\n      }\n\n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          source: `weather-${intent}`\n        }\n      };\n    } catch (error: any) {\n      console.error(`WeatherAgent error executing ${intent}:`, error);\n      return {\n        success: false,\n        error: error.message || 'Unknown error occurred',\n        output: null,\n        metadata: {\n          executionTime: Date.now() - startTime\n        }\n      };\n    }\n  }\n  \n  /**\n   * Determines if this agent can handle a specific query\n   */\n  async canHandle(query: string, _context?: any): Promise<number> {\n    const lowerQuery = query.toLowerCase();\n    \n    const weatherKeywords = [\n      'meteo', 'm├®t├®o', 'weather', 'temp├®rature', 'temperature', \n      'rain', 'snow', 'pluie', 'neige', 'forecast', 'pr├®vision',\n      'humid', 'humide', 'vent', 'wind', 'orage', 'storm',\n      'degrees', 'degr├®s', 'celsius', 'fahrenheit',\n      'today', 'tomorrow', 'aujourd\\'hui', 'demain',\n      'ce matin', 'ce soir', 'this morning', 'tonight',\n      'cette semaine', 'this week'\n    ];\n    \n    const weatherRegexes = [\n      /what.?s the weather( like)?( today| tomorrow)?/i,\n      /comment fait-il( aujourd'hui| demain)?/i,\n      /quel temps fait-il( aujourd'hui| demain)?/i,\n      /forecast for (today|tomorrow|this week)/i,\n      /pr├®visions (m├®t├®o|pour) (aujourd'hui|demain|cette semaine)/i\n    ];\n    \n    // Check for keyword matches\n    for (const keyword of weatherKeywords) {\n      if (lowerQuery.includes(keyword)) {\n        return 0.7; // 70% confidence\n      }\n    }\n    \n    // Check for regex patterns\n    for (const regex of weatherRegexes) {\n      if (regex.test(lowerQuery)) {\n        return 0.9; // 90% confidence\n      }\n    }\n    \n    return 0; // Cannot handle\n  }\n  \n  /**\n   * Returns required parameters for a specific task\n   */\n  async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    switch (task) {\n      case 'get_current':\n      case 'get_alerts':\n        return [{\n          name: 'location',\n          type: 'string',\n          required: false,\n          description: 'Location for weather information (city name). If not provided, geolocation will be used.'\n        }];\n      case 'get_forecast':\n        return [\n          {\n            name: 'location',\n            type: 'string',\n            required: false,\n            description: 'Location for weather forecast (city name). If not provided, geolocation will be used.'\n          },\n          {\n            name: 'days',\n            type: 'number',\n            required: false,\n            description: 'Number of days to forecast (1-7)',\n            defaultValue: 3\n          }\n        ];\n      case 'get_hourly':\n        return [\n          {\n            name: 'location',\n            type: 'string',\n            required: false,\n            description: 'Location for hourly forecast (city name). If not provided, geolocation will be used.'\n          },\n          {\n            name: 'hours',\n            type: 'number',\n            required: false,\n            description: 'Number of hours to forecast (1-48)',\n            defaultValue: 12\n          }\n        ];\n      case 'search_location':\n        return [{\n          name: 'query',\n          type: 'string',\n          required: true,\n          description: 'Location name to search for'\n        }];\n      default:\n        return [];\n    }\n  }\n  \n  /**\n   * Returns detailed capability information\n   */\n  async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'Current Weather',\n        description: 'Get current weather conditions for a location',\n        requiredParameters: await this.getRequiredParameters('get_current')\n      },\n      {\n        name: 'Weather Forecast',\n        description: 'Get multi-day weather forecast for a location',\n        requiredParameters: await this.getRequiredParameters('get_forecast')\n      },\n      {\n        name: 'Hourly Forecast',\n        description: 'Get hour-by-hour weather forecast',\n        requiredParameters: await this.getRequiredParameters('get_hourly')\n      },\n      {\n        name: 'Weather Alerts',\n        description: 'Get active weather warnings and alerts',\n        requiredParameters: await this.getRequiredParameters('get_alerts')\n      },\n      {\n        name: 'Location Search',\n        description: 'Search for a location by name',\n        requiredParameters: await this.getRequiredParameters('search_location')\n      }\n    ];\n  }\n\n  /**\n   * Validates input parameters\n   */\n  async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const intent = props.intent as WeatherIntent || props.command as WeatherIntent;\n    const parameters = props.parameters || {};\n    const errors: string[] = [];\n    \n    switch (intent) {\n      case 'search_location':\n        if (!parameters.query) {\n          errors.push('A location query is required for location search');\n        }\n        break;\n      case 'get_forecast':\n        if (parameters.days && (typeof parameters.days !== 'number' || parameters.days < 1 || parameters.days > 7)) {\n          errors.push('Days must be a number between 1 and 7');\n        }\n        break;\n      case 'get_hourly':\n        if (parameters.hours && (typeof parameters.hours !== 'number' || parameters.hours < 1 || parameters.hours > 48)) {\n          errors.push('Hours must be a number between 1 and 48');\n        }\n        break;\n    }\n    \n    return {\n      valid: errors.length === 0,\n      errors: errors.length > 0 ? errors : undefined\n    };\n  }\n  \n  /**\n   * Get current weather conditions\n   */\n  private async getCurrentWeather(locationQuery?: string): Promise<any> {\n    try {\n      let latitude, longitude, locationName;\n      \n      if (locationQuery) {\n        const location = await this.searchLocation(locationQuery);\n        latitude = location.latitude;\n        longitude = location.longitude;\n        locationName = location.name;\n      } else {\n        const position = await this.getCurrentPosition();\n        latitude = position.coords.latitude;\n        longitude = position.coords.longitude;\n        locationName = 'Current Location';\n      }\n      \n      const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&current_weather=true&hourly=temperature_2m,relativehumidity_2m,windspeed_10m,winddirection_10m&timezone=auto`;\n      \n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error('Failed to fetch weather data from API');\n      }\n      \n      const data = await response.json();\n      \n      // Process raw data into a more user-friendly format\n      const formattedData: FormattedWeatherData = {\n        location: locationName,\n        temperature: data.current_weather.temperature,\n        condition: this.mapWeatherCode(data.current_weather.weathercode),\n        wind_speed: data.current_weather.windspeed,\n        wind_direction: this.getWindDirection(data.current_weather.winddirection),\n        humidity: data.hourly.relativehumidity_2m[0]\n      };\n      \n      return formattedData;\n    } catch (error) {\n      console.error('Error getting current weather:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get weather forecast for multiple days\n   */\n  private async getForecast(locationQuery?: string, days: number = 3): Promise<any> {\n    try {\n      let latitude, longitude, locationName;\n      \n      if (locationQuery) {\n        const location = await this.searchLocation(locationQuery);\n        latitude = location.latitude;\n        longitude = location.longitude;\n        locationName = location.name;\n      } else {\n        const position = await this.getCurrentPosition();\n        latitude = position.coords.latitude;\n        longitude = position.coords.longitude;\n        locationName = 'Current Location';\n      }\n      \n      const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&daily=weathercode,temperature_2m_max,temperature_2m_min&timezone=auto`;\n      \n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error('Failed to fetch forecast data from API');\n      }\n      \n      const data = await response.json();\n      \n      // Format the forecast data\n      const forecast = [];\n      const daysToInclude = Math.min(days, data.daily.time.length);\n      \n      for (let i = 0; i < daysToInclude; i++) {\n        forecast.push({\n          day: this.formatDate(data.daily.time[i]),\n          min_temp: data.daily.temperature_2m_min[i],\n          max_temp: data.daily.temperature_2m_max[i],\n          condition: this.mapWeatherCode(data.daily.weathercode[i])\n        });\n      }\n      \n      const formattedData: FormattedWeatherData = {\n        location: locationName,\n        forecast\n      };\n      \n      return formattedData;\n    } catch (error) {\n      console.error('Error getting forecast:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get hourly weather forecast\n   */\n  private async getHourlyForecast(locationQuery?: string, hours: number = 12): Promise<any> {\n    try {\n      let latitude, longitude, locationName;\n      \n      if (locationQuery) {\n        const location = await this.searchLocation(locationQuery);\n        latitude = location.latitude;\n        longitude = location.longitude;\n        locationName = location.name;\n      } else {\n        const position = await this.getCurrentPosition();\n        latitude = position.coords.latitude;\n        longitude = position.coords.longitude;\n        locationName = 'Current Location';\n      }\n      \n      const url = `https://api.open-meteo.com/v1/forecast?latitude=${latitude}&longitude=${longitude}&hourly=temperature_2m,relativehumidity_2m,windspeed_10m,weathercode&forecast_hours=${hours}&timezone=auto`;\n      \n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error('Failed to fetch hourly forecast from API');\n      }\n      \n      const data = await response.json();\n      return {\n        location: locationName,\n        hourly_forecast: data.hourly\n      };\n    } catch (error) {\n      console.error('Error getting hourly forecast:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Get active weather alerts and warnings\n   */\n  private async getWeatherAlerts(locationQuery?: string): Promise<any> {\n    try {\n      let locationName;\n      \n      if (locationQuery) {\n        const location = await this.searchLocation(locationQuery);\n        locationName = location.name;\n      } else {\n        locationName = 'Current Location';\n      }\n      \n      // In a real implementation, this would call a weather alerts API\n      // For now, we'll return mock data\n      return {\n        location: locationName,\n        alerts: [],\n        has_active_alerts: false\n      };\n    } catch (error) {\n      console.error('Error getting weather alerts:', error);\n      throw error;\n    }\n  }\n  \n  /**\n   * Format a date string\n   */\n  private formatDate(dateString: string): string {\n    const date = new Date(dateString);\n    return date.toLocaleDateString(undefined, { weekday: 'long', month: 'short', day: 'numeric' });\n  }\n  \n  /**\n   * Convert wind direction in degrees to cardinal direction\n   */\n  private getWindDirection(degrees: number): string {\n    const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n    const index = Math.round((degrees % 360) / 45);\n    return directions[index];\n  }\n  \n  /**\n   * Map Open-Meteo weather codes to our weather condition type\n   */\n  private mapWeatherCode(code: number): WeatherCondition {\n    // WMO codes: https://www.nodc.noaa.gov/archive/arc0021/0002199/1.1/data/0-data/HTML/WMO-CODE/WMO4677.HTM\n    if (code === 0) return 'clear';\n    if (code === 1) return 'partly_cloudy';\n    if (code === 2) return 'partly_cloudy';\n    if (code === 3) return 'cloudy';\n    if (code >= 51 && code <= 67) return 'rain';\n    if (code >= 71 && code <= 77) return 'snow';\n    if (code === 95 || code === 96 || code === 99) return 'thunderstorm';\n    if (code >= 45 && code <= 49) return 'fog';\n    if (code >= 80 && code <= 82) return 'drizzle';\n    if (code >= 85 && code <= 86) return 'snow';\n    if (code >= 95 && code <= 96) return 'thunderstorm';\n    \n    return 'partly_cloudy'; // Default\n  }\n}\n\n// Register an instance of the agent with the registry.\nagentRegistry.register(new WeatherAgent());\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\WebContentReaderAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":30,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":30,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1198,1201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1198,1201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebContentReaderAgent: An agent that uses the WebContentReaderTool to read and summarize web pages.\n */\nimport { agentRegistry } from './registry';\nimport { WebContentReaderTool } from '../tools/WebContentReaderTool';\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult } from './types';\n\nexport class WebContentReaderAgent implements BaseAgent {\n  name = 'WebContentReaderAgent';\n  description = 'Reads and summarizes the content of a given URL. Use this when you need to understand the content of a specific web page.';\n  private tool: WebContentReaderTool;\n\n  constructor() {\n    this.tool = new WebContentReaderTool();\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { url } = props;\n\n    if (!url || typeof url !== 'string') {\n      return { success: false, error: 'A valid URL must be provided.', output: null };\n    }\n\n    try {\n      const result = await this.tool.execute({ url });\n      if (result.success) {\n        return { success: true, output: result.output?.summary || 'No summary available.' };\n      }\n      return { success: false, error: result.error ?? 'An unknown error occurred.', output: null };\n    } catch (error: any) {\n      console.error(`${this.name} execution failed:`, error);\n      return { success: false, error: error.message, output: null };\n    }\n  }\n}\n\nagentRegistry.register(new WebContentReaderAgent());\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\WebSearchAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1314,1317],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1314,1317],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebSearchAgent: An agent that uses the WebSearchTool to search the web.\n */\nimport { agentRegistry } from './registry';\nimport { WebSearchTool } from '../tools/WebSearchTool';\nimport type { BaseAgent, AgentExecuteProps, AgentExecuteResult } from './types';\n\nexport class WebSearchAgent implements BaseAgent {\n  name = 'WebSearchAgent';\n  description = 'Performs a web search and provides a concise answer. Use this for questions about current events, facts, or information not found elsewhere.';\n  version = '1.0.0';\n  domain = 'knowledge' as const;\n  capabilities = ['web_search', 'information_retrieval', 'question_answering'];\n  valid = true;\n  private tool: WebSearchTool;\n\n  constructor() {\n    this.tool = new WebSearchTool();\n  }\n\n  async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const { query } = props;\n\n    if (!query || typeof query !== 'string') {\n      return { success: false, error: 'A valid search query must be provided.', output: null };\n    }\n\n    try {\n      const result = await this.tool.execute({ query });\n      if (result.success) {\n        return { success: true, output: result.output?.summary || 'No summary available.' };\n      }\n      return { success: false, error: result.error ?? 'An unknown error occurred.', output: null };\n    } catch (error: any) {\n      console.error(`${this.name} execution failed:`, error);\n      return { success: false, error: error.message, output: null };\n    }\n  }\n}\n\nagentRegistry.register(new WebSearchAgent());\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\WorkflowCodeAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":293,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":293,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8155,8158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8155,8158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":326,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":326,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9076,9079],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9076,9079],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":359,"column":69,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":359,"endColumn":72,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9992,9995],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9992,9995],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":399,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11086,11089],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11086,11089],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":399,"column":90,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":399,"endColumn":93,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11117,11120],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11117,11120],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":452,"column":89,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":452,"endColumn":92,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12932,12935],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12932,12935],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":452,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":452,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12947,12950],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12947,12950],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { \n  AgentDomains,\n  AgentDomain,\n  AgentParameter,\n  AgentCapability,\n  AgentExecuteProps, \n  AgentExecuteResult, \n  BaseAgent \n} from './types';\nimport { agentRegistry } from './registry';\n\n/**\n * Agent sp├®cialis├® pour l'ex├®cution de code dans les workflows\n * Fournit un environnement d'ex├®cution s├®curis├® pour JavaScript/TypeScript\n */\nexport class WorkflowCodeAgent implements BaseAgent {\n  // Identit├® et m├®tadonn├®es\n  public name = 'WorkflowCodeAgent';\n  public description = 'Agent pour l\\'ex├®cution s├®curis├®e de code JavaScript/TypeScript dans les workflows';\n  public version = '1.0.0';\n  public domain: AgentDomain = AgentDomains.ANALYSIS;\n  public capabilities = ['executeCode', 'evaluateExpression', 'defineFunction'];\n  public valid = true;\n\n  // Liste des modules autoris├®s pour l'importation\n  private allowedModules: string[] = [\n    'lodash',\n    'moment',\n    'axios',\n    'uuid',\n    'json-schema',\n    // Ajouter d'autres modules de confiance ici\n  ];\n\n  /**\n   * M├®thode d'ex├®cution principale de l'agent\n   * @param props Propri├®t├®s d'ex├®cution\n   */\n  public async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Validation des entr├®es\n      const validation = await this.validateInput(props);\n      if (!validation.valid) {\n        return {\n          success: false,\n          output: null,\n          error: `Validation failed: ${validation.errors?.join(', ')}`,\n          metadata: {\n            executionTime: Date.now() - startTime,\n            timestamp: Date.now()\n          }\n        };\n      }\n      \n      // D├®terminer l'action ├á effectuer\n      const { intent, parameters } = props;\n      \n      switch (intent) {\n        case 'executeCode':\n          return await this.handleCodeExecution(parameters);\n          \n        case 'evaluateExpression':\n          return await this.handleExpressionEvaluation(parameters);\n          \n        case 'defineFunction':\n          return await this.handleFunctionDefinition(parameters);\n          \n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * V├®rifie si l'agent peut traiter la requ├¬te\n   * @param query Requ├¬te ├á v├®rifier\n   */\n  public async canHandle(query: string): Promise<number> {\n    const codeTerms = [\n      'code', 'execute', 'run', 'javascript', 'typescript', \n      'function', 'expression', 'eval', 'script', 'transform'\n    ];\n    \n    // Calculer un score bas├® sur les termes pr├®sents\n    const queryLower = query.toLowerCase();\n    let score = 0;\n    \n    for (const term of codeTerms) {\n      if (queryLower.includes(term)) {\n        score += 0.2;\n      }\n    }\n    \n    // Limiter ├á 0.9 pour laisser place ├á d'autres agents plus sp├®cifiques\n    return Math.min(score, 0.9);\n  }\n\n  /**\n   * Liste les param├¿tres requis pour une t├óche donn├®e\n   * @param task T├óche ├á ex├®cuter\n   */\n  public async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    if (task.includes('execute') || task.includes('code') || task.includes('run')) {\n      return [\n        {\n          name: 'code',\n          type: 'string',\n          required: true,\n          description: 'Code JavaScript/TypeScript ├á ex├®cuter'\n        },\n        {\n          name: 'input',\n          type: 'object',\n          required: false,\n          description: 'Donn├®es d\\'entr├®e pour le code'\n        },\n        {\n          name: 'timeout',\n          type: 'number',\n          required: false,\n          description: 'D├®lai maximum d\\'ex├®cution en ms',\n          defaultValue: 5000\n        }\n      ];\n    } else if (task.includes('expression') || task.includes('eval')) {\n      return [\n        {\n          name: 'expression',\n          type: 'string',\n          required: true,\n          description: 'Expression JavaScript ├á ├®valuer'\n        },\n        {\n          name: 'context',\n          type: 'object',\n          required: false,\n          description: 'Contexte pour l\\'├®valuation'\n        }\n      ];\n    }\n    \n    return [];\n  }\n\n  /**\n   * Retourne les capacit├®s d├®taill├®es de l'agent\n   */\n  public async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'executeCode',\n        description: 'Ex├®cute un bloc de code JavaScript/TypeScript dans un environnement s├®curis├®',\n        requiredParameters: [\n          {\n            name: 'code',\n            type: 'string',\n            required: true,\n            description: 'Code JavaScript/TypeScript ├á ex├®cuter'\n          },\n          {\n            name: 'input',\n            type: 'object',\n            required: false,\n            description: 'Donn├®es d\\'entr├®e pour le code'\n          }\n        ]\n      },\n      {\n        name: 'evaluateExpression',\n        description: '├ëvalue une expression JavaScript simple',\n        requiredParameters: [\n          {\n            name: 'expression',\n            type: 'string',\n            required: true,\n            description: 'Expression JavaScript ├á ├®valuer'\n          },\n          {\n            name: 'context',\n            type: 'object',\n            required: false,\n            description: 'Contexte pour l\\'├®valuation'\n          }\n        ]\n      },\n      {\n        name: 'defineFunction',\n        description: 'D├®finit une fonction r├®utilisable',\n        requiredParameters: [\n          {\n            name: 'name',\n            type: 'string',\n            required: true,\n            description: 'Nom de la fonction'\n          },\n          {\n            name: 'code',\n            type: 'string',\n            required: true,\n            description: 'Code de la fonction'\n          },\n          {\n            name: 'params',\n            type: 'array',\n            required: false,\n            description: 'Param├¿tres de la fonction'\n          }\n        ]\n      }\n    ];\n  }\n\n  /**\n   * Valide les entr├®es de l'agent\n   * @param props Propri├®t├®s ├á valider\n   */\n  public async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const errors: string[] = [];\n    const { intent, parameters } = props;\n    \n    if (!intent) {\n      errors.push('Intent is required');\n      return { valid: false, errors };\n    }\n    \n    if (!parameters) {\n      errors.push('Parameters are required');\n      return { valid: false, errors };\n    }\n    \n    switch (intent) {\n      case 'executeCode': {\n        if (!parameters.code) {\n          errors.push('Code is required for executeCode');\n        } else if (!this.isSafeCode(parameters.code)) {\n          errors.push('Code contains potentially unsafe operations');\n        }\n        break;\n      }\n      \n      case 'evaluateExpression': {\n        if (!parameters.expression) {\n          errors.push('Expression is required for evaluateExpression');\n        } else if (!this.isSafeExpression(parameters.expression)) {\n          errors.push('Expression contains potentially unsafe operations');\n        }\n        break;\n      }\n      \n      case 'defineFunction': {\n        if (!parameters.name) {\n          errors.push('Name is required for defineFunction');\n        }\n        if (!parameters.code) {\n          errors.push('Code is required for defineFunction');\n        } else if (!this.isSafeCode(parameters.code)) {\n          errors.push('Function code contains potentially unsafe operations');\n        }\n        break;\n      }\n      \n      default:\n        errors.push(`Unknown intent: ${intent}`);\n    }\n    \n    return { valid: errors.length === 0, errors };\n  }\n\n  /**\n   * G├¿re l'ex├®cution de code JavaScript/TypeScript\n   * @param parameters Param├¿tres pour l'ex├®cution\n   */\n  private async handleCodeExecution(parameters: Record<string, any>): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { code, input = {}, timeout = 5000 } = parameters;\n    \n    try {\n      // Cr├®er un environnement d'ex├®cution s├®curis├®\n      const result = await this.executeSandboxedCode(code, input, timeout);\n      \n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * G├¿re l'├®valuation d'expressions\n   * @param parameters Param├¿tres pour l'├®valuation\n   */\n  private async handleExpressionEvaluation(parameters: Record<string, any>): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { expression, context = {} } = parameters;\n    \n    try {\n      // ├ëvaluer l'expression de mani├¿re s├®curis├®e\n      const result = await this.evaluateSandboxedExpression(expression, context);\n      \n      return {\n        success: true,\n        output: result,\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * G├¿re la d├®finition de fonctions\n   * @param parameters Param├¿tres pour la d├®finition\n   */\n  private async handleFunctionDefinition(parameters: Record<string, any>): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { name, code, params = [] } = parameters;\n    \n    try {\n      // Cr├®er une fonction ├á partir du code\n      const functionBody = `return function ${name}(${params.join(', ')}) {\\n${code}\\n}`;\n      const func = new Function(functionBody)();\n      \n      return {\n        success: true,\n        output: {\n          name,\n          function: func.toString(),\n          params\n        },\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * Ex├®cute du code dans un environnement sandbox\n   * @param code Code ├á ex├®cuter\n   * @param input Donn├®es d'entr├®e\n   * @param timeout Timeout en ms\n   */\n  private async executeSandboxedCode(code: string, input: any, timeout: number): Promise<any> {\n    return new Promise((resolve, reject) => {\n      // Cr├®er un timeout pour l'ex├®cution\n      const timeoutId = setTimeout(() => {\n        reject(new Error(`Code execution timed out after ${timeout}ms`));\n      }, timeout);\n      \n      try {\n        // Dans une impl├®mentation r├®elle, nous utiliserions vm2/isolated-vm ou un Worker \n        // pour ex├®cuter le code dans un environnement isol├®\n        \n        // Pr├®paration du code avec des protections\n        const safeCode = `\n          \"use strict\";\n          // Enregistrer les variables globales que nous voulons prot├®ger\n          const _protectedGlobals = Object.keys(globalThis);\n          \n          // Fonction principale qui sera ex├®cut├®e\n          const _userFunction = async function(input) {\n            ${code}\n          };\n          \n          // V├®rifier qu'aucune variable globale n'a ├®t├® modifi├®e\n          const _currentGlobals = Object.keys(globalThis);\n          const _newGlobals = _currentGlobals.filter(k => !_protectedGlobals.includes(k));\n          \n          // Ex├®cuter la fonction et retourner le r├®sultat\n          return await _userFunction(input);\n        `;\n        \n        // Ex├®cuter le code\n        const result = new Function('input', safeCode)(input);\n        \n        // Nettoyer le timeout\n        clearTimeout(timeoutId);\n        \n        // R├®soudre avec le r├®sultat\n        resolve(result);\n      } catch (error) {\n        // Nettoyer le timeout\n        clearTimeout(timeoutId);\n        \n        // Rejeter avec l'erreur\n        reject(error);\n      }\n    });\n  }\n\n  /**\n   * ├ëvalue une expression dans un environnement sandbox\n   * @param expression Expression ├á ├®valuer\n   * @param context Contexte d'├®valuation\n   */\n  private async evaluateSandboxedExpression(expression: string, context: Record<string, any>): Promise<any> {\n    // Cr├®er une fonction qui ├®value l'expression dans le contexte donn├®\n    const evalFunction = new Function(\n      ...Object.keys(context),\n      `\"use strict\"; return (${expression});`\n    );\n    \n    // ├ëvaluer l'expression avec le contexte\n    return evalFunction(...Object.values(context));\n  }\n\n  /**\n   * V├®rifie si le code est s├®curis├®\n   * @param code Code ├á v├®rifier\n   */\n  private isSafeCode(code: string): boolean {\n    // Liste des motifs dangereux\n    const unsafePatterns = [\n      /eval\\s*\\(/,                   // eval()\n      /Function\\s*\\(/,               // Function constructor\n      /process/,                     // Node.js process object\n      /require\\s*\\([^)]*['\"](fs|path|child_process|os|net|http|https|crypto|dns|dgram|stream|zlib|tls|v8)['\"]/,  // Dangerous modules\n      /document\\s*\\.\\s*(write|cookie)/,  // DOM manipulation\n      /localStorage/,                // Browser storage\n      /window\\s*\\.\\s*(location|open|history)/, // Browser navigation\n    ];\n    \n    // V├®rifier si le code contient des motifs dangereux\n    return !unsafePatterns.some(pattern => pattern.test(code));\n  }\n\n  /**\n   * V├®rifie si l'expression est s├®curis├®e\n   * @param expression Expression ├á v├®rifier\n   */\n  private isSafeExpression(expression: string): boolean {\n    // Pour les expressions, nous sommes encore plus stricts\n    const unsafePatterns = [\n      /eval\\s*\\(/,        // eval()\n      /Function\\s*\\(/,     // Function constructor\n      /\\bprocess\\b/,       // Node.js process\n      /require\\s*\\(/,      // require()\n      /import\\s*\\(/,       // dynamic import\n      /\\bdocument\\b/,      // Browser DOM\n      /\\bwindow\\b/,        // Browser window\n      /\\blocalStorage\\b/,  // Browser storage\n      /\\.\\s*prototype\\s*\\./ // Prototype manipulation\n    ];\n    \n    return !unsafePatterns.some(pattern => pattern.test(expression));\n  }\n}\n\n// Enregistrement de l'agent dans le registre\nagentRegistry.register(new WorkflowCodeAgent());\n\nexport default WorkflowCodeAgent;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\WorkflowHTTPAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":276,"column":62,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":276,"endColumn":65,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7542,7545],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7542,7545],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":355,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":355,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9701,9704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9701,9704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'version' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":359,"column":64,"nodeType":null,"messageId":"unusedVar","endLine":359,"endColumn":71},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":459,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":459,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12764,12767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12764,12767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":569,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":569,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import axios, { AxiosRequestConfig, Method } from 'axios';\nimport { \n  AgentDomains,\n  AgentDomain,\n  AgentParameter,\n  AgentCapability,\n  AgentExecuteProps, \n  AgentExecuteResult, \n  BaseAgent \n} from './types';\nimport { agentRegistry } from './registry';\n\n/**\n * Agent sp├®cialis├® pour les requ├¬tes HTTP dans les workflows\n * Fournit des m├®thodes s├®curis├®es pour interagir avec des API externes\n */\nexport class WorkflowHTTPAgent implements BaseAgent {\n  // Identit├® et m├®tadonn├®es\n  public name = 'WorkflowHTTPAgent';\n  public description = 'Agent pour les requ├¬tes HTTP dans les workflows';\n  public version = '1.0.0';\n  public domain: AgentDomain = AgentDomains.INTEGRATION;\n  public capabilities = ['httpRequest', 'apiCall', 'webhookManagement'];\n  public valid = true;\n\n  // Liste des h├┤tes autoris├®s - peut ├¬tre configur├® par l'administrateur\n  private allowedHosts: string[] = [\n    'api.weather.com',\n    'api.github.com',\n    'api.openai.com',\n    'localhost',\n    '127.0.0.1',\n    // Ajouter d'autres h├┤tes de confiance ici\n  ];\n\n  /**\n   * M├®thode d'ex├®cution principale de l'agent\n   * @param props Propri├®t├®s d'ex├®cution\n   */\n  public async execute(props: AgentExecuteProps): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    \n    try {\n      // Validation des entr├®es\n      const validation = await this.validateInput(props);\n      if (!validation.valid) {\n        return {\n          success: false,\n          output: null,\n          error: `Validation failed: ${validation.errors?.join(', ')}`,\n          metadata: {\n            executionTime: Date.now() - startTime,\n            timestamp: Date.now()\n          }\n        };\n      }\n      \n      // D├®terminer l'action ├á effectuer\n      const { intent, parameters } = props;\n      \n      switch (intent) {\n        case 'httpRequest':\n          return await this.handleHttpRequest(parameters);\n          \n        case 'apiCall':\n          return await this.handleApiCall(parameters);\n          \n        case 'webhookManagement':\n          return await this.handleWebhookManagement(parameters);\n          \n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown intent: ${intent}`,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * V├®rifie si l'agent peut traiter la requ├¬te\n   * @param query Requ├¬te ├á v├®rifier\n   */\n  public async canHandle(query: string): Promise<number> {\n    const httpTerms = ['http', 'request', 'api', 'get', 'post', 'fetch', 'webhook', 'api call'];\n    \n    // Calculer un score bas├® sur les termes pr├®sents\n    const queryLower = query.toLowerCase();\n    let score = 0;\n    \n    for (const term of httpTerms) {\n      if (queryLower.includes(term)) {\n        score += 0.2;\n      }\n    }\n    \n    // Limiter ├á 0.9 pour laisser place ├á d'autres agents plus sp├®cifiques\n    return Math.min(score, 0.9);\n  }\n\n  /**\n   * Liste les param├¿tres requis pour une t├óche donn├®e\n   * @param task T├óche ├á ex├®cuter\n   */\n  public async getRequiredParameters(task: string): Promise<AgentParameter[]> {\n    if (task.includes('http') || task.includes('request') || task.includes('api')) {\n      return [\n        {\n          name: 'url',\n          type: 'string',\n          required: true,\n          description: 'URL de la requ├¬te'\n        },\n        {\n          name: 'method',\n          type: 'string',\n          required: false,\n          description: 'M├®thode HTTP (GET, POST, PUT, DELETE, etc.)',\n          defaultValue: 'GET'\n        },\n        {\n          name: 'headers',\n          type: 'object',\n          required: false,\n          description: 'En-t├¬tes de la requ├¬te'\n        },\n        {\n          name: 'data',\n          type: 'object',\n          required: false,\n          description: 'Donn├®es ├á envoyer avec la requ├¬te'\n        }\n      ];\n    }\n    \n    return [];\n  }\n\n  /**\n   * Retourne les capacit├®s d├®taill├®es de l'agent\n   */\n  public async getCapabilities(): Promise<AgentCapability[]> {\n    return [\n      {\n        name: 'httpRequest',\n        description: 'Envoie une requ├¬te HTTP ├á une URL sp├®cifique',\n        requiredParameters: [\n          {\n            name: 'url',\n            type: 'string',\n            required: true,\n            description: 'URL de la requ├¬te'\n          },\n          {\n            name: 'method',\n            type: 'string',\n            required: false,\n            description: 'M├®thode HTTP (GET, POST, PUT, DELETE, etc.)',\n            defaultValue: 'GET'\n          }\n        ]\n      },\n      {\n        name: 'apiCall',\n        description: 'Effectue un appel API structur├® avec authentification',\n        requiredParameters: [\n          {\n            name: 'endpoint',\n            type: 'string',\n            required: true,\n            description: 'Point de terminaison API'\n          },\n          {\n            name: 'apiKey',\n            type: 'string',\n            required: true,\n            description: 'Cl├® API pour l\\'authentification'\n          }\n        ]\n      },\n      {\n        name: 'webhookManagement',\n        description: 'G├¿re les webhooks pour les workflows',\n        requiredParameters: [\n          {\n            name: 'action',\n            type: 'string',\n            required: true,\n            description: 'Action ├á effectuer (create, update, delete, test)'\n          },\n          {\n            name: 'workflowId',\n            type: 'string',\n            required: true,\n            description: 'ID du workflow associ├®'\n          }\n        ]\n      }\n    ];\n  }\n\n  /**\n   * Valide les entr├®es de l'agent\n   * @param props Propri├®t├®s ├á valider\n   */\n  public async validateInput(props: AgentExecuteProps): Promise<{ valid: boolean; errors?: string[] }> {\n    const errors: string[] = [];\n    const { intent, parameters } = props;\n    \n    if (!intent) {\n      errors.push('Intent is required');\n      return { valid: false, errors };\n    }\n    \n    if (!parameters) {\n      errors.push('Parameters are required');\n      return { valid: false, errors };\n    }\n    \n    switch (intent) {\n      case 'httpRequest': {\n        if (!parameters.url) {\n          errors.push('URL is required for httpRequest');\n        } else if (!this.isAllowedUrl(parameters.url)) {\n          errors.push('URL is not allowed for security reasons');\n        }\n        break;\n      }\n      \n      case 'apiCall': {\n        if (!parameters.endpoint) {\n          errors.push('Endpoint is required for apiCall');\n        }\n        if (!parameters.apiKey) {\n          errors.push('API key is required for apiCall');\n        }\n        break;\n      }\n      \n      case 'webhookManagement': {\n        if (!parameters.action) {\n          errors.push('Action is required for webhookManagement');\n        }\n        if (!parameters.workflowId) {\n          errors.push('Workflow ID is required for webhookManagement');\n        }\n        break;\n      }\n      \n      default:\n        errors.push(`Unknown intent: ${intent}`);\n    }\n    \n    return { valid: errors.length === 0, errors };\n  }\n\n  /**\n   * G├¿re une requ├¬te HTTP g├®n├®rique\n   * @param parameters Param├¿tres de la requ├¬te\n   */\n  private async handleHttpRequest(parameters: Record<string, any>): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    \n    try {\n      const { url, method = 'GET', headers = {}, data, timeout = 10000 } = parameters;\n      \n      // V├®rification de s├®curit├®\n      if (!this.isAllowedUrl(url)) {\n        return {\n          success: false,\n          output: null,\n          error: 'URL not allowed for security reasons',\n          metadata: {\n            executionTime: Date.now() - startTime,\n            timestamp: Date.now()\n          }\n        };\n      }\n      \n      // Configuration de la requ├¬te\n      const config: AxiosRequestConfig = {\n        url,\n        method: method as Method,\n        headers,\n        timeout,\n        ...(data && method !== 'GET' ? { data } : {}),\n        ...(data && method === 'GET' ? { params: data } : {})\n      };\n      \n      // Ex├®cution de la requ├¬te\n      const response = await axios(config);\n      \n      return {\n        success: true,\n        output: {\n          status: response.status,\n          statusText: response.statusText,\n          data: response.data,\n          headers: response.headers\n        },\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now(),\n          source: url\n        }\n      };\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        return {\n          success: false,\n          output: error.response ? {\n            status: error.response.status,\n            statusText: error.response.statusText,\n            data: error.response.data\n          } : null,\n          error: error.message,\n          metadata: {\n            executionTime: Date.now() - startTime,\n            timestamp: Date.now()\n          }\n        };\n      }\n      \n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * G├¿re un appel API structur├® avec authentification\n   * @param parameters Param├¿tres de l'appel API\n   */\n  private async handleApiCall(parameters: Record<string, any>): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    \n    try {\n      const { endpoint, apiKey, method = 'GET', data, service, version = 'v1' } = parameters;\n      \n      // Construction de l'URL bas├®e sur le service\n      let baseUrl = '';\n      switch (service?.toLowerCase()) {\n        case 'github':\n          baseUrl = 'https://api.github.com';\n          break;\n        case 'openai':\n          baseUrl = 'https://api.openai.com';\n          break;\n        // Ajouter d'autres services support├®s ici\n        default:\n          baseUrl = endpoint.startsWith('http') ? '' : 'https://';\n      }\n      \n      const url = `${baseUrl}${endpoint}`;\n      \n      // V├®rification de s├®curit├®\n      if (!this.isAllowedUrl(url)) {\n        return {\n          success: false,\n          output: null,\n          error: 'API endpoint not allowed for security reasons',\n          metadata: {\n            executionTime: Date.now() - startTime,\n            timestamp: Date.now()\n          }\n        };\n      }\n      \n      // Configuration des en-t├¬tes d'authentification\n      const headers: Record<string, string> = {};\n      if (apiKey) {\n        if (service?.toLowerCase() === 'github') {\n          headers['Authorization'] = `Bearer ${apiKey}`;\n        } else if (service?.toLowerCase() === 'openai') {\n          headers['Authorization'] = `Bearer ${apiKey}`;\n        } else {\n          headers['Authorization'] = apiKey.startsWith('Bearer ') ? apiKey : `Bearer ${apiKey}`;\n        }\n      }\n      \n      // Ajout d'en-t├¬tes communs\n      headers['Content-Type'] = 'application/json';\n      headers['Accept'] = 'application/json';\n      \n      // Ex├®cution de la requ├¬te\n      const response = await axios({\n        url,\n        method: method as Method,\n        headers,\n        data: method !== 'GET' ? data : undefined,\n        params: method === 'GET' ? data : undefined\n      });\n      \n      return {\n        success: true,\n        output: {\n          status: response.status,\n          data: response.data\n        },\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now(),\n          source: service || url\n        }\n      };\n    } catch (error) {\n      if (axios.isAxiosError(error)) {\n        return {\n          success: false,\n          output: error.response ? {\n            status: error.response.status,\n            data: error.response.data\n          } : null,\n          error: error.message,\n          metadata: {\n            executionTime: Date.now() - startTime,\n            timestamp: Date.now()\n          }\n        };\n      }\n      \n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * G├¿re les op├®rations de gestion des webhooks\n   * @param parameters Param├¿tres pour la gestion des webhooks\n   */\n  private async handleWebhookManagement(parameters: Record<string, any>): Promise<AgentExecuteResult> {\n    const startTime = Date.now();\n    const { action, workflowId } = parameters;\n    \n    try {\n      // G├®n├®ration d'un ID unique pour le webhook\n      const webhookId = `wh_${Date.now()}_${Math.random().toString(36).substring(2, 9)}`;\n      const baseUrl = window.location.origin || 'https://app.lisa-assistant.com';\n      const webhookUrl = `${baseUrl}/api/webhooks/${webhookId}`;\n      \n      switch (action.toLowerCase()) {\n        case 'create':\n          // Dans une impl├®mentation r├®elle, enregistrerait le webhook dans une base de donn├®es\n          return {\n            success: true,\n            output: {\n              webhookId,\n              webhookUrl,\n              workflowId,\n              created: new Date().toISOString()\n            },\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n          \n        case 'update':\n          // Mise ├á jour d'un webhook existant\n          return {\n            success: true,\n            output: {\n              webhookId: parameters.webhookId || webhookId,\n              webhookUrl,\n              workflowId,\n              updated: new Date().toISOString()\n            },\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n          \n        case 'delete':\n          // Suppression d'un webhook\n          return {\n            success: true,\n            output: {\n              webhookId: parameters.webhookId,\n              deleted: true,\n              timestamp: new Date().toISOString()\n            },\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n          \n        case 'test':\n          // Test d'un webhook\n          return {\n            success: true,\n            output: {\n              webhookId: parameters.webhookId || webhookId,\n              testResult: 'Webhook test successful',\n              timestamp: new Date().toISOString()\n            },\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n          \n        default:\n          return {\n            success: false,\n            output: null,\n            error: `Unknown webhook action: ${action}`,\n            metadata: {\n              executionTime: Date.now() - startTime,\n              timestamp: Date.now()\n            }\n          };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        output: null,\n        error: error instanceof Error ? error.message : String(error),\n        metadata: {\n          executionTime: Date.now() - startTime,\n          timestamp: Date.now()\n        }\n      };\n    }\n  }\n\n  /**\n   * V├®rifie si une URL est autoris├®e pour des raisons de s├®curit├®\n   * @param url URL ├á v├®rifier\n   */\n  private isAllowedUrl(url: string): boolean {\n    try {\n      const parsedUrl = new URL(url);\n      const hostname = parsedUrl.hostname;\n      \n      // V├®rifier si l'h├┤te est dans la liste des h├┤tes autoris├®s\n      return this.allowedHosts.some(allowedHost => \n        hostname === allowedHost || hostname.endsWith(`.${allowedHost}`)\n      );\n    } catch (error) {\n      return false;\n    }\n  }\n}\n\n// Enregistrement de l'agent dans le registre\nagentRegistry.register(new WorkflowHTTPAgent());\n\nexport default WorkflowHTTPAgent;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\__tests__\\MetaHumanAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\loadAgents.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\registry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\tests\\CodeInterpreterAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\tests\\MemoryAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\tests\\PlannerAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\tests\\SmallTalkAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\tests\\WebContentReaderAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\tests\\WebSearchAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\agents\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[639,642],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[639,642],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1112,1115],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1112,1115],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1290,1293],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1290,1293],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":54,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":54,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1429,1432],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1429,1432],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1621,1624],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1621,1624],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2962,2965],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2962,2965],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":103,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":103,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3189,3192],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3189,3192],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":117,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":117,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3943,3946],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3943,3946],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":135,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":135,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4808,4811],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4808,4811],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Defines the common interfaces and types for all agents in the system.\n */\n\n/**\n * Agent domains for categorization\n */\nexport const AgentDomains = {\n  KNOWLEDGE: \"knowledge\",\n  PRODUCTIVITY: \"productivity\",\n  ANALYSIS: \"analysis\",\n  INTEGRATION: \"integration\",\n  PLANNING: \"planning\"\n} as const;\n\n/**\n * Type for agent domains\n */\nexport type AgentDomain = typeof AgentDomains[keyof typeof AgentDomains];\n\n/**\n * Parameter definition for agent execution\n */\nexport interface AgentParameter {\n  name: string;\n  type: \"string\" | \"number\" | \"boolean\" | \"array\" | \"object\";\n  required: boolean;\n  description?: string;\n  defaultValue?: any;\n}\n\n/**\n * Capability metadata for agent discoverability\n */\nexport interface AgentCapability {\n  name: string;\n  description: string;\n  requiredParameters: AgentParameter[];\n}\n\n/**\n * The input properties for an agent's execute method.\n * It's a flexible key-value store to accommodate different agent needs.\n */\nexport interface AgentExecuteProps {\n  // Common properties\n  intent?: string;                // The specific action to perform\n  context?: Record<string, any>;  // Contextual information for the execution\n  language?: string;              // The language to use for operations (e.g., 'en', 'fr', 'es')\n  parameters?: Record<string, any>; // Parameters for the execution\n  // Add any other common properties\n  \n  // Generic catch-all for other properties\n  [key: string]: any;\n}\n\n/**\n * The standardized result format for any agent execution.\n */\nexport interface AgentExecuteResult {\n  success: boolean;          // Whether the execution was successful\n  output: any;               // The result of the execution\n  error?: Error | string;    // Error details if execution failed\n  metadata?: {               // Additional metadata about the execution\n    executionTime?: number;  // Time taken to execute in ms\n    confidence?: number;     // Confidence score (0-1) for the result\n    source?: string;         // Source of the information\n    timestamp?: number;      // Timestamp of when the result was generated\n  };\n}\n\nimport { z } from 'zod';\n\nexport interface NodeInputOutput {\n  id: string;\n  type: string;\n  label: string;\n  description?: string;\n  required?: boolean;\n}\n\n/**\n * The base interface that every agent must implement.\n */\nexport interface BaseAgent {\n  // Identity properties\n  name: string;                     // A unique name for the agent\n  description: string;              // A brief description of what the agent does\n  version: string;                  // Version of the agent implementation\n  domain: AgentDomain;              // The domain this agent belongs to\n  capabilities: string[];           // List of specific capabilities this agent provides\n  requiresAuthentication?: boolean; // Whether this agent requires authentication\n\n  // Input/Output definitions for workflow editor\n  inputs?: NodeInputOutput[];\n  outputs?: NodeInputOutput[];\n  configSchema?: z.ZodObject<any>; // Zod schema for agent-specific configuration\n\n  // Core methods\n  execute(props: AgentExecuteProps): Promise<AgentExecuteResult>;  // Main execution method\n  \n  // Optional methods\n  canHandle?(query: string, context?: any): Promise<number>;  // Returns confidence score (0-1)\n  getRequiredParameters?(task: string): Promise<AgentParameter[]>; // Returns required parameters\n  getCapabilities?(): Promise<AgentCapability[]>;  // Returns detailed capability information\n  validateInput?(props: AgentExecuteProps): Promise<{valid: boolean, errors?: string[]}>; // Validates input\n}\n\n/**\n * Interface for plan steps in complex workflows\n */\nexport interface PlanStep {\n  id: string;                 // Unique identifier for the step\n  agent: string;              // Agent responsible for executing this step\n  task: string;               // Description of the task\n  dependencies: string[];     // IDs of steps that must complete before this one\n  parameters?: Record<string, any>; // Parameters for the execution\n  status: \"pending\" | \"waiting\" | \"in_progress\" | \"completed\" | \"failed\"; // Current status\n  result?: AgentExecuteResult; // Result when completed\n  retryCount?: number;        // Number of retry attempts\n  startTime?: number;         // Timestamp when execution started\n  endTime?: number;           // Timestamp when execution completed\n}\n\n/**\n * Interface for complex multi-step plans\n */\nexport interface Plan {\n  id: string;                 // Unique identifier for the plan\n  goal: string;               // High-level description of the goal\n  steps: PlanStep[];          // Steps to achieve the goal\n  createdAt: number;          // Creation timestamp\n  updatedAt: number;          // Last update timestamp\n  status: \"pending\" | \"in_progress\" | \"completed\" | \"failed\"; // Overall plan status\n  context?: Record<string, any>; // Shared context across steps\n}\n\n/**\n * Interface for saved plan templates\n */\nexport interface PlanTemplate {\n  id: string;                 // Unique identifier for the template\n  name: string;               // User-friendly name\n  description: string;        // Description of what this template does\n  plan: Omit<Plan, 'id' | 'createdAt' | 'updatedAt' | 'status'>; // Plan structure without execution-specific fields\n  tags: string[];             // Searchable tags\n  createdAt: number;          // Creation timestamp\n}\n\n/**\n * Interface for plan checkpoints to resume execution\n */\nexport interface PlanCheckpoint {\n  id: string;                 // Unique identifier for the checkpoint\n  planId: string;             // Reference to the original plan\n  description: string;        // Description of the checkpoint state\n  state: Plan;                // Complete plan state at checkpoint time\n  timestamp: number;          // When the checkpoint was created\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\controllers\\authController.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\examples\\lisa-api-client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\middleware\\auth.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\middleware\\logger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":18,"column":11,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":18,"endColumn":14,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[398,401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[398,401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1241,1244],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1241,1244],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":96,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":96,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2202,2205],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2202,2205],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2337,2340],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2337,2340],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":101,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":101,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2353,2356],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2353,2356],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2618,2621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2618,2621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3015,3018],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3015,3018],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Middleware de logging structur├® pour l'API Lisa\n */\n\nimport { type Request, type Response, type NextFunction } from 'express';\n\nexport interface LogEntry {\n  timestamp: string;\n  level: 'info' | 'warn' | 'error' | 'debug';\n  message: string;\n  method?: string;\n  url?: string;\n  statusCode?: number;\n  responseTime?: number;\n  userId?: string;\n  ip?: string;\n  userAgent?: string;\n  error?: any;\n}\n\nclass Logger {\n  private static instance: Logger;\n\n  static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  private formatLog(entry: LogEntry): string {\n    return JSON.stringify({\n      ...entry,\n      timestamp: new Date().toISOString()\n    });\n  }\n\n  info(message: string, meta?: Partial<LogEntry>): void {\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: 'info',\n      message,\n      ...meta\n    };\n    console.log(this.formatLog(entry));\n  }\n\n  warn(message: string, meta?: Partial<LogEntry>): void {\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: 'warn',\n      message,\n      ...meta\n    };\n    console.warn(this.formatLog(entry));\n  }\n\n  error(message: string, error?: any, meta?: Partial<LogEntry>): void {\n    const entry: LogEntry = {\n      timestamp: new Date().toISOString(),\n      level: 'error',\n      message,\n      error: error?.stack || error,\n      ...meta\n    };\n    console.error(this.formatLog(entry));\n  }\n\n  debug(message: string, meta?: Partial<LogEntry>): void {\n    if (process.env.NODE_ENV === 'development') {\n      const entry: LogEntry = {\n        timestamp: new Date().toISOString(),\n        level: 'debug',\n        message,\n        ...meta\n      };\n      console.debug(this.formatLog(entry));\n    }\n  }\n}\n\nexport const logger = Logger.getInstance();\n\n/**\n * Middleware de logging des requ├¬tes HTTP\n */\nexport const requestLogger = (req: Request, res: Response, next: NextFunction) => {\n  const startTime = Date.now();\n  \n  // Log de la requ├¬te entrante\n  logger.info('Incoming request', {\n    method: req.method,\n    url: req.url,\n    ip: req.ip,\n    userAgent: req.get('User-Agent'),\n    userId: (req as any).user?.userId\n  });\n\n  // Override de res.end pour capturer la r├®ponse\n  const originalEnd = res.end;\n  res.end = function(chunk?: any, encoding?: any) {\n    const responseTime = Date.now() - startTime;\n    \n    // Log de la r├®ponse\n    logger.info('Request completed', {\n      method: req.method,\n      url: req.url,\n      statusCode: res.statusCode,\n      responseTime,\n      ip: req.ip,\n      userId: (req as any).user?.userId\n    });\n\n    // Appeler la m├®thode originale\n    originalEnd.call(this, chunk, encoding);\n  };\n\n  next();\n};\n\n/**\n * Middleware de gestion des erreurs avec logging\n */\nexport const errorLogger = (err: Error, req: Request, res: Response, next: NextFunction) => {\n  logger.error('Request error', err, {\n    method: req.method,\n    url: req.url,\n    ip: req.ip,\n    userId: (req as any).user?.userId\n  });\n\n  next(err);\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\middleware\\prometheus.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\middleware\\rateLimiter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\middleware\\security.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\middleware\\structuredLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\middleware\\validation.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":19,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":19,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[644,647],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[644,647],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1153,1156],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1153,1156],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1364,1367],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1364,1367],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Middleware de validation Zod pour les routes API\n */\n\nimport { type Request, type Response, type NextFunction } from 'express';\nimport { type ZodSchema, ZodError } from 'zod';\nimport { type ApiResponse } from '../config.js';\n\nexport const validateBody = (schema: ZodSchema) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const validatedData = schema.parse(req.body);\n      req.body = validatedData;\n      next();\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const response: ApiResponse = {\n          success: false,\n          error: `Validation error: ${error.issues.map((e: any) => `${e.path.join('.')}: ${e.message}`).join(', ')}`\n        };\n        return res.status(400).json(response);\n      }\n      \n      const response: ApiResponse = {\n        success: false,\n        error: 'Invalid request data'\n      };\n      res.status(400).json(response);\n    }\n  };\n};\n\nexport const validateQuery = (schema: ZodSchema) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    try {\n      const validatedData = schema.parse(req.query);\n      req.query = validatedData as any;\n      next();\n    } catch (error) {\n      if (error instanceof ZodError) {\n        const response: ApiResponse = {\n          success: false,\n          error: `Query validation error: ${error.issues.map((e: any) => `${e.path.join('.')}: ${e.message}`).join(', ')}`\n        };\n        return res.status(400).json(response);\n      }\n      \n      const response: ApiResponse = {\n        success: false,\n        error: 'Invalid query parameters'\n      };\n      res.status(400).json(response);\n    }\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\agentRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\authRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\healthRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\intentRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\memoryRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\robotRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\todoRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\routes\\weatherRoutes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\schemas\\robotSchemas.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\server.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\services\\authService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\services\\rosBridgeService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[318,321],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[318,321],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[352,355],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[352,355],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":38,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":38,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1003,1006],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1003,1006],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":128,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":128,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3607,3610],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3607,3610],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":149,"column":74,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":149,"endColumn":77,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4215,4218],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4215,4218],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":173,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":173,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4701,4704],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4701,4704],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":244,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":244,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6601,6604],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6601,6604],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Service de pont ROS Bridge pour communication avec les robots ROS2\n */\n\nimport WebSocket from 'ws';\nimport { API_CONFIG } from '../config.js';\n\nexport interface RosMessage {\n  op: 'publish' | 'subscribe' | 'unsubscribe' | 'call_service' | 'advertise' | 'unadvertise';\n  topic?: string;\n  type?: string;\n  msg?: any;\n  service?: string;\n  args?: any;\n  id?: string;\n}\n\nexport interface RobotCommand {\n  linear: { x: number; y: number; z: number };\n  angular: { x: number; y: number; z: number };\n}\n\nexport interface RobotStatus {\n  connected: boolean;\n  position?: { x: number; y: number; z: number };\n  orientation?: { x: number; y: number; z: number; w: number };\n  battery?: number;\n  lastUpdate: Date;\n}\n\nclass RosBridgeService {\n  private ws: WebSocket | null = null;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000;\n  private isConnecting = false;\n  private messageQueue: RosMessage[] = [];\n  private subscribers = new Map<string, (data: any) => void>();\n\n  constructor() {\n    this.connect();\n  }\n\n  private async connect(): Promise<void> {\n    if (this.isConnecting || (this.ws && this.ws.readyState === WebSocket.OPEN)) {\n      return;\n    }\n\n    this.isConnecting = true;\n\n    try {\n      console.log(`Tentative de connexion ├á ROS Bridge: ${API_CONFIG.robot.rosBridgeUrl}`);\n      \n      this.ws = new WebSocket(API_CONFIG.robot.rosBridgeUrl);\n\n      this.ws.on('open', () => {\n        console.log('Connexion ROS Bridge ├®tablie');\n        this.isConnecting = false;\n        this.reconnectAttempts = 0;\n        \n        // Traiter la queue de messages en attente\n        this.processMessageQueue();\n        \n        // S'abonner aux topics de base\n        this.subscribeToBasicTopics();\n      });\n\n      this.ws.on('message', (data: WebSocket.Data) => {\n        try {\n          const message = JSON.parse(data.toString());\n          this.handleIncomingMessage(message);\n        } catch (error) {\n          console.error('Erreur parsing message ROS:', error);\n        }\n      });\n\n      this.ws.on('close', () => {\n        console.log('Connexion ROS Bridge ferm├®e');\n        this.ws = null;\n        this.isConnecting = false;\n        this.scheduleReconnect();\n      });\n\n      this.ws.on('error', (error) => {\n        console.error('Erreur ROS Bridge:', error);\n        this.isConnecting = false;\n        this.scheduleReconnect();\n      });\n\n    } catch (error) {\n      console.error('Erreur connexion ROS Bridge:', error);\n      this.isConnecting = false;\n      this.scheduleReconnect();\n    }\n  }\n\n  private scheduleReconnect(): void {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n      \n      console.log(`Reconnexion ROS Bridge dans ${delay}ms (tentative ${this.reconnectAttempts}/${this.maxReconnectAttempts})`);\n      \n      setTimeout(() => {\n        this.connect();\n      }, delay);\n    } else {\n      console.error('Nombre maximum de tentatives de reconnexion atteint');\n    }\n  }\n\n  private processMessageQueue(): void {\n    while (this.messageQueue.length > 0) {\n      const message = this.messageQueue.shift();\n      if (message) {\n        this.sendMessage(message);\n      }\n    }\n  }\n\n  private subscribeToBasicTopics(): void {\n    // S'abonner aux topics de base du robot\n    this.subscribe('/robot_state', 'lisa_msgs/RobotState');\n    this.subscribe('/odom', 'nav_msgs/Odometry');\n    this.subscribe('/battery_state', 'sensor_msgs/BatteryState');\n  }\n\n  private handleIncomingMessage(message: any): void {\n    if (message.topic && this.subscribers.has(message.topic)) {\n      const callback = this.subscribers.get(message.topic);\n      if (callback) {\n        callback(message.msg);\n      }\n    }\n  }\n\n  public sendMessage(message: RosMessage): void {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      this.ws.send(JSON.stringify(message));\n    } else {\n      // Ajouter ├á la queue si pas connect├®\n      this.messageQueue.push(message);\n      if (!this.isConnecting) {\n        this.connect();\n      }\n    }\n  }\n\n  public subscribe(topic: string, messageType: string, callback?: (data: any) => void): void {\n    const message: RosMessage = {\n      op: 'subscribe',\n      topic,\n      type: messageType\n    };\n\n    if (callback) {\n      this.subscribers.set(topic, callback);\n    }\n\n    this.sendMessage(message);\n  }\n\n  public unsubscribe(topic: string): void {\n    const message: RosMessage = {\n      op: 'unsubscribe',\n      topic\n    };\n\n    this.subscribers.delete(topic);\n    this.sendMessage(message);\n  }\n\n  public publish(topic: string, messageType: string, data: any): void {\n    const message: RosMessage = {\n      op: 'publish',\n      topic,\n      type: messageType,\n      msg: data\n    };\n\n    this.sendMessage(message);\n  }\n\n  public async moveRobot(command: RobotCommand): Promise<boolean> {\n    try {\n      // Valider les limites de vitesse\n      const linear = {\n        x: Math.max(-API_CONFIG.robot.maxLinearVelocity, \n            Math.min(API_CONFIG.robot.maxLinearVelocity, command.linear.x)),\n        y: Math.max(-API_CONFIG.robot.maxLinearVelocity, \n            Math.min(API_CONFIG.robot.maxLinearVelocity, command.linear.y)),\n        z: 0\n      };\n\n      const angular = {\n        x: 0,\n        y: 0,\n        z: Math.max(-API_CONFIG.robot.maxAngularVelocity, \n            Math.min(API_CONFIG.robot.maxAngularVelocity, command.angular.z))\n      };\n\n      const cmdVel = {\n        linear,\n        angular\n      };\n\n      this.publish('/cmd_vel', 'geometry_msgs/Twist', cmdVel);\n      return true;\n    } catch (error) {\n      console.error('Erreur envoi commande mouvement:', error);\n      return false;\n    }\n  }\n\n  public async sayText(text: string, language: string = 'fr'): Promise<boolean> {\n    try {\n      const ttsMessage = {\n        text,\n        language,\n        voice: 'default'\n      };\n\n      this.publish('/tts/say', 'lisa_msgs/TTSRequest', ttsMessage);\n      return true;\n    } catch (error) {\n      console.error('Erreur envoi commande TTS:', error);\n      return false;\n    }\n  }\n\n  public async getRobotStatus(): Promise<RobotStatus> {\n    return new Promise((resolve) => {\n      const status: RobotStatus = {\n        connected: this.ws?.readyState === WebSocket.OPEN,\n        lastUpdate: new Date()\n      };\n\n      // Timeout pour ├®viter d'attendre ind├®finiment\n      const timeout = setTimeout(() => {\n        resolve(status);\n      }, 1000);\n\n      // ├ëcouter temporairement le status du robot\n      const statusCallback = (data: any) => {\n        clearTimeout(timeout);\n        this.subscribers.delete('/robot_state');\n        \n        resolve({\n          connected: true,\n          position: data.position,\n          orientation: data.orientation,\n          battery: data.battery_percentage,\n          lastUpdate: new Date()\n        });\n      };\n\n      this.subscribe('/robot_state', 'lisa_msgs/RobotState', statusCallback);\n    });\n  }\n\n  public async emergencyStop(): Promise<boolean> {\n    try {\n      // Arr├¬t d'urgence - vitesse z├®ro\n      const stopCommand: RobotCommand = {\n        linear: { x: 0, y: 0, z: 0 },\n        angular: { x: 0, y: 0, z: 0 }\n      };\n\n      await this.moveRobot(stopCommand);\n      \n      // Publier aussi sur le topic d'arr├¬t d'urgence\n      this.publish('/safety/estop', 'std_msgs/Bool', { data: true });\n      \n      return true;\n    } catch (error) {\n      console.error('Erreur arr├¬t d\\'urgence:', error);\n      return false;\n    }\n  }\n\n  public isConnected(): boolean {\n    return this.ws?.readyState === WebSocket.OPEN || false;\n  }\n\n  public disconnect(): void {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.subscribers.clear();\n    this.messageQueue.length = 0;\n  }\n}\n\n// Instance singleton\nexport const rosBridgeService = new RosBridgeService();\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\api\\utils\\envValidation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\AccessibilitySettings.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\AccessibilityWrapper.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":114,"column":17,"nodeType":"Identifier","messageId":"namedExport","endLine":114,"endColumn":33},{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":141,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":141,"endColumn":47}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ÔÖ┐ Accessibility Wrapper - Wrapper d'Accessibilit├®\n * Fournit les fonctionnalit├®s A11y de base pour tous les composants\n */\n\nimport React, { useEffect, useState } from 'react';\n\ninterface AccessibilityConfig {\n  enableKeyboardNav: boolean;\n  enableAriaLive: boolean;\n  enableReducedMotion: boolean;\n  enableHighContrast: boolean;\n  enableLargeText: boolean;\n}\n\ninterface Props {\n  children: React.ReactNode;\n  config?: Partial<AccessibilityConfig>;\n}\n\nconst DEFAULT_CONFIG: AccessibilityConfig = {\n  enableKeyboardNav: true,\n  enableAriaLive: true,\n  enableReducedMotion: false,\n  enableHighContrast: false,\n  enableLargeText: false\n};\n\nexport const AccessibilityWrapper: React.FC<Props> = ({ children, config = {} }) => {\n  const [a11yConfig, setA11yConfig] = useState<AccessibilityConfig>({\n    ...DEFAULT_CONFIG,\n    ...config\n  });\n\n  const [_prefersReducedMotion, setPrefersReducedMotion] = useState(false);\n  const [_prefersHighContrast, setPrefersHighContrast] = useState(false);\n\n  useEffect(() => {\n    // V├®rifier les pr├®f├®rences syst├¿me\n    const motionQuery = window.matchMedia('(prefers-reduced-motion: reduce)');\n    const contrastQuery = window.matchMedia('(prefers-contrast: more)');\n\n    setPrefersReducedMotion(motionQuery.matches);\n    setPrefersHighContrast(contrastQuery.matches);\n\n    // ├ëcouter les changements\n    const handleMotionChange = (e: MediaQueryListEvent) => {\n      setPrefersReducedMotion(e.matches);\n      setA11yConfig(prev => ({\n        ...prev,\n        enableReducedMotion: e.matches\n      }));\n    };\n\n    const handleContrastChange = (e: MediaQueryListEvent) => {\n      setPrefersHighContrast(e.matches);\n      setA11yConfig(prev => ({\n        ...prev,\n        enableHighContrast: e.matches\n      }));\n    };\n\n    motionQuery.addEventListener('change', handleMotionChange);\n    contrastQuery.addEventListener('change', handleContrastChange);\n\n    return () => {\n      motionQuery.removeEventListener('change', handleMotionChange);\n      contrastQuery.removeEventListener('change', handleContrastChange);\n    };\n  }, []);\n\n  // Appliquer les styles d'accessibilit├®\n  const wrapperStyle: React.CSSProperties = {\n    ...(a11yConfig.enableReducedMotion && {\n      '--animation-duration': '0.01ms',\n      '--animation-delay': '0.01ms'\n    } as React.CSSProperties),\n    ...(a11yConfig.enableHighContrast && {\n      '--text-color': '#000',\n      '--bg-color': '#fff'\n    } as React.CSSProperties),\n    ...(a11yConfig.enableLargeText && {\n      fontSize: '1.25rem'\n    })\n  };\n\n  return (\n    <div\n      style={wrapperStyle}\n      className={`\n        ${a11yConfig.enableReducedMotion ? 'motion-safe-none' : ''}\n        ${a11yConfig.enableHighContrast ? 'high-contrast' : ''}\n        ${a11yConfig.enableLargeText ? 'large-text' : ''}\n      `}\n      role=\"main\"\n      aria-label=\"Application principale\"\n    >\n      {children}\n\n      {/* Lien d'acc├¿s rapide au contenu principal */}\n      <a\n        href=\"#main-content\"\n        className=\"sr-only focus:not-sr-only focus:absolute focus:top-0 focus:left-0 focus:z-50 focus:p-2 focus:bg-blue-600 focus:text-white\"\n      >\n        Aller au contenu principal\n      </a>\n    </div>\n  );\n};\n\n/**\n * Hook pour utiliser la config d'accessibilit├®\n */\nexport function useAccessibility() {\n  const [config, setConfig] = useState<AccessibilityConfig>(DEFAULT_CONFIG);\n\n  useEffect(() => {\n    // Charger depuis localStorage\n    const saved = localStorage.getItem('lisa:a11y:config');\n    if (saved) {\n      try {\n        setConfig(JSON.parse(saved));\n      } catch (e) {\n        console.error('Erreur parsing a11y config:', e);\n      }\n    }\n  }, []);\n\n  const updateConfig = (newConfig: Partial<AccessibilityConfig>) => {\n    const updated = { ...config, ...newConfig };\n    setConfig(updated);\n    localStorage.setItem('lisa:a11y:config', JSON.stringify(updated));\n  };\n\n  return { config, updateConfig };\n}\n\n/**\n * Classe utilitaire pour les styles screen-reader only\n */\nexport const srOnlyStyles: React.CSSProperties = {\n  position: 'absolute',\n  width: '1px',\n  height: '1px',\n  padding: '0',\n  margin: '-1px',\n  overflow: 'hidden',\n  clip: 'rect(0, 0, 0, 0)',\n  whiteSpace: 'nowrap',\n  borderWidth: '0'\n};\n\n/**\n * Composant Screen Reader Only\n */\nexport const ScreenReaderOnly: React.FC<{ children: React.ReactNode }> = ({ children }) => (\n  <span style={srOnlyStyles}>{children}</span>\n);\n\n/**\n * CSS pour l'accessibilit├® (├á ajouter dans le CSS global)\n */\nexport const a11yStyles = `\n  /* Reduced Motion */\n  @media (prefers-reduced-motion: reduce) {\n    *,\n    *::before,\n    *::after {\n      animation-duration: 0.01ms !important;\n      animation-iteration-count: 1 !important;\n      transition-duration: 0.01ms !important;\n    }\n  }\n\n  /* High Contrast */\n  @media (prefers-contrast: more) {\n    body {\n      color: #000;\n      background-color: #fff;\n    }\n    \n    button, a {\n      border: 2px solid currentColor;\n    }\n  }\n\n  /* Focus Visible */\n  button:focus-visible,\n  a:focus-visible,\n  input:focus-visible,\n  select:focus-visible,\n  textarea:focus-visible {\n    outline: 3px solid #4F46E5;\n    outline-offset: 2px;\n  }\n\n  /* Skip Link */\n  .sr-only {\n    position: absolute;\n    width: 1px;\n    height: 1px;\n    padding: 0;\n    margin: -1px;\n    overflow: hidden;\n    clip: rect(0, 0, 0, 0);\n    white-space: nowrap;\n    border-width: 0;\n  }\n\n  .sr-only:focus-visible {\n    position: static;\n    width: auto;\n    height: auto;\n    padding: inherit;\n    margin: inherit;\n    overflow: visible;\n    clip: auto;\n    white-space: normal;\n  }\n\n  /* Large Text */\n  .large-text {\n    font-size: 1.25rem;\n    line-height: 1.5;\n  }\n\n  /* Motion Safe */\n  .motion-safe-none {\n    animation: none !important;\n    transition: none !important;\n  }\n`;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\AlarmTimerPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\AppWithLisaVivante.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getLisaState' is defined but never used. Allowed unused vars must match /^_/u.","line":10,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":39},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'isLisaInitialized'. Either include it or remove the dependency array.","line":68,"column":6,"nodeType":"ArrayExpression","endLine":68,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [isLisaInitialized]","fix":{"range":[2235,2237],"text":"[isLisaInitialized]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ­ƒîƒ App With Lisa Vivante\n * Application wrapper qui int├¿gre Lisa Vivante\n */\n\nimport { useEffect, useState } from 'react';\nimport { Outlet } from 'react-router-dom';\nimport { Toaster } from 'sonner';\nimport { LisaNavigation } from './LisaNavigation';\nimport { initLisaVivante, getLisaState, getLisaStats } from '../manifesto/initLisaVivante';\nimport { validateLisaIsAlive } from '../manifesto/validation';\nimport { toast } from 'sonner';\n\nexport function AppWithLisaVivante() {\n  const [isLisaInitialized, setIsLisaInitialized] = useState(false);\n  const [lisaStatus, setLisaStatus] = useState<'alive' | 'degraded' | 'unknown'>('unknown');\n\n  useEffect(() => {\n    const initializeLisa = async () => {\n      try {\n        console.log('­ƒÜÇ Initializing Lisa Vivante...');\n        \n        // Initialiser Lisa\n        const state = await initLisaVivante({\n          enableSensors: true,\n          enableAudit: true,\n          enableMemory: true,\n          debugMode: import.meta.env.DEV,\n          autoValidate: true,\n          validationInterval: 30000\n        });\n\n        setIsLisaInitialized(true);\n        console.log('Ô£à Lisa Vivante initialized:', state);\n\n        // Valider le statut\n        const validation = await validateLisaIsAlive();\n        if (validation.isAlive) {\n          setLisaStatus('alive');\n          toast.success('Lisa est Vivante! Tous les piliers sont actifs.');\n        } else {\n          setLisaStatus('degraded');\n          toast.warning('Lisa est en mode d├®grad├®. Certains piliers sont inactifs.');\n        }\n\n        // Afficher les statistiques\n        const stats = getLisaStats();\n        console.log('­ƒôè Lisa Stats:', stats);\n\n      } catch (error) {\n        console.error('ÔØî Failed to initialize Lisa Vivante:', error);\n        toast.error('Erreur lors de l\\'initialisation de Lisa Vivante');\n        setLisaStatus('unknown');\n      }\n    };\n\n    initializeLisa();\n\n    // Validation p├®riodique\n    const intervalId = setInterval(async () => {\n      if (isLisaInitialized) {\n        const validation = await validateLisaIsAlive();\n        setLisaStatus(validation.isAlive ? 'alive' : 'degraded');\n      }\n    }, 60000); // Toutes les minutes\n\n    return () => clearInterval(intervalId);\n  }, []);\n\n  return (\n    <div className=\"min-h-screen bg-gray-50 dark:bg-gray-900\">\n      {/* Navigation */}\n      <LisaNavigation />\n\n      {/* Main Content */}\n      <div className=\"md:ml-64 min-h-screen\">\n        {/* Status Bar */}\n        <div className=\"bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700 px-6 py-3\">\n          <div className=\"flex items-center justify-between\">\n            <div className=\"flex items-center gap-3\">\n              <div className={`w-3 h-3 rounded-full ${\n                lisaStatus === 'alive' ? 'bg-green-500 animate-pulse' :\n                lisaStatus === 'degraded' ? 'bg-yellow-500' :\n                'bg-gray-400'\n              }`} />\n              <span className=\"text-sm font-medium\">\n                {lisaStatus === 'alive' ? 'Lisa est Vivante' :\n                 lisaStatus === 'degraded' ? 'Mode D├®grad├®' :\n                 'Initialisation...'}\n              </span>\n            </div>\n            <div className=\"text-xs text-gray-500\">\n              {new Date().toLocaleString('fr-FR')}\n            </div>\n          </div>\n        </div>\n\n        {/* Page Content */}\n        <main className=\"p-6\">\n          <Outlet />\n        </main>\n      </div>\n\n      {/* Toast Notifications */}\n      <Toaster\n        position=\"bottom-right\"\n        theme=\"light\"\n        richColors\n        closeButton\n        expand\n      />\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\AppsPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[482,485],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[482,485],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useVisionAudioStore\" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?","line":13,"column":20,"nodeType":"Identifier","endLine":13,"endColumn":39},{"ruleId":"react-hooks/rules-of-hooks","severity":2,"message":"React Hook \"useMcpClient\" is called conditionally. React Hooks must be called in the exact same order in every component render. Did you accidentally call a React Hook after an early return?","line":14,"column":28,"nodeType":"Identifier","endLine":14,"endColumn":40}],"suppressedMessages":[],"errorCount":2,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useVisionAudioStore } from '../store/visionAudioStore';\nimport { useTranslation } from 'react-i18next';\nimport { useMcpClient } from '../hooks';\n\nexport default function AppsPanel() {\n  const { t } = useTranslation();\n  const intent = useVisionAudioStore(s => s.intent);\n  const intentPayload = useVisionAudioStore(s => s.intentPayload);\n\n  if (intent !== 'mcp_list' || !intentPayload || !('resources' in intentPayload)) return null;\n\n  const resources = (intentPayload as any).resources as { uri: string; name?: string; type?: string }[];\n  const setState = useVisionAudioStore(s=>s.setState);\n  const { readResource } = useMcpClient();\n\n  return (\n    <div role=\"region\" aria-live=\"polite\" aria-label={t('mcp_resources')} style={{ position: 'absolute', right: 10, top: 10, width: 250, maxHeight: 300, overflow: 'auto', background: '#ffffffdd', borderRadius: 8, padding: 8 }}>\n      <h4 style={{ margin: '4px 0' }}>{t('mcp_resources')}</h4>\n      <ul style={{ listStyle: 'none', padding: 0, margin: 0 }}>\n        {resources.map((r) => (\n          <li key={r.uri} style={{ margin: '4px 0', fontSize: 12, cursor:'pointer' }} onClick={async ()=>{\n            const data = await readResource('memory', r.uri);\n            setState({ intent:'mcp_open', intentPayload:data });\n          }}>\n            <strong>{r.name ?? r.uri}</strong>\n            {r.type && <span style={{ color: '#666' }}> ({r.type})</span>}\n          </li>\n        ))}\n      </ul>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ChatInterface.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'className' is defined but never used. Allowed unused args must match /^_/u.","line":9,"column":63,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":72}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useRef, useEffect } from 'react';\nimport { Send, Mic, MicOff, Volume2, VolumeX, Trash2, Minimize2 } from 'lucide-react';\nimport { useChatInterface } from '../hooks/useChatInterface';\n\ninterface ChatInterfaceProps {\n  className?: string;\n}\n\nexport const ChatInterface: React.FC<ChatInterfaceProps> = ({ className }) => {\n  const {\n    messages,\n    isListening,\n    isSpeaking,\n    handleUserMessage,\n    toggleListening,\n    toggleSpeaking,\n    clearChat,\n    currentIntent\n  } = useChatInterface();\n  \n  const [inputMessage, setInputMessage] = useState('');\n  const [isMinimized, setIsMinimized] = useState(false);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const inputRef = useRef<HTMLInputElement>(null);\n\n  // Auto-scroll to bottom when new messages arrive\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  // Focus input when component mounts\n  useEffect(() => {\n    if (!isMinimized) {\n      inputRef.current?.focus();\n    }\n  }, [isMinimized]);\n\n  const handleSendMessage = async () => {\n    if (!inputMessage.trim()) return;\n    \n    const message = inputMessage;\n    setInputMessage('');\n    \n    await handleUserMessage(message);\n  };\n\n  const handleKeyPress = (e: React.KeyboardEvent) => {\n    if (e.key === 'Enter' && !e.shiftKey) {\n      e.preventDefault();\n      handleSendMessage();\n    }\n  };\n\n  const formatTime = (date: Date) => {\n    return date.toLocaleTimeString('fr-FR', { \n      hour: '2-digit', \n      minute: '2-digit' \n    });\n  };\n\n  if (isMinimized) {\n    return (\n      <div className=\"fixed bottom-4 left-4 z-50\">\n        <button\n          onClick={() => setIsMinimized(false)}\n          className=\"bg-blue-600 hover:bg-blue-700 text-white p-3 rounded-full shadow-lg transition-all duration-200 hover:scale-105\"\n        >\n          <div className=\"flex items-center gap-2\">\n            <div className=\"w-3 h-3 bg-green-400 rounded-full animate-pulse\"></div>\n            <span className=\"text-sm font-medium\">Lisa</span>\n          </div>\n        </button>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"fixed bottom-4 left-4 w-96 h-96 bg-white dark:bg-gray-800 rounded-lg shadow-2xl border border-gray-200 dark:border-gray-700 flex flex-col z-50\">\n      {/* Header */}\n      <div className=\"flex items-center justify-between p-4 border-b border-gray-200 dark:border-gray-700 bg-gradient-to-r from-blue-600 to-purple-600 text-white rounded-t-lg\">\n        <div className=\"flex items-center gap-3\">\n          <div className=\"w-8 h-8 bg-white bg-opacity-20 rounded-full flex items-center justify-center\">\n            <div className=\"w-3 h-3 bg-green-400 rounded-full animate-pulse\"></div>\n          </div>\n          <div>\n            <h3 className=\"font-semibold\">Lisa</h3>\n            <p className=\"text-xs opacity-90\">\n              {currentIntent === 'listening' ? '├Ç l\\'├®coute...' : \n               currentIntent === 'processing' ? 'En traitement...' : 'En ligne'}\n            </p>\n          </div>\n        </div>\n        <div className=\"flex items-center gap-2\">\n          <button\n            onClick={toggleSpeaking}\n            className=\"p-1.5 hover:bg-white hover:bg-opacity-20 rounded transition-colors\"\n            title={isSpeaking ? 'D├®sactiver la voix' : 'Activer la voix'}\n          >\n            {isSpeaking ? <Volume2 size={16} /> : <VolumeX size={16} />}\n          </button>\n          <button\n            onClick={toggleListening}\n            className={`p-1.5 hover:bg-white hover:bg-opacity-20 rounded transition-colors ${\n              isListening ? 'bg-red-500' : ''\n            }`}\n            title={isListening ? 'Arr├¬ter l\\'├®coute' : 'Commencer l\\'├®coute'}\n          >\n            {isListening ? <MicOff size={16} /> : <Mic size={16} />}\n          </button>\n          <button\n            onClick={clearChat}\n            className=\"p-1.5 hover:bg-white hover:bg-opacity-20 rounded transition-colors\"\n            title=\"Effacer la conversation\"\n          >\n            <Trash2 size={16} />\n          </button>\n          <button\n            onClick={() => setIsMinimized(true)}\n            className=\"p-1.5 hover:bg-white hover:bg-opacity-20 rounded transition-colors\"\n            title=\"R├®duire\"\n          >\n            <Minimize2 size={16} />\n          </button>\n        </div>\n      </div>\n\n      {/* Messages */}\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-4\">\n        {messages.map((message) => (\n          <div\n            key={message.id}\n            className={`flex ${message.sender === 'user' ? 'justify-end' : 'justify-start'}`}\n          >\n            <div\n              className={`max-w-xs px-4 py-2 rounded-lg ${\n                message.sender === 'user'\n                  ? 'bg-blue-600 text-white rounded-br-none'\n                  : message.type === 'system'\n                  ? 'bg-yellow-100 dark:bg-yellow-900 text-yellow-800 dark:text-yellow-200 rounded-bl-none border border-yellow-300 dark:border-yellow-700'\n                  : 'bg-gray-100 dark:bg-gray-700 text-gray-900 dark:text-gray-100 rounded-bl-none'\n              }`}\n            >\n              <p className=\"text-sm\">{message.content}</p>\n              <p className={`text-xs mt-1 ${\n                message.sender === 'user' ? 'text-blue-100' : 'text-gray-500 dark:text-gray-400'\n              }`}>\n                {formatTime(message.timestamp)}\n              </p>\n            </div>\n          </div>\n        ))}\n        <div ref={messagesEndRef} />\n      </div>\n\n      {/* Input */}\n      <div className=\"p-4 border-t border-gray-200 dark:border-gray-700\">\n        <div className=\"flex items-center gap-2\">\n          <input\n            ref={inputRef}\n            type=\"text\"\n            value={inputMessage}\n            onChange={(e) => setInputMessage(e.target.value)}\n            onKeyPress={handleKeyPress}\n            placeholder=\"Tapez votre message...\"\n            className=\"flex-1 px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 dark:bg-gray-700 dark:text-white text-sm\"\n          />\n          <button\n            onClick={handleSendMessage}\n            disabled={!inputMessage.trim()}\n            className=\"p-2 bg-blue-600 hover:bg-blue-700 disabled:bg-gray-300 disabled:cursor-not-allowed text-white rounded-lg transition-colors\"\n            title=\"Envoyer\"\n          >\n            <Send size={16} />\n          </button>\n        </div>\n        {isListening && (\n          <div className=\"mt-2 flex items-center gap-2 text-sm text-red-600 dark:text-red-400\">\n            <div className=\"w-2 h-2 bg-red-500 rounded-full animate-pulse\"></div>\n            <span>En ├®coute... Parlez maintenant</span>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default ChatInterface;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ClipboardSummaryPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\CodeInterpreterPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1281,1284],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1281,1284],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2274,2277],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2274,2277],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3217,3220],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3217,3220],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CodeInterpreterPanel - Panel for executing Python code\n * \n * This component provides a user interface for writing and executing\n * Python code in a sandboxed environment using the Pyodide runtime.\n */\n\nimport React, { useState } from 'react';\nimport { \n  Box, \n  Typography, \n  Button, \n  Paper, \n  IconButton, \n  Alert, \n  Tooltip,\n  CircularProgress,\n  TextField\n} from '@mui/material';\nimport CodeIcon from '@mui/icons-material/Code';\nimport PlayArrowIcon from '@mui/icons-material/PlayArrow';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport { agentRegistry } from '../agents/registry';\n\ninterface CodeInterpreterPanelProps {\n  expanded?: boolean;\n}\n\nexport const CodeInterpreterPanel: React.FC<CodeInterpreterPanelProps> = ({ expanded = false }) => {\n  // Component state\n  const [isExpanded, setIsExpanded] = useState(expanded);\n  const [code, setCode] = useState<string>('# Enter your Python code here\\n# Example:\\nimport numpy as np\\n\\narr = np.array([1, 2, 3, 4, 5])\\nresult = np.mean(arr)\\nprint(f\"Mean value: {result}\")');\n  const [isExecuting, setIsExecuting] = useState(false);\n  const [result, setResult] = useState<any>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  // Reference to the CodeInterpreterAgent\n  const codeInterpreterAgent = agentRegistry.getAgent('CodeInterpreterAgent');\n\n  // Check if agent is available\n  const agentAvailable = !!codeInterpreterAgent && codeInterpreterAgent.name === 'CodeInterpreterAgent';\n\n  // Function to execute the code\n  const executeCode = async () => {\n    if (!agentAvailable) {\n      setError('CodeInterpreterAgent is not available');\n      return;\n    }\n\n    if (!code.trim()) {\n      setError('Please enter some code to execute');\n      return;\n    }\n\n    setError(null);\n    setIsExecuting(true);\n    setResult(null);\n    \n    try {\n      const executionResult = await codeInterpreterAgent?.execute({\n        intent: 'execute_code',\n        parameters: { code }\n      });\n\n      if (!executionResult.success) {\n        throw new Error(executionResult.error as string);\n      }\n\n      setResult(executionResult.output);\n    } catch (err: any) {\n      setError(err.message || 'An error occurred while executing the code');\n    } finally {\n      setIsExecuting(false);\n    }\n  };\n\n  // Function to copy the result to clipboard\n  const copyResultToClipboard = () => {\n    if (result !== null) {\n      const resultText = typeof result === 'object' ? JSON.stringify(result, null, 2) : String(result);\n      navigator.clipboard.writeText(resultText)\n        .then(() => {\n          // Visual feedback\n          const temp = result;\n          setResult('Copied!');\n          setTimeout(() => {\n            setResult(temp);\n          }, 1000);\n        })\n        .catch(err => {\n          console.error('Error copying to clipboard:', err);\n          setError('Failed to copy to clipboard');\n        });\n    }\n  };\n\n  // Toggle panel expansion\n  const toggleExpand = () => {\n    setIsExpanded(!isExpanded);\n  };\n\n  // Format the execution result for display\n  const formatResult = (result: any): string => {\n    if (result === null || result === undefined) return 'No result';\n    \n    if (typeof result === 'object') {\n      try {\n        return JSON.stringify(result, null, 2);\n      } catch {\n        return String(result);\n      }\n    }\n    \n    return String(result);\n  };\n\n  return (\n    <Box sx={{ mb: 2 }}>\n      <Paper \n        elevation={3} \n        sx={{ \n          p: 2, \n          borderRadius: 2,\n          bgcolor: 'background.paper',\n          transition: 'all 0.3s ease'\n        }}\n      >\n        <Box \n          sx={{ \n            display: 'flex', \n            justifyContent: 'space-between', \n            alignItems: 'center',\n            mb: isExpanded ? 2 : 0 \n          }}\n          onClick={toggleExpand}\n          style={{ cursor: 'pointer' }}\n        >\n          <Box sx={{ display: 'flex', alignItems: 'center' }}>\n            <CodeIcon sx={{ mr: 1, color: 'primary.main' }} />\n            <Typography variant=\"h6\">Code Interpreter</Typography>\n          </Box>\n          <IconButton>\n            {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n          </IconButton>\n        </Box>\n\n        {isExpanded && (\n          <>\n            {!agentAvailable ? (\n              <Alert severity=\"error\">\n                Code interpreter functionality is not available. Please check your configuration.\n              </Alert>\n            ) : (\n              <>\n                <Box sx={{ mb: 2 }}>\n                  <TextField\n                    label=\"Python Code\"\n                    multiline\n                    rows={8}\n                    value={code}\n                    onChange={(e) => setCode(e.target.value)}\n                    variant=\"outlined\"\n                    fullWidth\n                    InputProps={{\n                      style: { fontFamily: 'monospace', fontSize: '0.9rem' }\n                    }}\n                  />\n                </Box>\n\n                <Box sx={{ display: 'flex', mb: 2 }}>\n                  <Button\n                    variant=\"contained\"\n                    color=\"primary\"\n                    onClick={executeCode}\n                    disabled={isExecuting}\n                    startIcon={isExecuting ? <CircularProgress size={20} color=\"inherit\" /> : <PlayArrowIcon />}\n                  >\n                    {isExecuting ? 'Executing...' : 'Run Code'}\n                  </Button>\n                </Box>\n\n                {error && (\n                  <Alert severity=\"error\" sx={{ mb: 2 }}>\n                    {error}\n                  </Alert>\n                )}\n\n                {result !== null && (\n                  <Paper \n                    elevation={1}\n                    sx={{ \n                      p: 2, \n                      mb: 2, \n                      position: 'relative',\n                      backgroundColor: 'grey.100',\n                      fontFamily: 'monospace',\n                      whiteSpace: 'pre-wrap',\n                      maxHeight: '200px',\n                      overflow: 'auto'\n                    }}\n                  >\n                    <Typography variant=\"subtitle1\" gutterBottom>\n                      Output:\n                    </Typography>\n                    <Typography variant=\"body2\" component=\"pre\" sx={{ fontFamily: 'monospace' }}>\n                      {formatResult(result)}\n                    </Typography>\n                    <Box sx={{ position: 'absolute', top: 8, right: 8 }}>\n                      <Tooltip title=\"Copy result\">\n                        <IconButton onClick={copyResultToClipboard}>\n                          <ContentCopyIcon />\n                        </IconButton>\n                      </Tooltip>\n                    </Box>\n                  </Paper>\n                )}\n\n                <Typography variant=\"body2\" color=\"text.secondary\">\n                  Execute Python code using the built-in Pyodide interpreter. Note that only sandboxed operations are supported.\n                </Typography>\n              </>\n            )}\n          </>\n        )}\n      </Paper>\n    </Box>\n  );\n};\n\nexport default CodeInterpreterPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\DataAnalysisPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[543,546],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[543,546],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * DataAnalysisPanel - Data visualization and analysis interface\n */\n\nimport { useState } from 'react';\nimport { useDataAnalysis } from '../hooks/useDataAnalysis';\nimport { BarChart3, TrendingUp, Activity } from 'lucide-react';\n\nexport const DataAnalysisPanel = () => {\n  const { loading, error, analyzeData, calculateStatistics, detectTrends } = useDataAnalysis();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [dataInput, setDataInput] = useState('1, 2, 3, 4, 5, 6, 7, 8, 9, 10');\n  const [result, setResult] = useState<any>(null);\n  const [resultType, setResultType] = useState<string>('');\n\n  const parseData = (): number[] => {\n    return dataInput.split(',').map(v => parseFloat(v.trim())).filter(v => !isNaN(v));\n  };\n\n  const handleAnalyze = async () => {\n    const data = parseData();\n    if (data.length === 0) return;\n    const res = await analyzeData(data);\n    if (res.success) {\n      setResult(res.output);\n      setResultType('analyze');\n    }\n  };\n\n  const handleCalculateStats = async () => {\n    const data = parseData();\n    if (data.length === 0) return;\n    const res = await calculateStatistics(data);\n    if (res.success) {\n      setResult(res.output);\n      setResultType('stats');\n    }\n  };\n\n  const handleDetectTrends = async () => {\n    const data = parseData();\n    if (data.length === 0) return;\n    const res = await detectTrends(data);\n    if (res.success) {\n      setResult(res.output);\n      setResultType('trends');\n    }\n  };\n\n  return (\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 max-w-md\">\n      <div className=\"flex items-center justify-between cursor-pointer\" onClick={() => setIsExpanded(!isExpanded)}>\n        <div className=\"flex items-center gap-2\">\n          <BarChart3 className=\"w-5 h-5 text-purple-500\" />\n          <h3 className=\"font-semibold\">­ƒôè Data Analysis</h3>\n        </div>\n      </div>\n\n      {isExpanded && (\n        <div className=\"mt-4 space-y-3\">\n          {error && (\n            <div className=\"text-red-500 text-sm p-2 bg-red-50 rounded\">\n              {error}\n            </div>\n          )}\n\n          <div>\n            <label className=\"text-sm font-semibold mb-1 block\">Data (comma-separated):</label>\n            <textarea\n              value={dataInput}\n              onChange={(e) => setDataInput(e.target.value)}\n              rows={3}\n              className=\"w-full px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600 text-sm font-mono\"\n              placeholder=\"1, 2, 3, 4, 5\"\n            />\n            <div className=\"text-xs text-gray-500 mt-1\">\n              {parseData().length} data points\n            </div>\n          </div>\n\n          <div className=\"grid grid-cols-3 gap-2\">\n            <button\n              onClick={handleAnalyze}\n              disabled={loading}\n              className=\"px-3 py-2 bg-purple-500 text-white rounded hover:bg-purple-600 disabled:opacity-50 text-sm flex items-center justify-center gap-1\"\n            >\n              <Activity className=\"w-3 h-3\" />\n              Analyze\n            </button>\n            <button\n              onClick={handleCalculateStats}\n              disabled={loading}\n              className=\"px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 text-sm\"\n            >\n              Stats\n            </button>\n            <button\n              onClick={handleDetectTrends}\n              disabled={loading}\n              className=\"px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 text-sm flex items-center justify-center gap-1\"\n            >\n              <TrendingUp className=\"w-3 h-3\" />\n              Trends\n            </button>\n          </div>\n\n          {result && (\n            <div className=\"p-3 bg-gray-50 dark:bg-gray-700 rounded max-h-60 overflow-y-auto\">\n              {resultType === 'stats' && (\n                <div className=\"space-y-2 text-sm\">\n                  <div className=\"grid grid-cols-2 gap-2\">\n                    <div><span className=\"font-semibold\">Min:</span> {result.min?.toFixed(2)}</div>\n                    <div><span className=\"font-semibold\">Max:</span> {result.max?.toFixed(2)}</div>\n                    <div><span className=\"font-semibold\">Mean:</span> {result.mean?.toFixed(2)}</div>\n                    <div><span className=\"font-semibold\">Median:</span> {result.median?.toFixed(2)}</div>\n                    <div><span className=\"font-semibold\">Std Dev:</span> {result.stdDev?.toFixed(2)}</div>\n                    <div><span className=\"font-semibold\">Sum:</span> {result.sum?.toFixed(2)}</div>\n                  </div>\n                </div>\n              )}\n              {resultType === 'trends' && (\n                <div className=\"text-sm\">\n                  <div className=\"font-semibold mb-1\">Trend Analysis:</div>\n                  <div className=\"flex items-center gap-2\">\n                    <TrendingUp className={`w-4 h-4 ${result.trend === 'increasing' ? 'text-green-500' : result.trend === 'decreasing' ? 'text-red-500' : 'text-gray-500'}`} />\n                    <span className=\"capitalize\">{result.trend}</span>\n                  </div>\n                  {result.changePercent && (\n                    <div className=\"text-xs mt-1\">Change: {result.changePercent}%</div>\n                  )}\n                </div>\n              )}\n              {resultType === 'analyze' && result.statistics && (\n                <div className=\"space-y-2\">\n                  <div className=\"font-semibold\">Statistics:</div>\n                  <div className=\"text-xs space-y-1\">\n                    <div>Mean: {result.statistics.mean?.toFixed(2)}</div>\n                    <div>Data Points: {result.dataPoints}</div>\n                  </div>\n                  {result.trends && (\n                    <div className=\"mt-2\">\n                      <div className=\"font-semibold text-xs\">Trend:</div>\n                      <div className=\"text-xs capitalize\">{result.trends.trend}</div>\n                    </div>\n                  )}\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\DebugPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":37,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":37,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1541,1544],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1541,1544],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":40,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":40,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1643,1646],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1643,1646],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"no-case-declarations","severity":2,"message":"Unexpected lexical declaration in case block.","line":61,"column":9,"nodeType":"VariableDeclaration","messageId":"unexpected","endLine":61,"endColumn":40,"suggestions":[{"messageId":"addBrackets","fix":{"range":[2202,3790],"text":"{ const stats = getTracesStats();\n        return <div style={{ maxHeight: '400px', overflow: 'auto' }}>\n          <div style={{ marginBottom: '10px', padding: '5px', backgroundColor: 'rgba(0,0,0,0.3)' }}>\n            <div>Total: {stats.total} plans</div>\n            <div>R├®ussis: {stats.successful} | ├ëchecs: {stats.failed}</div>\n            <div>Dur├®e moyenne: {Math.round(stats.averageDuration / 1000)}s</div>\n          </div>\n          \n          <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>\n            {traces.map(trace => (\n              <div \n                key={trace.id}\n                onClick={() => selectTrace(trace.id)}\n                style={{\n                  padding: '5px',\n                  cursor: 'pointer',\n                  backgroundColor: selectedTrace?.id === trace.id ? 'rgba(50,150,255,0.3)' : 'rgba(0,0,0,0.2)',\n                  borderLeft: `3px solid ${trace.endTime ? \n                    (trace.summary?.includes('failed') ? '#ff5555' : '#55ff55') : \n                    '#ffff55'}`\n                }}\n              >\n                <div style={{ fontWeight: 'bold', fontSize: '11px' }}>\n                  {trace.requestId.substring(0, 30)}{trace.requestId.length > 30 ? '...' : ''}\n                </div>\n                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '10px' }}>\n                  <span>{trace.steps.length} ├®tapes</span>\n                  <span>{formatRelativeTime(trace.startTime)}</span>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>; }"},"desc":"Add {} brackets around the case block."}]}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useVisionAudioStore } from '../store/visionAudioStore';\nimport { useEffect, useState } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport usePlanTracer from '../hooks/usePlanTracer';\nimport { formatDistance } from 'date-fns';\nimport { fr } from 'date-fns/locale';\n\nexport default function DebugPanel() {\n  const { t } = useTranslation();\n  const smileDetected = useVisionAudioStore(s => s.smileDetected);\n  const speechDetected = useVisionAudioStore(s => s.speechDetected);\n  const [open, setOpen] = useState(false);\n  const [mode, setMode] = useState<'store' | 'plans' | 'trace'>('store');\n  \n  // Get snapshot only when needed for display\n  const getSnapshot = () => useVisionAudioStore.getState();\n  const { traces, selectedTrace, selectTrace, getTracesStats } = usePlanTracer({\n    refreshInterval: 3000, // Rafra├«chir toutes les 3 secondes\n    limit: 10 // Limiter ├á 10 traces\n  });\n\n  useEffect(() => {\n    // auto-open when smile+speech for demo\n    if (smileDetected && speechDetected) setOpen(true);\n  }, [smileDetected, speechDetected]);\n  \n  useEffect(() => {\n    // Gestionnaire d'├®v├®nement pour ouvrir le debug panel avec une trace sp├®cifique\n    const handleOpenTrace = (event: CustomEvent<{traceId: string}>) => {\n      setOpen(true);\n      setMode('trace');\n      selectTrace(event.detail.traceId);\n    };\n    \n    // TypeScript ne permet pas directement de typer l'├®v├®nement personnalis├®\n    // donc on doit utiliser 'as any' ici\n    window.addEventListener('open-debug-trace', handleOpenTrace as any);\n    \n    return () => {\n      window.removeEventListener('open-debug-trace', handleOpenTrace as any);\n    };\n  }, [selectTrace]);\n  \n  // Format de date relative\n  const formatRelativeTime = (timestamp: number) => {\n    return formatDistance(new Date(timestamp), new Date(), {\n      addSuffix: true,\n      locale: fr\n    });\n  };\n\n  // Rendu du contenu en fonction du mode s├®lectionn├®\n  const renderContent = () => {\n    switch (mode) {\n      case 'store':\n        return <pre style={{ whiteSpace: 'pre-wrap', maxHeight: '400px', overflow: 'auto' }}>\n          {JSON.stringify(getSnapshot(), null, 2)}\n        </pre>;\n        \n      case 'plans':\n        const stats = getTracesStats();\n        return <div style={{ maxHeight: '400px', overflow: 'auto' }}>\n          <div style={{ marginBottom: '10px', padding: '5px', backgroundColor: 'rgba(0,0,0,0.3)' }}>\n            <div>Total: {stats.total} plans</div>\n            <div>R├®ussis: {stats.successful} | ├ëchecs: {stats.failed}</div>\n            <div>Dur├®e moyenne: {Math.round(stats.averageDuration / 1000)}s</div>\n          </div>\n          \n          <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>\n            {traces.map(trace => (\n              <div \n                key={trace.id}\n                onClick={() => selectTrace(trace.id)}\n                style={{\n                  padding: '5px',\n                  cursor: 'pointer',\n                  backgroundColor: selectedTrace?.id === trace.id ? 'rgba(50,150,255,0.3)' : 'rgba(0,0,0,0.2)',\n                  borderLeft: `3px solid ${trace.endTime ? \n                    (trace.summary?.includes('failed') ? '#ff5555' : '#55ff55') : \n                    '#ffff55'}`\n                }}\n              >\n                <div style={{ fontWeight: 'bold', fontSize: '11px' }}>\n                  {trace.requestId.substring(0, 30)}{trace.requestId.length > 30 ? '...' : ''}\n                </div>\n                <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '10px' }}>\n                  <span>{trace.steps.length} ├®tapes</span>\n                  <span>{formatRelativeTime(trace.startTime)}</span>\n                </div>\n              </div>\n            ))}\n          </div>\n        </div>;\n        \n      case 'trace':\n        if (!selectedTrace) {\n          return <div style={{ padding: '10px', color: '#aaaaaa' }}>\n            S├®lectionnez d'abord un plan dans l'onglet \"Plans\"\n          </div>;\n        }\n        \n        return <div style={{ maxHeight: '400px', overflow: 'auto' }}>\n          <div style={{ marginBottom: '10px', padding: '5px', backgroundColor: 'rgba(0,0,0,0.3)' }}>\n            <div style={{ fontWeight: 'bold', marginBottom: '5px' }}>\n              {selectedTrace.requestId.substring(0, 50)}{selectedTrace.requestId.length > 50 ? '...' : ''}\n            </div>\n            <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px' }}>\n              <span>D├®marr├®: {new Date(selectedTrace.startTime).toLocaleTimeString()}</span>\n              {selectedTrace.endTime && \n                <span>Dur├®e: {Math.round((selectedTrace.endTime - selectedTrace.startTime) / 1000)}s</span>\n              }\n            </div>\n            {selectedTrace.summary && \n              <div style={{ \n                marginTop: '5px', \n                padding: '3px', \n                backgroundColor: selectedTrace.summary.includes('failed') ? 'rgba(255,0,0,0.2)' : 'rgba(0,255,0,0.2)'\n              }}>\n                {selectedTrace.summary}\n              </div>\n            }\n          </div>\n          \n          <div style={{ display: 'flex', flexDirection: 'column', gap: '5px' }}>\n            {selectedTrace.steps.map(step => {\n              const timestamp = new Date(step.timestamp).toLocaleTimeString();\n              let icon = '­ƒöä';\n              const color = '#dddddd';\n              \n              // Ic├┤nes en fonction du type d'op├®ration\n              switch (step.operation) {\n                case 'plan_generation': icon = '­ƒº®'; break;\n                case 'plan_execution': icon = step.details.error ? 'ÔØî' : 'ÔûÂ´©Å'; break;\n                case 'plan_revision': icon = '­ƒöº'; break;\n                case 'checkpoint': icon = '­ƒÆ¥'; break;\n                case 'template_operation': icon = '­ƒôï'; break;\n              }\n              \n              return (\n                <div key={step.id} style={{ padding: '5px', backgroundColor: 'rgba(0,0,0,0.2)', borderLeft: `3px solid ${color}` }}>\n                  <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: '11px' }}>\n                    <span>\n                      {icon} {step.operation}\n                    </span>\n                    <span style={{ color: '#aaaaaa', fontSize: '10px' }}>{timestamp}</span>\n                  </div>\n                  \n                  {step.details.explanation && (\n                    <div style={{ margin: '5px 0', padding: '3px', backgroundColor: 'rgba(255,255,255,0.1)', fontSize: '11px' }}>\n                      {step.details.explanation}\n                    </div>\n                  )}\n                  \n                  {step.details.error && (\n                    <div style={{ margin: '5px 0', padding: '3px', backgroundColor: 'rgba(255,0,0,0.2)', fontSize: '11px' }}>\n                      {step.details.error}\n                    </div>\n                  )}\n                  \n                  {step.details.metadata && (\n                    <div style={{ fontSize: '10px', color: '#aaaaaa', marginTop: '3px' }}>\n                      {Object.entries(step.details.metadata).map(([key, value]) => (\n                        <span key={key} style={{ marginRight: '5px' }}>{key}={String(value)}</span>\n                      ))}\n                    </div>\n                  )}\n                </div>\n              );\n            })}\n          </div>\n        </div>;\n        \n      default:\n        return null;\n    }\n  };\n\n  return (\n    <div role=\"region\" aria-live=\"polite\" aria-label={t('debug_panel')}\n      style={{\n        position: 'fixed',\n        top: 0,\n        right: 0,\n        background: 'rgba(0,0,0,0.8)',\n        color: '#fff',\n        padding: open ? '10px' : '5px',\n        maxWidth: open ? 500 : 80,\n        maxHeight: open ? 500 : 30,\n        fontSize: 12,\n        overflowY: 'auto',\n        zIndex: 9999,\n        borderBottomLeftRadius: '5px',\n        boxShadow: '0 0 10px rgba(0,0,0,0.5)'\n      }}\n    >\n      <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: open ? '10px' : 0 }}>\n        <button onClick={() => setOpen(!open)} style={{ fontSize: 10 }}>\n          {open ? t('hide') : t('debug')}\n        </button>\n        \n        {open && (\n          <div style={{ display: 'flex', gap: '5px' }}>\n            <button \n              onClick={() => setMode('store')} \n              style={{ \n                fontSize: 10, \n                backgroundColor: mode === 'store' ? 'rgba(255,255,255,0.2)' : undefined \n              }}\n            >\n              Store\n            </button>\n            <button \n              onClick={() => setMode('plans')} \n              style={{ \n                fontSize: 10, \n                backgroundColor: mode === 'plans' ? 'rgba(255,255,255,0.2)' : undefined \n              }}\n            >\n              Plans\n            </button>\n            <button \n              onClick={() => setMode('trace')} \n              style={{ \n                fontSize: 10, \n                backgroundColor: mode === 'trace' ? 'rgba(255,255,255,0.2)' : undefined \n              }}\n            >\n              Trace\n            </button>\n          </div>\n        )}\n      </div>\n      \n      {open && renderContent()}\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\EmailPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'suggestResponse' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":10,"column":42,"nodeType":null,"messageId":"unusedVar","endLine":10,"endColumn":57},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[528,531],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[528,531],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * EmailPanel - Email management interface\n */\n\nimport { useState } from 'react';\nimport { useEmail } from '../hooks/useEmail';\nimport { Mail, Sparkles, AlertCircle, Send } from 'lucide-react';\n\nexport const EmailPanel = () => {\n  const { loading, error, classifyEmail, suggestResponse, detectSpam, generateReply } = useEmail();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [emailInput, setEmailInput] = useState({ subject: '', body: '', from: 'test@example.com' });\n  const [result, setResult] = useState<any>(null);\n  const [resultType, setResultType] = useState<string>('');\n\n  const handleClassify = async () => {\n    const email = { ...emailInput, id: Date.now().toString(), to: 'me@example.com', timestamp: Date.now(), read: false };\n    const res = await classifyEmail(email);\n    if (res.success) {\n      setResult(res.output);\n      setResultType('classify');\n    }\n  };\n\n  const handleDetectSpam = async () => {\n    const email = { ...emailInput, id: Date.now().toString(), to: 'me@example.com', timestamp: Date.now(), read: false };\n    const res = await detectSpam(email);\n    if (res.success) {\n      setResult(res.output);\n      setResultType('spam');\n    }\n  };\n\n  const handleGenerateReply = async () => {\n    const email = { ...emailInput, id: Date.now().toString(), to: 'me@example.com', timestamp: Date.now(), read: false };\n    const res = await generateReply(email);\n    if (res.success) {\n      setResult(res.output);\n      setResultType('reply');\n    }\n  };\n\n  return (\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 max-w-md\">\n      <div className=\"flex items-center justify-between cursor-pointer\" onClick={() => setIsExpanded(!isExpanded)}>\n        <div className=\"flex items-center gap-2\">\n          <Mail className=\"w-5 h-5 text-blue-500\" />\n          <h3 className=\"font-semibold\">­ƒôº Email Assistant</h3>\n        </div>\n      </div>\n\n      {isExpanded && (\n        <div className=\"mt-4 space-y-3\">\n          {error && (\n            <div className=\"text-red-500 text-sm p-2 bg-red-50 rounded\">\n              {error}\n            </div>\n          )}\n\n          <div className=\"space-y-2\">\n            <input\n              type=\"text\"\n              placeholder=\"Subject\"\n              value={emailInput.subject}\n              onChange={(e) => setEmailInput({ ...emailInput, subject: e.target.value })}\n              className=\"w-full px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n            />\n            <textarea\n              placeholder=\"Email body\"\n              value={emailInput.body}\n              onChange={(e) => setEmailInput({ ...emailInput, body: e.target.value })}\n              rows={4}\n              className=\"w-full px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n            />\n          </div>\n\n          <div className=\"grid grid-cols-3 gap-2\">\n            <button\n              onClick={handleClassify}\n              disabled={loading}\n              className=\"px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 text-sm flex items-center justify-center gap-1\"\n            >\n              <Sparkles className=\"w-3 h-3\" />\n              Classify\n            </button>\n            <button\n              onClick={handleDetectSpam}\n              disabled={loading}\n              className=\"px-3 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 disabled:opacity-50 text-sm flex items-center justify-center gap-1\"\n            >\n              <AlertCircle className=\"w-3 h-3\" />\n              Spam?\n            </button>\n            <button\n              onClick={handleGenerateReply}\n              disabled={loading}\n              className=\"px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 text-sm flex items-center justify-center gap-1\"\n            >\n              <Send className=\"w-3 h-3\" />\n              Reply\n            </button>\n          </div>\n\n          {result && (\n            <div className=\"p-3 bg-gray-50 dark:bg-gray-700 rounded max-h-60 overflow-y-auto\">\n              {resultType === 'classify' && (\n                <div>\n                  <div className=\"font-semibold\">Category: {result.category}</div>\n                  <div className=\"text-sm\">Confidence: {(result.confidence * 100).toFixed(0)}%</div>\n                  {result.suggestedActions && (\n                    <div className=\"mt-2 text-xs\">\n                      <div className=\"font-semibold\">Suggested Actions:</div>\n                      {result.suggestedActions.map((action: string, i: number) => (\n                        <div key={i}>ÔÇó {action}</div>\n                      ))}\n                    </div>\n                  )}\n                </div>\n              )}\n              {resultType === 'spam' && (\n                <div>\n                  <div className=\"font-semibold\">{result.isSpam ? 'ÔÜá´©Å SPAM DETECTED' : 'Ô£à Legitimate'}</div>\n                  <div className=\"text-sm\">Spam Score: {result.spamScore}/100</div>\n                  <div className=\"text-xs mt-1\">{result.recommendation}</div>\n                </div>\n              )}\n              {resultType === 'reply' && (\n                <div>\n                  <div className=\"font-semibold\">Generated Reply:</div>\n                  <div className=\"text-sm mt-2 p-2 bg-white dark:bg-gray-800 rounded\">{result.reply}</div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ErrorBoundary.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\GitHubPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":380,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":380,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11313,11316],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11313,11316],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":381,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":381,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11359,11362],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11359,11362],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":424,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":424,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12523,12526],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12523,12526],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect } from 'react';\nimport { useAppStore } from '../store/appStore';\nimport { agentRegistry } from '../agents/registry';\nimport { createLogger } from '../utils/logger';\nimport GitHubCacheService from '../services/GitHubCacheService';\nimport './GitHubPanel.css';\n\nconst logger = createLogger('GitHubPanel');\n\ninterface Repository {\n  id: number;\n  name: string;\n  fullName: string;\n  description: string | null;\n  url: string;\n  stars: number;\n  forks: number;\n  language: string | null;\n  isPrivate: boolean;\n}\n\ninterface Issue {\n  id: number;\n  number: number;\n  title: string;\n  state: string;\n  url: string;\n  createdAt: string;\n  author: string;\n  labels: string[];\n}\n\ninterface PullRequest {\n  id: number;\n  number: number;\n  title: string;\n  state: string;\n  url: string;\n  author: string;\n  sourceBranch: string;\n  targetBranch: string;\n}\n\ninterface Commit {\n  sha: string;\n  message: string;\n  author: string;\n  date: string;\n  url: string;\n}\n\ntype ViewType = 'repos' | 'issues' | 'pulls' | 'commits' | 'readme';\n\nconst GitHubPanel: React.FC = () => {\n  const [isVisible, setIsVisible] = useState(false);\n  const [token, setToken] = useState('');\n  const [username, setUsername] = useState('');\n  const [repoOwner, setRepoOwner] = useState('');\n  const [repoName, setRepoName] = useState('');\n  const [currentView, setCurrentView] = useState<ViewType>('repos');\n  const [repositories, setRepositories] = useState<Repository[]>([]);\n  const [issues, setIssues] = useState<Issue[]>([]);\n  const [pullRequests, setPullRequests] = useState<PullRequest[]>([]);\n  const [commits, setCommits] = useState<Commit[]>([]);\n  const [readme, setReadme] = useState<{ content: string | null, url: string | null }>({ content: null, url: null });\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n  const [notification, setNotification] = useState<{ message: string, type: 'success' | 'error' | 'info' } | null>(null);\n  const [useCache, setUseCache] = useState<boolean>(true);\n  const [cacheStatus, setCacheStatus] = useState<{\n    repositories: boolean;\n    issues: boolean;\n    pullRequests: boolean;\n    commits: boolean;\n    readme: boolean;\n  }>({repositories: false, issues: false, pullRequests: false, commits: false, readme: false});\n\n  const { intent } = useAppStore();\n\n  useEffect(() => {\n    // V├®rifier si l'intent concerne GitHub\n    if (intent && intent.toLowerCase().includes('github')) {\n      setIsVisible(true);\n    }\n  }, [intent]);\n\n  useEffect(() => {\n    // Charger le token de l'API GitHub depuis localStorage s'il existe\n    const savedToken = localStorage.getItem('github_token');\n    if (savedToken) {\n      setToken(savedToken);\n    }\n\n    // Charger d'autres pr├®f├®rences utilisateur\n    const savedUsername = localStorage.getItem('github_username');\n    if (savedUsername) {\n      setUsername(savedUsername);\n    }\n    \n    // Charger la pr├®f├®rence de cache\n    const savedCachePreference = localStorage.getItem('github_use_cache');\n    if (savedCachePreference !== null) {\n      setUseCache(savedCachePreference === 'true');\n    }\n  }, []);\n\n  const handleSaveToken = () => {\n    if (token) {\n      localStorage.setItem('github_token', token);\n      setNotification({ message: 'Token GitHub sauvegard├®', type: 'success' });\n      setTimeout(() => setNotification(null), 3000);\n    }\n  };\n\n  const handleSaveUsername = () => {\n    if (username) {\n      localStorage.setItem('github_username', username);\n      setNotification({ message: 'Nom d\\'utilisateur sauvegard├®', type: 'success' });\n      setTimeout(() => setNotification(null), 3000);\n      loadRepositories();\n    }\n  };\n\n  /**\n   * G├¿re le changement de pr├®f├®rence de cache\n   */\n  const handleCacheToggle = () => {\n    const newCacheValue = !useCache;\n    setUseCache(newCacheValue);\n    localStorage.setItem('github_use_cache', String(newCacheValue));\n    setNotification({ \n      message: newCacheValue ? 'Cache activ├®' : 'Cache d├®sactiv├®', \n      type: 'info' \n    });\n    setTimeout(() => setNotification(null), 3000);\n  };\n  \n  /**\n   * Efface le cache GitHub et rafra├«che les donn├®es\n   */\n  const handleClearCache = async () => {\n    setIsLoading(true);\n    setNotification({ message: 'Effacement du cache en cours...', type: 'info' });\n    \n    try {\n      const cacheService = GitHubCacheService.getInstance();\n      await cacheService.clearAllCache();\n      \n      setNotification({ message: 'Cache effac├® avec succ├¿s', type: 'success' });\n      \n      // Recharger les donn├®es actuelles selon la vue active\n      if (currentView === 'repos') {\n        await loadRepositories();\n      } else if (currentView === 'issues') {\n        await loadIssues();\n      } else if (currentView === 'pulls') {\n        await loadPullRequests();\n      } else if (currentView === 'commits') {\n        await loadCommits();\n      } else if (currentView === 'readme') {\n        await loadReadme();\n      }\n    } catch (error) {\n      logger.error('Erreur lors de l\\'effacement du cache', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    } finally {\n      setIsLoading(false);\n      setTimeout(() => setNotification(null), 3000);\n    }\n  };\n\n  const loadRepositories = async () => {\n    if (!username) {\n      setError('Veuillez sp├®cifier un nom d\\'utilisateur');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    setCacheStatus(prev => ({...prev, repositories: false}));\n\n    try {\n      const githubAgent = agentRegistry.getAgent('GitHubAgent');\n      if (!githubAgent) {\n        throw new Error('GitHubAgent non trouv├®');\n      }\n\n      // V├®rifier d'abord si les donn├®es sont dans le cache\n      let cachedData = null;\n      if (useCache) {\n        const cacheService = GitHubCacheService.getInstance();\n        cachedData = await cacheService.getRepositories(username);\n        if (cachedData) {\n          setCacheStatus(prev => ({...prev, repositories: true}));\n        }\n      }\n\n      const result = await githubAgent.execute({\n        action: 'listRepositories',\n        token,\n        username,\n        useCache\n      });\n\n      setRepositories(result as unknown as Repository[]);\n      setCurrentView('repos');\n    } catch (error) {\n      logger.error('Erreur lors du chargement des d├®p├┤ts', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadIssues = async () => {\n    if (!repoOwner || !repoName) {\n      setError('Veuillez sp├®cifier le propri├®taire et le nom du d├®p├┤t');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    setCacheStatus(prev => ({...prev, issues: false}));\n\n    try {\n      const githubAgent = agentRegistry.getAgent('GitHubAgent');\n      if (!githubAgent) {\n        throw new Error('GitHubAgent non trouv├®');\n      }\n\n      // V├®rifier d'abord si les donn├®es sont dans le cache\n      if (useCache) {\n        const cacheService = GitHubCacheService.getInstance();\n        const cachedData = await cacheService.getIssues(repoOwner, repoName, 'all');\n        if (cachedData) {\n          setCacheStatus(prev => ({...prev, issues: true}));\n        }\n      }\n\n      const result = await githubAgent.execute({\n        action: 'listIssues',\n        token,\n        owner: repoOwner,\n        repo: repoName,\n        state: 'all',\n        useCache\n      });\n\n      setIssues(result as unknown as Issue[]);\n      setCurrentView('issues');\n    } catch (error) {\n      logger.error('Erreur lors du chargement des issues', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadPullRequests = async () => {\n    if (!repoOwner || !repoName) {\n      setError('Veuillez sp├®cifier le propri├®taire et le nom du d├®p├┤t');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    setCacheStatus(prev => ({...prev, pullRequests: false}));\n\n    try {\n      const githubAgent = agentRegistry.getAgent('GitHubAgent');\n      if (!githubAgent) {\n        throw new Error('GitHubAgent non trouv├®');\n      }\n      \n      // V├®rifier d'abord si les donn├®es sont dans le cache\n      if (useCache) {\n        const cacheService = GitHubCacheService.getInstance();\n        const cachedData = await cacheService.getPullRequests(repoOwner, repoName, 'all');\n        if (cachedData) {\n          setCacheStatus(prev => ({...prev, pullRequests: true}));\n        }\n      }\n\n      const result = await githubAgent.execute({\n        action: 'listPullRequests',\n        token,\n        owner: repoOwner,\n        repo: repoName,\n        state: 'all',\n        useCache\n      });\n\n      setPullRequests(result as unknown as PullRequest[]);\n      setCurrentView('pulls');\n    } catch (error) {\n      logger.error('Erreur lors du chargement des pull requests', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadCommits = async () => {\n    if (!repoOwner || !repoName) {\n      setError('Veuillez sp├®cifier le propri├®taire et le nom du d├®p├┤t');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    setCacheStatus(prev => ({...prev, commits: false}));\n\n    try {\n      const githubAgent = agentRegistry.getAgent('GitHubAgent');\n      if (!githubAgent) {\n        throw new Error('GitHubAgent non trouv├®');\n      }\n      \n      // V├®rifier d'abord si les donn├®es sont dans le cache\n      if (useCache) {\n        const cacheService = GitHubCacheService.getInstance();\n        const cachedData = await cacheService.getCommits(repoOwner, repoName);\n        if (cachedData) {\n          setCacheStatus(prev => ({...prev, commits: true}));\n        }\n      }\n\n      const result = await githubAgent.execute({\n        action: 'listCommits',\n        token,\n        owner: repoOwner,\n        repo: repoName,\n        useCache\n      });\n\n      setCommits(result as unknown as Commit[]);\n      setCurrentView('commits');\n    } catch (error) {\n      logger.error('Erreur lors du chargement des commits', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const loadReadme = async () => {\n    if (!repoOwner || !repoName) {\n      setError('Veuillez sp├®cifier le propri├®taire et le nom du d├®p├┤t');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n    setCacheStatus(prev => ({...prev, readme: false}));\n\n    try {\n      const githubAgent = agentRegistry.getAgent('GitHubAgent');\n      if (!githubAgent) {\n        throw new Error('GitHubAgent non trouv├®');\n      }\n      \n      // V├®rifier d'abord si les donn├®es sont dans le cache\n      if (useCache) {\n        const cacheService = GitHubCacheService.getInstance();\n        const cachedData = await cacheService.getReadme(repoOwner, repoName);\n        if (cachedData) {\n          setCacheStatus(prev => ({...prev, readme: true}));\n        }\n      }\n\n      const result = await githubAgent.execute({\n        action: 'getReadme',\n        token,\n        owner: repoOwner,\n        repo: repoName,\n        useCache\n      });\n\n      setReadme({\n        content: (result as any).content ?? null,\n        url: (result as any).url ?? null,\n      });\n      setCurrentView('readme');\n    } catch (error) {\n      logger.error('Erreur lors du chargement du README', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  const handleSelectRepository = (owner: string, name: string) => {\n    setRepoOwner(owner);\n    setRepoName(name);\n    // Chargement des issues par d├®faut apr├¿s s├®lection d'un d├®p├┤t\n    setCurrentView('issues');\n    loadIssues();\n  };\n\n  const handleCreateIssue = async (title: string, body: string) => {\n    if (!repoOwner || !repoName || !title || !body) {\n      setError('Informations manquantes pour cr├®er une issue');\n      return;\n    }\n\n    setIsLoading(true);\n    setError(null);\n\n    try {\n      const githubAgent = agentRegistry.getAgent('GitHubAgent');\n      if (!githubAgent) {\n        throw new Error('GitHubAgent non trouv├®');\n      }\n\n      const result = await githubAgent.execute({\n        action: 'createIssue',\n        token,\n        owner: repoOwner,\n        repo: repoName,\n        title,\n        body\n      });\n\n      const issueNumber = (result as any)?.number ?? 'N/A';\n      setNotification({ message: `Issue cr├®├®e: #${issueNumber}`, type: 'success' });\n      // Recharger les issues pour afficher la nouvelle\n      loadIssues();\n    } catch (error) {\n      logger.error('Erreur lors de la cr├®ation de l\\'issue', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n\n  if (!isVisible) {\n    return null;\n  }\n\n  return (\n    <div className=\"github-panel\">\n      <h2>GitHub Explorer</h2>\n      \n      {notification && (\n        <div className={`notification ${notification.type}`}>\n          {notification.message}\n        </div>\n      )}\n\n      <div className=\"auth-section\">\n        <div className=\"input-group\">\n          <input \n            type=\"password\"\n            placeholder=\"Token GitHub (optionnel)\" \n            value={token}\n            onChange={(e) => setToken(e.target.value)}\n          />\n          <button onClick={handleSaveToken}>Sauvegarder Token</button>\n        </div>\n        <div className=\"input-group\">\n          <input \n            type=\"text\"\n            placeholder=\"Nom d'utilisateur GitHub\" \n            value={username}\n            onChange={(e) => setUsername(e.target.value)}\n          />\n          <button onClick={handleSaveUsername}>Sauvegarder</button>\n        </div>\n        <button className=\"load-button\" onClick={loadRepositories}>\n          Charger les d├®p├┤ts\n        </button>\n      </div>\n\n      {error && <div className=\"error-message\">{error}</div>}\n\n      {repoOwner && repoName && (\n        <div className=\"repo-context\">\n          <h3>D├®p├┤t s├®lectionn├®: {repoOwner}/{repoName}</h3>\n          <div className=\"nav-buttons\">\n            <button \n              onClick={loadIssues}\n              className={currentView === 'issues' ? 'active' : ''}\n            >\n              Issues\n            </button>\n            <button \n              onClick={loadPullRequests}\n              className={currentView === 'pulls' ? 'active' : ''}\n            >\n              Pull Requests\n            </button>\n            <button \n              onClick={loadCommits}\n              className={currentView === 'commits' ? 'active' : ''}\n            >\n              Commits\n            </button>\n            <button \n              onClick={loadReadme}\n              className={currentView === 'readme' ? 'active' : ''}\n            >\n              README\n            </button>\n          </div>\n        </div>\n      )}\n\n      {isLoading ? (\n        <div className=\"loading\">Chargement en cours...</div>\n      ) : (\n        <div className=\"content-area\">\n          {currentView === 'repos' && repositories.length > 0 && (\n            <div className=\"repos-list\">\n              <h3>D├®p├┤ts ({repositories.length})</h3>\n              <ul>\n                {repositories.map(repo => (\n                  <li key={repo.id} className=\"repo-item\">\n                    <div className=\"repo-header\">\n                      <h4>{repo.name}</h4>\n                      <span className=\"repo-stats\">\n                        Ô¡É {repo.stars} ­ƒì┤ {repo.forks}\n                      </span>\n                    </div>\n                    <p className=\"repo-desc\">{repo.description || 'Pas de description'}</p>\n                    <div className=\"repo-footer\">\n                      <span className=\"repo-lang\">{repo.language || 'N/A'}</span>\n                      <div className=\"repo-actions\">\n                        <a href={repo.url} target=\"_blank\" rel=\"noopener noreferrer\">\n                          Voir sur GitHub\n                        </a>\n                        <button \n                          onClick={() => handleSelectRepository(\n                            repo.fullName.split('/')[0], \n                            repo.fullName.split('/')[1]\n                          )}\n                        >\n                          Explorer\n                        </button>\n                      </div>\n                    </div>\n                  </li>\n                ))}\n              </ul>\n            </div>\n          )}\n\n          {currentView === 'issues' && (\n            <>\n              <div className=\"create-issue\">\n                <h3>Cr├®er une issue</h3>\n                <input \n                  type=\"text\" \n                  placeholder=\"Titre de l'issue\" \n                  id=\"issue-title\" \n                />\n                <textarea \n                  placeholder=\"Description de l'issue\" \n                  id=\"issue-body\"\n                />\n                <button \n                  onClick={() => {\n                    const title = (document.getElementById('issue-title') as HTMLInputElement).value;\n                    const body = (document.getElementById('issue-body') as HTMLTextAreaElement).value;\n                    handleCreateIssue(title, body);\n                  }}\n                >\n                  Cr├®er l'issue\n                </button>\n              </div>\n\n              <div className=\"issues-list\">\n                <h3>Issues ({issues.length})</h3>\n                {issues.length === 0 ? (\n                  <p>Aucune issue trouv├®e</p>\n                ) : (\n                  <ul>\n                    {issues.map(issue => (\n                      <li key={issue.id} className=\"issue-item\">\n                        <div className=\"issue-header\">\n                          <span className={`issue-state ${issue.state}`}>\n                            {issue.state === 'open' ? '­ƒƒó' : '­ƒö┤'} #{issue.number}\n                          </span>\n                          <h4>{issue.title}</h4>\n                        </div>\n                        <div className=\"issue-footer\">\n                          <span className=\"issue-author\">@{issue.author}</span>\n                          <a href={issue.url} target=\"_blank\" rel=\"noopener noreferrer\">\n                            Voir sur GitHub\n                          </a>\n                        </div>\n                        <div className=\"issue-labels\">\n                          {issue.labels.map(label => (\n                            <span key={label} className=\"issue-label\">{label}</span>\n                          ))}\n                        </div>\n                      </li>\n                    ))}\n                  </ul>\n                )}\n              </div>\n            </>\n          )}\n\n          {currentView === 'pulls' && (\n            <div className=\"pulls-list\">\n              <h3>Pull Requests ({pullRequests.length})</h3>\n              {pullRequests.length === 0 ? (\n                <p>Aucune pull request trouv├®e</p>\n              ) : (\n                <ul>\n                  {pullRequests.map(pr => (\n                    <li key={pr.id} className=\"pr-item\">\n                      <div className=\"pr-header\">\n                        <span className={`pr-state ${pr.state}`}>\n                          {pr.state === 'open' ? '­ƒƒó' : '­ƒö┤'} #{pr.number}\n                        </span>\n                        <h4>{pr.title}</h4>\n                      </div>\n                      <div className=\"pr-branches\">\n                        {pr.sourceBranch} ÔåÆ {pr.targetBranch}\n                      </div>\n                      <div className=\"pr-footer\">\n                        <span className=\"pr-author\">@{pr.author}</span>\n                        <a href={pr.url} target=\"_blank\" rel=\"noopener noreferrer\">\n                          Voir sur GitHub\n                        </a>\n                      </div>\n                    </li>\n                  ))}\n                </ul>\n              )}\n            </div>\n          )}\n\n          {currentView === 'commits' && (\n            <div className=\"commits-list\">\n              <h3>Commits r├®cents ({commits.length})</h3>\n              {commits.length === 0 ? (\n                <p>Aucun commit trouv├®</p>\n              ) : (\n                <ul>\n                  {commits.map(commit => (\n                    <li key={commit.sha} className=\"commit-item\">\n                      <div className=\"commit-header\">\n                        <h4 className=\"commit-sha\">{commit.sha.substring(0, 7)}</h4>\n                        <span className=\"commit-date\">\n                          {new Date(commit.date).toLocaleDateString()}\n                        </span>\n                      </div>\n                      <p className=\"commit-message\">{commit.message}</p>\n                      <div className=\"commit-footer\">\n                        <span className=\"commit-author\">@{commit.author}</span>\n                        <a href={commit.url} target=\"_blank\" rel=\"noopener noreferrer\">\n                          Voir sur GitHub\n                        </a>\n                      </div>\n                    </li>\n                  ))}\n                </ul>\n              )}\n            </div>\n          )}\n\n          {currentView === 'readme' && (\n            <div className=\"readme-content\">\n              <h3>README</h3>\n              {readme.content ? (\n                <div className=\"markdown-content\">\n                  <pre>{readme.content}</pre>\n                </div>\n              ) : (\n                <p>Pas de README trouv├®</p>\n              )}\n              {readme.url && (\n                <div className=\"readme-footer\">\n                  <a href={readme.url} target=\"_blank\" rel=\"noopener noreferrer\">\n                    Voir sur GitHub\n                  </a>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n\n      <div className=\"github-panel-footer\">\n        <div className=\"cache-controls\">\n          <div className=\"cache-toggle\">\n            <label className=\"toggle-switch\">\n              <input \n                type=\"checkbox\" \n                checked={useCache} \n                onChange={handleCacheToggle}\n              />\n              <span className=\"toggle-slider\"></span>\n            </label>\n            <span>Utiliser le cache</span>\n            {cacheStatus[currentView as keyof typeof cacheStatus] && (\n              <span className=\"cache-indicator\">­ƒöä Donn├®es en cache</span>\n            )}\n          </div>\n          <button \n            className=\"clear-cache-button\" \n            onClick={handleClearCache}\n            disabled={!useCache}\n          >\n            Rafra├«chir le cache\n          </button>\n        </div>\n        <div className=\"close-button-container\">\n          <button \n            className=\"close-button\" \n            onClick={() => setIsVisible(false)}\n          >\n            Fermer\n          </button>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default GitHubPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\GoogleCalendarButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\HealthMonitorPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Activity' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":25},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[525,528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[525,528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[594,597],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[594,597],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":129,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":129,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4695,4698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4695,4698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * HealthMonitorPanel - Health tracking dashboard\n */\n\nimport { useState } from 'react';\nimport { useHealthMonitor } from '../hooks/useHealthMonitor';\nimport { Heart, Activity, TrendingUp } from 'lucide-react';\n\nexport const HealthMonitorPanel = () => {\n  const { loading, error, trackMetric, getRecommendations } = useHealthMonitor();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [metric, setMetric] = useState('steps');\n  const [value, setValue] = useState('');\n  const [result, setResult] = useState<any>(null);\n  const [recommendations, setRecommendations] = useState<any>(null);\n\n  const handleTrackMetric = async () => {\n    const numValue = parseFloat(value);\n    if (isNaN(numValue)) return;\n    \n    const res = await trackMetric(metric, numValue);\n    if (res.success) {\n      setResult(res.output);\n      setValue('');\n    }\n  };\n\n  const handleGetRecommendations = async () => {\n    const res = await getRecommendations();\n    if (res.success) {\n      setRecommendations(res.output);\n    }\n  };\n\n  const metricOptions = [\n    { value: 'steps', label: 'Steps', icon: '­ƒÜÂ', unit: 'steps' },\n    { value: 'heart_rate', label: 'Heart Rate', icon: 'ÔØñ´©Å', unit: 'bpm' },\n    { value: 'sleep_duration', label: 'Sleep', icon: '­ƒÿ┤', unit: 'hours' },\n    { value: 'water_intake', label: 'Water', icon: '­ƒÆº', unit: 'ml' },\n    { value: 'weight', label: 'Weight', icon: 'ÔÜû´©Å', unit: 'kg' }\n  ];\n\n  const getStatusColor = (status: string) => {\n    const colors: Record<string, string> = {\n      optimal: 'text-green-500',\n      normal: 'text-blue-500',\n      high: 'text-orange-500',\n      low: 'text-yellow-500'\n    };\n    return colors[status] || 'text-gray-500';\n  };\n\n  return (\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 max-w-md\">\n      <div className=\"flex items-center justify-between cursor-pointer\" onClick={() => setIsExpanded(!isExpanded)}>\n        <div className=\"flex items-center gap-2\">\n          <Heart className=\"w-5 h-5 text-red-500\" />\n          <h3 className=\"font-semibold\">­ƒÆ¬ Health Monitor</h3>\n        </div>\n      </div>\n\n      {isExpanded && (\n        <div className=\"mt-4 space-y-3\">\n          {error && (\n            <div className=\"text-red-500 text-sm p-2 bg-red-50 rounded\">\n              {error}\n            </div>\n          )}\n\n          <div className=\"space-y-2\">\n            <select\n              value={metric}\n              onChange={(e) => setMetric(e.target.value)}\n              className=\"w-full px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n            >\n              {metricOptions.map(opt => (\n                <option key={opt.value} value={opt.value}>\n                  {opt.icon} {opt.label}\n                </option>\n              ))}\n            </select>\n\n            <div className=\"flex items-center gap-2\">\n              <input\n                type=\"number\"\n                value={value}\n                onChange={(e) => setValue(e.target.value)}\n                placeholder=\"Value\"\n                className=\"flex-1 px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n              />\n              <span className=\"text-sm text-gray-500\">\n                {metricOptions.find(m => m.value === metric)?.unit}\n              </span>\n              <button\n                onClick={handleTrackMetric}\n                disabled={loading || !value}\n                className=\"px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50\"\n              >\n                Log\n              </button>\n            </div>\n          </div>\n\n          {result && (\n            <div className=\"p-3 bg-blue-50 dark:bg-blue-900/20 rounded\">\n              <div className=\"flex items-center justify-between\">\n                <div>\n                  <div className=\"font-semibold\">{result.metric}</div>\n                  <div className=\"text-2xl font-bold\">{result.value} {result.unit}</div>\n                </div>\n                <div className={`text-lg font-semibold ${getStatusColor(result.status)}`}>\n                  {result.status}\n                </div>\n              </div>\n            </div>\n          )}\n\n          <button\n            onClick={handleGetRecommendations}\n            disabled={loading}\n            className=\"w-full px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50 flex items-center justify-center gap-2\"\n          >\n            <TrendingUp className=\"w-4 h-4\" />\n              Get Health Tips\n            </button>\n\n          {recommendations && recommendations.recommendations && (\n            <div className=\"max-h-60 overflow-y-auto space-y-2\">\n              {recommendations.recommendations.map((rec: any, i: number) => (\n                <div key={i} className=\"p-2 bg-green-50 dark:bg-green-900/20 rounded text-sm\">\n                  <div className=\"font-semibold\">{rec.title}</div>\n                  <div className=\"text-xs text-gray-600 dark:text-gray-400\">{rec.description}</div>\n                  <div className=\"text-xs text-green-600 mt-1\">Ô£ô {rec.benefit}</div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\HearingPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Button' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'CircularProgress' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":51},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setError' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":24,"column":17,"nodeType":null,"messageId":"unusedVar","endLine":24,"endColumn":25}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n// src/components/HearingPanel.tsx\n\nimport React, { useState, useEffect } from 'react';\nimport { Box, Typography, Button, CircularProgress, Paper, Alert, Switch, FormControlLabel } from '@mui/material';\nimport HearingIcon from '@mui/icons-material/Hearing';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport { useAppStore } from '../store/appStore';\nimport { hearingSense, HearingPerceptPayload } from '../senses/hearing';\n\ninterface HearingPanelProps {\n  expanded?: boolean;\n}\n\nexport const HearingPanel: React.FC<HearingPanelProps> = ({ expanded = false }) => {\n  const { featureFlags, setState } = useAppStore((s) => ({\n    featureFlags: s.featureFlags,\n    setState: s.setState,\n  }));\n  const [isExpanded, setIsExpanded] = useState(expanded);\n  const [isListening, setIsListening] = useState(false);\n  const [lastPercept, setLastPercept] = useState<HearingPerceptPayload | null>(null);\n  const [error, setError] = useState<string | null>(null);\n\n  const handleAdvancedHearingToggle = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setState((state) => ({\n      featureFlags: {\n        ...state.featureFlags,\n        advancedHearing: event.target.checked,\n      },\n    }));\n  };\n\n  useEffect(() => {\n    const handleHearingPercept = (percept: { payload: HearingPerceptPayload }) => {\n      setLastPercept(percept.payload);\n    };\n\n    if (featureFlags.advancedHearing) {\n      hearingSense.setOnPerceptCallback(handleHearingPercept);\n      // Initialize the worker with audio context and stream\n      // Note: micStream might be null initially, handle this in initializeHearingWorker\n      hearingSense.initialize(); // No longer passing audioCtx and micStream directly\n      setIsListening(true);\n    } else {\n      hearingSense.terminate();\n      setIsListening(false);\n    }\n\n    return () => {\n      hearingSense.terminate();\n      hearingSense.setOnPerceptCallback(null);\n    };\n  }, [featureFlags.advancedHearing]);\n\n  const toggleExpand = () => {\n    setIsExpanded(!isExpanded);\n  };\n\n  return (\n    <Box sx={{\n      border: '1px solid #e0e0e0',\n      borderRadius: 1,\n      mb: 2,\n      overflow: 'hidden',\n      transition: 'all 0.3s ease'\n    }}>\n      {/* Panel Header */}\n      <Box\n        sx={{\n          p: 1,\n          bgcolor: 'primary.main',\n          color: 'white',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          cursor: 'pointer'\n        }}\n        onClick={toggleExpand}\n      >\n        <Box sx={{ display: 'flex', alignItems: 'center' }}>\n          <HearingIcon sx={{ mr: 1 }} />\n          <Typography variant=\"subtitle1\">Audition Avanc├®e</Typography>\n        </Box>\n        {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n      </Box>\n\n      {/* Panel Content */}\n      {isExpanded && (\n        <Box sx={{ p: 2 }}>\n          <FormControlLabel\n            control={\n              <Switch\n                checked={featureFlags.advancedHearing}\n                onChange={handleAdvancedHearingToggle}\n                name=\"advancedHearing\"\n                color=\"primary\"\n              />\n            }\n            label=\"Activer l'Audition Avanc├®e (STT, NLU, SER)\"\n          />\n\n          {featureFlags.advancedHearing && (\n            <Box sx={{ mt: 2 }}>\n              <Typography variant=\"h6\" gutterBottom>Statut:</Typography>\n              <Paper elevation={1} sx={{ p: 2 }}>\n                <Typography variant=\"body1\">\n                  Statut d'├®coute: {isListening ? 'Actif' : 'Inactif'}\n                </Typography>\n                {lastPercept && (\n                  <Box sx={{ mt: 2 }}>\n                    <Typography variant=\"h6\">Dernier Percept Audio:</Typography>\n                    {lastPercept.text && (\n                      <Typography variant=\"body2\"><strong>Texte:</strong> {lastPercept.text}</Typography>\n                    )}\n                    {lastPercept.emotion && (\n                      <Typography variant=\"body2\"><strong>├ëmotion:</strong> {lastPercept.emotion}</Typography>\n                    )}\n                    {lastPercept.sentiment && (\n                      <Typography variant=\"body2\"><strong>Sentiment:</strong> {lastPercept.sentiment}</Typography>\n                    )}\n                    {lastPercept.intent && (\n                      <Typography variant=\"body2\"><strong>Intention:</strong> {lastPercept.intent}</Typography>\n                    )}\n                  </Box>\n                )}\n              </Paper>\n            </Box>\n          )}\n\n          {error && (\n            <Alert severity=\"error\" sx={{ mt: 2 }}>\n              {error}\n            </Alert>\n          )}\n\n          <Typography variant=\"body2\" color=\"text.secondary\" sx={{ mt: 2 }}>\n            L'audition avanc├®e permet ├á Lisa de comprendre la parole (STT), le sentiment, l'intention (NLU) et l'├®motion (SER).\n          </Typography>\n        </Box>\n      )}\n    </Box>\n  );\n};\n\nexport default HearingPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\IncarnationDashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\LisaCanvas.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":198,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":198,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8032,8035],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8032,8035],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8172,8175],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8172,8175],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8198,8201],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8198,8201],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8224,8227],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8224,8227],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":200,"column":122,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":200,"endColumn":125,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8254,8257],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8254,8257],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8346,8349],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8346,8349],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8378,8381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8378,8381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":113,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":116,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8418,8421],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8418,8421],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":202,"column":139,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":202,"endColumn":142,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8444,8447],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8444,8447],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef, useCallback } from 'react';\nimport { useTranslation } from 'react-i18next';\n\nimport DrawWorker from '../workers/drawWorker.ts?worker';\nimport { useAppStore } from '../store/appStore'; // Changed from useVisionAudioStore\nimport { visionSense } from '../senses/vision';\nimport type { Percept, VisionPayload, DetectionResult, MediaPipeFacePayload, MediaPipeHandPayload } from '../senses/vision';\nimport { logComponent, logError, startupLogger } from '../utils/startupLogger';\n\nconst MAX_PERCEPTS = 10; // Limiter le nombre de percepts stock├®s\n\ninterface Props {\n  video?: HTMLVideoElement | null;\n}\n\n/**\n * Renders landmarks and detections from Zustand store over the provided video element.\n */\nexport default function LisaCanvas({ video }: Props) {\n  const { t } = useTranslation();\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n  \n  logComponent('LisaCanvas', 'Component mounting', { hasVideo: !!video });\n  \n  // S├®parer les selectors pour ├®viter re-renders inutiles\n  const percepts = useAppStore((s) => s.percepts);\n  const lastSilenceMs = useAppStore((s) => s.lastSilenceMs);\n  const audio = useAppStore((s) => s.audio);\n  const smileDetected = useAppStore((s) => s.smileDetected);\n  const speechDetected = useAppStore((s) => s.speechDetected);\n  const featureFlags = useAppStore((s) => s.featureFlags);\n  const workerRef = useRef<Worker | null>(null);\n  const useWorker = useRef<boolean>(false);\n  const cheerUntilRef = useRef<number>(0);\n  const isTransferredRef = useRef<boolean>(false);\n\n  // Init worker & offscreen if supported\n  useEffect(() => {\n    if (!canvasRef.current) {\n      logComponent('LisaCanvas', 'Canvas ref not ready');\n      return;\n    }\n    \n    // Prevent double transfer in React Strict Mode (dev)\n    if (isTransferredRef.current) {\n      logComponent('LisaCanvas', 'Canvas already transferred (Strict Mode protection)');\n      return;\n    }\n    \n    startupLogger.startTimer('canvas-worker-init');\n    \n    if ('transferControlToOffscreen' in canvasRef.current && import.meta.env.PROD) {\n      try {\n        logComponent('LisaCanvas', 'Transferring canvas to OffscreenCanvas');\n        const off = (canvasRef.current as HTMLCanvasElement & { transferControlToOffscreen: () => OffscreenCanvas }).transferControlToOffscreen();\n        workerRef.current = new DrawWorker();\n        workerRef.current.postMessage({ canvas: off }, [off]);\n        useWorker.current = true;\n        isTransferredRef.current = true;\n        \n        startupLogger.endTimer('canvas-worker-init', 'component', 'LisaCanvas');\n        logComponent('LisaCanvas', 'Worker initialized successfully');\n      } catch (error) {\n        logError('component', 'Failed to initialize canvas worker', error, 'LisaCanvas');\n      }\n    } else {\n      const reason = !('transferControlToOffscreen' in canvasRef.current)\n        ? 'OffscreenCanvas not supported'\n        : 'Dev mode (Strict Mode) - OffscreenCanvas disabled';\n      logComponent('LisaCanvas', `${reason}, using main thread`);\n    }\n    \n    return () => {\n      // Cleanup worker on unmount\n      if (workerRef.current) {\n        logComponent('LisaCanvas', 'Terminating worker');\n        workerRef.current.terminate();\n        workerRef.current = null;\n      }\n    };\n  }, []);\n\n  // Subscribe to visionSense percepts and update store\n  const handleVisionPercept = useCallback((percept: Percept<VisionPayload>) => {\n    useAppStore.setState((state) => {\n      const currentPercepts = state.percepts || [];\n      // Garder seulement les MAX_PERCEPTS plus r├®cents pour ├®viter accumulation infinie\n      const newPercepts = [...currentPercepts, percept].slice(-MAX_PERCEPTS);\n      return { percepts: newPercepts };\n    });\n  }, []);\n\n  useEffect(() => {\n    // Note: advancedVision est d├®sactiv├® par d├®faut pour ├®viter les boucles infinies\n    // Activer manuellement via les param├¿tres si n├®cessaire\n    logComponent('LisaCanvas', 'Vision sense effect', { advancedVision: featureFlags.advancedVision });\n    \n    if (featureFlags.advancedVision) {\n      startupLogger.startTimer('vision-sense-start');\n      logComponent('LisaCanvas', 'Starting vision sense');\n      visionSense.setOnPerceptCallback(handleVisionPercept);\n      visionSense.start();\n      startupLogger.endTimer('vision-sense-start', 'component', 'LisaCanvas');\n    } else {\n      logComponent('LisaCanvas', 'Stopping vision sense (advancedVision disabled)');\n      visionSense.stop();\n    }\n\n    return () => {\n      logComponent('LisaCanvas', 'Cleaning up vision sense');\n      visionSense.stop();\n      visionSense.setOnPerceptCallback(null);\n    };\n  }, [featureFlags.advancedVision, handleVisionPercept]);\n\n  // Resize canvas to match video size on mount / resize\n  useEffect(() => {\n    if (!video || !canvasRef.current) return;\n    const resize = () => {\n      if (!canvasRef.current || !video) return;\n\n      // If the canvas was transferred, never mutate width/height directly\n      if (isTransferredRef.current) {\n        if (workerRef.current) {\n          workerRef.current.postMessage({\n            type: 'resize',\n            width: video.videoWidth,\n            height: video.videoHeight\n          });\n        }\n        return;\n      }\n\n      // Otherwise, safe to set size directly\n      canvasRef.current.width = video.videoWidth;\n      canvasRef.current.height = video.videoHeight;\n    };\n    resize();\n    window.addEventListener('resize', resize);\n    return () => window.removeEventListener('resize', resize);\n  }, [video]);\n\n  // Draw when store updates\n  useEffect(() => {\n    if (!video || !canvasRef.current) return;\n    if (useWorker.current && workerRef.current) {\n      workerRef.current.postMessage({\n        width: canvasRef.current.width,\n        height: canvasRef.current.height,\n        percepts,\n        smileDetected,\n        speechDetected,\n        featureFlags,\n      });\n      return;\n    }\n    const ctx = canvasRef.current.getContext('2d')!;\n    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);\n\n    // Percepts\n    percepts?.forEach((p) => {\n      if (p.modality === 'vision') {\n        if (featureFlags.advancedVision && (p.payload as DetectionResult).boxes) {\n          // Advanced Vision (YOLOv8-n or similar)\n          const payload = p.payload as DetectionResult;\n          payload.boxes.forEach((box, i) => {\n            const [x1, y1, x2, y2] = box;\n            const width = x2 - x1;\n            const height = y2 - y1;\n            ctx.strokeStyle = '#00FFFF'; // Cyan for advanced vision\n            ctx.lineWidth = 2;\n            ctx.strokeRect(x1 * ctx.canvas.width, y1 * ctx.canvas.height, width * ctx.canvas.width, height * ctx.canvas.height);\n            ctx.fillStyle = '#00FFFF';\n            ctx.fillText(`${payload.classes[i]} (${(payload.scores[i] * 100).toFixed(0)}%)`, x1 * ctx.canvas.width, y1 * ctx.canvas.height - 4);\n          });\n        } else if ((p.payload as MediaPipeFacePayload).type === 'face') {\n          // MediaPipe Face Detection\n          const payload = p.payload as MediaPipeFacePayload;\n          payload.boxes.forEach(box => {\n            const [x, y, width, height] = box;\n            ctx.strokeStyle = 'yellow';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(x, y, width, height);\n            ctx.fillStyle = 'yellow';\n            ctx.fillText(`Face (${(payload.scores[0] * 100).toFixed(0)}%)`, x, y - 4);\n          });\n        } else if ((p.payload as MediaPipeHandPayload).type === 'hand') {\n          // MediaPipe Hand Detection\n          const payload = p.payload as MediaPipeHandPayload;\n          payload.boxes.forEach(box => {\n            const [x, y, width, height] = box;\n            ctx.strokeStyle = payload.handedness === 'Left' ? 'red' : 'blue';\n            ctx.lineWidth = 2;\n            ctx.strokeRect(x, y, width, height);\n            ctx.fillStyle = payload.handedness === 'Left' ? 'red' : 'blue';\n            ctx.fillText(`${payload.handedness} Hand (${(payload.scores[0] * 100).toFixed(0)}%)`, x, y - 4);\n          });\n        } else if ((p.payload as any).type === 'object') { // Existing MediaPipe Object Detection\n          ctx.strokeStyle = 'lime';\n          ctx.strokeRect((p.payload as any).box.x, (p.payload as any).box.y, (p.payload as any).box.width, (p.payload as any).box.height);\n          ctx.fillStyle = 'lime';\n          ctx.fillText(`${(p.payload as any).category} (${(p.payload as any).score.toFixed(2)})`, (p.payload as any).box.x, (p.payload as any).box.y - 4);\n        }\n      }\n    });\n\n    // TODO: pose skeleton\n\n    // Smile + voice animation\n    if (smileDetected && speechDetected) {\n      cheerUntilRef.current = Date.now() + 3000; // show 3s\n    }\n    if (Date.now() < cheerUntilRef.current) {\n      ctx.font = '48px sans-serif';\n      ctx.fillStyle = 'rgba(255,215,0,0.9)';\n      ctx.fillText(t('smile_voice_overlay'), ctx.canvas.width / 2 - 100, 60);\n    }\n\n    // Silence banner\n    if (lastSilenceMs >= 10000) {\n      ctx.fillStyle = 'rgba(255,255,255,0.8)';\n      ctx.fillRect(10, 10, 260, 30);\n      ctx.fillStyle = '#000';\n      ctx.fillText(t('silence_banner'), 20, 30);\n    }\n\n    // Friendly greeting\n    // Note: `faces` is not defined here. Assuming it comes from percepts now.\n    // if (faces?.length && audio?.category === 'Speech') {\n    //   ctx.fillStyle = '#0f0';\n    //   ctx.fillText(t('greeting_overlay'), ctx.canvas.width - 100, 30);\n    // }\n  }, [percepts, lastSilenceMs, audio, video, smileDetected, speechDetected, featureFlags.advancedVision, t, featureFlags]);\n\n  return <canvas ref={canvasRef} style={{ position: 'absolute', top: 0, left: 0 }} />;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\LisaNavigation.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\LisaVivanteComplete.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\LoadingFallback.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\LoginForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\MemoryMap.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\MemoryPanel.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadRecentMemories'. Either include it or remove the dependency array.","line":38,"column":6,"nodeType":"ArrayExpression","endLine":38,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [loadRecentMemories]","fix":{"range":[1294,1296],"text":"[loadRecentMemories]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MemoryPanel.tsx\n * \n * Interface utilisateur pour la gestion des m├®moires de Lisa.\n * Permet ├á l'utilisateur de visualiser, rechercher, ajouter et modifier les m├®moires.\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { useMemory } from '../hooks/useMemory';\nimport type { Memory } from '../agents/MemoryAgent';\n\nconst MemoryPanel: React.FC = () => {\n  const { t } = useTranslation();\n  const [activeTab, setActiveTab] = useState<'recent' | 'search' | 'add'>('recent');\n  const [memories, setMemories] = useState<Memory[]>([]);\n  const [searchText, setSearchText] = useState('');\n  const [newMemoryContent, setNewMemoryContent] = useState('');\n  const [newMemoryType, setNewMemoryType] = useState<Memory['type']>('fact');\n  const [newMemoryTags, setNewMemoryTags] = useState('');\n  const [editingMemoryId, setEditingMemoryId] = useState<string | null>(null);\n  const [searchResults, setSearchResults] = useState<Memory[]>([]);\n\n  const { \n    storeMemory, \n    retrieveMemories, \n    updateMemory, \n    deleteMemory, \n    getRecentMemories, \n    isLoading, \n    error, \n    clearError \n  } = useMemory({ defaultLimit: 10 });\n\n  // Chargement initial des m├®moires r├®centes\n  useEffect(() => {\n    loadRecentMemories();\n  }, []);\n\n  // Charger les m├®moires r├®centes\n  const loadRecentMemories = async () => {\n    const recentMemories = await getRecentMemories(10);\n    setMemories(recentMemories);\n  };\n\n  // Rechercher des m├®moires\n  const handleSearch = async () => {\n    if (!searchText.trim()) {\n      return;\n    }\n    \n    const results = await retrieveMemories({\n      text: searchText,\n      limit: 20\n    });\n    \n    setSearchResults(results);\n  };\n\n  // Ajouter une nouvelle m├®moire\n  const handleAddMemory = async () => {\n    if (!newMemoryContent.trim()) {\n      return;\n    }\n    \n    const tags = newMemoryTags\n      .split(',')\n      .map(tag => tag.trim())\n      .filter(tag => tag.length > 0);\n    \n    await storeMemory(newMemoryContent, {\n      type: newMemoryType,\n      tags,\n      source: 'manual_entry'\n    });\n    \n    setNewMemoryContent('');\n    setNewMemoryTags('');\n    loadRecentMemories();\n    setActiveTab('recent');\n  };\n\n  // Supprimer une m├®moire\n  const handleDeleteMemory = async (id: string) => {\n    if (window.confirm(t('memory.confirmDelete'))) {\n      await deleteMemory(id);\n      \n      // Mise ├á jour des listes\n      if (activeTab === 'recent') {\n        loadRecentMemories();\n      } else if (activeTab === 'search') {\n        setSearchResults(prev => prev.filter(mem => mem.id !== id));\n      }\n    }\n  };\n\n  // Commencer ├á ├®diter une m├®moire\n  const handleStartEditing = (memory: Memory) => {\n    setEditingMemoryId(memory.id);\n    setNewMemoryContent(memory.content);\n    setNewMemoryType(memory.type);\n    setNewMemoryTags(memory.tags.join(', '));\n  };\n\n  // Sauvegarder les modifications d'une m├®moire\n  const handleSaveEdit = async (id: string) => {\n    const tags = newMemoryTags\n      .split(',')\n      .map(tag => tag.trim())\n      .filter(tag => tag.length > 0);\n    \n    await updateMemory(id, {\n      content: newMemoryContent,\n      type: newMemoryType,\n      tags\n    });\n    \n    setEditingMemoryId(null);\n    \n    // Mise ├á jour des listes\n    if (activeTab === 'recent') {\n      loadRecentMemories();\n    } else if (activeTab === 'search') {\n      const updatedResults = await retrieveMemories({\n        text: searchText,\n        limit: 20\n      });\n      setSearchResults(updatedResults);\n    }\n  };\n\n  // Annuler l'├®dition\n  const handleCancelEdit = () => {\n    setEditingMemoryId(null);\n  };\n\n  // Format de date pour l'affichage\n  const formatDate = (timestamp: number) => {\n    return new Date(timestamp).toLocaleString();\n  };\n\n  // Rendu d'une m├®moire\n  const renderMemory = (memory: Memory) => {\n    const isEditing = editingMemoryId === memory.id;\n    \n    if (isEditing) {\n      return (\n        <div key={memory.id} className=\"memory-item editing\">\n          <div className=\"memory-edit-form\">\n            <select \n              value={newMemoryType}\n              onChange={e => setNewMemoryType(e.target.value as Memory['type'])}\n              className=\"memory-type-select\"\n            >\n              <option value=\"fact\">{t('memory.types.fact')}</option>\n              <option value=\"preference\">{t('memory.types.preference')}</option>\n              <option value=\"interaction\">{t('memory.types.interaction')}</option>\n              <option value=\"context\">{t('memory.types.context')}</option>\n            </select>\n            \n            <textarea\n              value={newMemoryContent}\n              onChange={e => setNewMemoryContent(e.target.value)}\n              className=\"memory-content-input\"\n            />\n            \n            <input \n              type=\"text\"\n              value={newMemoryTags}\n              onChange={e => setNewMemoryTags(e.target.value)}\n              placeholder={t('memory.tagsPlaceholder')}\n              className=\"memory-tags-input\"\n            />\n            \n            <div className=\"memory-edit-actions\">\n              <button onClick={() => handleSaveEdit(memory.id)}>\n                {t('common.save')}\n              </button>\n              <button onClick={handleCancelEdit} className=\"secondary\">\n                {t('common.cancel')}\n              </button>\n            </div>\n          </div>\n        </div>\n      );\n    }\n    \n    return (\n      <div key={memory.id} className={`memory-item memory-type-${memory.type}`}>\n        <div className=\"memory-header\">\n          <span className=\"memory-type\">{t(`memory.types.${memory.type}`)}</span>\n          <span className=\"memory-date\">{formatDate(memory.timestamp)}</span>\n        </div>\n        \n        <p className=\"memory-content\">{memory.content}</p>\n        \n        {memory.tags.length > 0 && (\n          <div className=\"memory-tags\">\n            {memory.tags.map(tag => (\n              <span key={tag} className=\"memory-tag\">{tag}</span>\n            ))}\n          </div>\n        )}\n        \n        <div className=\"memory-actions\">\n          <button onClick={() => handleStartEditing(memory)} className=\"icon-button\">\n            Ô£Å´©Å\n          </button>\n          <button onClick={() => handleDeleteMemory(memory.id)} className=\"icon-button danger\">\n            ­ƒùæ´©Å\n          </button>\n        </div>\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"panel memory-panel\">\n      <h2>{t('memory.title')}</h2>\n      \n      {error && (\n        <div className=\"error-message\">\n          <p>{error}</p>\n          <button onClick={clearError}>{t('common.dismiss')}</button>\n        </div>\n      )}\n      \n      <div className=\"memory-tabs\">\n        <button \n          className={activeTab === 'recent' ? 'active' : ''}\n          onClick={() => { setActiveTab('recent'); loadRecentMemories(); }}\n        >\n          {t('memory.tabs.recent')}\n        </button>\n        <button \n          className={activeTab === 'search' ? 'active' : ''}\n          onClick={() => setActiveTab('search')}\n        >\n          {t('memory.tabs.search')}\n        </button>\n        <button \n          className={activeTab === 'add' ? 'active' : ''}\n          onClick={() => setActiveTab('add')}\n        >\n          {t('memory.tabs.add')}\n        </button>\n      </div>\n      \n      <div className=\"memory-tab-content\">\n        {/* Onglet R├®centes */}\n        {activeTab === 'recent' && (\n          <div className=\"memory-recent\">\n            {isLoading ? (\n              <div className=\"loading\">{t('common.loading')}</div>\n            ) : memories.length === 0 ? (\n              <p className=\"empty-message\">{t('memory.noMemories')}</p>\n            ) : (\n              <div className=\"memory-list\">\n                {memories.map(memory => renderMemory(memory))}\n              </div>\n            )}\n            <button onClick={loadRecentMemories} className=\"refresh-button\">\n              {t('memory.refresh')}\n            </button>\n          </div>\n        )}\n        \n        {/* Onglet Recherche */}\n        {activeTab === 'search' && (\n          <div className=\"memory-search\">\n            <div className=\"search-form\">\n              <input \n                type=\"text\"\n                value={searchText}\n                onChange={e => setSearchText(e.target.value)}\n                placeholder={t('memory.searchPlaceholder')}\n                className=\"search-input\"\n              />\n              <button onClick={handleSearch} disabled={isLoading}>\n                {t('common.search')}\n              </button>\n            </div>\n            \n            {isLoading ? (\n              <div className=\"loading\">{t('common.loading')}</div>\n            ) : searchResults.length > 0 ? (\n              <div className=\"memory-list search-results\">\n                {searchResults.map(memory => renderMemory(memory))}\n              </div>\n            ) : searchText ? (\n              <p className=\"empty-message\">{t('memory.noResults')}</p>\n            ) : null}\n          </div>\n        )}\n        \n        {/* Onglet Ajouter */}\n        {activeTab === 'add' && (\n          <div className=\"memory-add\">\n            <div className=\"add-form\">\n              <label>\n                {t('memory.type')}\n                <select \n                  value={newMemoryType}\n                  onChange={e => setNewMemoryType(e.target.value as Memory['type'])}\n                  className=\"memory-type-select\"\n                >\n                  <option value=\"fact\">{t('memory.types.fact')}</option>\n                  <option value=\"preference\">{t('memory.types.preference')}</option>\n                  <option value=\"interaction\">{t('memory.types.interaction')}</option>\n                  <option value=\"context\">{t('memory.types.context')}</option>\n                </select>\n              </label>\n              \n              <label>\n                {t('memory.content')}\n                <textarea\n                  value={newMemoryContent}\n                  onChange={e => setNewMemoryContent(e.target.value)}\n                  className=\"memory-content-input\"\n                  placeholder={t('memory.contentPlaceholder')}\n                  rows={4}\n                />\n              </label>\n              \n              <label>\n                {t('memory.tags')}\n                <input \n                  type=\"text\"\n                  value={newMemoryTags}\n                  onChange={e => setNewMemoryTags(e.target.value)}\n                  placeholder={t('memory.tagsPlaceholder')}\n                  className=\"memory-tags-input\"\n                />\n              </label>\n              \n              <button \n                onClick={handleAddMemory} \n                disabled={isLoading || !newMemoryContent.trim()}\n              >\n                {t('memory.addButton')}\n              </button>\n            </div>\n          </div>\n        )}\n      </div>\n      \n      <style jsx>{`\n        .memory-panel {\n          padding: 1rem;\n          background-color: rgba(255, 255, 255, 0.9);\n          border-radius: 8px;\n          box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);\n          max-width: 800px;\n          margin: 0 auto;\n        }\n        \n        .memory-tabs {\n          display: flex;\n          margin-bottom: 1rem;\n          border-bottom: 1px solid #ddd;\n        }\n        \n        .memory-tabs button {\n          padding: 0.5rem 1rem;\n          background: none;\n          border: none;\n          cursor: pointer;\n          font-weight: 500;\n          color: #555;\n        }\n        \n        .memory-tabs button.active {\n          color: #007bff;\n          border-bottom: 2px solid #007bff;\n        }\n        \n        .memory-list {\n          display: flex;\n          flex-direction: column;\n          gap: 1rem;\n          margin-top: 1rem;\n        }\n        \n        .memory-item {\n          border-radius: 8px;\n          padding: 1rem;\n          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);\n          position: relative;\n        }\n        \n        .memory-type-fact {\n          background-color: #e3f2fd;\n        }\n        \n        .memory-type-preference {\n          background-color: #e8f5e9;\n        }\n        \n        .memory-type-interaction {\n          background-color: #fff8e1;\n        }\n        \n        .memory-type-context {\n          background-color: #f3e5f5;\n        }\n        \n        .memory-header {\n          display: flex;\n          justify-content: space-between;\n          margin-bottom: 0.5rem;\n        }\n        \n        .memory-type {\n          font-weight: 600;\n          color: #333;\n        }\n        \n        .memory-date {\n          font-size: 0.8rem;\n          color: #777;\n        }\n        \n        .memory-content {\n          margin: 0.5rem 0;\n          font-size: 1rem;\n          line-height: 1.5;\n          color: #333;\n        }\n        \n        .memory-tags {\n          display: flex;\n          flex-wrap: wrap;\n          gap: 0.5rem;\n          margin-top: 0.5rem;\n        }\n        \n        .memory-tag {\n          background-color: rgba(0, 0, 0, 0.1);\n          padding: 0.25rem 0.5rem;\n          border-radius: 4px;\n          font-size: 0.8rem;\n          font-weight: 500;\n        }\n        \n        .memory-actions {\n          display: flex;\n          justify-content: flex-end;\n          gap: 0.5rem;\n          margin-top: 0.5rem;\n        }\n        \n        .icon-button {\n          background: none;\n          border: none;\n          font-size: 1.2rem;\n          cursor: pointer;\n          padding: 0.25rem;\n        }\n        \n        .icon-button.danger {\n          color: #dc3545;\n        }\n        \n        .memory-edit-form {\n          display: flex;\n          flex-direction: column;\n          gap: 0.5rem;\n        }\n        \n        .memory-type-select,\n        .memory-content-input,\n        .memory-tags-input {\n          padding: 0.5rem;\n          border-radius: 4px;\n          border: 1px solid #ddd;\n        }\n        \n        .memory-content-input {\n          resize: vertical;\n          min-height: 100px;\n        }\n        \n        .memory-edit-actions {\n          display: flex;\n          justify-content: flex-end;\n          gap: 0.5rem;\n          margin-top: 0.5rem;\n        }\n        \n        .search-form {\n          display: flex;\n          gap: 0.5rem;\n          margin-bottom: 1rem;\n        }\n        \n        .search-input {\n          flex: 1;\n          padding: 0.5rem;\n          border-radius: 4px;\n          border: 1px solid #ddd;\n        }\n        \n        .add-form {\n          display: flex;\n          flex-direction: column;\n          gap: 1rem;\n        }\n        \n        .add-form label {\n          display: flex;\n          flex-direction: column;\n          gap: 0.25rem;\n          font-weight: 500;\n        }\n        \n        .empty-message {\n          text-align: center;\n          margin: 2rem 0;\n          color: #666;\n        }\n        \n        .loading {\n          text-align: center;\n          margin: 2rem 0;\n          color: #666;\n          font-style: italic;\n        }\n        \n        .error-message {\n          background-color: #f8d7da;\n          color: #721c24;\n          padding: 0.75rem;\n          border-radius: 4px;\n          margin-bottom: 1rem;\n          display: flex;\n          justify-content: space-between;\n          align-items: center;\n        }\n        \n        .refresh-button {\n          margin-top: 1rem;\n          align-self: center;\n        }\n      `}</style>\n    </div>\n  );\n};\n\nexport default MemoryPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\MetaHumanCanvas.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\MetaHumanControlsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\MetaHumanUE56Controls.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":105,"column":76,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":105,"endColumn":79,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2400,2403],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2400,2403],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * MetaHumanUE56Controls.tsx\n * \n * Interface de contr├┤le pour les fonctionnalit├®s Unreal Engine 5.6\n * Lumen, Nanite, Chaos Physics, MetaSound\n */\n\nimport React, { useState } from 'react';\nimport {\n  Box,\n  Card,\n  CardContent,\n  Typography,\n  Switch,\n  Slider,\n  FormControl,\n  FormLabel,\n  Select,\n  MenuItem,\n  Button,\n  Chip\n} from '@mui/material';\nimport LightMode from '@mui/icons-material/LightMode';\nimport Memory from '@mui/icons-material/Memory';\nimport Science from '@mui/icons-material/Science';\nimport VolumeUp from '@mui/icons-material/VolumeUp';\nimport Settings from '@mui/icons-material/Settings';\nimport { useUnrealEngine } from '../hooks/useUnrealEngine';\n\ninterface UE56Settings {\n  lumen: {\n    globalIllumination: boolean;\n    reflections: boolean;\n    quality: 'low' | 'medium' | 'high' | 'epic';\n    updateRate: number;\n  };\n  nanite: {\n    enabled: boolean;\n    clusterCulling: boolean;\n    programmableRaster: boolean;\n    maxTriangles: number;\n  };\n  chaos: {\n    enabled: boolean;\n    clothSimulation: boolean;\n    hairPhysics: boolean;\n    fluidSimulation: boolean;\n  };\n  metaSound: {\n    volume: number;\n    pitch: number;\n    spatialAudio: boolean;\n  };\n}\n\nexport const MetaHumanUE56Controls: React.FC = () => {\n  const { configureLumen, configureNanite, configureChaosPhysics, playMetaSound, status } = useUnrealEngine();\n  \n  const [settings, setSettings] = useState<UE56Settings>({\n    lumen: {\n      globalIllumination: true,\n      reflections: true,\n      quality: 'high',\n      updateRate: 60\n    },\n    nanite: {\n      enabled: true,\n      clusterCulling: true,\n      programmableRaster: true,\n      maxTriangles: 1000000\n    },\n    chaos: {\n      enabled: true,\n      clothSimulation: true,\n      hairPhysics: true,\n      fluidSimulation: false\n    },\n    metaSound: {\n      volume: 0.8,\n      pitch: 1.0,\n      spatialAudio: true\n    }\n  });\n\n  const handleLumenUpdate = () => {\n    configureLumen(settings.lumen);\n  };\n\n  const handleNaniteUpdate = () => {\n    configureNanite(settings.nanite);\n  };\n\n  const handleChaosUpdate = () => {\n    configureChaosPhysics(settings.chaos);\n  };\n\n  const handleMetaSoundTest = () => {\n    playMetaSound({\n      soundAsset: '/Game/MetaHuman/Audio/TestSound',\n      ...settings.metaSound,\n      position: { x: 0, y: 0, z: 100 }\n    });\n  };\n\n  const updateSetting = (category: keyof UE56Settings, key: string, value: any) => {\n    setSettings(prev => ({\n      ...prev,\n      [category]: {\n        ...prev[category],\n        [key]: value\n      }\n    }));\n  };\n\n  return (\n    <Box sx={{ p: 2 }}>\n      <Typography variant=\"h5\" gutterBottom sx={{ display: 'flex', alignItems: 'center', gap: 1 }}>\n        <Settings />\n        Contr├┤les Unreal Engine 5.6\n        <Chip \n          label={status.isConnected ? 'Connect├®' : 'D├®connect├®'} \n          color={status.isConnected ? 'success' : 'error'} \n          size=\"small\" \n        />\n      </Typography>\n\n      <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 3 }}>\n        {/* Lumen Controls */}\n        <Box sx={{ flex: '1 1 400px', minWidth: '400px' }}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>\n                <LightMode />\n                Lumen Global Illumination\n              </Typography>\n              \n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Illumination Globale</FormLabel>\n                <Switch\n                  checked={settings.lumen.globalIllumination}\n                  onChange={(e) => updateSetting('lumen', 'globalIllumination', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>R├®flexions</FormLabel>\n                <Switch\n                  checked={settings.lumen.reflections}\n                  onChange={(e) => updateSetting('lumen', 'reflections', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Qualit├®</FormLabel>\n                <Select\n                  value={settings.lumen.quality}\n                  onChange={(e) => updateSetting('lumen', 'quality', e.target.value)}\n                >\n                  <MenuItem value=\"low\">Faible</MenuItem>\n                  <MenuItem value=\"medium\">Moyenne</MenuItem>\n                  <MenuItem value=\"high\">├ëlev├®e</MenuItem>\n                  <MenuItem value=\"epic\">├ëpique</MenuItem>\n                </Select>\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Taux de mise ├á jour (FPS): {settings.lumen.updateRate}</FormLabel>\n                <Slider\n                  value={settings.lumen.updateRate}\n                  onChange={(_, value) => updateSetting('lumen', 'updateRate', value)}\n                  min={30}\n                  max={120}\n                  step={10}\n                  marks\n                />\n              </FormControl>\n\n              <Button variant=\"contained\" onClick={handleLumenUpdate} fullWidth>\n                Appliquer Lumen\n              </Button>\n            </CardContent>\n          </Card>\n        </Box>\n\n        {/* Nanite Controls */}\n        <Box sx={{ flex: '1 1 400px', minWidth: '400px' }}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>\n                <Memory />\n                Nanite Virtualized Geometry\n              </Typography>\n              \n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Activ├®</FormLabel>\n                <Switch\n                  checked={settings.nanite.enabled}\n                  onChange={(e) => updateSetting('nanite', 'enabled', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Cluster Culling</FormLabel>\n                <Switch\n                  checked={settings.nanite.clusterCulling}\n                  onChange={(e) => updateSetting('nanite', 'clusterCulling', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Programmable Raster</FormLabel>\n                <Switch\n                  checked={settings.nanite.programmableRaster}\n                  onChange={(e) => updateSetting('nanite', 'programmableRaster', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Max Triangles: {settings.nanite.maxTriangles.toLocaleString()}</FormLabel>\n                <Slider\n                  value={settings.nanite.maxTriangles}\n                  onChange={(_, value) => updateSetting('nanite', 'maxTriangles', value)}\n                  min={100000}\n                  max={5000000}\n                  step={100000}\n                />\n              </FormControl>\n\n              <Button variant=\"contained\" onClick={handleNaniteUpdate} fullWidth>\n                Appliquer Nanite\n              </Button>\n            </CardContent>\n          </Card>\n        </Box>\n\n        {/* Chaos Physics Controls */}\n        <Box sx={{ flex: '1 1 400px', minWidth: '400px' }}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>\n                <Science />\n                Chaos Physics\n              </Typography>\n              \n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Activ├®</FormLabel>\n                <Switch\n                  checked={settings.chaos.enabled}\n                  onChange={(e) => updateSetting('chaos', 'enabled', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Simulation de V├¬tements</FormLabel>\n                <Switch\n                  checked={settings.chaos.clothSimulation}\n                  onChange={(e) => updateSetting('chaos', 'clothSimulation', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Physique des Cheveux</FormLabel>\n                <Switch\n                  checked={settings.chaos.hairPhysics}\n                  onChange={(e) => updateSetting('chaos', 'hairPhysics', e.target.checked)}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Simulation de Fluides</FormLabel>\n                <Switch\n                  checked={settings.chaos.fluidSimulation}\n                  onChange={(e) => updateSetting('chaos', 'fluidSimulation', e.target.checked)}\n                />\n              </FormControl>\n\n              <Button variant=\"contained\" onClick={handleChaosUpdate} fullWidth>\n                Appliquer Chaos\n              </Button>\n            </CardContent>\n          </Card>\n        </Box>\n\n        {/* MetaSound Controls */}\n        <Box sx={{ flex: '1 1 400px', minWidth: '400px' }}>\n          <Card>\n            <CardContent>\n              <Typography variant=\"h6\" sx={{ display: 'flex', alignItems: 'center', gap: 1, mb: 2 }}>\n                <VolumeUp />\n                MetaSound Audio\n              </Typography>\n              \n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Volume: {Math.round(settings.metaSound.volume * 100)}%</FormLabel>\n                <Slider\n                  value={settings.metaSound.volume}\n                  onChange={(_, value) => updateSetting('metaSound', 'volume', value)}\n                  min={0}\n                  max={1}\n                  step={0.1}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Pitch: {settings.metaSound.pitch}x</FormLabel>\n                <Slider\n                  value={settings.metaSound.pitch}\n                  onChange={(_, value) => updateSetting('metaSound', 'pitch', value)}\n                  min={0.5}\n                  max={2.0}\n                  step={0.1}\n                />\n              </FormControl>\n\n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <FormLabel>Audio Spatial</FormLabel>\n                <Switch\n                  checked={settings.metaSound.spatialAudio}\n                  onChange={(e) => updateSetting('metaSound', 'spatialAudio', e.target.checked)}\n                />\n              </FormControl>\n\n              <Button variant=\"contained\" onClick={handleMetaSoundTest} fullWidth>\n                Tester MetaSound\n              </Button>\n            </CardContent>\n          </Card>\n        </Box>\n      </Box>\n    </Box>\n  );\n};\n\nexport default MetaHumanUE56Controls;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\MicIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ModelLoader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\NotificationPermissionPrompt.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\OCRPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TextField' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setEnhanceImage' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":33,"column":24,"nodeType":null,"messageId":"unusedVar","endLine":33,"endColumn":39},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":77,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":77,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2772,2775],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2772,2775],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * OCRPanel - Panneau pour la reconnaissance optique de caract├¿res\n * \n * Ce composant fournit une interface utilisateur pour extraire du texte\n * ├á partir d'images, de captures d'├®cran ou de la webcam.\n */\n\nimport React, { useState } from 'react';\nimport { Box, Typography, Button, TextField, Select, MenuItem, FormControl, \n  InputLabel, CircularProgress, Paper, IconButton, Alert, Tooltip } from '@mui/material';\nimport ImageSearchIcon from '@mui/icons-material/ImageSearch';\nimport ScreenshotIcon from '@mui/icons-material/Screenshot';\nimport PhotoCameraIcon from '@mui/icons-material/PhotoCamera';\nimport ContentCopyIcon from '@mui/icons-material/ContentCopy';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport { agentRegistry } from '../agents/registry';\nimport type { OCRAgent, OCRSource, OCROptions, OCRResult } from '../agents/OCRAgent';\n\ninterface OCRPanelProps {\n  expanded?: boolean;\n}\n\nexport const OCRPanel: React.FC<OCRPanelProps> = ({ expanded = false }) => {\n  // ├ëtats du composant\n  const [isExpanded, setIsExpanded] = useState(expanded);\n  const [source, setSource] = useState<OCRSource>('screenshot');\n  const [language, setLanguage] = useState<string>('auto');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [result, setResult] = useState<OCRResult | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [imagePreview, setImagePreview] = useState<string | null>(null);\n  const [enhanceImage, setEnhanceImage] = useState(true);\n  const [fileInput, setFileInput] = useState<File | null>(null);\n\n  // R├®f├®rence ├á l'agent OCR\n  const ocrAgent = agentRegistry.getAgent('OCRAgent') as OCRAgent;\n\n  // V├®rification de la disponibilit├® de l'agent\n  const agentAvailable = !!ocrAgent;\n\n  // Fonction pour extraire du texte\n  const extractText = async () => {\n    if (!agentAvailable) {\n      setError('OCRAgent n\\'est pas disponible');\n      return;\n    }\n\n    setError(null);\n    setIsProcessing(true);\n    \n    try {\n      const options: OCROptions = {\n        language,\n        enhanceImage,\n      };\n\n      const result = await ocrAgent.execute({\n        intent: 'extract_text',\n        parameters: {\n          source,\n          options\n        }\n      });\n\n      if (!result.success) {\n        throw new Error(result.error as string);\n      }\n\n      setResult(result.output as OCRResult);\n      \n      // Dans une impl├®mentation r├®elle, on pourrait r├®cup├®rer l'image source ici\n      // et la d├®finir comme aper├ºu\n      if (source === 'screenshot') {\n        setImagePreview(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==\");\n      }\n    } catch (err: any) {\n      setError(err.message || 'Une erreur est survenue lors de l\\'extraction du texte');\n      setResult(null);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Fonction pour copier le texte extrait dans le presse-papiers\n  const copyToClipboard = () => {\n    if (result && result.text) {\n      navigator.clipboard.writeText(result.text)\n        .then(() => {\n          // Feedback visuel temporaire\n          const originalText = result.text;\n          setResult({...result, text: 'Copi├® !'});\n          setTimeout(() => {\n            setResult({...result, text: originalText});\n          }, 1000);\n        })\n        .catch(err => {\n          console.error('Erreur lors de la copie dans le presse-papiers:', err);\n          setError('Impossible de copier dans le presse-papiers');\n        });\n    }\n  };\n\n  // Gestion du fichier s├®lectionn├®\n  const handleFileChange = (event: React.ChangeEvent<HTMLInputElement>) => {\n    const files = event.target.files;\n    if (files && files.length > 0) {\n      setFileInput(files[0]);\n      \n      // Cr├®er un aper├ºu de l'image\n      const reader = new FileReader();\n      reader.onload = (e) => {\n        setImagePreview(e.target?.result as string);\n      };\n      reader.readAsDataURL(files[0]);\n    }\n  };\n\n  // Bascule de l'├®tat d'expansion du panneau\n  const toggleExpand = () => {\n    setIsExpanded(!isExpanded);\n  };\n\n  // D├®terminer l'ic├┤ne ├á afficher en fonction de la source\n  const getSourceIcon = () => {\n    switch (source) {\n      case 'screenshot':\n        return <ScreenshotIcon />;\n      case 'webcam':\n        return <PhotoCameraIcon />;\n      case 'file':\n        return <ImageSearchIcon />;\n      default:\n        return <ScreenshotIcon />;\n    }\n  };\n\n  return (\n    <Box sx={{ \n      border: '1px solid #e0e0e0',\n      borderRadius: 1,\n      mb: 2,\n      overflow: 'hidden',\n      transition: 'all 0.3s ease'\n    }}>\n      {/* En-t├¬te du panneau */}\n      <Box \n        sx={{ \n          p: 1, \n          bgcolor: 'primary.main', \n          color: 'white',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          cursor: 'pointer'\n        }}\n        onClick={toggleExpand}\n      >\n        <Box sx={{ display: 'flex', alignItems: 'center' }}>\n          <ImageSearchIcon sx={{ mr: 1 }} />\n          <Typography variant=\"subtitle1\">Reconnaissance de Texte (OCR)</Typography>\n        </Box>\n        {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n      </Box>\n      \n      {/* Contenu du panneau */}\n      {isExpanded && (\n        <Box sx={{ p: 2 }}>\n          {!agentAvailable ? (\n            <Alert severity=\"warning\">\n              L'agent OCR n'est pas disponible actuellement.\n            </Alert>\n          ) : (\n            <>\n              <Box sx={{ mb: 2 }}>\n                <FormControl fullWidth>\n                  <InputLabel>Source</InputLabel>\n                  <Select\n                    value={source}\n                    onChange={(e) => setSource(e.target.value as OCRSource)}\n                    label=\"Source\"\n                    startAdornment={getSourceIcon()}\n                  >\n                    <MenuItem value=\"screenshot\">Capture d'├®cran</MenuItem>\n                    <MenuItem value=\"webcam\">Webcam</MenuItem>\n                    <MenuItem value=\"file\">Fichier image</MenuItem>\n                    <MenuItem value=\"clipboard\" disabled>Presse-papiers (Bient├┤t)</MenuItem>\n                    <MenuItem value=\"selection\" disabled>S├®lection (Bient├┤t)</MenuItem>\n                  </Select>\n                </FormControl>\n              </Box>\n              \n              {source === 'file' && (\n                <Box sx={{ mb: 2 }}>\n                  <Button\n                    variant=\"outlined\"\n                    component=\"label\"\n                    fullWidth\n                    startIcon={<ImageSearchIcon />}\n                  >\n                    S├®lectionner un fichier\n                    <input\n                      type=\"file\"\n                      hidden\n                      accept=\"image/*\"\n                      onChange={handleFileChange}\n                    />\n                  </Button>\n                  {fileInput && (\n                    <Typography variant=\"body2\" sx={{ mt: 1 }}>\n                      Fichier: {fileInput.name}\n                    </Typography>\n                  )}\n                </Box>\n              )}\n              \n              <Box sx={{ mb: 2 }}>\n                <FormControl fullWidth>\n                  <InputLabel>Langue</InputLabel>\n                  <Select\n                    value={language}\n                    onChange={(e) => setLanguage(e.target.value)}\n                    label=\"Langue\"\n                  >\n                    <MenuItem value=\"auto\">Auto-d├®tection</MenuItem>\n                    <MenuItem value=\"fr\">Fran├ºais</MenuItem>\n                    <MenuItem value=\"en\">Anglais</MenuItem>\n                    <MenuItem value=\"es\">Espagnol</MenuItem>\n                    <MenuItem value=\"de\">Allemand</MenuItem>\n                  </Select>\n                </FormControl>\n              </Box>\n              \n              <Box sx={{ display: 'flex', mb: 2, gap: 1 }}>\n                <Button \n                  variant=\"contained\" \n                  onClick={extractText}\n                  disabled={isProcessing || (source === 'file' && !fileInput)}\n                  fullWidth\n                  startIcon={isProcessing ? <CircularProgress size={20} color=\"inherit\" /> : getSourceIcon()}\n                >\n                  {isProcessing ? 'Extraction en cours...' : 'Extraire le texte'}\n                </Button>\n              </Box>\n              \n              {error && (\n                <Alert severity=\"error\" sx={{ mb: 2 }}>\n                  {error}\n                </Alert>\n              )}\n              \n              {imagePreview && (\n                <Paper \n                  elevation={3} \n                  sx={{ \n                    mb: 2, \n                    p: 1, \n                    display: 'flex',\n                    justifyContent: 'center',\n                    maxHeight: '200px',\n                    overflow: 'hidden'\n                  }}\n                >\n                  <img \n                    src={imagePreview} \n                    alt=\"Preview\" \n                    style={{ \n                      maxWidth: '100%',\n                      maxHeight: '180px',\n                      objectFit: 'contain'\n                    }} \n                  />\n                </Paper>\n              )}\n              \n              {result && result.text && (\n                <Paper elevation={3} sx={{ p: 2, mb: 2, position: 'relative' }}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    Texte extrait:\n                  </Typography>\n                  <Typography variant=\"body1\" sx={{ whiteSpace: 'pre-wrap' }}>\n                    {result.text}\n                  </Typography>\n                  <Box sx={{ position: 'absolute', top: 8, right: 8 }}>\n                    <Tooltip title=\"Copier le texte\">\n                      <IconButton onClick={copyToClipboard}>\n                        <ContentCopyIcon />\n                      </IconButton>\n                    </Tooltip>\n                  </Box>\n                  {result.confidence !== undefined && (\n                    <Typography variant=\"caption\" display=\"block\" sx={{ mt: 1, color: 'text.secondary' }}>\n                      Confiance: {(result.confidence * 100).toFixed(1)}%\n                    </Typography>\n                  )}\n                </Paper>\n              )}\n              \n              <Typography variant=\"body2\" color=\"text.secondary\">\n                La reconnaissance optique de caract├¿res (OCR) vous permet d'extraire du texte ├á partir d'images.\n              </Typography>\n            </>\n          )}\n        </Box>\n      )}\n    </Box>\n  );\n};\n\nexport default OCRPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\Phase2Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\Phase3Dashboard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\PlanExplanationPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\PlannerStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\PowerShellPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\PrivacyCenter.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ProactiveSuggestionsPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\RegisterForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ResourceViewer.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[965,968],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[965,968],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport { useEffect, useState } from 'react';\nimport ReactMarkdown from 'react-markdown';\nimport ReactJson from '@microlink/react-json-view';\n\n/**\n * Slide-up panel that renders the content of an MCP resource when the store\n * intent is `mcp_open`.\n */\nexport default function ResourceViewer() {\n  const { t } = useTranslation();\n  const intent = useVisionAudioStore(s => s.intent);\n  const intentPayload = useVisionAudioStore(s => s.intentPayload);\n  const setState = useVisionAudioStore(s => s.setState);\n  const [visible, setVisible] = useState(false);\n\n  useEffect(() => {\n    setVisible(intent === 'mcp_open');\n  }, [intent]);\n\n  if (!visible) return null;\n\n  const close = () => setState({ intent: undefined, intentPayload: undefined });\n\n  // Detect mime / content type heuristically\n  const payload = intentPayload as any;\n  let render: React.ReactNode;\n\n  if (typeof payload === 'string') {\n    // Try JSON first\n    try {\n      const obj = JSON.parse(payload);\n      render = <ReactJson src={obj} collapsed={2} name={false} />;\n    } catch {\n      // Treat as markdown / plain text\n      render = <ReactMarkdown>{payload}</ReactMarkdown>;\n    }\n  } else if (typeof payload === 'object') {\n    render = <ReactJson src={payload} collapsed={2} name={false} />;\n  } else {\n    render = <pre>{String(payload)}</pre>;\n  }\n\n  return (\n    <div role=\"dialog\" aria-label={t('resource_viewer')} style={{ position: 'fixed', bottom: 0, left: 0, right: 0, height: '70%', background: '#fff', borderTopLeftRadius: 12, borderTopRightRadius: 12, boxShadow: '0 -4px 16px rgba(0,0,0,.2)', overflowY: 'auto', padding: 16, zIndex: 1000 }}>\n      <button aria-label={t('close')} onClick={close} style={{ position: 'absolute', top: 8, right: 12, background: 'transparent', border: 'none', fontSize: 18, cursor: 'pointer' }}>Ô£ò</button>\n      <div style={{ paddingTop: 24 }}>\n        {render}\n      </div>\n    </div>\n  );\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\RobotControl.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\SchedulerPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AlertTriangle' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[525,528],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[525,528],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[588,591],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[588,591],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3657,3660],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3657,3660],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SchedulerPanel - Schedule optimization interface\n */\n\nimport { useState } from 'react';\nimport { useScheduler } from '../hooks/useScheduler';\nimport { Calendar, Clock, AlertTriangle } from 'lucide-react';\n\nexport const SchedulerPanel = () => {\n  const { loading, error, suggestTime, findAvailability } = useScheduler();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [purpose, setPurpose] = useState('');\n  const [duration, setDuration] = useState(60);\n  const [suggestions, setSuggestions] = useState<any>(null);\n  const [availability, setAvailability] = useState<any>(null);\n\n  const handleSuggestTime = async () => {\n    const result = await suggestTime(purpose, duration);\n    if (result.success) {\n      setSuggestions(result.output);\n    }\n  };\n\n  const handleFindAvailability = async () => {\n    const startDate = new Date();\n    const endDate = new Date(startDate.getTime() + 7 * 24 * 60 * 60 * 1000);\n    const result = await findAvailability(startDate, endDate, duration);\n    if (result.success) {\n      setAvailability(result.output);\n    }\n  };\n\n  const formatTime = (date: Date) => {\n    return new Date(date).toLocaleString('fr-FR', { \n      weekday: 'short', \n      month: 'short', \n      day: 'numeric', \n      hour: '2-digit', \n      minute: '2-digit' \n    });\n  };\n\n  return (\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 max-w-md\">\n      <div className=\"flex items-center justify-between cursor-pointer\" onClick={() => setIsExpanded(!isExpanded)}>\n        <div className=\"flex items-center gap-2\">\n          <Calendar className=\"w-5 h-5 text-blue-500\" />\n          <h3 className=\"font-semibold\">­ƒôà Smart Scheduler</h3>\n        </div>\n      </div>\n\n      {isExpanded && (\n        <div className=\"mt-4 space-y-3\">\n          {error && (\n            <div className=\"text-red-500 text-sm p-2 bg-red-50 rounded\">\n              {error}\n            </div>\n          )}\n\n          <div className=\"space-y-2\">\n            <input\n              type=\"text\"\n              placeholder=\"Meeting purpose\"\n              value={purpose}\n              onChange={(e) => setPurpose(e.target.value)}\n              className=\"w-full px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n            />\n            <div className=\"flex items-center gap-2\">\n              <Clock className=\"w-4 h-4\" />\n              <input\n                type=\"number\"\n                value={duration}\n                onChange={(e) => setDuration(Number(e.target.value))}\n                className=\"flex-1 px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n                min=\"15\"\n                max=\"480\"\n              />\n              <span className=\"text-sm\">minutes</span>\n            </div>\n          </div>\n\n          <div className=\"flex gap-2\">\n            <button\n              onClick={handleSuggestTime}\n              disabled={loading || !purpose}\n              className=\"flex-1 px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50\"\n            >\n              Suggest Time\n            </button>\n            <button\n              onClick={handleFindAvailability}\n              disabled={loading}\n              className=\"flex-1 px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50\"\n            >\n              Find Slots\n            </button>\n          </div>\n\n          {suggestions && suggestions.suggestions && (\n            <div className=\"p-3 bg-blue-50 dark:bg-blue-900/20 rounded max-h-60 overflow-y-auto\">\n              <div className=\"font-semibold mb-2\">Suggested Times:</div>\n              {suggestions.suggestions.map((sug: any, i: number) => (\n                <div key={i} className=\"p-2 bg-white dark:bg-gray-800 rounded mb-2\">\n                  <div className=\"flex items-center justify-between\">\n                    <div className=\"font-semibold text-sm\">{formatTime(sug.timeSlot.start)}</div>\n                    <div className=\"text-xs text-green-500\">{(sug.confidence * 100).toFixed(0)}%</div>\n                  </div>\n                  <div className=\"text-xs text-gray-600 dark:text-gray-400\">{sug.reason}</div>\n                </div>\n              ))}\n            </div>\n          )}\n\n          {availability && (\n            <div className=\"p-3 bg-green-50 dark:bg-green-900/20 rounded\">\n              <div className=\"font-semibold mb-2\">Available Slots: {availability.availableSlots?.length || 0}</div>\n              {availability.bestSlot && (\n                <div className=\"text-sm p-2 bg-white dark:bg-gray-800 rounded\">\n                  <div className=\"font-semibold\">Best Slot:</div>\n                  <div>{formatTime(availability.bestSlot.start)}</div>\n                  <div className=\"text-xs text-green-500\">Score: {availability.bestSlot.score}/100</div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ScreenSharePanel.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'stopSharing'. Either include it or remove the dependency array.","line":77,"column":6,"nodeType":"ArrayExpression","endLine":77,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [stopSharing]","fix":{"range":[2577,2579],"text":"[stopSharing]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3110,3113],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3110,3113],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState, useEffect, useRef } from 'react';\nimport { useAppStore } from '../store/appStore';\nimport { agentRegistry } from '../agents/registry';\nimport { createLogger } from '../utils/logger';\nimport './ScreenSharePanel.css';\n\nconst logger = createLogger('ScreenSharePanel');\n\ninterface ShareSession {\n  id: string;\n  startTime: number;\n  status: 'active' | 'ended';\n  type: 'screen' | 'window' | 'tab';\n  hasAudio: boolean;\n  resolution?: string;\n  endTime?: number;\n}\n\nconst ScreenSharePanel: React.FC = () => {\n  const [isVisible, setIsVisible] = useState(false);\n  const [isSharing, setIsSharing] = useState(false);\n  const [shareOptions, setShareOptions] = useState({\n    audio: false,\n    shareType: 'screen' as 'screen' | 'window' | 'tab',\n  });\n  const [mediaStream, setMediaStream] = useState<MediaStream | null>(null);\n  const [currentSession, setCurrentSession] = useState<ShareSession | null>(null);\n  const [sessionHistory, setSessionHistory] = useState<ShareSession[]>([]);\n  const [error, setError] = useState<string | null>(null);\n  const [notification, setNotification] = useState<{message: string, type: 'success' | 'error' | 'info'} | null>(null);\n\n  const videoRef = useRef<HTMLVideoElement>(null);\n  const { intent } = useAppStore();\n\n  // Charger l'historique des sessions depuis le localStorage\n  useEffect(() => {\n    const savedHistory = localStorage.getItem('screenshare_history');\n    if (savedHistory) {\n      try {\n        const parsedHistory = JSON.parse(savedHistory);\n        setSessionHistory(parsedHistory);\n      } catch (error) {\n        logger.error('Erreur lors du chargement de l\\'historique des sessions', error);\n      }\n    }\n  }, []);\n\n  // Sauvegarder l'historique des sessions dans le localStorage\n  useEffect(() => {\n    if (sessionHistory.length > 0) {\n      localStorage.setItem('screenshare_history', JSON.stringify(sessionHistory));\n    }\n  }, [sessionHistory]);\n\n  // D├®tecter les intents li├®s au partage d'├®cran\n  useEffect(() => {\n    if (intent && \n       (intent.toLowerCase().includes('partage d\\'├®cran') || \n        intent.toLowerCase().includes('partager mon ├®cran') ||\n        intent.toLowerCase().includes('screen share'))) {\n      setIsVisible(true);\n    }\n  }, [intent]);\n\n  // Configurer la vid├®o quand le stream change\n  useEffect(() => {\n    if (videoRef.current && mediaStream) {\n      videoRef.current.srcObject = mediaStream;\n    }\n  }, [mediaStream]);\n\n  // Nettoyer la session de partage lors du d├®montage du composant\n  useEffect(() => {\n    return () => {\n      stopSharing();\n    };\n  }, []);\n\n  // D├®marrer le partage d'├®cran\n  const startSharing = async () => {\n    setError(null);\n    \n    try {\n      const screenShareAgent = agentRegistry.getAgent('ScreenShareAgent');\n      if (!screenShareAgent) {\n        throw new Error('ScreenShareAgent non trouv├®');\n      }\n\n      const execResult = await screenShareAgent.execute({\n        action: 'startScreenShare',\n        options: {\n          audio: shareOptions.audio,\n          shareType: shareOptions.shareType\n        }\n      });\n\n      const stream = (execResult as any)?.stream as MediaStream | undefined;\n      if (stream) {\n        setMediaStream(stream);\n        setIsSharing(true);\n        \n        const newSession: ShareSession = {\n          id: Date.now().toString(),\n          startTime: Date.now(),\n          status: 'active',\n          type: shareOptions.shareType,\n          hasAudio: shareOptions.audio,\n          resolution: `${stream.getVideoTracks()[0].getSettings().width}x${stream.getVideoTracks()[0].getSettings().height}`\n        };\n        \n        setCurrentSession(newSession);\n        showNotification('Partage d\\'├®cran d├®marr├®', 'success');\n        \n        // Configurer la d├®tection de fin de partage\n        stream.getVideoTracks()[0].addEventListener('ended', () => {\n          handleStreamEnded(newSession.id);\n        });\n      } else {\n        throw new Error('Aucun flux m├®dia re├ºu');\n      }\n    } catch (error) {\n      logger.error('Erreur lors du d├®marrage du partage d\\'├®cran', error);\n      setError(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`);\n      showNotification(`Erreur: ${error instanceof Error ? error.message : 'Erreur inconnue'}`, 'error');\n    }\n  };\n\n  // Arr├¬ter le partage d'├®cran\n  const stopSharing = () => {\n    if (mediaStream) {\n      mediaStream.getTracks().forEach(track => track.stop());\n      setMediaStream(null);\n    }\n    \n    if (currentSession) {\n      handleStreamEnded(currentSession.id);\n    }\n    \n    setIsSharing(false);\n  };\n\n  // G├®rer la fin d'une session de partage\n  const handleStreamEnded = (sessionId: string) => {\n    if (currentSession && currentSession.id === sessionId) {\n      const endedSession = {\n        ...currentSession,\n        status: 'ended' as const,\n        endTime: Date.now()\n      };\n      \n      setSessionHistory(prev => [endedSession, ...prev]);\n      setCurrentSession(null);\n      showNotification('Partage d\\'├®cran termin├®', 'info');\n    }\n  };\n\n  // Afficher une notification\n  const showNotification = (message: string, type: 'success' | 'error' | 'info') => {\n    setNotification({ message, type });\n    setTimeout(() => setNotification(null), 3000);\n  };\n\n  // Formater la dur├®e\n  const formatDuration = (startTime: number, endTime: number) => {\n    const durationMs = endTime - startTime;\n    const seconds = Math.floor(durationMs / 1000) % 60;\n    const minutes = Math.floor(durationMs / (1000 * 60)) % 60;\n    const hours = Math.floor(durationMs / (1000 * 60 * 60));\n    \n    return `${hours > 0 ? `${hours}h ` : ''}${minutes}m ${seconds}s`;\n  };\n\n  // Formater la date\n  const formatDate = (timestamp: number) => {\n    return new Date(timestamp).toLocaleString();\n  };\n\n  // Effacer l'historique des sessions\n  const clearHistory = () => {\n    setSessionHistory([]);\n    localStorage.removeItem('screenshare_history');\n    showNotification('Historique effac├®', 'success');\n  };\n\n  if (!isVisible) {\n    return null;\n  }\n\n  return (\n    <div className=\"screenshare-panel\">\n      <div className=\"screenshare-header\">\n        <h2>Partage d'├®cran</h2>\n        <button \n          className=\"close-button\" \n          onClick={() => setIsVisible(false)}\n        >\n          ├ù\n        </button>\n      </div>\n\n      {notification && (\n        <div className={`notification ${notification.type}`}>\n          {notification.message}\n        </div>\n      )}\n\n      {error && (\n        <div className=\"error-message\">\n          {error}\n        </div>\n      )}\n\n      <div className=\"screenshare-content\">\n        <div className=\"screenshare-controls\">\n          <h3>{isSharing ? 'Session active' : 'D├®marrer un partage d\\'├®cran'}</h3>\n          \n          {!isSharing ? (\n            <>\n              <div className=\"option-group\">\n                <label>Type de partage:</label>\n                <div className=\"radio-options\">\n                  <label>\n                    <input\n                      type=\"radio\"\n                      name=\"shareType\"\n                      checked={shareOptions.shareType === 'screen'}\n                      onChange={() => setShareOptions(prev => ({...prev, shareType: 'screen'}))}\n                    />\n                    ├ëcran complet\n                  </label>\n                  <label>\n                    <input\n                      type=\"radio\"\n                      name=\"shareType\"\n                      checked={shareOptions.shareType === 'window'}\n                      onChange={() => setShareOptions(prev => ({...prev, shareType: 'window'}))}\n                    />\n                    Fen├¬tre\n                  </label>\n                  <label>\n                    <input\n                      type=\"radio\"\n                      name=\"shareType\"\n                      checked={shareOptions.shareType === 'tab'}\n                      onChange={() => setShareOptions(prev => ({...prev, shareType: 'tab'}))}\n                    />\n                    Onglet\n                  </label>\n                </div>\n              </div>\n              \n              <div className=\"option-group\">\n                <label>\n                  <input\n                    type=\"checkbox\"\n                    checked={shareOptions.audio}\n                    onChange={() => setShareOptions(prev => ({...prev, audio: !prev.audio}))}\n                  />\n                  Partager l'audio\n                </label>\n              </div>\n              \n              <button \n                className=\"start-button\"\n                onClick={startSharing}\n              >\n                D├®marrer le partage\n              </button>\n            </>\n          ) : (\n            <div className=\"active-session\">\n              <div className=\"session-info\">\n                <div><strong>Type:</strong> {currentSession?.type === 'screen' ? '├ëcran complet' : currentSession?.type === 'window' ? 'Fen├¬tre' : 'Onglet'}</div>\n                <div><strong>Audio:</strong> {currentSession?.hasAudio ? 'Activ├®' : 'D├®sactiv├®'}</div>\n                <div><strong>R├®solution:</strong> {currentSession?.resolution || 'Inconnue'}</div>\n                <div><strong>D├®marr├®:</strong> {currentSession ? formatDate(currentSession.startTime) : ''}</div>\n              </div>\n              \n              <button \n                className=\"stop-button\"\n                onClick={stopSharing}\n              >\n                Arr├¬ter le partage\n              </button>\n            </div>\n          )}\n        </div>\n\n        <div className=\"preview-container\">\n          {isSharing ? (\n            <video \n              ref={videoRef}\n              autoPlay \n              muted\n              className=\"video-preview\"\n            />\n          ) : (\n            <div className=\"preview-placeholder\">\n              <span>L'aper├ºu du partage s'affichera ici</span>\n            </div>\n          )}\n        </div>\n      </div>\n\n      <div className=\"screenshare-history\">\n        <div className=\"history-header\">\n          <h3>Historique des sessions</h3>\n          {sessionHistory.length > 0 && (\n            <button \n              className=\"clear-history-button\"\n              onClick={clearHistory}\n            >\n              Effacer l'historique\n            </button>\n          )}\n        </div>\n        \n        {sessionHistory.length > 0 ? (\n          <div className=\"history-list\">\n            {sessionHistory.map(session => (\n              <div key={session.id} className=\"history-item\">\n                <div className=\"history-info\">\n                  <div className=\"history-type\">\n                    {session.type === 'screen' ? '­ƒûÑ´©Å ├ëcran complet' : session.type === 'window' ? '­ƒ¬ƒ Fen├¬tre' : '­ƒöû Onglet'}\n                    {session.hasAudio && ' ­ƒöè'}\n                  </div>\n                  <div className=\"history-time\">\n                    {formatDate(session.startTime)}\n                    {session.endTime && ` (${formatDuration(session.startTime, session.endTime)})`}\n                  </div>\n                </div>\n              </div>\n            ))}\n          </div>\n        ) : (\n          <p className=\"no-history\">Aucune session de partage dans l'historique</p>\n        )}\n      </div>\n\n      <div className=\"screenshare-footer\">\n        <div className=\"privacy-notice\">\n          <span>­ƒöÆ</span> Vos partages d'├®cran sont s├®curis├®s et ne sont jamais enregistr├®s sur nos serveurs.\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default ScreenSharePanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\SecurityPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[468,471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[468,471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[517,520],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[517,520],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[586,589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[586,589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":108,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":108,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4148,4151],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4148,4151],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5273,5276],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5273,5276],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SecurityPanel - Security monitoring dashboard\n */\n\nimport { useState } from 'react';\nimport { useSecurity } from '../hooks/useSecurity';\nimport { Shield, AlertTriangle, CheckCircle, RefreshCw } from 'lucide-react';\n\nexport const SecurityPanel = () => {\n  const { loading, error, securityScore, scanSecurity, detectRisks, getRecommendations } = useSecurity();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [scanResult, setScanResult] = useState<any>(null);\n  const [risks, setRisks] = useState<any>(null);\n  const [recommendations, setRecommendations] = useState<any>(null);\n\n  const handleScan = async () => {\n    const result = await scanSecurity();\n    if (result.success) {\n      setScanResult(result.output);\n    }\n  };\n\n  const handleDetectRisks = async () => {\n    const result = await detectRisks();\n    if (result.success) {\n      setRisks(result.output);\n    }\n  };\n\n  const handleGetRecommendations = async () => {\n    const result = await getRecommendations();\n    if (result.success) {\n      setRecommendations(result.output);\n    }\n  };\n\n  const getScoreColor = (score: number) => {\n    if (score >= 90) return 'text-green-500';\n    if (score >= 70) return 'text-yellow-500';\n    return 'text-red-500';\n  };\n\n  return (\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 max-w-md\">\n      <div className=\"flex items-center justify-between cursor-pointer\" onClick={() => setIsExpanded(!isExpanded)}>\n        <div className=\"flex items-center gap-2\">\n          <Shield className=\"w-5 h-5 text-blue-500\" />\n          <h3 className=\"font-semibold\">­ƒöÆ Security Monitor</h3>\n        </div>\n        {securityScore !== null && (\n          <div className={`font-bold ${getScoreColor(securityScore)}`}>\n            {securityScore}/100\n          </div>\n        )}\n      </div>\n\n      {isExpanded && (\n        <div className=\"mt-4 space-y-3\">\n          {error && (\n            <div className=\"text-red-500 text-sm p-2 bg-red-50 rounded\">\n              {error}\n            </div>\n          )}\n\n          <div className=\"flex gap-2\">\n            <button\n              onClick={handleScan}\n              disabled={loading}\n              className=\"flex-1 px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50 flex items-center justify-center gap-2\"\n            >\n              {loading ? <RefreshCw className=\"w-4 h-4 animate-spin\" /> : <Shield className=\"w-4 h-4\" />}\n              Scan\n            </button>\n            <button\n              onClick={handleDetectRisks}\n              disabled={loading}\n              className=\"flex-1 px-3 py-2 bg-orange-500 text-white rounded hover:bg-orange-600 disabled:opacity-50\"\n            >\n              Detect Risks\n            </button>\n          </div>\n\n          {scanResult && (\n            <div className=\"p-3 bg-gray-50 dark:bg-gray-700 rounded\">\n              <div className=\"flex items-center justify-between mb-2\">\n                <span className=\"font-semibold\">Security Score:</span>\n                <span className={`text-xl font-bold ${getScoreColor(scanResult.score)}`}>\n                  {scanResult.score}/100\n                </span>\n              </div>\n              <div className=\"text-sm space-y-1\">\n                <div className=\"flex items-center gap-2\">\n                  <CheckCircle className=\"w-4 h-4 text-green-500\" />\n                  <span>Passed: {scanResult.passed}</span>\n                </div>\n                <div className=\"flex items-center gap-2\">\n                  <AlertTriangle className=\"w-4 h-4 text-red-500\" />\n                  <span>Failed: {scanResult.failed}</span>\n                </div>\n                <div className=\"flex items-center gap-2\">\n                  <AlertTriangle className=\"w-4 h-4 text-yellow-500\" />\n                  <span>Warnings: {scanResult.warnings}</span>\n                </div>\n              </div>\n              {scanResult.risks && scanResult.risks.length > 0 && (\n                <div className=\"mt-2 max-h-40 overflow-y-auto\">\n                  <div className=\"font-semibold text-sm mb-1\">Risks Found:</div>\n                  {scanResult.risks.map((risk: any, i: number) => (\n                    <div key={i} className=\"text-xs p-2 bg-white dark:bg-gray-800 rounded mb-1\">\n                      <div className=\"font-semibold text-red-500\">{risk.type}</div>\n                      <div>{risk.description}</div>\n                    </div>\n                  ))}\n                </div>\n              )}\n            </div>\n          )}\n\n          {risks && (\n            <div className=\"p-3 bg-orange-50 dark:bg-orange-900/20 rounded\">\n              <div className=\"font-semibold mb-2\">Risks Detected: {risks.risksDetected}</div>\n              <div className=\"text-sm\">{risks.summary}</div>\n            </div>\n          )}\n\n          <button\n            onClick={handleGetRecommendations}\n            disabled={loading}\n            className=\"w-full px-3 py-2 bg-green-500 text-white rounded hover:bg-green-600 disabled:opacity-50\"\n          >\n            Get Recommendations\n          </button>\n\n          {recommendations && recommendations.recommendations && (\n            <div className=\"max-h-60 overflow-y-auto space-y-2\">\n              {recommendations.recommendations.map((rec: any, i: number) => (\n                <div key={i} className=\"p-2 bg-blue-50 dark:bg-blue-900/20 rounded text-sm\">\n                  <div className=\"font-semibold\">{rec.title}</div>\n                  <div className=\"text-xs text-gray-600 dark:text-gray-400\">{rec.description}</div>\n                  <div className=\"text-xs text-blue-600 mt-1\">Priority: {rec.priority}</div>\n                </div>\n              ))}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\SensorPermissionsPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AlertTriangle' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'X' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":54,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":55}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * ­ƒöÉ Panel de Permissions des Capteurs\n * G├¿re le consentement explicite pour cam├®ra, microphone, g├®olocalisation\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { Camera, Mic, MapPin, Shield, AlertTriangle, X } from 'lucide-react';\n\nexport interface SensorPermissions {\n  camera: {\n    granted: boolean;\n    scope: 'session' | 'project' | 'task';\n    lastActivated?: Date;\n    activationCount: number;\n  };\n  microphone: {\n    granted: boolean;\n    scope: 'session' | 'project' | 'task';\n    lastActivated?: Date;\n    activationCount: number;\n  };\n  geolocation: {\n    granted: boolean;\n    scope: 'session' | 'project' | 'task';\n    lastActivated?: Date;\n  };\n}\n\ninterface Props {\n  onPermissionsChange?: (permissions: SensorPermissions) => void;\n  onEmergencyCutoff?: () => void;\n}\n\nexport const SensorPermissionsPanel: React.FC<Props> = ({\n  onPermissionsChange,\n  onEmergencyCutoff\n}) => {\n  const [permissions, setPermissions] = useState<SensorPermissions>(() => {\n    const saved = localStorage.getItem('lisa:sensor:permissions');\n    return saved ? JSON.parse(saved) : {\n      camera: { granted: false, scope: 'session', activationCount: 0 },\n      microphone: { granted: false, scope: 'session', activationCount: 0 },\n      geolocation: { granted: false, scope: 'session' }\n    };\n  });\n\n  const [showEmergencyConfirm, setShowEmergencyConfirm] = useState(false);\n\n  useEffect(() => {\n    // Sauvegarder les permissions\n    localStorage.setItem('lisa:sensor:permissions', JSON.stringify(permissions));\n    localStorage.setItem('lisa:sensor:consent', \n      (permissions.camera.granted || permissions.microphone.granted) ? 'granted' : 'denied'\n    );\n    \n    // Notifier le parent\n    onPermissionsChange?.(permissions);\n  }, [permissions, onPermissionsChange]);\n\n  const handlePermissionToggle = async (sensor: keyof SensorPermissions) => {\n    const current = permissions[sensor];\n    const newGranted = !current.granted;\n\n    if (newGranted) {\n      // Demander la permission du navigateur\n      try {\n        if (sensor === 'camera') {\n          const stream = await navigator.mediaDevices.getUserMedia({ video: true });\n          stream.getTracks().forEach(track => track.stop());\n        } else if (sensor === 'microphone') {\n          const stream = await navigator.mediaDevices.getUserMedia({ audio: true });\n          stream.getTracks().forEach(track => track.stop());\n        } else if (sensor === 'geolocation') {\n          await new Promise((resolve, reject) => {\n            navigator.geolocation.getCurrentPosition(resolve, reject);\n          });\n        }\n\n        // Mise ├á jour des permissions\n        setPermissions(prev => ({\n          ...prev,\n          [sensor]: {\n            ...prev[sensor],\n            granted: true,\n            lastActivated: new Date()\n          }\n        }));\n\n        // Log d'audit\n        const auditLog = JSON.parse(localStorage.getItem('lisa:sensor:audit') || '[]');\n        auditLog.push({\n          timestamp: new Date().toISOString(),\n          sensor,\n          action: 'granted',\n          scope: current.scope\n        });\n        localStorage.setItem('lisa:sensor:audit', JSON.stringify(auditLog));\n\n      } catch (error) {\n        console.error(`Permission refus├®e pour ${sensor}:`, error);\n        alert(`Permission refus├®e pour ${sensor}. Veuillez v├®rifier les param├¿tres de votre navigateur.`);\n      }\n    } else {\n      // R├®voquer la permission\n      setPermissions(prev => ({\n        ...prev,\n        [sensor]: {\n          ...prev[sensor],\n          granted: false\n        }\n      }));\n\n      // Log d'audit\n      const auditLog = JSON.parse(localStorage.getItem('lisa:sensor:audit') || '[]');\n      auditLog.push({\n        timestamp: new Date().toISOString(),\n        sensor,\n        action: 'revoked',\n        scope: current.scope\n      });\n      localStorage.setItem('lisa:sensor:audit', JSON.stringify(auditLog));\n    }\n  };\n\n  const handleScopeChange = (sensor: keyof SensorPermissions, scope: 'session' | 'project' | 'task') => {\n    setPermissions(prev => ({\n      ...prev,\n      [sensor]: {\n        ...prev[sensor],\n        scope\n      }\n    }));\n  };\n\n  const handleEmergencyCutoff = () => {\n    if (!showEmergencyConfirm) {\n      setShowEmergencyConfirm(true);\n      return;\n    }\n\n    // Couper tous les capteurs\n    setPermissions({\n      camera: { granted: false, scope: 'session', activationCount: 0 },\n      microphone: { granted: false, scope: 'session', activationCount: 0 },\n      geolocation: { granted: false, scope: 'session' }\n    });\n\n    // Stopper les streams actifs\n    if (window.lisaStopCamera) window.lisaStopCamera();\n    if (window.lisaStopMicrophone) window.lisaStopMicrophone();\n\n    // Log d'audit\n    const auditLog = JSON.parse(localStorage.getItem('lisa:sensor:audit') || '[]');\n    auditLog.push({\n      timestamp: new Date().toISOString(),\n      action: 'EMERGENCY_CUTOFF',\n      allSensors: true\n    });\n    localStorage.setItem('lisa:sensor:audit', JSON.stringify(auditLog));\n\n    onEmergencyCutoff?.();\n    setShowEmergencyConfirm(false);\n\n    alert('­ƒö┤ Tous les capteurs ont ├®t├® coup├®s');\n  };\n\n  const exportAuditLog = () => {\n    const auditLog = localStorage.getItem('lisa:sensor:audit') || '[]';\n    const blob = new Blob([auditLog], { type: 'application/json' });\n    const url = URL.createObjectURL(blob);\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = `lisa-sensor-audit-${new Date().toISOString()}.json`;\n    a.click();\n    URL.revokeObjectURL(url);\n  };\n\n  return (\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-6\">\n      <div className=\"flex items-center justify-between mb-6\">\n        <h2 className=\"text-2xl font-bold flex items-center gap-2\">\n          <Shield className=\"text-blue-500\" />\n          Permissions des Capteurs\n        </h2>\n        \n        {/* Bouton Coupure d'Urgence */}\n        <button\n          onClick={handleEmergencyCutoff}\n          className={`px-4 py-2 rounded-lg font-semibold transition-all ${\n            showEmergencyConfirm \n              ? 'bg-red-600 text-white animate-pulse' \n              : 'bg-red-500 text-white hover:bg-red-600'\n          }`}\n        >\n          {showEmergencyConfirm ? 'ÔÜá´©Å CONFIRMER COUPURE' : '­ƒö┤ COUPURE D\\'URGENCE'}\n        </button>\n      </div>\n\n      {showEmergencyConfirm && (\n        <div className=\"mb-4 p-3 bg-red-100 dark:bg-red-900/30 border border-red-300 rounded-lg\">\n          <p className=\"text-red-700 dark:text-red-300\">\n            ÔÜá´©Å ├ètes-vous s├╗r? Tous les capteurs seront imm├®diatement coup├®s.\n          </p>\n        </div>\n      )}\n\n      <div className=\"space-y-6\">\n        {/* Camera */}\n        <div className=\"border dark:border-gray-700 rounded-lg p-4\">\n          <div className=\"flex items-center justify-between mb-3\">\n            <div className=\"flex items-center gap-3\">\n              <Camera className={permissions.camera.granted ? 'text-green-500' : 'text-gray-400'} />\n              <div>\n                <h3 className=\"font-semibold\">Cam├®ra</h3>\n                <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                  D├®tection visage, mains, objets\n                </p>\n              </div>\n            </div>\n            \n            <button\n              onClick={() => handlePermissionToggle('camera')}\n              className={`px-4 py-2 rounded-lg font-medium transition-colors ${\n                permissions.camera.granted\n                  ? 'bg-green-500 text-white hover:bg-green-600'\n                  : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300'\n              }`}\n            >\n              {permissions.camera.granted ? 'Ô£à Activ├®' : 'D├®sactiv├®'}\n            </button>\n          </div>\n\n          <div className=\"flex gap-2 mt-3\">\n            <span className=\"text-sm text-gray-600\">Port├®e:</span>\n            {(['session', 'project', 'task'] as const).map(scope => (\n              <button\n                key={scope}\n                onClick={() => handleScopeChange('camera', scope)}\n                className={`px-3 py-1 text-sm rounded ${\n                  permissions.camera.scope === scope\n                    ? 'bg-blue-500 text-white'\n                    : 'bg-gray-200 dark:bg-gray-700'\n                }`}\n              >\n                {scope}\n              </button>\n            ))}\n          </div>\n\n          {permissions.camera.lastActivated && (\n            <p className=\"text-xs text-gray-500 mt-2\">\n              Derni├¿re activation: {new Date(permissions.camera.lastActivated).toLocaleString()}\n            </p>\n          )}\n        </div>\n\n        {/* Microphone */}\n        <div className=\"border dark:border-gray-700 rounded-lg p-4\">\n          <div className=\"flex items-center justify-between mb-3\">\n            <div className=\"flex items-center gap-3\">\n              <Mic className={permissions.microphone.granted ? 'text-green-500' : 'text-gray-400'} />\n              <div>\n                <h3 className=\"font-semibold\">Microphone</h3>\n                <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                  Commandes vocales, transcription\n                </p>\n              </div>\n            </div>\n            \n            <button\n              onClick={() => handlePermissionToggle('microphone')}\n              className={`px-4 py-2 rounded-lg font-medium transition-colors ${\n                permissions.microphone.granted\n                  ? 'bg-green-500 text-white hover:bg-green-600'\n                  : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300'\n              }`}\n            >\n              {permissions.microphone.granted ? 'Ô£à Activ├®' : 'D├®sactiv├®'}\n            </button>\n          </div>\n\n          <div className=\"flex gap-2 mt-3\">\n            <span className=\"text-sm text-gray-600\">Port├®e:</span>\n            {(['session', 'project', 'task'] as const).map(scope => (\n              <button\n                key={scope}\n                onClick={() => handleScopeChange('microphone', scope)}\n                className={`px-3 py-1 text-sm rounded ${\n                  permissions.microphone.scope === scope\n                    ? 'bg-blue-500 text-white'\n                    : 'bg-gray-200 dark:bg-gray-700'\n                }`}\n              >\n                {scope}\n              </button>\n            ))}\n          </div>\n\n          {permissions.microphone.lastActivated && (\n            <p className=\"text-xs text-gray-500 mt-2\">\n              Derni├¿re activation: {new Date(permissions.microphone.lastActivated).toLocaleString()}\n            </p>\n          )}\n        </div>\n\n        {/* Geolocation */}\n        <div className=\"border dark:border-gray-700 rounded-lg p-4\">\n          <div className=\"flex items-center justify-between mb-3\">\n            <div className=\"flex items-center gap-3\">\n              <MapPin className={permissions.geolocation.granted ? 'text-green-500' : 'text-gray-400'} />\n              <div>\n                <h3 className=\"font-semibold\">G├®olocalisation</h3>\n                <p className=\"text-sm text-gray-600 dark:text-gray-400\">\n                  Services contextuels, m├®t├®o locale\n                </p>\n              </div>\n            </div>\n            \n            <button\n              onClick={() => handlePermissionToggle('geolocation')}\n              className={`px-4 py-2 rounded-lg font-medium transition-colors ${\n                permissions.geolocation.granted\n                  ? 'bg-green-500 text-white hover:bg-green-600'\n                  : 'bg-gray-200 dark:bg-gray-700 hover:bg-gray-300'\n              }`}\n            >\n              {permissions.geolocation.granted ? 'Ô£à Activ├®' : 'D├®sactiv├®'}\n            </button>\n          </div>\n\n          <div className=\"flex gap-2 mt-3\">\n            <span className=\"text-sm text-gray-600\">Port├®e:</span>\n            {(['session', 'project', 'task'] as const).map(scope => (\n              <button\n                key={scope}\n                onClick={() => handleScopeChange('geolocation', scope)}\n                className={`px-3 py-1 text-sm rounded ${\n                  permissions.geolocation.scope === scope\n                    ? 'bg-blue-500 text-white'\n                    : 'bg-gray-200 dark:bg-gray-700'\n                }`}\n              >\n                {scope}\n              </button>\n            ))}\n          </div>\n\n          {permissions.geolocation.lastActivated && (\n            <p className=\"text-xs text-gray-500 mt-2\">\n              Derni├¿re activation: {new Date(permissions.geolocation.lastActivated).toLocaleString()}\n            </p>\n          )}\n        </div>\n      </div>\n\n      {/* Export Audit Log */}\n      <div className=\"mt-6 pt-6 border-t dark:border-gray-700\">\n        <button\n          onClick={exportAuditLog}\n          className=\"px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors\"\n        >\n          ­ƒôÑ Exporter le Journal d'Audit\n        </button>\n        <p className=\"text-sm text-gray-600 dark:text-gray-400 mt-2\">\n          Journal local des activations de capteurs (JSON, sans donn├®es personnelles)\n        </p>\n      </div>\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\SensorStatus.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\SpeechSynthesisPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":83,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":83,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3132,3135],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3132,3135],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":227,"column":48,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":227,"endColumn":51,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7764,7767],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7764,7767],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SpeechSynthesisPanel - Panneau de contr├┤le pour la synth├¿se vocale\n * \n * Ce composant fournit une interface utilisateur pour la synth├¿se vocale,\n * permettant de lire du texte ├á haute voix, modifier les param├¿tres de voix,\n * et communiquer avec d'autres assistants comme Alexa et Gemini.\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { Box, Typography, Button, Slider, TextField, Select, MenuItem, FormControl, InputLabel } from '@mui/material';\nimport VolumeUpIcon from '@mui/icons-material/VolumeUp';\nimport StopIcon from '@mui/icons-material/Stop';\nimport SettingsIcon from '@mui/icons-material/Settings';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport useSpeechSynthesis from '../hooks/useSpeechSynthesis';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n\ninterface SpeechSynthesisPanelProps {\n  expanded?: boolean;\n}\n\nexport const SpeechSynthesisPanel: React.FC<SpeechSynthesisPanelProps> = ({ expanded = false }) => {\n  const { speak, stop, getVoices, updateSettings, state, availableVoices, currentSettings } = useSpeechSynthesis();\n  const [text, setText] = useState('');\n  const [isExpanded, setIsExpanded] = useState(expanded);\n  const [showSettings, setShowSettings] = useState(false);\n  const [rate, setRate] = useState(currentSettings.rate);\n  const [pitch, setPitch] = useState(currentSettings.pitch);\n  const [volume, setVolume] = useState(currentSettings.volume);\n  const [selectedVoice, setSelectedVoice] = useState(currentSettings.voice);\n  \n  const lastIntent = useVisionAudioStore((state) => state.lastIntent);\n  const lastSpokenText = useVisionAudioStore((state) => state.lastSpokenText);\n  const isListening = useVisionAudioStore((state) => state.isListening);\n  const audioEnabled = useVisionAudioStore((state) => state.audioEnabled);\n\n  // Mise ├á jour des param├¿tres locaux quand les param├¿tres actuels changent\n  useEffect(() => {\n    setRate(currentSettings.rate);\n    setPitch(currentSettings.pitch);\n    setVolume(currentSettings.volume);\n    setSelectedVoice(currentSettings.voice);\n  }, [currentSettings]);\n\n  // R├®cup├®rer ├á nouveau la liste des voix quand le composant est mont├®\n  useEffect(() => {\n    getVoices();\n  }, [getVoices]);\n\n  // Appliquer les modifications de param├¿tres\n  const applySettings = async () => {\n    await updateSettings({\n      rate,\n      pitch,\n      volume,\n      voice: selectedVoice\n    });\n    setShowSettings(false);\n  };\n\n  // Fonction pour parler\n  const handleSpeak = async () => {\n    if (text.trim()) {\n      await speak(text);\n    }\n  };\n\n  // Fonction pour arr├¬ter de parler\n  const handleStop = async () => {\n    await stop();\n  };\n\n  // G├®n├¿re une r├®ponse vocale ├á une commande r├®cente\n  const handleRespondVocally = async () => {\n    if (lastIntent && lastIntent.intent) {\n      const response = generateVocalResponse(lastIntent.intent, lastIntent.entities);\n      await speak(response);\n    }\n  };\n\n  // Fonction pour g├®n├®rer une r├®ponse vocale en fonction de l'intention\n  const generateVocalResponse = (intent: string, entities: any): string => {\n    // Exemple simple - dans une impl├®mentation r├®elle, ceci serait plus sophistiqu├®\n    switch (intent) {\n      case 'get_weather':\n        return `Voici la m├®t├®o pour ${entities.location || 'votre r├®gion'}. Il fait beau aujourd'hui avec une temp├®rature de 22 degr├®s.`;\n      case 'set_alarm':\n        return `J'ai r├®gl├® une alarme pour ${entities.time || 'l\\'heure demand├®e'}.`;\n      case 'create_todo':\n        return `J'ai ajout├® \"${entities.task || 'votre t├óche'}\" ├á votre liste de t├óches.`;\n      default:\n        return \"Je suis l├á pour vous aider. N'h├®sitez pas ├á me poser des questions.\";\n    }\n  };\n\n  // Bouton de bascule d'expansion\n  const toggleExpand = () => {\n    setIsExpanded(!isExpanded);\n  };\n\n  // Bouton de bascule des param├¿tres\n  const toggleSettings = () => {\n    setShowSettings(!showSettings);\n  };\n\n  return (\n    <Box sx={{ \n      border: '1px solid #e0e0e0',\n      borderRadius: 2,\n      padding: 2,\n      margin: 2,\n      backgroundColor: '#f9f9f9',\n      boxShadow: 1\n    }}>\n      <Box sx={{ \n        display: 'flex', \n        justifyContent: 'space-between', \n        alignItems: 'center',\n        mb: 2\n      }}>\n        <Typography variant=\"h6\" component=\"h2\" sx={{ display: 'flex', alignItems: 'center' }}>\n          <VolumeUpIcon sx={{ mr: 1 }} /> Synth├¿se Vocale\n        </Typography>\n        <Button \n          variant=\"text\" \n          size=\"small\"\n          onClick={toggleExpand}\n          startIcon={isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n        >\n          {isExpanded ? 'R├®duire' : 'D├®velopper'}\n        </Button>\n      </Box>\n\n      {isExpanded && (\n        <>\n          <TextField\n            label=\"Texte ├á prononcer\"\n            variant=\"outlined\"\n            fullWidth\n            multiline\n            rows={3}\n            value={text}\n            onChange={(e) => setText(e.target.value)}\n            sx={{ mb: 2 }}\n          />\n\n          <Box sx={{ display: 'flex', gap: 1, mb: 2 }}>\n            <Button \n              variant=\"contained\" \n              color=\"primary\"\n              startIcon={<VolumeUpIcon />}\n              onClick={handleSpeak}\n              disabled={!text.trim() || state === 'speaking' || !audioEnabled}\n              fullWidth\n            >\n              Prononcer\n            </Button>\n            <Button \n              variant=\"outlined\"\n              color=\"secondary\"\n              startIcon={<StopIcon />}\n              onClick={handleStop}\n              disabled={state !== 'speaking'}\n            >\n              Stop\n            </Button>\n            <Button \n              variant=\"outlined\"\n              startIcon={<SettingsIcon />}\n              onClick={toggleSettings}\n            >\n              Param├¿tres\n            </Button>\n          </Box>\n\n          {isListening && (\n            <Box sx={{ mt: 2, mb: 2, p: 1, bgcolor: 'primary.main', color: 'white', borderRadius: 1 }}>\n              <Typography variant=\"body2\">En ├®coute... Parlez maintenant</Typography>\n            </Box>\n          )}\n\n          {lastIntent && lastIntent.intent && (\n            <Box sx={{ mb: 2 }}>\n              <Typography variant=\"subtitle2\">Derni├¿re intention: {lastIntent.intent}</Typography>\n              <Button \n                variant=\"text\" \n                size=\"small\"\n                onClick={handleRespondVocally}\n                startIcon={<VolumeUpIcon />}\n                disabled={!audioEnabled}\n              >\n                R├®pondre vocalement\n              </Button>\n            </Box>\n          )}\n\n          {lastSpokenText && (\n            <Box sx={{ mb: 2 }}>\n              <Typography variant=\"subtitle2\">Dernier texte prononc├®:</Typography>\n              <Typography variant=\"body2\" color=\"text.secondary\">\n                {lastSpokenText.length > 50 \n                  ? `${lastSpokenText.substring(0, 50)}...` \n                  : lastSpokenText\n                }\n              </Typography>\n            </Box>\n          )}\n\n          {showSettings && (\n            <Box sx={{ \n              mt: 2, \n              p: 2, \n              border: '1px solid #e0e0e0', \n              borderRadius: 1,\n              bgcolor: 'background.paper' \n            }}>\n              <Typography variant=\"subtitle1\" gutterBottom>Param├¿tres de voix</Typography>\n              \n              <FormControl fullWidth sx={{ mb: 2 }}>\n                <InputLabel>Voix</InputLabel>\n                <Select\n                  value={selectedVoice}\n                  onChange={(e) => setSelectedVoice(e.target.value)}\n                  label=\"Voix\"\n                >\n                  {availableVoices.map((voice: any) => (\n                    <MenuItem key={voice.name} value={voice.name}>\n                      {voice.name} ({voice.lang})\n                    </MenuItem>\n                  ))}\n                </Select>\n              </FormControl>\n              \n              <Typography gutterBottom>Vitesse: {rate}</Typography>\n              <Slider\n                value={rate}\n                onChange={(_, value) => setRate(value as number)}\n                min={0.5}\n                max={2.0}\n                step={0.1}\n                marks\n                valueLabelDisplay=\"auto\"\n                sx={{ mb: 2 }}\n              />\n              \n              <Typography gutterBottom>Hauteur: {pitch}</Typography>\n              <Slider\n                value={pitch}\n                onChange={(_, value) => setPitch(value as number)}\n                min={0.5}\n                max={2.0}\n                step={0.1}\n                marks\n                valueLabelDisplay=\"auto\"\n                sx={{ mb: 2 }}\n              />\n              \n              <Typography gutterBottom>Volume: {volume}</Typography>\n              <Slider\n                value={volume}\n                onChange={(_, value) => setVolume(value as number)}\n                min={0.1}\n                max={1.0}\n                step={0.1}\n                marks\n                valueLabelDisplay=\"auto\"\n                sx={{ mb: 2 }}\n              />\n              \n              <Button \n                variant=\"contained\" \n                onClick={applySettings}\n                fullWidth\n              >\n                Appliquer les param├¿tres\n              </Button>\n            </Box>\n          )}\n\n          <Box sx={{ mt: 2 }}>\n            <Typography variant=\"body2\" color=\"text.secondary\">\n              Utilisez la synth├¿se vocale pour communiquer avec Alexa, Gemini et d'autres personnes.\n              Statut actuel : {state === 'speaking' ? 'En train de parler' : 'Pr├¬t'}\n            </Typography>\n          </Box>\n        </>\n      )}\n    </Box>\n  );\n};\n\nexport default SpeechSynthesisPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\SystemIntegrationPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getIntegrationTypeStyle' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":289,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":289,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Tabs' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":311,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":311,"endColumn":11},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'isLoading' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":361,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":361,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loadIntegrations' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":362,"column":5,"nodeType":null,"messageId":"unusedVar","endLine":362,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setExecutionParams' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":370,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":370,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'executionResult' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":371,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":371,"endColumn":25},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'expandedIntegrations' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":373,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":373,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setExpandedIntegrations' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":373,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":373,"endColumn":55},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'toast' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":376,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":376,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'newIntegration' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":383,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":383,"endColumn":24},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setNewIntegration' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":383,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":383,"endColumn":43},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'newTag' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":400,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":400,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setNewTag' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":400,"column":18,"nodeType":null,"messageId":"unusedVar","endLine":400,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleExecuteIntegration' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":410,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":410,"endColumn":33},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":417,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":417,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10441,10444],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10441,10444],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":420,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":420,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleTestIntegration' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":437,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":437,"endColumn":30},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'handleDeleteIntegration' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":456,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":456,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getIntegrationTypeStyle' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":480,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":480,"endColumn":32},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'toggleExpand' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":506,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":506,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'IntegrationCreateForm' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":565,"column":7,"nodeType":null,"messageId":"unusedVar","endLine":565,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":584,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":584,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15407,15410],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15407,15410],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":593,"column":52,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":593,"endColumn":55,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15593,15596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15593,15596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":604,"column":47,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":604,"endColumn":50,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[15830,15833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[15830,15833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":652,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":652,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17333,17336],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17333,17336],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":661,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":661,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[17777,17780],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[17777,17780],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":670,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":670,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18236,18239],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18236,18239],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":678,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":678,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[18653,18656],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[18653,18656],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":690,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":690,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[19325,19328],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[19325,19328],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":712,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":712,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20161,20164],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20161,20164],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":721,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":721,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[20596,20599],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[20596,20599],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":750,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":750,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":32,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * SystemIntegrationPanel.tsx\n * \n * Panneau d'interface utilisateur pour g├®rer les int├®grations syst├¿me\n * Permet de cr├®er, configurer, tester et ex├®cuter des int├®grations avec des syst├¿mes externes\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { useSystemIntegration } from '../hooks/useSystemIntegration';\nimport { SYSTEM_INTEGRATION_TYPES, type SystemIntegrationConfig, type SystemIntegrationType } from '../agents/SystemIntegrationAgent';\nimport { v4 as uuidv4 } from 'uuid';\nimport { useTranslation } from 'react-i18next';\n\n// Styles pour l'ensemble du panneau\nconst styles = {\n  container: {\n    display: 'flex' as const,\n    flexDirection: 'column' as const,\n    gap: '16px',\n    padding: '16px',\n    height: '100%',\n    maxHeight: '100%',\n    overflow: 'hidden',\n    backgroundColor: '#f8f9fa'\n  },\n  header: {\n    display: 'flex' as const,\n    alignItems: 'center' as const,\n    justifyContent: 'space-between' as const,\n    padding: '8px 0',\n    borderBottom: '1px solid #e1e4e8'\n  },\n  title: {\n    fontSize: '1.5em',\n    fontWeight: 'bold',\n    margin: '0'\n  },\n  tabs: {\n    display: 'flex' as const,\n    gap: '8px',\n    marginBottom: '16px',\n    borderBottom: '1px solid #e1e4e8'\n  },\n  tabButton: {\n    padding: '8px 16px',\n    border: 'none',\n    backgroundColor: 'transparent',\n    cursor: 'pointer',\n    borderBottom: '2px solid transparent',\n    fontWeight: 'normal',\n    color: '#555',\n    fontSize: '1rem'\n  },\n  activeTab: {\n    borderBottom: '2px solid #3182ce',\n    fontWeight: 'bold',\n    color: '#3182ce'\n  },\n  contentArea: {\n    flexGrow: 1,\n    overflowY: 'auto' as const,\n    padding: '8px'\n  },\n  card: {\n    border: '1px solid #e1e4e8',\n    borderRadius: '8px',\n    backgroundColor: '#fff',\n    overflow: 'hidden',\n    boxShadow: '0 1px 3px rgba(0,0,0,0.12)',\n    marginBottom: '16px'\n  },\n  selectedCard: {\n    border: '2px solid #3182ce',\n    boxShadow: '0 0 0 1px #3182ce'\n  },\n  cardHeader: {\n    padding: '12px 16px',\n    borderBottom: '1px solid #e1e4e8',\n    backgroundColor: '#f8f9fa'\n  },\n  cardTitle: {\n    fontSize: '1.1rem',\n    fontWeight: 'bold',\n    margin: '0'\n  },\n  cardDescription: {\n    fontSize: '0.9rem',\n    color: '#666',\n    margin: '4px 0 0 0'\n  },\n  cardContent: {\n    padding: '16px'\n  },\n  cardFooter: {\n    padding: '12px 16px',\n    borderTop: '1px solid #e1e4e8',\n    backgroundColor: '#f8f9fa',\n    display: 'flex' as const,\n    justifyContent: 'space-between' as const\n  },\n  grid: {\n    display: 'grid' as const,\n    gridTemplateColumns: 'repeat(auto-fill, minmax(300px, 1fr))',\n    gap: '16px'\n  },\n  formGroup: {\n    marginBottom: '16px'\n  },\n  label: {\n    display: 'block' as const,\n    marginBottom: '6px',\n    fontWeight: 'bold',\n    fontSize: '0.9rem'\n  },\n  input: {\n    width: '100%',\n    padding: '8px 12px',\n    border: '1px solid #ccc',\n    borderRadius: '4px',\n    fontSize: '1rem'\n  },\n  select: {\n    width: '100%',\n    padding: '8px 12px',\n    border: '1px solid #ccc',\n    borderRadius: '4px',\n    fontSize: '1rem',\n    backgroundColor: '#fff'\n  },\n  textarea: {\n    width: '100%',\n    padding: '8px 12px',\n    border: '1px solid #ccc',\n    borderRadius: '4px',\n    fontSize: '1rem',\n    fontFamily: 'monospace',\n    minHeight: '100px'\n  },\n  button: {\n    padding: '8px 16px',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontWeight: 'bold',\n    backgroundColor: '#3182ce',\n    color: '#fff',\n    fontSize: '0.9rem'\n  },\n  outlineButton: {\n    padding: '8px 16px',\n    border: '1px solid #3182ce',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontWeight: 'bold',\n    backgroundColor: 'transparent',\n    color: '#3182ce',\n    fontSize: '0.9rem'\n  },\n  dangerButton: {\n    padding: '8px 16px',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontWeight: 'bold',\n    backgroundColor: '#e53e3e',\n    color: '#fff',\n    fontSize: '0.9rem'\n  },\n  disabledButton: {\n    opacity: 0.6,\n    cursor: 'not-allowed'\n  },\n  badge: {\n    display: 'inline-block' as const,\n    padding: '2px 8px',\n    borderRadius: '12px',\n    fontSize: '0.8em',\n    fontWeight: 'bold',\n    backgroundColor: '#333',\n    color: '#fff',\n    marginRight: '5px'\n  },\n  badgeOutline: {\n    backgroundColor: 'transparent',\n    border: '1px solid #ccc',\n    color: '#333'\n  },\n  flexRow: {\n    display: 'flex' as const,\n    flexDirection: 'row' as const,\n    alignItems: 'center' as const,\n    gap: '8px'\n  },\n  flexColumn: {\n    display: 'flex' as const,\n    flexDirection: 'column' as const,\n    gap: '8px'\n  },\n  flexWrap: {\n    display: 'flex' as const,\n    flexWrap: 'wrap' as const,\n    gap: '4px'\n  },\n  loadingSpinner: {\n    display: 'inline-block',\n    width: '20px',\n    height: '20px',\n    border: '2px solid rgba(0,0,0,0.1)',\n    borderRadius: '50%',\n    borderTopColor: '#3182ce',\n    animation: 'spin 1s ease-in-out infinite'\n  },\n  separator: {\n    height: '1px',\n    backgroundColor: '#e1e4e8',\n    margin: '16px 0',\n    border: 'none'\n  },\n  tagInput: {\n    display: 'flex' as const,\n    flexWrap: 'wrap' as const,\n    gap: '8px',\n    alignItems: 'center' as const\n  },\n  tag: {\n    display: 'inline-flex' as const,\n    alignItems: 'center' as const,\n    backgroundColor: '#e1e4e8',\n    color: '#333',\n    padding: '2px 8px',\n    borderRadius: '12px',\n    fontSize: '0.8em'\n  },\n  removeTagButton: {\n    marginLeft: '4px',\n    border: 'none',\n    backgroundColor: 'transparent',\n    color: '#666',\n    cursor: 'pointer',\n    fontSize: '0.8em'\n  },\n  switchContainer: {\n    display: 'flex' as const,\n    alignItems: 'center' as const,\n    gap: '8px'\n  },\n  switch: {\n    position: 'relative' as const,\n    display: 'inline-block' as const,\n    width: '40px',\n    height: '20px'\n  },\n  switchInput: {\n    opacity: 0,\n    width: 0,\n    height: 0\n  },\n  switchSlider: {\n    position: 'absolute' as const,\n    cursor: 'pointer',\n    top: 0,\n    left: 0,\n    right: 0,\n    bottom: 0,\n    backgroundColor: '#ccc',\n    borderRadius: '20px',\n    transition: '0.4s'\n  },\n  switchSliderChecked: {\n    backgroundColor: '#3182ce'\n  },\n  switchSliderBefore: {\n    position: 'absolute' as const,\n    content: '\"\"',\n    height: '16px',\n    width: '16px',\n    left: '2px',\n    bottom: '2px',\n    backgroundColor: '#fff',\n    borderRadius: '50%',\n    transition: '0.4s'\n  },\n  switchSliderBeforeChecked: {\n    transform: 'translateX(20px)'\n  }\n};\n\n// Fonction pour obtenir le style de badge pour un type d'int├®gration\nconst getIntegrationTypeStyle = (type: SystemIntegrationType): React.CSSProperties => {\n  const baseStyle = { ...styles.badge };\n  \n  switch (type) {\n    case 'api': return { ...baseStyle, backgroundColor: '#4CAF50' };\n    case 'webhook': return { ...baseStyle, backgroundColor: '#2196F3' };\n    case 'mqtt': return { ...baseStyle, backgroundColor: '#9C27B0' };\n    case 'socket': return { ...baseStyle, backgroundColor: '#FF5722' };\n    case 'http': return { ...baseStyle, backgroundColor: '#3F51B5' };\n    case 'database': return { ...baseStyle, backgroundColor: '#607D8B' };\n    case 'file': return { ...baseStyle, backgroundColor: '#795548' };\n    case 'shell': return { ...baseStyle, backgroundColor: '#E91E63' };\n    default: return baseStyle;\n  }\n};\n\ninterface TabsProps {\n  activeTab: string;\n  setActiveTab: (tab: string) => void;\n}\n\n// Composant d'onglets pour la navigation\nconst Tabs: React.FC<TabsProps> = ({ activeTab, setActiveTab }) => {\n  return (\n    <div style={styles.tabs}>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'list' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('list')}\n      >\n        Liste\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'execute' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('execute')}\n      >\n        Ex├®cuter\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'create' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('create')}\n      >\n        Cr├®er\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'test' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('test')}\n      >\n        Test\n      </button>\n    </div>\n  );\n};\n\n/**\n * Composant principal du panneau d'int├®gration syst├¿me\n */\nexport const SystemIntegrationPanel: React.FC = () => {\n  const { t } = useTranslation();\n  const { \n    integrations, \n    isLoading, \n    loadIntegrations, \n    executeIntegration, \n    testIntegration,\n    deleteIntegration\n  } = useSystemIntegration();\n  \n  const [activeTab, setActiveTab] = useState<string>('list');\n  const [selectedIntegration, setSelectedIntegration] = useState<string | null>(null);\n  const [executionParams, setExecutionParams] = useState<string>('{}');\n  const [executionResult, setExecutionResult] = useState<string>('');\n  const [isExpanded, setIsExpanded] = useState<boolean>(false);\n  const [expandedIntegrations, setExpandedIntegrations] = useState<Record<string, boolean>>({});\n  \n  // Toast notification function (simplified version)\n  const toast = {\n    success: (message: string) => { console.log('SUCCESS:', message); },\n    error: (message: string) => { console.error('ERROR:', message); },\n    info: (message: string) => { console.info('INFO:', message); }\n  };\n\n  // ├ëtats pour la cr├®ation/├®dition d'int├®gration\n  const [newIntegration, setNewIntegration] = useState<{\n    name: string;\n    description: string;\n    type: SystemIntegrationType;\n    config: string;\n    enabled: boolean;\n    tags: string[];\n    icon?: string;\n  }>({\n    name: '', \n    description: '', \n    type: 'api', \n    config: '{}', \n    enabled: true, \n    tags: [],\n    icon: undefined\n  });\n  const [newTag, setNewTag] = useState<string>('');\n  \n  // Charger les int├®grations au montage du composant\n  useEffect(() => {\n    // Note: Nous utilisons directement les donn├®es d'int├®grations fournies par le hook\n    // Pas besoin d'appeler une fonction explicite pour charger les donn├®es\n    console.log('Int├®grations disponibles:', integrations.length);\n  }, [integrations.length]);\n\n  // Ex├®cuter une int├®gration\n  const handleExecuteIntegration = async () => {\n    if (!selectedIntegration) {\n      alert('Veuillez s├®lectionner une int├®gration ├á ex├®cuter.');\n      return;\n    }\n\n    try {\n      let params: Record<string, any> = {};\n      try {\n        params = JSON.parse(executionParams);\n      } catch (error) {\n        alert('Param├¿tres JSON invalides. Veuillez v├®rifier le format.');\n        return;\n      }\n\n      const result = await executeIntegration(selectedIntegration, params);\n      setExecutionResult(JSON.stringify(result.data, null, 2));\n      \n      if (result.success) {\n        alert('Int├®gration ex├®cut├®e avec succ├¿s !');\n      }\n    } catch (error) {\n      alert(`Erreur lors de l'ex├®cution : ${error instanceof Error ? error.message : String(error)}`);\n    }\n  };\n\n  // Tester une int├®gration\n  const handleTestIntegration = async () => {\n    if (!selectedIntegration) {\n      alert('Veuillez s├®lectionner une int├®gration ├á tester.');\n      return;\n    }\n\n    try {\n      const result = await testIntegration(selectedIntegration);\n      setExecutionResult(JSON.stringify(result.data, null, 2));\n      \n      if (result.success) {\n        alert('Test r├®ussi !');\n      }\n    } catch (error) {\n      alert(`Erreur lors du test : ${error instanceof Error ? error.message : String(error)}`);\n    }\n  };\n\n  // Supprimer une int├®gration\n  const handleDeleteIntegration = async () => {\n    if (!selectedIntegration) {\n      alert('Veuillez s├®lectionner une int├®gration ├á supprimer.');\n      return;\n    }\n    \n    const integration = getSelectedIntegration();\n    if (!integration) return;\n    \n    if (confirm(`├ètes-vous s├╗r de vouloir supprimer l'int├®gration \"${integration.name}\" ?`)) {\n      try {\n        const result = await deleteIntegration(selectedIntegration);\n        \n        if (result.success) {\n          setSelectedIntegration(null);\n          alert(`Int├®gration \"${integration.name}\" supprim├®e avec succ├¿s.`);\n        }\n      } catch (error) {\n        alert(`Erreur lors de la suppression : ${error instanceof Error ? error.message : String(error)}`);\n      }\n    }\n  };\n\n  // Obtenir le style de badge pour un type d'int├®gration\n  const getIntegrationTypeStyle = (type: SystemIntegrationType): React.CSSProperties => {\n    const baseStyle: React.CSSProperties = {\n      display: 'inline-block',\n      padding: '2px 8px',\n      borderRadius: '12px',\n      fontSize: '0.8em',\n      fontWeight: 'bold',\n      backgroundColor: '#333',\n      color: '#fff',\n      marginRight: '5px'\n    };\n    \n    switch (type) {\n      case 'api': return { ...baseStyle, backgroundColor: '#4CAF50' };\n      case 'webhook': return { ...baseStyle, backgroundColor: '#2196F3' };\n      case 'mqtt': return { ...baseStyle, backgroundColor: '#9C27B0' };\n      case 'socket': return { ...baseStyle, backgroundColor: '#FF5722' };\n      case 'http': return { ...baseStyle, backgroundColor: '#3F51B5' };\n      case 'database': return { ...baseStyle, backgroundColor: '#607D8B' };\n      case 'file': return { ...baseStyle, backgroundColor: '#795548' };\n      case 'shell': return { ...baseStyle, backgroundColor: '#E91E63' };\n      default: return baseStyle;\n    }\n  };\n  \n  // Basculer l'expansion du panneau\n  const toggleExpand = () => {\n    setIsExpanded(!isExpanded);\n  };\n\n  return (\n    <div style={styles.container}>\n      <div style={styles.header}>\n        <h2 style={styles.title}>{t('Int├®grations syst├¿me')}</h2>\n      </div>\n      \n      <div style={styles.tabs}>\n        <button \n          style={{\n            ...styles.tabButton,\n            ...(activeTab === 'list' ? styles.activeTab : {})\n          }}\n          onClick={() => setActiveTab('list')}\n        >\n          Liste\n        </button>\n        <button \n          style={{\n            ...styles.tabButton,\n            ...(activeTab === 'create' ? styles.activeTab : {})\n          }}\n          onClick={() => setActiveTab('create')}\n        >\n          Cr├®er\n        </button>\n        <button \n          style={{\n            ...styles.tabButton,\n            ...(activeTab === 'execute' ? styles.activeTab : {})\n          }}\n          onClick={() => setActiveTab('execute')}\n        >\n          Ex├®cuter\n        </button>\n        <button \n          style={{\n            ...styles.tabButton,\n            ...(activeTab === 'test' ? styles.activeTab : {})\n          }}\n          onClick={() => setActiveTab('test')}\n        >\n          Test\n        </button>\n      </div>\n    </div>\n  );\n};\n\n/**\n * Formulaire pour cr├®er une nouvelle int├®gration\n */\ninterface IntegrationCreateFormProps {\n  onSuccess: () => void;\n}\n\nconst IntegrationCreateForm: React.FC<IntegrationCreateFormProps> = ({ onSuccess }) => {\n  const { registerIntegration } = useSystemIntegration();\n  const [isLoading, setIsLoading] = useState(false);\n  \n  const [newIntegration, setNewIntegration] = useState<Partial<SystemIntegrationConfig>>({\n    id: uuidv4(),\n    name: '',\n    type: 'api',\n    enabled: true,\n    configuration: {},\n    metadata: {\n      description: '',\n      tags: []\n    }\n  });\n  \n  // Mettre ├á jour la valeur d'un champ de l'int├®gration\n  const updateIntegrationField = (\n    field: keyof SystemIntegrationConfig, \n    value: any\n  ) => {\n    setNewIntegration(prev => ({\n      ...prev,\n      [field]: value\n    }));\n  };\n  \n  // Mettre ├á jour la configuration\n  const updateConfiguration = (key: string, value: any) => {\n    setNewIntegration(prev => ({\n      ...prev,\n      configuration: {\n        ...prev.configuration,\n        [key]: value\n      }\n    }));\n  };\n\n  // Mettre ├á jour les m├®tadonn├®es\n  const updateMetadata = (key: string, value: any) => {\n    setNewIntegration(prev => ({\n      ...prev,\n      metadata: {\n        ...prev.metadata,\n        [key]: value\n      }\n    }));\n  };\n  \n  // G├®rer la cr├®ation d'une nouvelle int├®gration\n  const handleCreateIntegration = async (e: React.FormEvent) => {\n    e.preventDefault();\n    \n    if (!newIntegration.name || !newIntegration.type) {\n      alert('Veuillez remplir tous les champs obligatoires.');\n      return;\n    }\n    \n    try {\n      setIsLoading(true);\n      \n      const result = await registerIntegration(newIntegration as SystemIntegrationConfig);\n      \n      if (result.success) {\n        alert(`Int├®gration \"${newIntegration.name}\" cr├®├®e avec succ├¿s.`);\n        onSuccess();\n      }\n    } catch (error) {\n      alert(`Erreur lors de la cr├®ation : ${error instanceof Error ? error.message : String(error)}`);\n    } finally {\n      setIsLoading(false);\n    }\n  };\n  \n  // Obtenir les champs de configuration selon le type\n  const getConfigurationFields = () => {\n    switch (newIntegration.type) {\n      case 'api':\n        return (\n          <>\n            <div style={{display: 'flex', flexDirection: 'column', gap: '16px'}}>\n              <div style={{marginBottom: '8px'}}>\n                <label style={styles.label} htmlFor=\"baseUrl\">URL de base de l'API</label>\n                <input\n                  style={styles.input}\n                  id=\"baseUrl\"\n                  placeholder=\"https://api.example.com/v1\"\n                  value={(newIntegration.configuration as any)?.baseUrl || ''}\n                  onChange={(e) => updateConfiguration('baseUrl', e.target.value)}\n                />\n              </div>\n              <div style={{marginBottom: '8px'}}>\n                <label style={styles.label} htmlFor=\"authType\">Type d'authentification</label>\n                <select \n                  style={styles.select}\n                  id=\"authType\"\n                  value={(newIntegration.configuration as any)?.authType || 'none'}\n                  onChange={(e) => updateConfiguration('authType', e.target.value)}\n                >\n                  <option value=\"none\">Aucune</option>\n                  <option value=\"basic\">Basic Auth</option>\n                  <option value=\"bearer\">Bearer Token</option>\n                  <option value=\"apiKey\">API Key</option>\n                </select>\n              </div>\n              {(newIntegration.configuration as any)?.authType === 'apiKey' && (\n                <>\n                  <div style={{marginBottom: '8px'}}>\n                    <label style={styles.label} htmlFor=\"apiKeyName\">Nom de la cl├® API</label>\n                    <input\n                      style={styles.input}\n                      id=\"apiKeyName\"\n                      placeholder=\"X-API-KEY\"\n                      value={(newIntegration.configuration as any)?.apiKeyName || ''}\n                      onChange={(e) => updateConfiguration('apiKeyName', e.target.value)}\n                    />\n                  </div>\n                  <div style={{marginBottom: '8px'}}>\n                    <label style={styles.label} htmlFor=\"apiKeyValue\">Valeur de la cl├® API</label>\n                    <div style={{display: 'flex', alignItems: 'center', gap: '8px'}}>\n                      <input\n                        style={styles.input}\n                        id=\"apiKeyValue\"\n                        type=\"password\"\n                        placeholder=\"votre-cl├®-api\"\n                        value={(newIntegration.configuration as any)?.apiKeyValue || ''}\n                        onChange={(e) => updateConfiguration('apiKeyValue', e.target.value)}\n                      />\n                      {/* Lock icon would go here */}\n                    </div>\n                  </div>\n                </>\n              )}\n            </div>\n          </>\n        );\n      \n      case 'webhook':\n        return (\n          <>\n            <div style={{display: 'flex', flexDirection: 'column', gap: '16px'}}>\n              <div style={{marginBottom: '8px'}}>\n                <label style={styles.label} htmlFor=\"webhookUrl\">URL du webhook</label>\n                <input\n                  style={styles.input}\n                  id=\"webhookUrl\"\n                  placeholder=\"https://hooks.example.com/services/xxxxx\"\n                  value={(newIntegration.configuration as any)?.url || ''}\n                  onChange={(e) => updateConfiguration('url', e.target.value)}\n                />\n              </div>\n              <div style={{marginBottom: '8px'}}>\n                <label style={styles.label} htmlFor=\"webhookMethod\">M├®thode HTTP</label>\n                <select \n                  style={styles.select}\n                  id=\"webhookMethod\"\n                  value={(newIntegration.configuration as any)?.method || 'POST'}\n                  onChange={(e) => updateConfiguration('method', e.target.value)}\n                >\n                  <option value=\"GET\">GET</option>\n                  <option value=\"POST\">POST</option>\n                  <option value=\"PUT\">PUT</option>\n                  <option value=\"DELETE\">DELETE</option>\n                </select>\n              </div>\n            </div>\n          </>\n        );\n      \n      // Autres types...\n      \n      default:\n        return (\n          <div style={{marginBottom: '8px'}}>\n            <label style={styles.label} htmlFor=\"configJson\">Configuration JSON</label>\n            <textarea\n              style={{...styles.textarea, fontFamily: 'monospace'}}\n              id=\"configJson\"\n              placeholder=\"{}\"\n              rows={5}\n              value={JSON.stringify(newIntegration.configuration || {}, null, 2)}\n              onChange={(e) => {\n                try {\n                  const config = JSON.parse(e.target.value);\n                  updateIntegrationField('configuration', config);\n                } catch (error) {\n                  // Ignorer les erreurs d'analyse JSON pendant la saisie\n                }\n              }}\n            />\n          </div>\n        );\n    }\n  };\n  \n  return (\n    <form onSubmit={handleCreateIntegration}>\n      <div style={styles.card}>\n        <div style={styles.cardHeader}>\n          <h3 style={styles.cardTitle}>Cr├®er une nouvelle int├®gration</h3>\n          <p style={styles.cardDescription}>\n            Configurez une nouvelle int├®gration syst├¿me pour ├®tendre les capacit├®s de Lisa\n          </p>\n        </div>\n        \n        <div style={{...styles.cardContent, display: 'flex', flexDirection: 'column', gap: '16px'}}>\n          <div style={{marginBottom: '8px'}}>\n            <label style={styles.label} htmlFor=\"name\">Nom de l'int├®gration *</label>\n            <input\n              style={styles.input}\n              id=\"name\"\n              placeholder=\"Nom de l'int├®gration\"\n              value={newIntegration.name || ''}\n              onChange={(e) => updateIntegrationField('name', e.target.value)}\n              required\n            />\n          </div>\n          \n          <div style={{marginBottom: '8px'}}>\n            <label style={styles.label} htmlFor=\"type\">Type d'int├®gration *</label>\n            <select \n              style={styles.select}\n              id=\"type\"\n              value={newIntegration.type || 'api'} \n              onChange={(e) => updateIntegrationField('type', e.target.value as SystemIntegrationType)}\n            >\n              <option value=\"\" disabled>S├®lectionner un type d'int├®gration</option>\n              {SYSTEM_INTEGRATION_TYPES.map((type) => (\n                <option key={type} value={type}>\n                  {type.toUpperCase()}\n                </option>\n              ))}\n            </select>\n          </div>\n          \n          <div style={{display: 'flex', alignItems: 'center', gap: '8px'}}>\n            <input\n              type=\"checkbox\"\n              id=\"enabled\"\n              checked={newIntegration.enabled}\n              onChange={(e) => updateIntegrationField('enabled', e.target.checked)}\n              style={{width: 'auto'}}\n            />\n            <label style={{...styles.label, margin: 0}} htmlFor=\"enabled\">Activer cette int├®gration</label>\n          </div>\n          \n          <hr style={styles.separator} />\n          \n          <div style={{marginBottom: '8px'}}>\n            <h3 style={{fontSize: '1.125rem', fontWeight: '500', marginBottom: '8px'}}>Configuration</h3>\n            {getConfigurationFields()}\n          </div>\n          \n          <hr style={styles.separator} />\n          \n          <div style={{display: 'flex', flexDirection: 'column', gap: '16px'}}>\n            <h3 style={{fontSize: '1.125rem', fontWeight: '500', marginBottom: '8px'}}>M├®tadonn├®es</h3>\n            \n            <div style={{marginBottom: '8px'}}>\n              <label style={styles.label} htmlFor=\"description\">Description</label>\n              <textarea\n                style={styles.textarea}\n                id=\"description\"\n                placeholder=\"Description de cette int├®gration...\"\n                value={newIntegration.metadata?.description || ''}\n                onChange={(e) => updateMetadata('description', e.target.value)}\n              />\n            </div>\n            \n            <div style={{marginBottom: '8px'}}>\n              <label style={styles.label} htmlFor=\"tags\">Tags (s├®par├®s par des virgules)</label>\n              <input\n                style={styles.input}\n                id=\"tags\"\n                placeholder=\"api, weather, service...\"\n                value={(newIntegration.metadata?.tags || []).join(', ')}\n                onChange={(e) => updateMetadata('tags', e.target.value.split(',').map(tag => tag.trim()).filter(Boolean))}\n              />\n            </div>\n          </div>\n        </div>\n        \n        <div style={{...styles.cardFooter, display: 'flex', justifyContent: 'space-between'}}>\n          <button \n            style={styles.outlineButton} \n            type=\"button\" \n            onClick={() => onSuccess()}\n          >\n            Annuler\n          </button>\n          <button \n            style={{...styles.button, ...(isLoading ? styles.disabledButton : {})}} \n            type=\"submit\" \n            disabled={isLoading}\n          >\n            {isLoading ? 'Cr├®ation...' : 'Cr├®er l\\'int├®gration'}\n          </button>\n        </div>\n      </div>\n    </form>\n  );\n};\n\nexport default SystemIntegrationPanel;","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\TodoPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\TranslationPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":14,"column":40,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":14,"endColumn":43,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[561,564],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[561,564],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":15,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":15,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[618,621],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[618,621],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'getSupportedLanguages' and 'languages.length'. Either include them or remove the dependency array.","line":25,"column":6,"nodeType":"ArrayExpression","endLine":25,"endColumn":18,"suggestions":[{"desc":"Update the dependencies array to be: [getSupportedLanguages, isExpanded, languages.length]","fix":{"range":[867,879],"text":"[getSupportedLanguages, isExpanded, languages.length]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * TranslationPanel - Multi-language translation interface\n */\n\nimport { useState, useEffect } from 'react';\nimport { useTranslationAgent } from '../hooks/useTranslation';\nimport { Languages, ArrowRight } from 'lucide-react';\n\nexport const TranslationPanel = () => {\n  const { loading, error, translate, detectLanguage, getSupportedLanguages } = useTranslationAgent();\n  const [isExpanded, setIsExpanded] = useState(false);\n  const [text, setText] = useState('');\n  const [targetLang, setTargetLang] = useState('en');\n  const [result, setResult] = useState<any>(null);\n  const [languages, setLanguages] = useState<any[]>([]);\n\n  useEffect(() => {\n    if (isExpanded && languages.length === 0) {\n      getSupportedLanguages().then(res => {\n        if (res.success && res.output) {\n          setLanguages(res.output.languages || []);\n        }\n      });\n    }\n  }, [isExpanded]);\n\n  const handleTranslate = async () => {\n    const res = await translate(text, targetLang);\n    if (res.success) {\n      setResult(res.output);\n    }\n  };\n\n  const handleDetectLanguage = async () => {\n    const res = await detectLanguage(text);\n    if (res.success) {\n      setResult({ detectedLanguage: res.output });\n    }\n  };\n\n  return (\n    <div className=\"bg-white dark:bg-gray-800 rounded-lg shadow-lg p-4 max-w-md\">\n      <div className=\"flex items-center justify-between cursor-pointer\" onClick={() => setIsExpanded(!isExpanded)}>\n        <div className=\"flex items-center gap-2\">\n          <Languages className=\"w-5 h-5 text-indigo-500\" />\n          <h3 className=\"font-semibold\">­ƒîÉ Translation</h3>\n        </div>\n      </div>\n\n      {isExpanded && (\n        <div className=\"mt-4 space-y-3\">\n          {error && (\n            <div className=\"text-red-500 text-sm p-2 bg-red-50 rounded\">\n              {error}\n            </div>\n          )}\n\n          <div className=\"space-y-2\">\n            <textarea\n              placeholder=\"Enter text to translate...\"\n              value={text}\n              onChange={(e) => setText(e.target.value)}\n              rows={4}\n              className=\"w-full px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n            />\n            \n            <div className=\"flex items-center gap-2\">\n              <select\n                value={targetLang}\n                onChange={(e) => setTargetLang(e.target.value)}\n                className=\"flex-1 px-3 py-2 border rounded dark:bg-gray-700 dark:border-gray-600\"\n              >\n                {languages.map(lang => (\n                  <option key={lang.code} value={lang.code}>\n                    {lang.name}\n                  </option>\n                ))}\n              </select>\n              <ArrowRight className=\"w-4 h-4 text-gray-500\" />\n            </div>\n          </div>\n\n          <div className=\"flex gap-2\">\n            <button\n              onClick={handleTranslate}\n              disabled={loading || !text}\n              className=\"flex-1 px-3 py-2 bg-indigo-500 text-white rounded hover:bg-indigo-600 disabled:opacity-50\"\n            >\n              Translate\n            </button>\n            <button\n              onClick={handleDetectLanguage}\n              disabled={loading || !text}\n              className=\"flex-1 px-3 py-2 bg-blue-500 text-white rounded hover:bg-blue-600 disabled:opacity-50\"\n            >\n              Detect\n            </button>\n          </div>\n\n          {result && (\n            <div className=\"p-3 bg-gray-50 dark:bg-gray-700 rounded\">\n              {result.translatedText && (\n                <div>\n                  <div className=\"font-semibold text-sm mb-2\">Translation:</div>\n                  <div className=\"p-2 bg-white dark:bg-gray-800 rounded\">\n                    {result.translatedText}\n                  </div>\n                  <div className=\"text-xs text-gray-500 mt-2\">\n                    {result.sourceLang} ÔåÆ {result.targetLang} ({(result.confidence * 100).toFixed(0)}%)\n                  </div>\n                </div>\n              )}\n              {result.detectedLanguage && (\n                <div>\n                  <div className=\"font-semibold text-sm mb-1\">Detected Language:</div>\n                  <div className=\"text-lg\">\n                    {result.detectedLanguage.languageName} ({result.detectedLanguage.language})\n                  </div>\n                  <div className=\"text-xs text-gray-500 mt-1\">\n                    Confidence: {(result.detectedLanguage.confidence * 100).toFixed(0)}%\n                  </div>\n                </div>\n              )}\n            </div>\n          )}\n        </div>\n      )}\n    </div>\n  );\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\UserWorkflowPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'selectedWorkflow' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":64,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":64,"endColumn":26},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'editStep' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":65,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":18},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'setEditStep' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":65,"column":20,"nodeType":null,"messageId":"unusedVar","endLine":65,"endColumn":31},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'loadWorkflows'. Either include it or remove the dependency array.","line":83,"column":6,"nodeType":"ArrayExpression","endLine":83,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [loadWorkflows]","fix":{"range":[2526,2528],"text":"[loadWorkflows]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * UserWorkflowPanel.tsx\n * \n * Panneau de gestion des workflows d├®finis par l'utilisateur dans l'interface Lisa\n * Permet de cr├®er, ex├®cuter, et g├®rer des workflows personnalis├®s via des commandes en langage naturel\n */\n\nimport React, { useState, useEffect } from 'react';\nimport { useUserWorkflows } from '../hooks/useUserWorkflows';\nimport type { WorkflowDefinition } from '../agents/UserWorkflowAgent';\n\ninterface UserWorkflowPanelProps {\n  handleIntent: (intent: string, isInternal: boolean) => Promise<void>;\n}\n\ninterface TabsProps {\n  activeTab: string;\n  setActiveTab: (tab: string) => void;\n}\n\n// Composant d'onglets pour la navigation\nconst Tabs: React.FC<TabsProps> = ({ activeTab, setActiveTab }) => {\n  return (\n    <div style={styles.tabs}>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'workflows' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('workflows')}\n      >\n        Workflows\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'create' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('create')}\n      >\n        Cr├®er\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'nlCreate' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('nlCreate')}\n      >\n        NL Creator\n      </button>\n    </div>\n  );\n};\n\nexport const UserWorkflowPanel: React.FC<UserWorkflowPanelProps> = () => {\n  // ├ëtat local\n  const [activeTab, setActiveTab] = useState<string>('workflows');\n  const [expanded, setExpanded] = useState<Record<string, boolean>>({});\n  const [newWorkflowName, setNewWorkflowName] = useState<string>('');\n  const [newWorkflowDesc, setNewWorkflowDesc] = useState<string>('');\n  const [newWorkflowTrigger, setNewWorkflowTrigger] = useState<string>('');\n  const [nlPrompt, setNlPrompt] = useState<string>('');\n  const [selectedWorkflow, setSelectedWorkflow] = useState<string | null>(null);\n  const [editStep, setEditStep] = useState<{ index: number; content: string } | null>(null);\n  const [newStep, setNewStep] = useState<string>('');\n  \n  // Obtenir le hook de gestion des workflows utilisateur\n  const {\n    isLoading,\n    error,\n    workflows,\n    createWorkflow,\n    deleteWorkflow,\n    executeWorkflow,\n    getAllWorkflows,\n    parseNaturalLanguage\n  } = useUserWorkflows();\n  \n  // Charger les workflows au d├®marrage\n  useEffect(() => {\n    loadWorkflows();\n  }, []);\n  \n  // Fonction pour charger les workflows\n  const loadWorkflows = async () => {\n    await getAllWorkflows();\n  };\n  \n  // Fonction pour basculer l'affichage d├®taill├® d'un workflow\n  const toggleExpand = (workflowId: string) => {\n    setExpanded(prev => ({\n      ...prev,\n      [workflowId]: !prev[workflowId]\n    }));\n  };\n  \n  // Fonction pour ex├®cuter un workflow\n  const handleExecute = async (workflowId: string) => {\n    await executeWorkflow(workflowId);\n    await loadWorkflows(); // Recharger apr├¿s ex├®cution pour refl├®ter les changements d'├®tat\n  };\n  \n  // Fonction pour supprimer un workflow\n  const handleDelete = async (workflowId: string) => {\n    if (window.confirm('├ètes-vous s├╗r de vouloir supprimer ce workflow ?')) {\n      await deleteWorkflow(workflowId);\n      await loadWorkflows();\n    }\n  };\n  \n  // Fonction pour cr├®er un workflow via l'interface manuelle\n  const handleCreateWorkflow = async () => {\n    if (!newWorkflowName || !newWorkflowTrigger) {\n      alert('Le nom et le d├®clencheur sont obligatoires');\n      return;\n    }\n    \n    const workflowDef: WorkflowDefinition = {\n      name: newWorkflowName,\n      description: newWorkflowDesc || `Workflow cr├®├® le ${new Date().toLocaleDateString()}`,\n      trigger: newWorkflowTrigger,\n      steps: []\n    };\n    \n    try {\n      await createWorkflow(workflowDef);\n      \n      // R├®initialiser les champs\n      setNewWorkflowName('');\n      setNewWorkflowDesc('');\n      setNewWorkflowTrigger('');\n      \n      // Revenir ├á l'onglet des workflows\n      setActiveTab('workflows');\n      \n      // Recharger la liste\n      await loadWorkflows();\n    } catch (err) {\n      console.error('Erreur lors de la cr├®ation du workflow:', err);\n    }\n  };\n  \n  // Fonction pour cr├®er un workflow via langage naturel\n  const handleCreateFromNL = async () => {\n    if (!nlPrompt) {\n      alert('Veuillez entrer une instruction en langage naturel');\n      return;\n    }\n    \n    try {\n      const workflowDef = await parseNaturalLanguage(nlPrompt);\n      \n      if (workflowDef) {\n        await createWorkflow(workflowDef);\n        \n        // R├®initialiser les champs\n        setNlPrompt('');\n        \n        // Revenir ├á l'onglet des workflows\n        setActiveTab('workflows');\n        \n        // Recharger la liste\n        await loadWorkflows();\n      }\n    } catch (err) {\n      console.error('Erreur lors de la cr├®ation du workflow par langage naturel:', err);\n    }\n  };\n  \n  // Fonction pour ajouter une ├®tape ├á un workflow\n  const handleAddStep = (workflowId: string) => {\n    if (!newStep) return;\n    \n    setSelectedWorkflow(workflowId);\n    // Trouver le workflow et ajouter l'├®tape\n    // Note: Ceci est un exemple, il faudra impl├®menter la logique d'ajout d'├®tape\n    \n    setNewStep('');\n  };\n  \n  // Rendu du contenu selon l'onglet actif\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case 'workflows':\n        return (\n          <div style={styles.tabContent}>\n            <h4 style={styles.subHeader}>Vos Workflows Personnalis├®s</h4>\n            \n            {isLoading ? (\n              <p style={styles.loadingText}>Chargement des workflows...</p>\n            ) : workflows.length > 0 ? (\n              <ul style={styles.list}>\n                {workflows.map((workflow) => (\n                  <li key={workflow.id} style={styles.workflowItem}>\n                    <div style={styles.workflowHeader}>\n                      <div style={styles.workflowTitle}>\n                        {workflow.name}\n                      </div>\n                      <div style={styles.buttonGroup}>\n                        <button \n                          style={styles.actionButton}\n                          onClick={() => handleExecute(workflow.id)}\n                        >\n                          Ex├®cuter\n                        </button>\n                        <button \n                          style={{...styles.actionButton, backgroundColor: '#dc3545'}}\n                          onClick={() => handleDelete(workflow.id)}\n                        >\n                          Supprimer\n                        </button>\n                        <button \n                          style={{...styles.actionButton, backgroundColor: '#6c757d'}}\n                          onClick={() => toggleExpand(workflow.id)}\n                        >\n                          {expanded[workflow.id] ? 'R├®duire' : 'D├®tails'}\n                        </button>\n                      </div>\n                    </div>\n                    \n                    <div style={styles.workflowInfo}>\n                      <span style={styles.triggerLabel}>D├®clencheur: </span>\n                      <span style={styles.trigger}>\"{workflow.trigger}\"</span>\n                    </div>\n                    \n                    {expanded[workflow.id] && (\n                      <div style={styles.details}>\n                        <p style={styles.description}>{workflow.description}</p>\n                        \n                        <h5 style={styles.stepsHeader}>├ëtapes ({workflow.stepCount})</h5>\n                        \n                        <div style={styles.addStepContainer}>\n                          <input\n                            type=\"text\"\n                            value={newStep}\n                            onChange={(e) => setNewStep(e.target.value)}\n                            placeholder=\"Ajouter une ├®tape...\"\n                            style={styles.input}\n                          />\n                          <button\n                            style={styles.addButton}\n                            onClick={() => handleAddStep(workflow.id)}\n                          >\n                            +\n                          </button>\n                        </div>\n                      </div>\n                    )}\n                  </li>\n                ))}\n              </ul>\n            ) : (\n              <p style={styles.emptyText}>\n                Aucun workflow personnalis├®. Cr├®ez-en un nouveau dans l'onglet \"Cr├®er\".\n              </p>\n            )}\n            \n            {error && <p style={styles.errorText}>{error}</p>}\n          </div>\n        );\n        \n      case 'create':\n        return (\n          <div style={styles.tabContent}>\n            <h4 style={styles.subHeader}>Cr├®er un Workflow</h4>\n            \n            <div style={styles.formGroup}>\n              <label style={styles.label}>\n                Nom du workflow:\n                <input\n                  type=\"text\"\n                  value={newWorkflowName}\n                  onChange={(e) => setNewWorkflowName(e.target.value)}\n                  placeholder=\"Mon Workflow\"\n                  style={styles.input}\n                />\n              </label>\n            </div>\n            \n            <div style={styles.formGroup}>\n              <label style={styles.label}>\n                Description:\n                <textarea\n                  value={newWorkflowDesc}\n                  onChange={(e) => setNewWorkflowDesc(e.target.value)}\n                  placeholder=\"Description du workflow...\"\n                  style={styles.textarea}\n                />\n              </label>\n            </div>\n            \n            <div style={styles.formGroup}>\n              <label style={styles.label}>\n                Phrase de d├®clenchement:\n                <input\n                  type=\"text\"\n                  value={newWorkflowTrigger}\n                  onChange={(e) => setNewWorkflowTrigger(e.target.value)}\n                  placeholder=\"Ex: quand je dis bonjour\"\n                  style={styles.input}\n                />\n              </label>\n            </div>\n            \n            <button\n              style={styles.createButton}\n              onClick={handleCreateWorkflow}\n              disabled={isLoading}\n            >\n              {isLoading ? 'Cr├®ation...' : 'Cr├®er le Workflow'}\n            </button>\n          </div>\n        );\n        \n      case 'nlCreate':\n        return (\n          <div style={styles.tabContent}>\n            <h4 style={styles.subHeader}>Cr├®ation en Langage Naturel</h4>\n            <p style={styles.nlInfo}>\n              D├®crivez votre workflow en langage naturel et Lisa le cr├®era pour vous.\n            </p>\n            \n            <div style={styles.formGroup}>\n              <label style={styles.label}>\n                Description du workflow:\n                <textarea\n                  value={nlPrompt}\n                  onChange={(e) => setNlPrompt(e.target.value)}\n                  placeholder=\"Ex: Cr├®e un workflow qui envoie un message quand je dis bonjour et qui r├®pond avec la m├®t├®o du jour\"\n                  style={{...styles.textarea, minHeight: '150px'}}\n                />\n              </label>\n            </div>\n            \n            <button\n              style={styles.createButton}\n              onClick={handleCreateFromNL}\n              disabled={isLoading}\n            >\n              {isLoading ? 'Cr├®ation...' : 'G├®n├®rer le Workflow'}\n            </button>\n            \n            <p style={styles.nlTips}>\n              <strong>Astuces:</strong> Incluez des informations sur le d├®clencheur, les ├®tapes du workflow et le r├®sultat attendu.\n            </p>\n          </div>\n        );\n        \n      default:\n        return <div>Contenu non disponible</div>;\n    }\n  };\n  \n  return (\n    <div style={styles.container}>\n      <div style={styles.header}>\n        <h3 style={styles.title}>Workflows Personnalis├®s</h3>\n      </div>\n      \n      <Tabs activeTab={activeTab} setActiveTab={setActiveTab} />\n      \n      {renderTabContent()}\n    </div>\n  );\n};\n\n// Styles\nconst styles: Record<string, React.CSSProperties> = {\n  container: {\n    backgroundColor: 'rgba(30, 30, 30, 0.7)',\n    borderRadius: '10px',\n    padding: '15px',\n    height: '100%',\n    display: 'flex',\n    flexDirection: 'column',\n    overflow: 'hidden',\n  },\n  header: {\n    marginBottom: '15px',\n  },\n  title: {\n    margin: '0 0 10px 0',\n    color: '#f0f0f0',\n    fontSize: '1.2em',\n  },\n  tabs: {\n    display: 'flex',\n    borderBottom: '1px solid #444',\n    marginBottom: '15px',\n  },\n  tabButton: {\n    flex: 1,\n    backgroundColor: 'transparent',\n    border: 'none',\n    color: '#aaa',\n    padding: '8px 12px',\n    cursor: 'pointer',\n    fontSize: '0.9em',\n    transition: 'all 0.2s',\n  },\n  activeTab: {\n    color: '#fff',\n    borderBottom: '2px solid #007bff',\n  },\n  tabContent: {\n    padding: '5px 0',\n    overflowY: 'auto',\n    flexGrow: 1,\n  },\n  subHeader: {\n    marginTop: 0,\n    marginBottom: '15px',\n    color: '#aaa',\n    fontSize: '0.9em',\n  },\n  list: {\n    listStyle: 'none',\n    padding: 0,\n    margin: 0,\n  },\n  workflowItem: {\n    padding: '12px',\n    marginBottom: '12px',\n    backgroundColor: 'rgba(50, 50, 50, 0.5)',\n    borderRadius: '5px',\n    border: '1px solid #444',\n  },\n  workflowHeader: {\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: '8px',\n  },\n  workflowTitle: {\n    fontWeight: 'bold',\n    fontSize: '1em',\n    color: '#e0e0e0',\n  },\n  workflowInfo: {\n    marginBottom: '8px',\n    display: 'flex',\n    alignItems: 'center',\n  },\n  triggerLabel: {\n    color: '#888',\n    fontSize: '0.85em',\n    marginRight: '5px',\n  },\n  trigger: {\n    color: '#ffc107',\n    fontSize: '0.9em',\n    fontStyle: 'italic',\n  },\n  buttonGroup: {\n    display: 'flex',\n    gap: '5px',\n  },\n  actionButton: {\n    backgroundColor: '#28a745',\n    color: 'white',\n    border: 'none',\n    padding: '5px 10px',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontSize: '0.8em',\n  },\n  details: {\n    padding: '10px',\n    backgroundColor: 'rgba(40, 40, 40, 0.5)',\n    borderRadius: '5px',\n    marginTop: '10px',\n  },\n  description: {\n    color: '#ccc',\n    fontSize: '0.9em',\n    marginBottom: '15px',\n  },\n  stepsHeader: {\n    color: '#aaa',\n    fontSize: '0.85em',\n    marginBottom: '8px',\n    fontWeight: 'normal',\n  },\n  formGroup: {\n    marginBottom: '15px',\n  },\n  label: {\n    display: 'block',\n    marginBottom: '5px',\n    color: '#aaa',\n    fontSize: '0.85em',\n  },\n  input: {\n    width: '100%',\n    backgroundColor: '#333',\n    color: '#fff',\n    border: '1px solid #555',\n    padding: '8px',\n    borderRadius: '4px',\n    fontSize: '0.9em',\n    marginTop: '5px',\n  },\n  textarea: {\n    width: '100%',\n    backgroundColor: '#333',\n    color: '#fff',\n    border: '1px solid #555',\n    padding: '8px',\n    borderRadius: '4px',\n    fontSize: '0.9em',\n    minHeight: '100px',\n    resize: 'vertical',\n    marginTop: '5px',\n  },\n  createButton: {\n    backgroundColor: '#28a745',\n    color: 'white',\n    border: 'none',\n    padding: '10px 15px',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    width: '100%',\n    fontSize: '1em',\n  },\n  addStepContainer: {\n    display: 'flex',\n    gap: '5px',\n  },\n  addButton: {\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontSize: '1.1em',\n    width: '30px',\n    height: '30px',\n    display: 'flex',\n    alignItems: 'center',\n    justifyContent: 'center',\n  },\n  loadingText: {\n    color: '#888',\n    fontSize: '0.9em',\n    fontStyle: 'italic',\n  },\n  errorText: {\n    color: '#dc3545',\n    fontSize: '0.85em',\n    marginTop: '10px',\n  },\n  emptyText: {\n    color: '#888',\n    fontSize: '0.9em',\n    fontStyle: 'italic',\n  },\n  nlInfo: {\n    color: '#aaa',\n    fontSize: '0.85em',\n    marginBottom: '15px',\n  },\n  nlTips: {\n    color: '#888',\n    fontSize: '0.8em',\n    marginTop: '15px',\n    backgroundColor: 'rgba(0, 123, 255, 0.1)',\n    padding: '10px',\n    borderRadius: '4px',\n    border: '1px solid rgba(0, 123, 255, 0.2)',\n  },\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\VisionPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Grid' is defined but never used. Allowed unused vars must match /^_/u.","line":11,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":11,"endColumn":50},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'permissions' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":31,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":31,"endColumn":22},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'initWebcam'. Either include it or remove the dependency array.","line":79,"column":6,"nodeType":"ArrayExpression","endLine":79,"endColumn":26,"suggestions":[{"desc":"Update the dependencies array to be: [initWebcam, isExpanded, source]","fix":{"range":[3105,3125],"text":"[initWebcam, isExpanded, source]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3715,3718],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3715,3718],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":150,"column":19,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":150,"endColumn":22,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5165,5168],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5165,5168],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * VisionPanel - Panneau pour la vision par ordinateur\n * \n * Ce composant fournit une interface utilisateur pour utiliser les capacit├®s\n * de vision par ordinateur, permettant d'analyser des images et de d├®crire\n * ce qui est visible via la webcam ou des captures d'├®cran.\n */\n\nimport React, { useState, useRef, useEffect } from 'react';\nimport { Box, Typography, Button, Select, MenuItem, FormControl, \n  InputLabel, CircularProgress, Paper, Chip, Grid, Alert, Switch, FormControlLabel } from '@mui/material';\nimport VisibilityIcon from '@mui/icons-material/Visibility';\nimport PhotoCameraIcon from '@mui/icons-material/PhotoCamera';\nimport ScreenshotIcon from '@mui/icons-material/Screenshot';\nimport CategoryIcon from '@mui/icons-material/Category';\nimport FaceIcon from '@mui/icons-material/Face';\nimport ColorLensIcon from '@mui/icons-material/ColorLens';\nimport ExpandMoreIcon from '@mui/icons-material/ExpandMore';\nimport ExpandLessIcon from '@mui/icons-material/ExpandLess';\nimport { agentRegistry } from '../agents/registry';\nimport { useMediaPermissions } from '../hooks/useMediaPermissions';\nimport type { VisionAgent, VisionSource, VisionTask, VisionResult } from '../agents/VisionAgent';\nimport { useAppStore } from '../store/appStore';\n\ninterface VisionPanelProps {\n  expanded?: boolean;\n}\n\nexport const VisionPanel: React.FC<VisionPanelProps> = ({ expanded = false }) => {\n  // Media permissions hook\n  const { permissions, requestCamera } = useMediaPermissions();\n  // Global state\n  const { featureFlags, setState } = useAppStore((s) => ({\n    featureFlags: s.featureFlags,\n    setState: s.setState,\n  }));\n  // ├ëtats du composant\n  const [isExpanded, setIsExpanded] = useState(expanded);\n  const [source, setSource] = useState<VisionSource>('webcam');\n  const [task, setTask] = useState<VisionTask>('general_description');\n  const [isProcessing, setIsProcessing] = useState(false);\n  const [result, setResult] = useState<VisionResult | null>(null);\n  const [error, setError] = useState<string | null>(null);\n  const [imagePreview, setImagePreview] = useState<string | null>(null);\n  const [webcamActive, setWebcamActive] = useState(false);\n\n  const handleAdvancedVisionToggle = (event: React.ChangeEvent<HTMLInputElement>) => {\n    setState((state) => ({\n      featureFlags: {\n        ...state.featureFlags,\n        advancedVision: event.target.checked,\n      },\n    }));\n  };\n\n  // R├®f├®rence ├á l'├®l├®ment vid├®o pour la webcam\n  const videoRef = useRef<HTMLVideoElement | null>(null);\n  // R├®f├®rence au stream de la webcam\n  const streamRef = useRef<MediaStream | null>(null);\n\n  // R├®f├®rence ├á l'agent Vision\n  const visionAgent = agentRegistry.getAgent('VisionAgent') as VisionAgent;\n\n  // V├®rification de la disponibilit├® de l'agent\n  const agentAvailable = !!visionAgent;\n\n  // Initialiser ou arr├¬ter la webcam en fonction de l'├®tat du panneau et de la source\n  useEffect(() => {\n    if (isExpanded && source === 'webcam') {\n      initWebcam();\n    } else {\n      stopWebcam();\n    }\n\n    // Nettoyage au d├®montage du composant\n    return () => {\n      stopWebcam();\n    };\n  }, [isExpanded, source]);\n\n  // Fonction pour initialiser la webcam\n  const initWebcam = async () => {\n    try {\n      if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {\n        throw new Error('La fonctionnalit├® de webcam n\\'est pas disponible dans ce navigateur');\n      }\n\n      const stream = await requestCamera({ video: true });\n      if (!stream) {\n        throw new Error('Permission cam├®ra refus├®e');\n      }\n      \n      if (videoRef.current) {\n        videoRef.current.srcObject = stream;\n        streamRef.current = stream;\n        setWebcamActive(true);\n      }\n    } catch (err: any) {\n      console.error('Erreur d\\'acc├¿s ├á la webcam:', err);\n      setError(err.message || 'Impossible d\\'acc├®der ├á la webcam');\n      setWebcamActive(false);\n    }\n  };\n\n  // Fonction pour arr├¬ter la webcam\n  const stopWebcam = () => {\n    if (streamRef.current) {\n      streamRef.current.getTracks().forEach(track => track.stop());\n      streamRef.current = null;\n      setWebcamActive(false);\n    }\n  };\n\n  // Fonction pour analyser l'image\n  const analyzeImage = async () => {\n    if (!agentAvailable) {\n      setError('VisionAgent n\\'est pas disponible');\n      return;\n    }\n\n    setError(null);\n    setIsProcessing(true);\n    \n    try {\n      // Capture d'image depuis la webcam si n├®cessaire\n      if (source === 'webcam' && !webcamActive) {\n        await initWebcam();\n      }\n\n      const result = await visionAgent.execute({\n        intent: 'analyze_image',\n        parameters: {\n          source,\n          task,\n          options: {\n            confidenceThreshold: 0.7,\n            maxResults: 10\n          }\n        }\n      });\n\n      if (!result.success) {\n        throw new Error(result.error as string);\n      }\n\n      setResult(result.output as VisionResult);\n      \n      // Dans une impl├®mentation r├®elle, on pourrait capturer l'image et la d├®finir comme aper├ºu\n      setImagePreview(\"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVR42mP8z8BQDwAEhQGAhKmMIQAAAABJRU5ErkJggg==\");\n    } catch (err: any) {\n      setError(err.message || 'Une erreur est survenue lors de l\\'analyse de l\\'image');\n      setResult(null);\n    } finally {\n      setIsProcessing(false);\n    }\n  };\n\n  // Bascule de l'├®tat d'expansion du panneau\n  const toggleExpand = () => {\n    setIsExpanded(!isExpanded);\n  };\n\n  // D├®terminer l'ic├┤ne ├á afficher en fonction de la t├óche\n  const getTaskIcon = () => {\n    switch (task) {\n      case 'general_description':\n        return <VisibilityIcon />;\n      case 'object_detection':\n        return <CategoryIcon />;\n      case 'face_detection':\n        return <FaceIcon />;\n      case 'color_analysis':\n        return <ColorLensIcon />;\n      default:\n        return <VisibilityIcon />;\n    }\n  };\n\n  // Rendu du r├®sultat en fonction de la t├óche\n  const renderTaskResult = () => {\n    if (!result) return null;\n\n    switch (task) {\n      case 'general_description':\n        return (\n          <>\n            <Typography variant=\"body1\" sx={{ mb: 1 }}>\n              {result.description || \"Aucune description disponible.\"}\n            </Typography>\n            {result.sceneCategories && (\n              <Box sx={{ mt: 1 }}>\n                <Typography variant=\"subtitle2\">Cat├®gories d├®tect├®es:</Typography>\n                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1, mt: 1 }}>\n                  {result.sceneCategories.map((category, index) => (\n                    <Chip \n                      key={index}\n                      label={`${category.category} (${(category.confidence * 100).toFixed(0)}%)`}\n                      size=\"small\"\n                      color=\"primary\"\n                      variant=\"outlined\"\n                    />\n                  ))}\n                </Box>\n              </Box>\n            )}\n          </>\n        );\n\n      case 'object_detection':\n        return (\n          <>\n            {result.objects && result.objects.length > 0 ? (\n              <>\n                <Typography variant=\"subtitle2\" sx={{ mb: 1 }}>\n                  Objets d├®tect├®s: {result.objects.length}\n                </Typography>\n                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>\n                  {result.objects.map((obj, index) => (\n                    <Box key={index} sx={{ width: { xs: 'calc(50% - 4px)', sm: 'calc(33.33% - 4px)' } }}>\n                      <Paper \n                        elevation={2} \n                        sx={{ \n                          p: 1, \n                          textAlign: 'center',\n                          bgcolor: (theme) => theme.palette.grey[50]\n                        }}\n                      >\n                        <Typography variant=\"body2\" fontWeight=\"bold\">\n                          {obj.name}\n                        </Typography>\n                        <Typography variant=\"caption\" display=\"block\">\n                          {(obj.confidence * 100).toFixed(0)}% de confiance\n                        </Typography>\n                      </Paper>\n                    </Box>\n                  ))}\n                </Box>\n              </>\n            ) : (\n              <Typography variant=\"body1\">Aucun objet d├®tect├®.</Typography>\n            )}\n          </>\n        );\n\n      case 'face_detection':\n        return (\n          <>\n            <Typography variant=\"body1\" sx={{ mb: 1 }}>\n              {result.faceCount !== undefined ? \n                `${result.faceCount} ${result.faceCount > 1 ? 'visages d├®tect├®s' : 'visage d├®tect├®'}.` : \n                \"Aucun visage d├®tect├®.\"\n              }\n            </Typography>\n            {result.objects && result.objects.filter(obj => obj.name === 'face').map((face, index) => (\n              <Paper key={index} elevation={2} sx={{ p: 1, mb: 1 }}>\n                <Typography variant=\"subtitle2\">\n                  Visage {index + 1} ({(face.confidence * 100).toFixed(0)}%)\n                </Typography>\n                {face.attributes && (\n                  <Box sx={{ mt: 1 }}>\n                    {Object.entries(face.attributes).map(([key, value], i) => (\n                      <Typography key={i} variant=\"caption\" display=\"block\">\n                        {key}: {value}\n                      </Typography>\n                    ))}\n                  </Box>\n                )}\n              </Paper>\n            ))}\n          </>\n        );\n\n      case 'color_analysis':\n        return (\n          <>\n            {result.dominantColors && result.dominantColors.length > 0 ? (\n              <>\n                <Typography variant=\"subtitle2\" sx={{ mb: 1 }}>\n                  Couleurs dominantes:\n                </Typography>\n                <Box sx={{ display: 'flex', flexWrap: 'wrap', gap: 1 }}>\n                  {result.dominantColors.map((color, index) => (\n                    <Box key={index} sx={{ width: { xs: 'calc(25% - 4px)', sm: 'calc(16.66% - 4px)' } }}>\n                      <Box \n                        sx={{ \n                          height: 40, \n                          bgcolor: color.color,\n                          borderRadius: 1,\n                          boxShadow: 1,\n                          mb: 0.5\n                        }} \n                      />\n                      <Typography variant=\"caption\" display=\"block\" sx={{ textAlign: 'center' }}>\n                        {(color.percentage * 100).toFixed(0)}%\n                      </Typography>\n                    </Box>\n                  ))}\n                </Box>\n              </>\n            ) : (\n              <Typography variant=\"body1\">Aucune analyse de couleur disponible.</Typography>\n            )}\n          </>\n        );\n\n      default:\n        return <Typography>Aucun r├®sultat disponible.</Typography>;\n    }\n  };\n\n  return (\n    <Box sx={{ \n      border: '1px solid #e0e0e0',\n      borderRadius: 1,\n      mb: 2,\n      overflow: 'hidden',\n      transition: 'all 0.3s ease'\n    }}>\n      {/* En-t├¬te du panneau */}\n      <Box \n        sx={{ \n          p: 1, \n          bgcolor: 'primary.main', \n          color: 'white',\n          display: 'flex',\n          alignItems: 'center',\n          justifyContent: 'space-between',\n          cursor: 'pointer'\n        }}\n        onClick={toggleExpand}\n      >\n        <Box sx={{ display: 'flex', alignItems: 'center' }}>\n          <VisibilityIcon sx={{ mr: 1 }} />\n          <Typography variant=\"subtitle1\">Vision par Ordinateur</Typography>\n        </Box>\n        {isExpanded ? <ExpandLessIcon /> : <ExpandMoreIcon />}\n      </Box>\n      \n      {/* Contenu du panneau */}\n      {isExpanded && (\n        <Box sx={{ p: 2 }}>\n          {!agentAvailable ? (\n            <Alert severity=\"warning\">\n              L'agent de vision n'est pas disponible actuellement.\n            </Alert>\n          ) : (\n            <>\n              <Box sx={{ mb: 2 }}>\n                <FormControlLabel\n                  control={\n                    <Switch\n                      checked={featureFlags.advancedVision}\n                      onChange={handleAdvancedVisionToggle}\n                      name=\"advancedVision\"\n                      color=\"primary\"\n                    />\n                  }\n                  label=\"Activer la Vision Avanc├®e (YOLOv8-n)\"\n                />\n              </Box>\n\n              <Box sx={{ mb: 2 }}>\n                <FormControl fullWidth>\n                  <InputLabel>Source</InputLabel>\n                  <Select\n                    value={source}\n                    onChange={(e) => setSource(e.target.value as VisionSource)}\n                    label=\"Source\"\n                    startAdornment={source === 'webcam' ? <PhotoCameraIcon sx={{ mr: 1 }} /> : <ScreenshotIcon sx={{ mr: 1 }} />}\n                  >\n                    <MenuItem value=\"webcam\">Webcam</MenuItem>\n                    <MenuItem value=\"screenshot\">Capture d'├®cran</MenuItem>\n                    <MenuItem value=\"file\" disabled>Fichier image (Bient├┤t)</MenuItem>\n                    <MenuItem value=\"url\" disabled>URL d'image (Bient├┤t)</MenuItem>\n                  </Select>\n                </FormControl>\n              </Box>\n              \n              <Box sx={{ mb: 2 }}>\n                <FormControl fullWidth>\n                  <InputLabel>Type d'analyse</InputLabel>\n                  <Select\n                    value={task}\n                    onChange={(e) => setTask(e.target.value as VisionTask)}\n                    label=\"Type d'analyse\"\n                    startAdornment={getTaskIcon()}\n                  >\n                    <MenuItem value=\"general_description\">Description g├®n├®rale</MenuItem>\n                    <MenuItem value=\"object_detection\">D├®tection d'objets</MenuItem>\n                    <MenuItem value=\"face_detection\">D├®tection de visages</MenuItem>\n                    <MenuItem value=\"color_analysis\">Analyse des couleurs</MenuItem>\n                    <MenuItem value=\"landmark_detection\" disabled>D├®tection de points d'int├®r├¬t (Bient├┤t)</MenuItem>\n                  </Select>\n                </FormControl>\n              </Box>\n              \n              {/* Pr├®visualisation de la webcam */}\n              {source === 'webcam' && (\n                <Paper \n                  elevation={3} \n                  sx={{ \n                    mb: 2, \n                    p: 1, \n                    display: 'flex',\n                    justifyContent: 'center',\n                    height: webcamActive ? '200px' : 'auto'\n                  }}\n                >\n                  {webcamActive ? (\n                    <video\n                      ref={videoRef}\n                      autoPlay\n                      muted\n                      playsInline\n                      style={{\n                        maxWidth: '100%',\n                        maxHeight: '180px',\n                        objectFit: 'contain'\n                      }}\n                    />\n                  ) : (\n                    <Box sx={{ \n                      display: 'flex', \n                      flexDirection: 'column', \n                      alignItems: 'center',\n                      justifyContent: 'center',\n                      height: '100px' \n                    }}>\n                      <PhotoCameraIcon sx={{ fontSize: 40, color: 'text.secondary', mb: 1 }} />\n                      <Typography variant=\"body2\" color=\"text.secondary\">\n                        Webcam non active\n                      </Typography>\n                    </Box>\n                  )}\n                </Paper>\n              )}\n              \n              {/* Aper├ºu d'image (pour les captures d'├®cran ou les r├®sultats) */}\n              {source !== 'webcam' && imagePreview && (\n                <Paper \n                  elevation={3} \n                  sx={{ \n                    mb: 2, \n                    p: 1, \n                    display: 'flex',\n                    justifyContent: 'center',\n                    maxHeight: '200px',\n                    overflow: 'hidden'\n                  }}\n                >\n                  <img \n                    src={imagePreview} \n                    alt=\"Preview\" \n                    style={{ \n                      maxWidth: '100%',\n                      maxHeight: '180px',\n                      objectFit: 'contain'\n                    }} \n                  />\n                </Paper>\n              )}\n              \n              <Box sx={{ display: 'flex', mb: 2, gap: 1 }}>\n                <Button \n                  variant=\"contained\" \n                  onClick={analyzeImage}\n                  disabled={isProcessing}\n                  fullWidth\n                  startIcon={isProcessing ? \n                    <CircularProgress size={20} color=\"inherit\" /> : \n                    getTaskIcon()\n                  }\n                >\n                  {isProcessing ? 'Analyse en cours...' : 'Analyser l\\'image'}\n                </Button>\n              </Box>\n              \n              {error && (\n                <Alert severity=\"error\" sx={{ mb: 2 }}>\n                  {error}\n                </Alert>\n              )}\n              \n              {/* R├®sultats */}\n              {result && (\n                <Paper elevation={3} sx={{ p: 2, mb: 2 }}>\n                  <Typography variant=\"subtitle1\" gutterBottom>\n                    R├®sultats:\n                  </Typography>\n                  {renderTaskResult()}\n                  \n                  {result.processingTimeMs !== undefined && (\n                    <Typography variant=\"caption\" display=\"block\" sx={{ mt: 2, color: 'text.secondary' }}>\n                      Temps de traitement: {result.processingTimeMs} ms\n                    </Typography>\n                  )}\n                </Paper>\n              )}\n              \n              <Typography variant=\"body2\" color=\"text.secondary\">\n                La vision par ordinateur permet ├á Lisa d'analyser et de comprendre le contenu visuel.\n                Utilisez diff├®rentes analyses pour obtenir des informations sur ce qui est visible.\n              </Typography>\n            </>\n          )}\n        </Box>\n      )}\n    </Box>\n  );\n};\n\nexport default VisionPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\WeatherBanner.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\WorkflowManagerPanel.tsx","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'Workflow' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":23}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useState } from 'react';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport { useWorkflowEngine } from '../hooks/useWorkflowEngine';\nimport type { Workflow } from '../utils/WorkflowEngine';\n\ninterface WorkflowManagerPanelProps {\n  handleIntent: (intent: string, isInternal: boolean) => Promise<void>;\n}\n\ninterface TabsProps {\n  activeTab: string;\n  setActiveTab: (tab: string) => void;\n}\n\nconst Tabs: React.FC<TabsProps> = ({ activeTab, setActiveTab }) => {\n  return (\n    <div style={styles.tabs}>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'active' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('active')}\n      >\n        Active\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'templates' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('templates')}\n      >\n        Templates\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'history' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('history')}\n      >\n        History\n      </button>\n      <button \n        style={{\n          ...styles.tabButton,\n          ...(activeTab === 'create' ? styles.activeTab : {})\n        }}\n        onClick={() => setActiveTab('create')}\n      >\n        Create\n      </button>\n    </div>\n  );\n};\n\nexport const WorkflowManagerPanel: React.FC<WorkflowManagerPanelProps> = ({ handleIntent }) => {\n  // State hooks\n  const [activeTab, setActiveTab] = useState<string>('active');\n  const [newWorkflowName, setNewWorkflowName] = useState<string>('');\n  const [newWorkflowDesc, setNewWorkflowDesc] = useState<string>('');\n  const [nlPrompt, setNlPrompt] = useState<string>('');\n  const [showDetails, setShowDetails] = useState<Record<string, boolean>>({});\n  \n  // Get data from workflow engine\n  const {\n    activeWorkflows,\n    templates,\n    history,\n    isLoading,\n    createWorkflow,\n    executeWorkflow,\n    pauseWorkflow,\n    resumeWorkflow,\n    cancelWorkflow,\n    saveAsTemplate,\n    createWorkflowFromNL\n  } = useWorkflowEngine();\n  \n  // Get legacy data from store (for backward compatibility)\n  const { legacyTemplates, checkpoints } = useVisionAudioStore(state => ({\n    legacyTemplates: state.templates || [],\n    checkpoints: state.checkpoints || [],\n  }));\n  \n  const handleLoadTemplate = (templateName: string) => {\n    handleIntent(`load template ${templateName}`, true);\n  };\n\n  const handleResumeCheckpoint = (checkpointId: string) => {\n    handleIntent(`resume checkpoint ${checkpointId}`, true);\n  };\n  \n  // Create a new workflow from natural language\n  const handleCreateFromNL = async () => {\n    if (!nlPrompt) return;\n    \n    try {\n      await createWorkflowFromNL(\n        nlPrompt,\n        newWorkflowName || `Workflow ${new Date().toLocaleTimeString()}`,\n        newWorkflowDesc || 'Created from natural language'\n      );\n      \n      setNlPrompt('');\n      setNewWorkflowName('');\n      setNewWorkflowDesc('');\n      setActiveTab('active');\n    } catch (error) {\n      console.error('Failed to create workflow:', error);\n    }\n  };\n  \n  // Execute workflow\n  const handleExecuteWorkflow = async (workflowId: string) => {\n    try {\n      await executeWorkflow(workflowId);\n    } catch (error) {\n      console.error('Failed to execute workflow:', error);\n    }\n  };\n  \n  // Toggle showing details for a workflow\n  const toggleDetails = (id: string) => {\n    setShowDetails(prev => ({\n      ...prev,\n      [id]: !prev[id]\n    }));\n  };\n  \n  // Render appropriate content based on active tab\n  const renderTabContent = () => {\n    switch (activeTab) {\n      case 'active':\n        return (\n          <div style={styles.tabContent}>\n            <h4 style={styles.subHeader}>Active Workflows</h4>\n            {activeWorkflows.length > 0 ? (\n              <ul style={styles.list}>\n                {activeWorkflows.map(workflow => (\n                  <li key={workflow.id} style={styles.workflowItem}>\n                    <div style={styles.workflowHeader}>\n                      <span style={styles.workflowTitle}>{workflow.name}</span>\n                      <div style={styles.buttonGroup}>\n                        {workflow.status === 'pending' && (\n                          <button \n                            onClick={() => handleExecuteWorkflow(workflow.id)}\n                            style={styles.button}\n                            disabled={isLoading[workflow.id]}\n                          >\n                            {isLoading[workflow.id] ? 'Starting...' : 'Start'}\n                          </button>\n                        )}\n                        {workflow.status === 'in_progress' && (\n                          <button \n                            onClick={() => pauseWorkflow(workflow.id)}\n                            style={styles.button}\n                          >\n                            Pause\n                          </button>\n                        )}\n                        {workflow.status === 'paused' && (\n                          <button \n                            onClick={() => resumeWorkflow(workflow.id)}\n                            style={styles.button}\n                          >\n                            Resume\n                          </button>\n                        )}\n                        <button \n                          onClick={() => cancelWorkflow(workflow.id)}\n                          style={{...styles.button, backgroundColor: '#dc3545'}}\n                        >\n                          Cancel\n                        </button>\n                        <button \n                          onClick={() => toggleDetails(workflow.id)}\n                          style={{...styles.button, backgroundColor: '#6c757d'}}\n                        >\n                          {showDetails[workflow.id] ? 'Hide' : 'Details'}\n                        </button>\n                      </div>\n                    </div>\n                    \n                    {/* Progress bar */}\n                    <div style={styles.progressContainer}>\n                      <div \n                        style={{\n                          ...styles.progressBar,\n                          width: `${workflow.progress}%`\n                        }}\n                      />\n                      <span style={styles.progressText}>{workflow.progress}%</span>\n                    </div>\n                    \n                    {/* Details section */}\n                    {showDetails[workflow.id] && (\n                      <div style={styles.details}>\n                        <p style={styles.detailText}>\n                          <strong>Status:</strong> {workflow.status}\n                        </p>\n                        <p style={styles.detailText}>\n                          <strong>Steps:</strong> {workflow.steps.length}\n                        </p>\n                        <div style={styles.stepsList}>\n                          {workflow.steps.map(step => (\n                            <div \n                              key={step.id} \n                              style={{\n                                ...styles.step,\n                                ...getStepStatusStyle(step.status)\n                              }}\n                            >\n                              <span style={styles.stepText}>\n                                {step.description}\n                              </span>\n                              <span style={styles.stepStatus}>\n                                {step.status}\n                              </span>\n                            </div>\n                          ))}\n                        </div>\n                        <div style={styles.buttonGroup}>\n                          <button\n                            onClick={() => {\n                              saveAsTemplate(\n                                workflow.id,\n                                `${workflow.name} Template`,\n                                workflow.description,\n                                ['auto-saved']\n                              );\n                            }}\n                            style={styles.button}\n                          >\n                            Save as Template\n                          </button>\n                        </div>\n                      </div>\n                    )}\n                  </li>\n                ))}\n              </ul>\n            ) : (\n              <p style={styles.emptyText}>No active workflows.</p>\n            )}\n          </div>\n        );\n        \n      case 'templates':\n        return (\n          <div style={styles.tabContent}>\n            <h4 style={styles.subHeader}>Workflow Templates</h4>\n            \n            {/* Advanced templates */}\n            {templates.length > 0 ? (\n              <ul style={styles.list}>\n                {templates.map(template => (\n                  <li key={template.id} style={styles.workflowItem}>\n                    <div style={styles.workflowHeader}>\n                      <span style={styles.workflowTitle}>{template.name}</span>\n                      <div style={styles.buttonGroup}>\n                        <button \n                          onClick={() => {\n                            createWorkflow({\n                              name: template.name,\n                              description: template.description,\n                              templateId: template.id\n                            });\n                            setActiveTab('active');\n                          }}\n                          style={styles.button}\n                        >\n                          Load\n                        </button>\n                        <button \n                          onClick={() => toggleDetails(template.id)}\n                          style={{...styles.button, backgroundColor: '#6c757d'}}\n                        >\n                          {showDetails[template.id] ? 'Hide' : 'Details'}\n                        </button>\n                      </div>\n                    </div>\n                    \n                    {/* Template details */}\n                    {showDetails[template.id] && (\n                      <div style={styles.details}>\n                        <p style={styles.detailText}>\n                          <strong>Description:</strong> {template.description}\n                        </p>\n                        <p style={styles.detailText}>\n                          <strong>Steps:</strong> {template.steps.length}\n                        </p>\n                        <div style={styles.tagsList}>\n                          {template.tags.map(tag => (\n                            <span key={tag} style={styles.tag}>{tag}</span>\n                          ))}\n                        </div>\n                      </div>\n                    )}\n                  </li>\n                ))}\n              </ul>\n            ) : null}\n            \n            {/* Legacy templates */}\n            {legacyTemplates.length > 0 ? (\n              <div>\n                <h5 style={styles.subSubHeader}>Legacy Templates</h5>\n                <ul style={styles.list}>\n                  {legacyTemplates.map(template => (\n                    <li key={template} style={styles.listItem}>\n                      <span>{template}</span>\n                      <button onClick={() => handleLoadTemplate(template)} style={styles.button}>Load</button>\n                    </li>\n                  ))}\n                </ul>\n              </div>\n            ) : null}\n            \n            {templates.length === 0 && legacyTemplates.length === 0 && (\n              <p style={styles.emptyText}>No saved templates.</p>\n            )}\n            \n            {/* Legacy checkpoints */}\n            <h4 style={styles.subHeader}>Checkpoints</h4>\n            {checkpoints.length > 0 ? (\n              <ul style={styles.list}>\n                {checkpoints.map(checkpoint => (\n                  <li key={checkpoint} style={styles.listItem}>\n                    <span style={styles.checkpointId}>{checkpoint}</span>\n                    <button onClick={() => handleResumeCheckpoint(checkpoint)} style={styles.button}>Resume</button>\n                  </li>\n                ))}\n              </ul>\n            ) : (\n              <p style={styles.emptyText}>No available checkpoints.</p>\n            )}\n          </div>\n        );\n        \n      case 'history':\n        return (\n          <div style={styles.tabContent}>\n            <h4 style={styles.subHeader}>Workflow History</h4>\n            {history.length > 0 ? (\n              <ul style={styles.list}>\n                {history.map(item => (\n                  <li key={item.id} style={styles.workflowItem}>\n                    <div style={styles.workflowHeader}>\n                      <span style={styles.workflowTitle}>\n                        {item.workflow.name}\n                      </span>\n                      <span style={{\n                        ...styles.outcome,\n                        color: item.outcome === 'completed' ? '#28a745' : \n                              item.outcome === 'failed' ? '#dc3545' : '#ffc107'\n                      }}>\n                        {item.outcome}\n                      </span>\n                    </div>\n                    <p style={styles.timestamp}>\n                      {new Date(item.startTime).toLocaleString()}\n                      {item.duration && ` (${(item.duration / 1000).toFixed(1)}s)`}\n                    </p>\n                    <p style={styles.summary}>{item.summary}</p>\n                    <button \n                      onClick={() => toggleDetails(item.id)}\n                      style={{...styles.button, backgroundColor: '#6c757d'}}\n                    >\n                      {showDetails[item.id] ? 'Hide' : 'Details'}\n                    </button>\n                    \n                    {showDetails[item.id] && (\n                      <div style={styles.details}>\n                        <p style={styles.detailText}>\n                          <strong>Steps:</strong> {item.workflow.steps.length}\n                        </p>\n                        <div style={styles.stepsList}>\n                          {item.workflow.steps.map(step => (\n                            <div \n                              key={step.id} \n                              style={{\n                                ...styles.step,\n                                ...getStepStatusStyle(step.status)\n                              }}\n                            >\n                              <span style={styles.stepText}>\n                                {step.description}\n                              </span>\n                              <span style={styles.stepStatus}>\n                                {step.status}\n                                {step.duration && ` (${(step.duration / 1000).toFixed(1)}s)`}\n                              </span>\n                            </div>\n                          ))}\n                        </div>\n                        <div style={styles.buttonGroup}>\n                          <button\n                            onClick={() => {\n                              createWorkflow({\n                                name: `${item.workflow.name} (Copy)`,\n                                description: item.workflow.description,\n                                steps: item.workflow.steps.map(({ id, description, agent, command, args, dependencies }) => ({\n                                  id, description, agent, command, args, dependencies\n                                }))\n                              });\n                              setActiveTab('active');\n                            }}\n                            style={styles.button}\n                          >\n                            Clone Workflow\n                          </button>\n                        </div>\n                      </div>\n                    )}\n                  </li>\n                ))}\n              </ul>\n            ) : (\n              <p style={styles.emptyText}>No workflow history.</p>\n            )}\n          </div>\n        );\n        \n      case 'create':\n        return (\n          <div style={styles.tabContent}>\n            <h4 style={styles.subHeader}>Create New Workflow</h4>\n            \n            <div style={styles.formGroup}>\n              <label style={styles.label}>Natural Language Request:</label>\n              <textarea\n                value={nlPrompt}\n                onChange={(e) => setNlPrompt(e.target.value)}\n                style={styles.textarea}\n                placeholder=\"Ask Lisa to create a workflow... e.g., 'Find Italian restaurants, book a table for two, and add to calendar'\"\n              />\n            </div>\n            \n            <div style={styles.formGroup}>\n              <label style={styles.label}>Workflow Name:</label>\n              <input\n                type=\"text\"\n                value={newWorkflowName}\n                onChange={(e) => setNewWorkflowName(e.target.value)}\n                style={styles.input}\n                placeholder=\"My Workflow\"\n              />\n            </div>\n            \n            <div style={styles.formGroup}>\n              <label style={styles.label}>Description:</label>\n              <input\n                type=\"text\"\n                value={newWorkflowDesc}\n                onChange={(e) => setNewWorkflowDesc(e.target.value)}\n                style={styles.input}\n                placeholder=\"Description of what this workflow does\"\n              />\n            </div>\n            \n            <button \n              onClick={handleCreateFromNL}\n              style={styles.createButton}\n              disabled={!nlPrompt}\n            >\n              {isLoading[nlPrompt] ? 'Creating...' : 'Create Workflow'}\n            </button>\n          </div>\n        );\n        \n      default:\n        return null;\n    }\n  };\n  \n  // Helper function to get style based on step status\n  const getStepStatusStyle = (status: string): React.CSSProperties => {\n    switch (status) {\n      case 'completed':\n        return { borderLeft: '3px solid #28a745' };\n      case 'failed':\n        return { borderLeft: '3px solid #dc3545' };\n      case 'in_progress':\n        return { borderLeft: '3px solid #007bff' };\n      case 'waiting':\n        return { borderLeft: '3px solid #ffc107' };\n      default:\n        return { borderLeft: '3px solid #6c757d' };\n    }\n  };\n\n  return (\n    <div style={styles.panel}>\n      <h3 style={styles.header}>Workflow Manager</h3>\n      <Tabs activeTab={activeTab} setActiveTab={setActiveTab} />\n      {renderTabContent()}\n    </div>\n  );\n};\n\nconst styles: { [key: string]: React.CSSProperties } = {\n  panel: {\n    position: 'absolute',\n    top: '10px',\n    right: '10px',\n    width: '400px',\n    backgroundColor: 'rgba(30, 30, 30, 0.9)',\n    borderRadius: '8px',\n    padding: '15px',\n    color: '#fff',\n    fontFamily: 'sans-serif',\n    border: '1px solid #444',\n    zIndex: 1000,\n    maxHeight: '90vh',\n    overflowY: 'auto',\n  },\n  header: {\n    marginTop: 0,\n    marginBottom: '15px',\n    borderBottom: '1px solid #444',\n    paddingBottom: '10px',\n  },\n  section: {\n    marginBottom: '15px',\n  },\n  tabs: {\n    display: 'flex',\n    borderBottom: '1px solid #444',\n    marginBottom: '15px',\n  },\n  tabButton: {\n    flex: 1,\n    backgroundColor: 'transparent',\n    border: 'none',\n    color: '#aaa',\n    padding: '8px 12px',\n    cursor: 'pointer',\n    fontSize: '0.9em',\n    transition: 'all 0.2s',\n  },\n  activeTab: {\n    color: '#fff',\n    borderBottom: '2px solid #007bff',\n  },\n  tabContent: {\n    padding: '5px 0',\n  },\n  subHeader: {\n    marginTop: 0,\n    marginBottom: '10px',\n    color: '#aaa',\n    fontSize: '0.9em',\n  },\n  subSubHeader: {\n    marginTop: '15px',\n    marginBottom: '5px',\n    color: '#888',\n    fontSize: '0.85em',\n  },\n  list: {\n    listStyle: 'none',\n    padding: 0,\n    margin: 0,\n  },\n  listItem: {\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    padding: '8px 0',\n    borderBottom: '1px solid #333',\n  },\n  workflowItem: {\n    padding: '10px',\n    marginBottom: '10px',\n    backgroundColor: 'rgba(50, 50, 50, 0.5)',\n    borderRadius: '5px',\n    border: '1px solid #444',\n  },\n  workflowHeader: {\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n    marginBottom: '8px',\n  },\n  workflowTitle: {\n    fontWeight: 'bold',\n    fontSize: '1em',\n  },\n  buttonGroup: {\n    display: 'flex',\n    gap: '5px',\n    flexWrap: 'wrap',\n    justifyContent: 'flex-end',\n  },\n  progressContainer: {\n    height: '6px',\n    backgroundColor: '#333',\n    borderRadius: '3px',\n    marginBottom: '10px',\n    position: 'relative',\n  },\n  progressBar: {\n    height: '100%',\n    backgroundColor: '#007bff',\n    borderRadius: '3px',\n    transition: 'width 0.3s',\n  },\n  progressText: {\n    position: 'absolute',\n    right: '0',\n    top: '-15px',\n    fontSize: '0.7em',\n    color: '#aaa',\n  },\n  details: {\n    padding: '10px',\n    backgroundColor: 'rgba(40, 40, 40, 0.5)',\n    borderRadius: '5px',\n    marginTop: '10px',\n  },\n  detailText: {\n    margin: '5px 0',\n    fontSize: '0.85em',\n  },\n  stepsList: {\n    marginTop: '10px',\n    maxHeight: '150px',\n    overflowY: 'auto',\n  },\n  step: {\n    padding: '5px 8px',\n    marginBottom: '5px',\n    backgroundColor: 'rgba(60, 60, 60, 0.5)',\n    borderRadius: '3px',\n    display: 'flex',\n    justifyContent: 'space-between',\n    alignItems: 'center',\n  },\n  stepText: {\n    fontSize: '0.8em',\n    flexGrow: 1,\n  },\n  stepStatus: {\n    fontSize: '0.7em',\n    padding: '2px 5px',\n    borderRadius: '3px',\n    backgroundColor: '#444',\n    marginLeft: '5px',\n  },\n  tagsList: {\n    display: 'flex',\n    flexWrap: 'wrap',\n    gap: '5px',\n    marginTop: '8px',\n  },\n  tag: {\n    fontSize: '0.7em',\n    padding: '2px 6px',\n    backgroundColor: '#333',\n    borderRadius: '10px',\n    color: '#ddd',\n  },\n  timestamp: {\n    fontSize: '0.75em',\n    color: '#888',\n    marginBottom: '5px',\n  },\n  summary: {\n    fontSize: '0.85em',\n    marginBottom: '10px',\n  },\n  outcome: {\n    fontSize: '0.75em',\n    fontWeight: 'bold',\n  },\n  formGroup: {\n    marginBottom: '15px',\n  },\n  label: {\n    display: 'block',\n    marginBottom: '5px',\n    color: '#aaa',\n    fontSize: '0.85em',\n  },\n  input: {\n    width: '100%',\n    backgroundColor: '#333',\n    color: '#fff',\n    border: '1px solid #555',\n    padding: '8px',\n    borderRadius: '4px',\n    fontSize: '0.9em',\n  },\n  textarea: {\n    width: '100%',\n    backgroundColor: '#333',\n    color: '#fff',\n    border: '1px solid #555',\n    padding: '8px',\n    borderRadius: '4px',\n    fontSize: '0.9em',\n    minHeight: '100px',\n    resize: 'vertical',\n  },\n  createButton: {\n    backgroundColor: '#28a745',\n    color: 'white',\n    border: 'none',\n    padding: '10px 15px',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    width: '100%',\n    fontSize: '1em',\n  },\n  button: {\n    backgroundColor: '#007bff',\n    color: 'white',\n    border: 'none',\n    padding: '5px 10px',\n    borderRadius: '4px',\n    cursor: 'pointer',\n    fontSize: '0.8em',\n  },\n  emptyText: {\n    color: '#888',\n    fontSize: '0.9em',\n  },\n  checkpointId: {\n    fontSize: '0.8em',\n    fontFamily: 'monospace',\n    color: '#ccc',\n    whiteSpace: 'nowrap',\n    overflow: 'hidden',\n    textOverflow: 'ellipsis',\n    maxWidth: '150px',\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\__tests__\\CodeInterpreterPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ChatHeader.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ChatInput.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ChatLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ChatMain.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ChatMessage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ChatMessages.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'messages' logical expression could make the dependencies of useEffect Hook (at line 22) change on every render. To fix this, wrap the initialization of 'messages' in its own useMemo() Hook.","line":17,"column":9,"nodeType":"VariableDeclarator","endLine":17,"endColumn":48}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Chat Messages Component\n * Zone d'affichage des messages avec scroll automatique\n */\n\nimport { useRef, useEffect } from 'react';\nimport { useChatHistoryStore } from '../../store/chatHistoryStore';\nimport { ChatMessage } from './ChatMessage';\nimport { TypingIndicator } from './TypingIndicator';\nimport { MessageSquare } from 'lucide-react';\n\nexport const ChatMessages = () => {\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n  const { getCurrentConversation, isTyping, currentConversationId } = useChatHistoryStore();\n  \n  const conversation = getCurrentConversation();\n  const messages = conversation?.messages || [];\n\n  // Auto-scroll to bottom\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages, isTyping]);\n\n  if (!currentConversationId) {\n    return (\n      <div className=\"flex-1 flex items-center justify-center p-6\">\n        <div className=\"text-center max-w-md\">\n          <div className=\"w-20 h-20 mx-auto mb-6 rounded-full bg-gradient-to-r from-blue-500 to-purple-500 flex items-center justify-center text-white text-3xl\">\n            ­ƒñû\n          </div>\n          <h2 className=\"text-2xl font-bold text-white mb-3\">\n            Bienvenue dans Lisa\n          </h2>\n          <p className=\"text-gray-400 mb-6\">\n            Votre assistant IA personnel. Commencez une conversation pour d├®marrer.\n          </p>\n          <button\n            onClick={() => useChatHistoryStore.getState().createConversation()}\n            className=\"px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white rounded-lg transition-colors font-medium inline-flex items-center gap-2\"\n          >\n            <MessageSquare size={20} />\n            Nouvelle conversation\n          </button>\n        </div>\n      </div>\n    );\n  }\n\n  return (\n    <div className=\"flex-1 overflow-y-auto p-6 bg-[#0a0a0a]\">\n      <div className=\"max-w-[800px] mx-auto space-y-6\">\n        {messages.length === 0 ? (\n          <div className=\"text-center py-12\">\n            <div className=\"w-16 h-16 mx-auto mb-4 rounded-full bg-[#2a2a2a] flex items-center justify-center text-2xl\">\n              ­ƒÆ¼\n            </div>\n            <p className=\"text-gray-400\">\n              Commencez en envoyant un message ci-dessous\n            </p>\n          </div>\n        ) : (\n          messages.map((message) => (\n            <ChatMessage key={message.id} message={message} />\n          ))\n        )}\n        \n        {isTyping && <TypingIndicator />}\n        \n        <div ref={messagesEndRef} />\n      </div>\n    </div>\n  );\n};\n\nexport default ChatMessages;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ChatSidebar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\CodeBlock.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\ImageUpload.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\InfoPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\MessageRenderer.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\TypingIndicator.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\chat\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\common\\OptimizedImage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\common\\imageUtils.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\layout\\ModernLayout.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\tests\\CodeInterpreterPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\tests\\ProactiveSuggestionsPanel.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Avatar.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Dialog.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Input.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernBadge.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernButton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernCard.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernDropdown.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernForm.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernModal.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernTable.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\ModernTabs.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Select.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Skeleton.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Switch.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Textarea.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Toast.tsx","messages":[{"ruleId":"react-refresh/only-export-components","severity":1,"message":"Fast refresh only works when a file only exports components. Use a new file to share constants or functions between components.","line":25,"column":14,"nodeType":"Identifier","messageId":"namedExport","endLine":25,"endColumn":22},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'removeToast'. Either include it or remove the dependency array.","line":40,"column":6,"nodeType":"ArrayExpression","endLine":40,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [removeToast]","fix":{"range":[1151,1153],"text":"[removeToast]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Toast Component  \n * Notifications toast\n */\n\nimport { createContext, useContext, useState, useCallback, type ReactNode } from 'react';\nimport { X, CheckCircle, AlertCircle, Info, AlertTriangle } from 'lucide-react';\nimport { cn } from '../../utils/cn';\n\ninterface Toast {\n  id: string;\n  type: 'success' | 'error' | 'info' | 'warning';\n  message: string;\n  duration?: number;\n}\n\ninterface ToastContextType {\n  toasts: Toast[];\n  addToast: (toast: Omit<Toast, 'id'>) => void;\n  removeToast: (id: string) => void;\n}\n\nconst ToastContext = createContext<ToastContextType | null>(null);\n\nexport const useToast = () => {\n  const context = useContext(ToastContext);\n  if (!context) throw new Error('useToast must be used within ToastProvider');\n  return context;\n};\n\nexport const ToastProvider = ({ children }: { children: ReactNode }) => {\n  const [toasts, setToasts] = useState<Toast[]>([]);\n\n  const addToast = useCallback((toast: Omit<Toast, 'id'>) => {\n    const id = crypto.randomUUID();\n    setToasts(prev => [...prev, { ...toast, id }]);\n    \n    const duration = toast.duration || 3000;\n    setTimeout(() => removeToast(id), duration);\n  }, []);\n\n  const removeToast = useCallback((id: string) => {\n    setToasts(prev => prev.filter(t => t.id !== id));\n  }, []);\n\n  return (\n    <ToastContext.Provider value={{ toasts, addToast, removeToast }}>\n      {children}\n      <ToastContainer toasts={toasts} removeToast={removeToast} />\n    </ToastContext.Provider>\n  );\n};\n\nconst ToastContainer = ({ \n  toasts, \n  removeToast \n}: { \n  toasts: Toast[]; \n  removeToast: (id: string) => void;\n}) => {\n  const icons = {\n    success: <CheckCircle size={20} />,\n    error: <AlertCircle size={20} />,\n    info: <Info size={20} />,\n    warning: <AlertTriangle size={20} />,\n  };\n\n  const styles = {\n    success: 'bg-green-500/10 border-green-500/30 text-green-300',\n    error: 'bg-red-500/10 border-red-500/30 text-red-300',\n    info: 'bg-blue-500/10 border-blue-500/30 text-blue-300',\n    warning: 'bg-yellow-500/10 border-yellow-500/30 text-yellow-300',\n  };\n\n  return (\n    <div className=\"fixed bottom-4 right-4 z-50 flex flex-col gap-2\">\n      {toasts.map(toast => (\n        <div\n          key={toast.id}\n          className={cn(\n            'flex items-center gap-3 px-4 py-3 rounded-lg border backdrop-blur-sm shadow-lg animate-in slide-in-from-right',\n            styles[toast.type]\n          )}\n        >\n          {icons[toast.type]}\n          <span className=\"flex-1 text-sm font-medium\">{toast.message}</span>\n          <button\n            onClick={() => removeToast(toast.id)}\n            className=\"p-1 hover:bg-white/10 rounded transition-colors\"\n          >\n            <X size={16} />\n          </button>\n        </div>\n      ))}\n    </div>\n  );\n};\n\nexport default Toast;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\Tooltip.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\ui\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\components\\workflow.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\constants\\aiModels.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\context\\ContextManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'SpecificContextItem' is defined but never used. Allowed unused vars must match /^_/u.","line":16,"column":3,"nodeType":null,"messageId":"unusedVar","endLine":16,"endColumn":22},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":370,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":370,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11437,11440],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11437,11440],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":393,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":393,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11954,11957],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11954,11957],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * context/ContextManager.ts\n * Impl├®mentation du gestionnaire de contexte\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport {\n  ContextItem,\n  ContextType,\n  ContextTypes,\n  ContextPriority,\n  ContextLifespan,\n  ContextQueryOptions,\n  ContextRelevanceMetric,\n  ContextStrategy,\n  SpecificContextItem\n} from './types';\n\n/**\n * Strat├®gie de contexte par d├®faut\n */\nclass DefaultContextStrategy implements ContextStrategy {\n  name = 'DefaultStrategy';\n  description = 'Strat├®gie par d├®faut pour la gestion du contexte';\n\n  evaluateRelevance(item: ContextItem, currentInput: string): ContextRelevanceMetric {\n    // Calcul simple bas├® sur l'├óge, la priorit├® et les correspondances de texte\n    const ageInMinutes = (Date.now() - item.timestamp) / (1000 * 60);\n    const ageWeight = Math.max(0, 1 - ageInMinutes / 60); // Diminue avec le temps (1 heure max)\n    \n    let textMatchScore = 0;\n    if (currentInput && typeof item.value === 'object') {\n      const itemText = JSON.stringify(item.value).toLowerCase();\n      const inputTerms = currentInput.toLowerCase().split(/\\s+/);\n      \n      // Cherche des correspondances de termes\n      inputTerms.forEach(term => {\n        if (term.length > 3 && itemText.includes(term)) {\n          textMatchScore += 0.2; // +0.2 pour chaque terme correspondant\n        }\n      });\n    }\n    \n    // Applique la pond├®ration bas├®e sur la priorit├®\n    const priorityWeight = item.priority / 5;\n    \n    // Calcule un score global\n    const relevanceScore = Math.min(\n      1, \n      (ageWeight * 0.3) + (priorityWeight * 0.4) + (textMatchScore * 0.3)\n    );\n    \n    return {\n      contextId: item.id,\n      relevanceScore,\n      reason: `Age: ${ageWeight.toFixed(2)}, Priority: ${priorityWeight.toFixed(2)}, TextMatch: ${textMatchScore.toFixed(2)}`,\n      expirationWeight: ageWeight\n    };\n  }\n\n  selectContextItems(items: ContextItem[], currentInput: string, maxItems: number): ContextItem[] {\n    // ├ëvalue la pertinence de chaque ├®l├®ment\n    const evaluations = items.map(item => ({\n      item,\n      relevance: this.evaluateRelevance(item, currentInput)\n    }));\n    \n    // Trie par score de pertinence d├®croissant\n    evaluations.sort((a, b) => b.relevance.relevanceScore - a.relevance.relevanceScore);\n    \n    // Retourne les ├®l├®ments les plus pertinents\n    return evaluations.slice(0, maxItems).map(e => e.item);\n  }\n\n  mergeContextItems(items: ContextItem[]): ContextItem[] {\n    // Regroupe les ├®l├®ments par type\n    const groupedByType: Record<string, ContextItem[]> = {};\n    \n    items.forEach(item => {\n      if (!groupedByType[item.type]) {\n        groupedByType[item.type] = [];\n      }\n      groupedByType[item.type].push(item);\n    });\n    \n    const mergedItems: ContextItem[] = [];\n    \n    // Pour chaque groupe, essaie de fusionner les ├®l├®ments similaires\n    Object.values(groupedByType).forEach(typeItems => {\n      // Strat├®gie simple: garde les items les plus r├®cents et prioritaires\n      if (typeItems.length === 1) {\n        mergedItems.push(typeItems[0]);\n        return;\n      }\n      \n      // Pour les items multiples, v├®rifie s'ils peuvent ├¬tre fusionn├®s\n      const itemsBySource: Record<string, ContextItem[]> = {};\n      typeItems.forEach(item => {\n        const sourceKey = String(item.source);\n        if (!itemsBySource[sourceKey]) {\n          itemsBySource[sourceKey] = [];\n        }\n        itemsBySource[sourceKey].push(item);\n      });\n      \n      // Prend l'├®l├®ment le plus r├®cent de chaque source\n      Object.values(itemsBySource).forEach(sourceItems => {\n        if (sourceItems.length === 1) {\n          mergedItems.push(sourceItems[0]);\n          return;\n        }\n        \n        // Trie par timestamp d├®croissant\n        sourceItems.sort((a, b) => b.timestamp - a.timestamp);\n        \n        // Si les ├®l├®ments sont tr├¿s proches dans le temps, tente de fusionner\n        const latest = sourceItems[0];\n        const timeClose = sourceItems.filter(item => \n          latest.timestamp - item.timestamp < 5 * 60 * 1000 // 5 minutes\n        );\n        \n        if (timeClose.length > 1) {\n          // Garde l'├®l├®ment de priorit├® la plus ├®lev├®e\n          timeClose.sort((a, b) => b.priority - a.priority);\n          mergedItems.push(timeClose[0]);\n        } else {\n          // Sinon, garde le plus r├®cent\n          mergedItems.push(latest);\n        }\n      });\n    });\n    \n    return mergedItems;\n  }\n\n  pruneContextItems(items: ContextItem[]): ContextItem[] {\n    const now = Date.now();\n    \n    // Supprime les ├®l├®ments expir├®s\n    return items.filter(item => {\n      // Les ├®l├®ments permanents ne sont jamais supprim├®s\n      if (item.lifespan === ContextLifespan.PERMANENT) return true;\n      \n      // Si expiresAt est d├®fini, v├®rifie s'il est d├®pass├®\n      if (item.expiresAt && item.expiresAt < now) return false;\n      \n      // Sinon, applique des r├¿gles bas├®es sur le lifespan\n      switch (item.lifespan) {\n        case ContextLifespan.EPHEMERAL:\n          return (now - item.timestamp) < 5 * 60 * 1000; // 5 minutes\n        case ContextLifespan.SHORT_TERM:\n          return (now - item.timestamp) < 24 * 60 * 60 * 1000; // 1 jour\n        case ContextLifespan.MEDIUM_TERM:\n          return (now - item.timestamp) < 7 * 24 * 60 * 60 * 1000; // 1 semaine\n        case ContextLifespan.LONG_TERM:\n          return (now - item.timestamp) < 30 * 24 * 60 * 60 * 1000; // 1 mois\n        default:\n          return true;\n      }\n    });\n  }\n}\n\n/**\n * Gestionnaire principal du contexte\n */\nexport class ContextManager {\n  private contextItems: ContextItem[] = [];\n  private strategy: ContextStrategy;\n  private maxContextSize = 1000; // Limite de taille du contexte\n  \n  constructor(strategy?: ContextStrategy) {\n    this.strategy = strategy || new DefaultContextStrategy();\n  }\n  \n  /**\n   * Ajoute un nouvel ├®l├®ment de contexte\n   */\n  addContext(item: Omit<ContextItem, 'id' | 'timestamp'>): ContextItem {\n    const newItem: ContextItem = {\n      ...item,\n      id: uuidv4(),\n      timestamp: Date.now()\n    };\n    \n    // Calcule expiresAt si non fourni\n    if (!newItem.expiresAt) {\n      switch (newItem.lifespan) {\n        case ContextLifespan.EPHEMERAL:\n          newItem.expiresAt = newItem.timestamp + 5 * 60 * 1000; // 5 minutes\n          break;\n        case ContextLifespan.SHORT_TERM:\n          newItem.expiresAt = newItem.timestamp + 24 * 60 * 60 * 1000; // 1 jour\n          break;\n        case ContextLifespan.MEDIUM_TERM:\n          newItem.expiresAt = newItem.timestamp + 7 * 24 * 60 * 60 * 1000; // 1 semaine\n          break;\n        case ContextLifespan.LONG_TERM:\n          newItem.expiresAt = newItem.timestamp + 30 * 24 * 60 * 60 * 1000; // 1 mois\n          break;\n        case ContextLifespan.PERMANENT:\n          // Pas d'expiration pour les contextes permanents\n          break;\n      }\n    }\n    \n    this.contextItems.push(newItem);\n    \n    // Limite le nombre d'├®l├®ments de contexte\n    if (this.contextItems.length > this.maxContextSize) {\n      this.contextItems = this.strategy.selectContextItems(\n        this.contextItems, \n        '', \n        this.maxContextSize\n      );\n    }\n    \n    return newItem;\n  }\n  \n  /**\n   * R├®cup├¿re un ├®l├®ment de contexte par son ID\n   */\n  getContextById(id: string): ContextItem | undefined {\n    return this.contextItems.find(item => item.id === id);\n  }\n  \n  /**\n   * Met ├á jour un ├®l├®ment de contexte existant\n   */\n  updateContext(id: string, updates: Partial<Omit<ContextItem, 'id' | 'type'>>): ContextItem | null {\n    const index = this.contextItems.findIndex(item => item.id === id);\n    if (index === -1) return null;\n    \n    const updatedItem = {\n      ...this.contextItems[index],\n      ...updates,\n      timestamp: Date.now() // Mise ├á jour de l'horodatage\n    };\n    \n    this.contextItems[index] = updatedItem;\n    return updatedItem;\n  }\n  \n  /**\n   * Supprime un ├®l├®ment de contexte\n   */\n  removeContext(id: string): boolean {\n    const initialLength = this.contextItems.length;\n    this.contextItems = this.contextItems.filter(item => item.id !== id);\n    return this.contextItems.length < initialLength;\n  }\n  \n  /**\n   * Recherche des ├®l├®ments de contexte selon des crit├¿res\n   */\n  queryContext(options: ContextQueryOptions = {}): ContextItem[] {\n    let results = [...this.contextItems];\n    \n    // Applique les filtres\n    if (options.types && options.types.length > 0) {\n      results = results.filter(item => options.types!.includes(item.type));\n    }\n    \n    if (options.sources && options.sources.length > 0) {\n      results = results.filter(item => \n        options.sources!.some(source => source === item.source)\n      );\n    }\n    \n    if (options.minPriority) {\n      results = results.filter(item => item.priority >= options.minPriority!);\n    }\n    \n    if (options.tags && options.tags.length > 0) {\n      results = results.filter(item => \n        options.tags!.some(tag => item.tags.includes(tag))\n      );\n    }\n    \n    if (options.fromTimestamp) {\n      results = results.filter(item => item.timestamp >= options.fromTimestamp!);\n    }\n    \n    if (options.toTimestamp) {\n      results = results.filter(item => item.timestamp <= options.toTimestamp!);\n    }\n    \n    if (!options.includeExpired) {\n      results = results.filter(item => !item.expiresAt || item.expiresAt > Date.now());\n    }\n    \n    if (options.searchText) {\n      const searchLower = options.searchText.toLowerCase();\n      results = results.filter(item => {\n        const itemText = JSON.stringify(item.value).toLowerCase();\n        return itemText.includes(searchLower);\n      });\n    }\n    \n    // Tri\n    if (options.sortBy) {\n      results.sort((a, b) => {\n        let comparison = 0;\n        if (options.sortBy === 'timestamp') {\n          comparison = a.timestamp - b.timestamp;\n        } else if (options.sortBy === 'priority') {\n          comparison = a.priority - b.priority;\n        }\n        \n        return options.sortOrder === 'asc' ? comparison : -comparison;\n      });\n    }\n    \n    // Limite\n    if (options.limit && options.limit > 0) {\n      results = results.slice(0, options.limit);\n    }\n    \n    return results;\n  }\n  \n  /**\n   * R├®cup├¿re le contexte le plus pertinent pour l'entr├®e actuelle\n   */\n  getRelevantContext(input: string, maxItems: number = 10): ContextItem[] {\n    // Nettoie d'abord les contextes expir├®s\n    this.contextItems = this.strategy.pruneContextItems(this.contextItems);\n    \n    // S├®lectionne les ├®l├®ments les plus pertinents\n    const relevant = this.strategy.selectContextItems(\n      this.contextItems,\n      input,\n      maxItems\n    );\n    \n    return relevant;\n  }\n  \n  /**\n   * Ajoute un ├®l├®ment de contexte de conversation\n   */\n  addConversationContext(\n    text: string, \n    role: 'user' | 'assistant', \n    metadata: { intent?: string; sentiment?: string; language?: string; } = {}\n  ): ContextItem {\n    return this.addContext({\n      type: ContextTypes.CONVERSATION,\n      value: {\n        text,\n        role,\n        intent: metadata.intent,\n        sentiment: metadata.sentiment,\n        language: metadata.language\n      },\n      source: role === 'user' ? 'user' : 'lisa',\n      priority: role === 'user' ? ContextPriority.HIGH : ContextPriority.MEDIUM,\n      lifespan: ContextLifespan.MEDIUM_TERM,\n      tags: ['conversation', role]\n    });\n  }\n  \n  /**\n   * Ajoute un ├®l├®ment de contexte d'entit├®\n   */\n  addEntityContext(\n    entityType: string,\n    name: string,\n    attributes: Record<string, any> = {},\n    references: string[] = []\n  ): ContextItem {\n    return this.addContext({\n      type: ContextTypes.ENTITY,\n      value: {\n        entityType,\n        name,\n        attributes,\n        references\n      },\n      source: 'context_manager',\n      priority: ContextPriority.MEDIUM,\n      lifespan: ContextLifespan.MEDIUM_TERM,\n      tags: ['entity', entityType]\n    });\n  }\n  \n  /**\n   * Ajoute un ├®l├®ment de contexte d'intention\n   */\n  addIntentContext(\n    intent: string,\n    parameters: Record<string, any> = {},\n    fulfilled: boolean = false,\n    followUpIntent?: string\n  ): ContextItem {\n    return this.addContext({\n      type: ContextTypes.INTENT_HISTORY,\n      value: {\n        intent,\n        parameters,\n        fulfilled,\n        timestamp: Date.now(),\n        followUpIntent\n      },\n      source: 'intent_handler',\n      priority: ContextPriority.HIGH,\n      lifespan: ContextLifespan.SHORT_TERM,\n      tags: ['intent', intent]\n    });\n  }\n  \n  /**\n   * Fusionne les contextes similaires\n   */\n  mergeContexts(): void {\n    this.contextItems = this.strategy.mergeContextItems(this.contextItems);\n  }\n  \n  /**\n   * Nettoie les contextes expir├®s\n   */\n  pruneContexts(): void {\n    this.contextItems = this.strategy.pruneContextItems(this.contextItems);\n  }\n  \n  /**\n   * R├®cup├¿re les statistiques du contexte\n   */\n  getStats(): {\n    totalItems: number;\n    byType: Record<string, number>;\n    byPriority: Record<string, number>;\n    byLifespan: Record<string, number>;\n  } {\n    const stats = {\n      totalItems: this.contextItems.length,\n      byType: {} as Record<string, number>,\n      byPriority: {} as Record<string, number>,\n      byLifespan: {} as Record<string, number>\n    };\n    \n    this.contextItems.forEach(item => {\n      // Compte par type\n      if (!stats.byType[item.type]) {\n        stats.byType[item.type] = 0;\n      }\n      stats.byType[item.type]++;\n      \n      // Compte par priorit├®\n      const priorityKey = `priority_${item.priority}`;\n      if (!stats.byPriority[priorityKey]) {\n        stats.byPriority[priorityKey] = 0;\n      }\n      stats.byPriority[priorityKey]++;\n      \n      // Compte par lifespan\n      if (!stats.byLifespan[item.lifespan]) {\n        stats.byLifespan[item.lifespan] = 0;\n      }\n      stats.byLifespan[item.lifespan]++;\n    });\n    \n    return stats;\n  }\n  \n  /**\n   * Exporte tous les ├®l├®ments de contexte\n   */\n  exportContexts(): ContextItem[] {\n    return [...this.contextItems];\n  }\n  \n  /**\n   * Importe des ├®l├®ments de contexte\n   */\n  importContexts(items: ContextItem[]): void {\n    // Fusionne avec les contextes existants\n    const newItems = items.filter(newItem => \n      !this.contextItems.some(existingItem => existingItem.id === newItem.id)\n    );\n    \n    this.contextItems = [...this.contextItems, ...newItems];\n    \n    // Applique la strat├®gie de fusion\n    this.mergeContexts();\n    \n    // Limite la taille\n    if (this.contextItems.length > this.maxContextSize) {\n      this.contextItems = this.strategy.selectContextItems(\n        this.contextItems, \n        '', \n        this.maxContextSize\n      );\n    }\n  }\n  \n  /**\n   * Nettoie tous les contextes\n   */\n  clearContexts(types?: ContextType[]): void {\n    if (!types) {\n      this.contextItems = [];\n    } else {\n      this.contextItems = this.contextItems.filter(\n        item => !types.includes(item.type)\n      );\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\context\\types.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'AgentType' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":6,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":15},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2069,2072],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2069,2072],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":68,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":68,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2586,2589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2586,2589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3413,3416],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3413,3416],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3810,3813],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3810,3813],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":118,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":118,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4169,4172],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4169,4172],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4630,4633],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4630,4633],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":145,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":145,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5043,5046],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5043,5046],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":8,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * context/types.ts\n * Types et interfaces pour le syst├¿me de gestion de contexte avanc├®\n */\n\nimport type { AgentDomain } from '../agents/types';\n\n// Type alias for agent references\ntype AgentType = string | AgentDomain;\n\n/**\n * Types de contexte support├®s\n */\nexport const ContextTypes = {\n  CONVERSATION: 'conversation',  // Contexte de conversation\n  USER_PREFERENCE: 'user_preference', // Pr├®f├®rences utilisateur\n  ENTITY: 'entity',              // Entit├®s mentionn├®es (lieux, personnes, etc.)\n  INTENT_HISTORY: 'intent_history', // Historique des intentions\n  QUERY_RESULT: 'query_result',  // R├®sultats de requ├¬te\n  SYSTEM_STATE: 'system_state',  // ├ëtat du syst├¿me\n  SESSION: 'session',            // Contexte de session\n  TEMPORAL: 'temporal',          // Contexte temporel (heure, date, saison)\n  LOCATION: 'location'           // Contexte de localisation\n} as const;\n\nexport type ContextType = typeof ContextTypes[keyof typeof ContextTypes];\n\n/**\n * Niveaux de priorit├® du contexte\n */\nexport const ContextPriority = {\n  VERY_LOW: 1,   // Peu important, peut ├¬tre ignor├® facilement\n  LOW: 2,        // Faible importance\n  MEDIUM: 3,     // Importance moyenne\n  HIGH: 4,       // Haute importance\n  VERY_HIGH: 5   // Critique, ne doit jamais ├¬tre ignor├®\n} as const;\n\nexport type ContextPriorityLevel = typeof ContextPriority[keyof typeof ContextPriority];\n\n/**\n * Dur├®e de vie du contexte\n */\nexport const ContextLifespan = {\n  EPHEMERAL: 'ephemeral',       // Tr├¿s court terme (1 ├®change)\n  SHORT_TERM: 'short_term',     // Court terme (session actuelle)\n  MEDIUM_TERM: 'medium_term',   // Moyen terme (quelques jours)\n  LONG_TERM: 'long_term',       // Long terme (plusieurs semaines)\n  PERMANENT: 'permanent'        // Permanent (stock├® ind├®finiment)\n} as const;\n\nexport type ContextLifespanType = typeof ContextLifespan[keyof typeof ContextLifespan];\n\n/**\n * Interface de base pour les ├®l├®ments de contexte\n */\nexport interface ContextItem {\n  id: string;                     // ID unique\n  type: ContextType;              // Type de contexte\n  value: any;                     // Valeur du contexte\n  source: string | AgentDomain;     // Source du contexte (utilisateur ou agent)\n  timestamp: number;              // Horodatage de cr├®ation\n  priority: ContextPriorityLevel; // Priorit├®\n  lifespan: ContextLifespanType;  // Dur├®e de vie\n  expiresAt?: number;             // Date d'expiration (optionnel)\n  tags: string[];                 // Tags pour la recherche et le filtrage\n  confidence?: number;            // Niveau de confiance (0-1)\n  metadata?: Record<string, any>; // M├®tadonn├®es additionnelles\n}\n\n/**\n * ├ël├®ment de contexte de conversation\n */\nexport interface ConversationContextItem extends ContextItem {\n  type: typeof ContextTypes.CONVERSATION;\n  value: {\n    text: string;           // Texte de la conversation\n    role: 'user' | 'assistant'; // R├┤le dans la conversation\n    referencedItems?: string[]; // R├®f├®rences ├á d'autres ├®l├®ments de contexte\n    intent?: string;        // Intention d├®tect├®e\n    sentiment?: string;     // Sentiment d├®tect├®\n    language?: string;      // Langue d├®tect├®e\n  };\n}\n\n/**\n * ├ël├®ment de contexte de pr├®f├®rence utilisateur\n */\nexport interface UserPreferenceContextItem extends ContextItem {\n  type: typeof ContextTypes.USER_PREFERENCE;\n  value: {\n    category: string;       // Cat├®gorie de pr├®f├®rence (e.g., 'weather', 'music')\n    preference: any;        // Valeur de la pr├®f├®rence\n    strength: number;       // Force de la pr├®f├®rence (0-1)\n  };\n}\n\n/**\n * ├ël├®ment de contexte d'entit├®\n */\nexport interface EntityContextItem extends ContextItem {\n  type: typeof ContextTypes.ENTITY;\n  value: {\n    entityType: string;     // Type d'entit├® (personne, lieu, etc.)\n    name: string;           // Nom de l'entit├®\n    attributes: Record<string, any>; // Attributs de l'entit├®\n    references: string[];   // R├®f├®rences textuelles ├á l'entit├®\n  };\n}\n\n/**\n * ├ël├®ment de contexte d'historique d'intention\n */\nexport interface IntentHistoryContextItem extends ContextItem {\n  type: typeof ContextTypes.INTENT_HISTORY;\n  value: {\n    intent: string;         // Intention d├®tect├®e\n    parameters: Record<string, any>; // Param├¿tres de l'intention\n    fulfilled: boolean;     // Si l'intention a ├®t├® satisfaite\n    timestamp: number;      // Quand l'intention a ├®t├® d├®tect├®e\n    followUpIntent?: string; // Intention de suivi attendue\n  };\n}\n\n/**\n * ├ël├®ment de contexte de r├®sultat de requ├¬te\n */\nexport interface QueryResultContextItem extends ContextItem {\n  type: typeof ContextTypes.QUERY_RESULT;\n  value: {\n    query: string;          // Requ├¬te originale\n    results: any[];         // R├®sultats de la requ├¬te\n    source: string;         // Source des r├®sultats (e.g., 'weather-api')\n    timestamp: number;      // Quand la requ├¬te a ├®t├® effectu├®e\n  };\n}\n\n/**\n * ├ël├®ment de contexte d'├®tat du syst├¿me\n */\nexport interface SystemStateContextItem extends ContextItem {\n  type: typeof ContextTypes.SYSTEM_STATE;\n  value: {\n    stateName: string;      // Nom de l'├®tat\n    stateValue: any;        // Valeur de l'├®tat\n    component: string;      // Composant concern├®\n  };\n}\n\n/**\n * ├ël├®ment de contexte de session\n */\nexport interface SessionContextItem extends ContextItem {\n  type: typeof ContextTypes.SESSION;\n  value: {\n    sessionId: string;      // ID de session\n    startTime: number;      // D├®but de la session\n    lastActiveTime: number; // Derni├¿re activit├®\n    activeAgents: AgentDomain[]; // Agents actifs dans la session\n    sessionGoals?: string[]; // Objectifs de la session\n  };\n}\n\n/**\n * ├ël├®ment de contexte temporel\n */\nexport interface TemporalContextItem extends ContextItem {\n  type: typeof ContextTypes.TEMPORAL;\n  value: {\n    timestamp: number;      // Horodatage\n    timeOfDay?: string;     // Moment de la journ├®e (matin, apr├¿s-midi, etc.)\n    dayOfWeek?: number;     // Jour de la semaine (0-6)\n    season?: string;        // Saison\n    isWorkday?: boolean;    // Si c'est un jour de travail\n    isHoliday?: boolean;    // Si c'est un jour f├®ri├®\n    holidayName?: string;   // Nom du jour f├®ri├®\n  };\n}\n\n/**\n * ├ël├®ment de contexte de localisation\n */\nexport interface LocationContextItem extends ContextItem {\n  type: typeof ContextTypes.LOCATION;\n  value: {\n    type: 'current' | 'reference' | 'destination'; // Type de localisation\n    name?: string;          // Nom du lieu\n    address?: string;       // Adresse\n    coordinates?: {         // Coordonn├®es g├®ographiques\n      latitude: number;\n      longitude: number;\n    };\n    locationType?: string;  // Type de lieu (maison, bureau, restaurant)\n  };\n}\n\n/**\n * Type union pour tous les types d'├®l├®ments de contexte\n */\nexport type SpecificContextItem = \n  | ConversationContextItem\n  | UserPreferenceContextItem\n  | EntityContextItem\n  | IntentHistoryContextItem\n  | QueryResultContextItem\n  | SystemStateContextItem\n  | SessionContextItem\n  | TemporalContextItem\n  | LocationContextItem;\n\n/**\n * Options de requ├¬te pour la recherche de contexte\n */\nexport interface ContextQueryOptions {\n  types?: ContextType[];           // Filtrer par types\n  sources?: (string | AgentDomain)[]; // Filtrer par sources\n  minPriority?: ContextPriorityLevel; // Priorit├® minimale\n  tags?: string[];                 // Filtrer par tags\n  fromTimestamp?: number;         // Filtrer par horodatage min\n  toTimestamp?: number;           // Filtrer par horodatage max\n  limit?: number;                  // Limiter le nombre de r├®sultats\n  sortBy?: 'timestamp' | 'priority'; // Trier par\n  sortOrder?: 'asc' | 'desc';      // Ordre de tri\n  includeExpired?: boolean;        // Inclure les contextes expir├®s\n  searchText?: string;             // Rechercher dans le contenu\n}\n\n/**\n * M├®trique d'importance du contexte\n */\nexport interface ContextRelevanceMetric {\n  contextId: string;       // ID du contexte\n  relevanceScore: number;  // Score de pertinence (0-1)\n  reason: string;          // Raison de la pertinence\n  expirationWeight: number; // Poids d'expiration (plus r├®cent = plus important)\n}\n\n/**\n * Interface pour les strat├®gies de gestion du contexte\n */\nexport interface ContextStrategy {\n  name: string;\n  description: string;\n  \n  // D├®terminer la pertinence d'un ├®l├®ment de contexte\n  evaluateRelevance(item: ContextItem, currentInput: string): ContextRelevanceMetric;\n  \n  // S├®lectionner les ├®l├®ments de contexte les plus pertinents\n  selectContextItems(items: ContextItem[], currentInput: string, maxItems: number): ContextItem[];\n  \n  // Fusionner des contextes similaires\n  mergeContextItems(items: ContextItem[]): ContextItem[];\n  \n  // Nettoyer les contextes expir├®s ou non pertinents\n  pruneContextItems(items: ContextItem[]): ContextItem[];\n}\n\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\client.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\client.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\default.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\default.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\edge.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\edge.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\index-browser.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\index.d.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'$Types' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":8,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":14},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used. Allowed unused vars must match /^_/u.","line":107,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":107,"endColumn":16},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'T' is defined but never used. Allowed unused vars must match /^_/u.","line":119,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":22},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":390,"column":23,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":390,"endColumn":25,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[12112,12114],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[12112,12114],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":419,"column":11,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":419,"endColumn":13,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[13064,13066],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[13064,13066],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-constraint","severity":2,"message":"Constraining the generic type `T` to `any` does nothing and is unnecessary.","line":446,"column":17,"nodeType":"TSTypeParameter","messageId":"unnecessaryConstraint","endLine":446,"endColumn":30,"suggestions":[{"messageId":"removeUnnecessaryConstraint","data":{"constraint":"any"},"fix":{"range":[13719,13731],"text":""},"desc":"Remove the unnecessary `any` constraint."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-constraint","severity":2,"message":"Constraining the generic type `T` to `unknown` does nothing and is unnecessary.","line":462,"column":27,"nodeType":"TSTypeParameter","messageId":"unnecessaryConstraint","endLine":462,"endColumn":44,"suggestions":[{"messageId":"removeUnnecessaryConstraint","data":{"constraint":"unknown"},"fix":{"range":[13969,13985],"text":""},"desc":"Remove the unnecessary `unknown` constraint."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-constraint","severity":2,"message":"Constraining the generic type `A` to `any` does nothing and is unnecessary.","line":523,"column":26,"nodeType":"TSTypeParameter","messageId":"unnecessaryConstraint","endLine":523,"endColumn":39,"suggestions":[{"messageId":"removeUnnecessaryConstraint","data":{"constraint":"any"},"fix":{"range":[15729,15741],"text":""},"desc":"Remove the unnecessary `any` constraint."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":523,"column":53,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":523,"endColumn":61},{"ruleId":"@typescript-eslint/no-unnecessary-type-constraint","severity":2,"message":"Constraining the generic type `A1` to `any` does nothing and is unnecessary.","line":572,"column":23,"nodeType":"TSTypeParameter","messageId":"unnecessaryConstraint","endLine":572,"endColumn":37,"suggestions":[{"messageId":"removeUnnecessaryConstraint","data":{"constraint":"any"},"fix":{"range":[16884,16896],"text":""},"desc":"Remove the unnecessary `any` constraint."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-constraint","severity":2,"message":"Constraining the generic type `A2` to `any` does nothing and is unnecessary.","line":572,"column":39,"nodeType":"TSTypeParameter","messageId":"unnecessaryConstraint","endLine":572,"endColumn":53,"suggestions":[{"messageId":"removeUnnecessaryConstraint","data":{"constraint":"any"},"fix":{"range":[16900,16912],"text":""},"desc":"Remove the unnecessary `any` constraint."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":627,"column":9,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":627,"endColumn":11,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[18201,18203],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[18201,18203],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":670,"column":39,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":670,"endColumn":41,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[19313,19315],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[19313,19315],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":671,"column":122,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":671,"endColumn":124,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[19524,19526],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[19524,19526],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":674,"column":111,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":674,"endColumn":113,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[19643,19645],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[19643,19645],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unnecessary-type-constraint","severity":2,"message":"Constraining the generic type `T` to `any` does nothing and is unnecessary.","line":1152,"column":25,"nodeType":"TSTypeParameter","messageId":"unnecessaryConstraint","endLine":1152,"endColumn":38,"suggestions":[{"messageId":"removeUnnecessaryConstraint","data":{"constraint":"any"},"fix":{"range":[36214,36226],"text":""},"desc":"Remove the unnecessary `any` constraint."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1239,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":1239,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1257,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":1257,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1272,"column":45,"nodeType":null,"messageId":"unusedVar","endLine":1272,"endColumn":52},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1292,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":1292,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1299,"column":53,"nodeType":null,"messageId":"unusedVar","endLine":1299,"endColumn":60},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1306,"column":58,"nodeType":null,"messageId":"unusedVar","endLine":1306,"endColumn":65},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1320,"column":41,"nodeType":null,"messageId":"unusedVar","endLine":1320,"endColumn":48},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1339,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":1339,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1346,"column":55,"nodeType":null,"messageId":"unusedVar","endLine":1346,"endColumn":62},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1422,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":1422,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1482,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":1482,"endColumn":38},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1563,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":1563,"endColumn":53},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1563,"column":116,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1563,"endColumn":118,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[47585,47587],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[47585,47587],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1564,"column":46,"nodeType":null,"messageId":"unusedVar","endLine":1564,"endColumn":53},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1564,"column":116,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1564,"endColumn":118,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[47703,47705],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[47703,47705],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1579,"column":17,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1579,"endColumn":19,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[48120,48122],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[48120,48122],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":1584,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":1584,"endColumn":29},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1589,"column":121,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1589,"endColumn":123,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[48594,48596],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[48594,48596],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1933,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1933,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[61516,61518],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[61516,61518],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1943,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1943,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[61904,61906],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[61904,61906],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1951,"column":9,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1951,"endColumn":11,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[62221,62223],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[62221,62223],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1957,"column":80,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1957,"endColumn":82,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[62483,62485],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[62483,62485],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1970,"column":144,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1970,"endColumn":146,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[63036,63038],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[63036,63038],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1972,"column":55,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1972,"endColumn":57,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[63179,63181],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[63179,63181],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":2232,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":2232,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":2288,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":2288,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":2384,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":2384,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":2499,"column":37,"nodeType":null,"messageId":"unusedVar","endLine":2499,"endColumn":44},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":2559,"column":35,"nodeType":null,"messageId":"unusedVar","endLine":2559,"endColumn":42},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2665,"column":17,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2665,"endColumn":19,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[84222,84224],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[84222,84224],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":2670,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":2670,"endColumn":33},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2675,"column":125,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2675,"endColumn":127,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[84724,84726],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[84724,84726],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3019,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3019,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[98302,98304],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[98302,98304],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3029,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3029,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[98690,98692],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[98690,98692],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3037,"column":9,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3037,"endColumn":11,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[99007,99009],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[99007,99009],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3043,"column":84,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3043,"endColumn":86,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[99273,99275],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[99273,99275],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3056,"column":148,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3056,"endColumn":150,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[99846,99848],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[99846,99848],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3058,"column":47,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3058,"endColumn":49,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[99981,99983],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[99981,99983],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3059,"column":51,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3059,"endColumn":53,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[100232,100234],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[100232,100234],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3060,"column":51,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3060,"endColumn":53,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[100445,100447],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[100445,100447],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3061,"column":61,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3061,"endColumn":63,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[100668,100670],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[100668,100670],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":3320,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":3320,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":3380,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":3380,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":3480,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":3480,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":3667,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":3667,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":3739,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":3739,"endColumn":38},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3852,"column":17,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3852,"endColumn":19,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[124976,124978],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[124976,124978],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":3857,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":3857,"endColumn":29},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3862,"column":121,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3862,"endColumn":123,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[125450,125452],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[125450,125452],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4206,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4206,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[138372,138374],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[138372,138374],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4216,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4216,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[138760,138762],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[138760,138762],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4224,"column":9,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4224,"endColumn":11,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[139077,139079],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[139077,139079],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4230,"column":80,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4230,"endColumn":82,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[139339,139341],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[139339,139341],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4243,"column":144,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4243,"endColumn":146,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[139892,139894],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[139892,139894],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4245,"column":55,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4245,"endColumn":57,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[140035,140037],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[140035,140037],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4246,"column":59,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4246,"endColumn":61,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[140306,140308],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[140306,140308],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4247,"column":59,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4247,"endColumn":61,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[140529,140531],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[140529,140531],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":4507,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":4507,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":4567,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":4567,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":4667,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":4667,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":4800,"column":33,"nodeType":null,"messageId":"unusedVar","endLine":4800,"endColumn":40},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":4860,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":4860,"endColumn":38},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4963,"column":17,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4963,"endColumn":19,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[162202,162204],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[162202,162204],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":4968,"column":22,"nodeType":null,"messageId":"unusedVar","endLine":4968,"endColumn":29},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":4973,"column":121,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":4973,"endColumn":123,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[162676,162678],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[162676,162678],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5317,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5317,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[175598,175600],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[175598,175600],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5327,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5327,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[175986,175988],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[175986,175988],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5335,"column":9,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5335,"endColumn":11,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[176303,176305],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[176303,176305],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5341,"column":80,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5341,"endColumn":82,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[176565,176567],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[176565,176567],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5354,"column":144,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5354,"endColumn":146,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[177118,177120],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[177118,177120],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5356,"column":55,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5356,"endColumn":57,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[177261,177263],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[177261,177263],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5357,"column":53,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5357,"endColumn":55,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[177526,177528],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[177526,177528],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":5358,"column":53,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":5358,"endColumn":55,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[177779,177781],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[177779,177781],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":5616,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":5616,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":5676,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":5676,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":5776,"column":34,"nodeType":null,"messageId":"unusedVar","endLine":5776,"endColumn":41},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":5871,"column":38,"nodeType":null,"messageId":"unusedVar","endLine":5871,"endColumn":45},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":5931,"column":36,"nodeType":null,"messageId":"unusedVar","endLine":5931,"endColumn":43},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6038,"column":17,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6038,"endColumn":19,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[198313,198315],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[198313,198315],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":6043,"column":27,"nodeType":null,"messageId":"unusedVar","endLine":6043,"endColumn":34},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6048,"column":126,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6048,"endColumn":128,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[198822,198824],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[198822,198824],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6392,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6392,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[212564,212566],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[212564,212566],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6402,"column":13,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6402,"endColumn":15,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[212952,212954],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[212952,212954],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6410,"column":9,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6410,"endColumn":11,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[213269,213271],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[213269,213271],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6416,"column":85,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6416,"endColumn":87,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[213536,213538],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[213536,213538],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6429,"column":149,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6429,"endColumn":151,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[214114,214116],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[214114,214116],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":6431,"column":55,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":6431,"endColumn":57,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[214257,214259],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[214257,214259],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":6692,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":6692,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":6752,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":6752,"endColumn":46},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ExtArgs' is defined but never used. Allowed unused vars must match /^_/u.","line":6852,"column":39,"nodeType":null,"messageId":"unusedVar","endLine":6852,"endColumn":46}],"suppressedMessages":[],"errorCount":62,"fatalErrorCount":0,"warningCount":44,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n/**\n * Client\n**/\n\nimport * as runtime from './runtime/library.js';\nimport $Types = runtime.Types // general types\nimport $Public = runtime.Types.Public\nimport $Utils = runtime.Types.Utils\nimport $Extensions = runtime.Types.Extensions\nimport $Result = runtime.Types.Result\n\nexport type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n\n/**\n * Model User\n * \n */\nexport type User = $Result.DefaultSelection<Prisma.$UserPayload>\n/**\n * Model Workflow\n * \n */\nexport type Workflow = $Result.DefaultSelection<Prisma.$WorkflowPayload>\n/**\n * Model Node\n * \n */\nexport type Node = $Result.DefaultSelection<Prisma.$NodePayload>\n/**\n * Model Edge\n * \n */\nexport type Edge = $Result.DefaultSelection<Prisma.$EdgePayload>\n/**\n * Model Execution\n * \n */\nexport type Execution = $Result.DefaultSelection<Prisma.$ExecutionPayload>\n\n/**\n * ##  Prisma Client ╩▓╦ó\n *\n * Type-safe database client for TypeScript & Node.js\n * @example\n * ```\n * const prisma = new PrismaClient()\n * // Fetch zero or more Users\n * const users = await prisma.user.findMany()\n * ```\n *\n *\n * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n */\nexport class PrismaClient<\n  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,\n  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,\n  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs\n> {\n  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }\n\n    /**\n   * ##  Prisma Client ╩▓╦ó\n   *\n   * Type-safe database client for TypeScript & Node.js\n   * @example\n   * ```\n   * const prisma = new PrismaClient()\n   * // Fetch zero or more Users\n   * const users = await prisma.user.findMany()\n   * ```\n   *\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).\n   */\n\n  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);\n  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;\n\n  /**\n   * Connect with the database\n   */\n  $connect(): $Utils.JsPromise<void>;\n\n  /**\n   * Disconnect from the database\n   */\n  $disconnect(): $Utils.JsPromise<void>;\n\n  /**\n   * Add a middleware\n   * @deprecated since 4.16.0. For new code, prefer client extensions instead.\n   * @see https://pris.ly/d/extensions\n   */\n  $use(cb: Prisma.Middleware): void\n\n/**\n   * Executes a prepared raw query and returns the number of affected rows.\n   * @example\n   * ```\n   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Executes a raw query and returns the number of affected rows.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;\n\n  /**\n   * Performs a prepared raw query and returns the `SELECT` data.\n   * @example\n   * ```\n   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;\n\n  /**\n   * Performs a raw query and returns the `SELECT` data.\n   * Susceptible to SQL injections, see documentation.\n   * @example\n   * ```\n   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')\n   * ```\n   *\n   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).\n   */\n  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;\n\n\n  /**\n   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.\n   * @example\n   * ```\n   * const [george, bob, alice] = await prisma.$transaction([\n   *   prisma.user.create({ data: { name: 'George' } }),\n   *   prisma.user.create({ data: { name: 'Bob' } }),\n   *   prisma.user.create({ data: { name: 'Alice' } }),\n   * ])\n   * ```\n   * \n   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).\n   */\n  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>\n\n  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>\n\n\n  $extends: $Extensions.ExtendsHook<\"extends\", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {\n    extArgs: ExtArgs\n  }>>\n\n      /**\n   * `prisma.user`: Exposes CRUD operations for the **User** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Users\n    * const users = await prisma.user.findMany()\n    * ```\n    */\n  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.workflow`: Exposes CRUD operations for the **Workflow** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Workflows\n    * const workflows = await prisma.workflow.findMany()\n    * ```\n    */\n  get workflow(): Prisma.WorkflowDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.node`: Exposes CRUD operations for the **Node** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Nodes\n    * const nodes = await prisma.node.findMany()\n    * ```\n    */\n  get node(): Prisma.NodeDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.edge`: Exposes CRUD operations for the **Edge** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Edges\n    * const edges = await prisma.edge.findMany()\n    * ```\n    */\n  get edge(): Prisma.EdgeDelegate<ExtArgs, ClientOptions>;\n\n  /**\n   * `prisma.execution`: Exposes CRUD operations for the **Execution** model.\n    * Example usage:\n    * ```ts\n    * // Fetch zero or more Executions\n    * const executions = await prisma.execution.findMany()\n    * ```\n    */\n  get execution(): Prisma.ExecutionDelegate<ExtArgs, ClientOptions>;\n}\n\nexport namespace Prisma {\n  export import DMMF = runtime.DMMF\n\n  export type PrismaPromise<T> = $Public.PrismaPromise<T>\n\n  /**\n   * Validator\n   */\n  export import validator = runtime.Public.validator\n\n  /**\n   * Prisma Errors\n   */\n  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError\n  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError\n  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError\n  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError\n  export import PrismaClientValidationError = runtime.PrismaClientValidationError\n\n  /**\n   * Re-export of sql-template-tag\n   */\n  export import sql = runtime.sqltag\n  export import empty = runtime.empty\n  export import join = runtime.join\n  export import raw = runtime.raw\n  export import Sql = runtime.Sql\n\n\n\n  /**\n   * Decimal.js\n   */\n  export import Decimal = runtime.Decimal\n\n  export type DecimalJsLike = runtime.DecimalJsLike\n\n  /**\n   * Metrics\n   */\n  export type Metrics = runtime.Metrics\n  export type Metric<T> = runtime.Metric<T>\n  export type MetricHistogram = runtime.MetricHistogram\n  export type MetricHistogramBucket = runtime.MetricHistogramBucket\n\n  /**\n  * Extensions\n  */\n  export import Extension = $Extensions.UserArgs\n  export import getExtensionContext = runtime.Extensions.getExtensionContext\n  export import Args = $Public.Args\n  export import Payload = $Public.Payload\n  export import Result = $Public.Result\n  export import Exact = $Public.Exact\n\n  /**\n   * Prisma Client JS version: 6.11.1\n   * Query Engine version: f40f79ec31188888a2e33acda0ecc8fd10a853a9\n   */\n  export type PrismaVersion = {\n    client: string\n  }\n\n  export const prismaVersion: PrismaVersion\n\n  /**\n   * Utility Types\n   */\n\n\n  export import JsonObject = runtime.JsonObject\n  export import JsonArray = runtime.JsonArray\n  export import JsonValue = runtime.JsonValue\n  export import InputJsonObject = runtime.InputJsonObject\n  export import InputJsonArray = runtime.InputJsonArray\n  export import InputJsonValue = runtime.InputJsonValue\n\n  /**\n   * Types of the values used to represent different kinds of `null` values when working with JSON fields.\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  namespace NullTypes {\n    /**\n    * Type of `Prisma.DbNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class DbNull {\n      private DbNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.JsonNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class JsonNull {\n      private JsonNull: never\n      private constructor()\n    }\n\n    /**\n    * Type of `Prisma.AnyNull`.\n    *\n    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.\n    *\n    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n    */\n    class AnyNull {\n      private AnyNull: never\n      private constructor()\n    }\n  }\n\n  /**\n   * Helper for filtering JSON entries that have `null` on the database (empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const DbNull: NullTypes.DbNull\n\n  /**\n   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const JsonNull: NullTypes.JsonNull\n\n  /**\n   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`\n   *\n   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field\n   */\n  export const AnyNull: NullTypes.AnyNull\n\n  type SelectAndInclude = {\n    select: any\n    include: any\n  }\n\n  type SelectAndOmit = {\n    select: any\n    omit: any\n  }\n\n  /**\n   * Get the type of the value, that the Promise holds.\n   */\n  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;\n\n  /**\n   * Get the return type of a function which returns a Promise.\n   */\n  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>\n\n  /**\n   * From T, pick a set of properties whose keys are in the union K\n   */\n  type Prisma__Pick<T, K extends keyof T> = {\n      [P in K]: T[P];\n  };\n\n\n  export type Enumerable<T> = T | Array<T>;\n\n  export type RequiredKeys<T> = {\n    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K\n  }[keyof T]\n\n  export type TruthyKeys<T> = keyof {\n    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K\n  }\n\n  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>\n\n  /**\n   * Subset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection\n   */\n  export type Subset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never;\n  };\n\n  /**\n   * SelectSubset\n   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.\n   * Additionally, it validates, if both select and include are present. If the case, it errors.\n   */\n  export type SelectSubset<T, U> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    (T extends SelectAndInclude\n      ? 'Please either choose `select` or `include`.'\n      : T extends SelectAndOmit\n        ? 'Please either choose `select` or `omit`.'\n        : {})\n\n  /**\n   * Subset + Intersection\n   * @desc From `T` pick properties that exist in `U` and intersect `K`\n   */\n  export type SubsetIntersection<T, U, K> = {\n    [key in keyof T]: key extends keyof U ? T[key] : never\n  } &\n    K\n\n  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };\n\n  /**\n   * XOR is needed to have a real mutually exclusive union type\n   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types\n   */\n  type XOR<T, U> =\n    T extends object ?\n    U extends object ?\n      (Without<T, U> & U) | (Without<U, T> & T)\n    : U : T\n\n\n  /**\n   * Is T a Record?\n   */\n  type IsObject<T extends any> = T extends Array<any>\n  ? False\n  : T extends Date\n  ? False\n  : T extends Uint8Array\n  ? False\n  : T extends bigint\n  ? False\n  : T extends object\n  ? True\n  : False\n\n\n  /**\n   * If it's T[], return T\n   */\n  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T\n\n  /**\n   * From ts-toolbelt\n   */\n\n  type __Either<O extends object, K extends Key> = Omit<O, K> &\n    {\n      // Merge all but K\n      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities\n    }[K]\n\n  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>\n\n  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>\n\n  type _Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean\n  > = {\n    1: EitherStrict<O, K>\n    0: EitherLoose<O, K>\n  }[strict]\n\n  type Either<\n    O extends object,\n    K extends Key,\n    strict extends Boolean = 1\n  > = O extends unknown ? _Either<O, K, strict> : never\n\n  export type Union = any\n\n  type PatchUndefined<O extends object, O1 extends object> = {\n    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]\n  } & {}\n\n  /** Helper Types for \"Merge\" **/\n  export type IntersectOf<U extends Union> = (\n    U extends unknown ? (k: U) => void : never\n  ) extends (k: infer I) => void\n    ? I\n    : never\n\n  export type Overwrite<O extends object, O1 extends object> = {\n      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];\n  } & {};\n\n  type _Merge<U extends object> = IntersectOf<Overwrite<U, {\n      [K in keyof U]-?: At<U, K>;\n  }>>;\n\n  type Key = string | number | symbol;\n  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;\n  type AtStrict<O extends object, K extends Key> = O[K & keyof O];\n  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;\n  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {\n      1: AtStrict<O, K>;\n      0: AtLoose<O, K>;\n  }[strict];\n\n  export type ComputeRaw<A extends any> = A extends Function ? A : {\n    [K in keyof A]: A[K];\n  } & {};\n\n  export type OptionalFlat<O> = {\n    [K in keyof O]?: O[K];\n  } & {};\n\n  type _Record<K extends keyof any, T> = {\n    [P in K]: T;\n  };\n\n  // cause typescript not to expand types and preserve names\n  type NoExpand<T> = T extends unknown ? T : never;\n\n  // this type assumes the passed object is entirely optional\n  type AtLeast<O extends object, K extends string> = NoExpand<\n    O extends unknown\n    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)\n      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O\n    : never>;\n\n  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;\n\n  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;\n  /** End Helper Types for \"Merge\" **/\n\n  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;\n\n  /**\n  A [[Boolean]]\n  */\n  export type Boolean = True | False\n\n  // /**\n  // 1\n  // */\n  export type True = 1\n\n  /**\n  0\n  */\n  export type False = 0\n\n  export type Not<B extends Boolean> = {\n    0: 1\n    1: 0\n  }[B]\n\n  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]\n    ? 0 // anything `never` is false\n    : A1 extends A2\n    ? 1\n    : 0\n\n  export type Has<U extends Union, U1 extends Union> = Not<\n    Extends<Exclude<U1, U>, U1>\n  >\n\n  export type Or<B1 extends Boolean, B2 extends Boolean> = {\n    0: {\n      0: 0\n      1: 1\n    }\n    1: {\n      0: 1\n      1: 1\n    }\n  }[B1][B2]\n\n  export type Keys<U extends Union> = U extends unknown ? keyof U : never\n\n  type Cast<A, B> = A extends B ? A : B;\n\n  export const type: unique symbol;\n\n\n\n  /**\n   * Used by group by\n   */\n\n  export type GetScalarType<T, O> = O extends object ? {\n    [P in keyof T]: P extends keyof O\n      ? O[P]\n      : never\n  } : never\n\n  type FieldPaths<\n    T,\n    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>\n  > = IsObject<T> extends True ? U : T\n\n  type GetHavingFields<T> = {\n    [K in keyof T]: Or<\n      Or<Extends<'OR', K>, Extends<'AND', K>>,\n      Extends<'NOT', K>\n    > extends True\n      ? // infer is only needed to not hit TS limit\n        // based on the brilliant idea of Pierre-Antoine Mills\n        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437\n        T[K] extends infer TK\n        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>\n        : never\n      : {} extends FieldPaths<T[K]>\n      ? never\n      : K\n  }[keyof T]\n\n  /**\n   * Convert tuple to union\n   */\n  type _TupleToUnion<T> = T extends (infer E)[] ? E : never\n  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>\n  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T\n\n  /**\n   * Like `Pick`, but additionally can also accept an array of keys\n   */\n  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>\n\n  /**\n   * Exclude all keys with underscores\n   */\n  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T\n\n\n  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>\n\n  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>\n\n\n  export const ModelName: {\n    User: 'User',\n    Workflow: 'Workflow',\n    Node: 'Node',\n    Edge: 'Edge',\n    Execution: 'Execution'\n  };\n\n  export type ModelName = (typeof ModelName)[keyof typeof ModelName]\n\n\n  export type Datasources = {\n    db?: Datasource\n  }\n\n  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {\n    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>\n  }\n\n  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {\n    globalOmitOptions: {\n      omit: GlobalOmitOptions\n    }\n    meta: {\n      modelProps: \"user\" | \"workflow\" | \"node\" | \"edge\" | \"execution\"\n      txIsolationLevel: Prisma.TransactionIsolationLevel\n    }\n    model: {\n      User: {\n        payload: Prisma.$UserPayload<ExtArgs>\n        fields: Prisma.UserFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.UserFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>\n          }\n          findFirst: {\n            args: Prisma.UserFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>\n          }\n          findMany: {\n            args: Prisma.UserFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]\n          }\n          create: {\n            args: Prisma.UserCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>\n          }\n          createMany: {\n            args: Prisma.UserCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]\n          }\n          delete: {\n            args: Prisma.UserDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>\n          }\n          update: {\n            args: Prisma.UserUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>\n          }\n          deleteMany: {\n            args: Prisma.UserDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.UserUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]\n          }\n          upsert: {\n            args: Prisma.UserUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$UserPayload>\n          }\n          aggregate: {\n            args: Prisma.UserAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateUser>\n          }\n          groupBy: {\n            args: Prisma.UserGroupByArgs<ExtArgs>\n            result: $Utils.Optional<UserGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.UserCountArgs<ExtArgs>\n            result: $Utils.Optional<UserCountAggregateOutputType> | number\n          }\n        }\n      }\n      Workflow: {\n        payload: Prisma.$WorkflowPayload<ExtArgs>\n        fields: Prisma.WorkflowFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.WorkflowFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.WorkflowFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>\n          }\n          findFirst: {\n            args: Prisma.WorkflowFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.WorkflowFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>\n          }\n          findMany: {\n            args: Prisma.WorkflowFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]\n          }\n          create: {\n            args: Prisma.WorkflowCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>\n          }\n          createMany: {\n            args: Prisma.WorkflowCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.WorkflowCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]\n          }\n          delete: {\n            args: Prisma.WorkflowDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>\n          }\n          update: {\n            args: Prisma.WorkflowUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>\n          }\n          deleteMany: {\n            args: Prisma.WorkflowDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.WorkflowUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.WorkflowUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>[]\n          }\n          upsert: {\n            args: Prisma.WorkflowUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$WorkflowPayload>\n          }\n          aggregate: {\n            args: Prisma.WorkflowAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateWorkflow>\n          }\n          groupBy: {\n            args: Prisma.WorkflowGroupByArgs<ExtArgs>\n            result: $Utils.Optional<WorkflowGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.WorkflowCountArgs<ExtArgs>\n            result: $Utils.Optional<WorkflowCountAggregateOutputType> | number\n          }\n        }\n      }\n      Node: {\n        payload: Prisma.$NodePayload<ExtArgs>\n        fields: Prisma.NodeFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.NodeFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.NodeFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>\n          }\n          findFirst: {\n            args: Prisma.NodeFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.NodeFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>\n          }\n          findMany: {\n            args: Prisma.NodeFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]\n          }\n          create: {\n            args: Prisma.NodeCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>\n          }\n          createMany: {\n            args: Prisma.NodeCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.NodeCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]\n          }\n          delete: {\n            args: Prisma.NodeDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>\n          }\n          update: {\n            args: Prisma.NodeUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>\n          }\n          deleteMany: {\n            args: Prisma.NodeDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.NodeUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.NodeUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>[]\n          }\n          upsert: {\n            args: Prisma.NodeUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$NodePayload>\n          }\n          aggregate: {\n            args: Prisma.NodeAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateNode>\n          }\n          groupBy: {\n            args: Prisma.NodeGroupByArgs<ExtArgs>\n            result: $Utils.Optional<NodeGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.NodeCountArgs<ExtArgs>\n            result: $Utils.Optional<NodeCountAggregateOutputType> | number\n          }\n        }\n      }\n      Edge: {\n        payload: Prisma.$EdgePayload<ExtArgs>\n        fields: Prisma.EdgeFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.EdgeFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.EdgeFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>\n          }\n          findFirst: {\n            args: Prisma.EdgeFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.EdgeFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>\n          }\n          findMany: {\n            args: Prisma.EdgeFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]\n          }\n          create: {\n            args: Prisma.EdgeCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>\n          }\n          createMany: {\n            args: Prisma.EdgeCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.EdgeCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]\n          }\n          delete: {\n            args: Prisma.EdgeDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>\n          }\n          update: {\n            args: Prisma.EdgeUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>\n          }\n          deleteMany: {\n            args: Prisma.EdgeDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.EdgeUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.EdgeUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>[]\n          }\n          upsert: {\n            args: Prisma.EdgeUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$EdgePayload>\n          }\n          aggregate: {\n            args: Prisma.EdgeAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateEdge>\n          }\n          groupBy: {\n            args: Prisma.EdgeGroupByArgs<ExtArgs>\n            result: $Utils.Optional<EdgeGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.EdgeCountArgs<ExtArgs>\n            result: $Utils.Optional<EdgeCountAggregateOutputType> | number\n          }\n        }\n      }\n      Execution: {\n        payload: Prisma.$ExecutionPayload<ExtArgs>\n        fields: Prisma.ExecutionFieldRefs\n        operations: {\n          findUnique: {\n            args: Prisma.ExecutionFindUniqueArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload> | null\n          }\n          findUniqueOrThrow: {\n            args: Prisma.ExecutionFindUniqueOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>\n          }\n          findFirst: {\n            args: Prisma.ExecutionFindFirstArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload> | null\n          }\n          findFirstOrThrow: {\n            args: Prisma.ExecutionFindFirstOrThrowArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>\n          }\n          findMany: {\n            args: Prisma.ExecutionFindManyArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>[]\n          }\n          create: {\n            args: Prisma.ExecutionCreateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>\n          }\n          createMany: {\n            args: Prisma.ExecutionCreateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          createManyAndReturn: {\n            args: Prisma.ExecutionCreateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>[]\n          }\n          delete: {\n            args: Prisma.ExecutionDeleteArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>\n          }\n          update: {\n            args: Prisma.ExecutionUpdateArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>\n          }\n          deleteMany: {\n            args: Prisma.ExecutionDeleteManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateMany: {\n            args: Prisma.ExecutionUpdateManyArgs<ExtArgs>\n            result: BatchPayload\n          }\n          updateManyAndReturn: {\n            args: Prisma.ExecutionUpdateManyAndReturnArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>[]\n          }\n          upsert: {\n            args: Prisma.ExecutionUpsertArgs<ExtArgs>\n            result: $Utils.PayloadToResult<Prisma.$ExecutionPayload>\n          }\n          aggregate: {\n            args: Prisma.ExecutionAggregateArgs<ExtArgs>\n            result: $Utils.Optional<AggregateExecution>\n          }\n          groupBy: {\n            args: Prisma.ExecutionGroupByArgs<ExtArgs>\n            result: $Utils.Optional<ExecutionGroupByOutputType>[]\n          }\n          count: {\n            args: Prisma.ExecutionCountArgs<ExtArgs>\n            result: $Utils.Optional<ExecutionCountAggregateOutputType> | number\n          }\n        }\n      }\n    }\n  } & {\n    other: {\n      payload: any\n      operations: {\n        $executeRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $executeRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n        $queryRaw: {\n          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],\n          result: any\n        }\n        $queryRawUnsafe: {\n          args: [query: string, ...values: any[]],\n          result: any\n        }\n      }\n    }\n  }\n  export const defineExtension: $Extensions.ExtendsHook<\"define\", Prisma.TypeMapCb, $Extensions.DefaultArgs>\n  export type DefaultPrismaClient = PrismaClient\n  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'\n  export interface PrismaClientOptions {\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasources?: Datasources\n    /**\n     * Overwrites the datasource url from your schema.prisma file\n     */\n    datasourceUrl?: string\n    /**\n     * @default \"colorless\"\n     */\n    errorFormat?: ErrorFormat\n    /**\n     * @example\n     * ```\n     * // Defaults to stdout\n     * log: ['query', 'info', 'warn', 'error']\n     * \n     * // Emit as events\n     * log: [\n     *   { emit: 'stdout', level: 'query' },\n     *   { emit: 'stdout', level: 'info' },\n     *   { emit: 'stdout', level: 'warn' }\n     *   { emit: 'stdout', level: 'error' }\n     * ]\n     * ```\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\n     */\n    log?: (LogLevel | LogDefinition)[]\n    /**\n     * The default values for transactionOptions\n     * maxWait ?= 2000\n     * timeout ?= 5000\n     */\n    transactionOptions?: {\n      maxWait?: number\n      timeout?: number\n      isolationLevel?: Prisma.TransactionIsolationLevel\n    }\n    /**\n     * Global configuration for omitting model fields by default.\n     * \n     * @example\n     * ```\n     * const prisma = new PrismaClient({\n     *   omit: {\n     *     user: {\n     *       password: true\n     *     }\n     *   }\n     * })\n     * ```\n     */\n    omit?: Prisma.GlobalOmitConfig\n  }\n  export type GlobalOmitConfig = {\n    user?: UserOmit\n    workflow?: WorkflowOmit\n    node?: NodeOmit\n    edge?: EdgeOmit\n    execution?: ExecutionOmit\n  }\n\n  /* Types for Logging */\n  export type LogLevel = 'info' | 'query' | 'warn' | 'error'\n  export type LogDefinition = {\n    level: LogLevel\n    emit: 'stdout' | 'event'\n  }\n\n  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never\n  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?\n    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>\n    : never\n\n  export type QueryEvent = {\n    timestamp: Date\n    query: string\n    params: string\n    duration: number\n    target: string\n  }\n\n  export type LogEvent = {\n    timestamp: Date\n    message: string\n    target: string\n  }\n  /* End Types for Logging */\n\n\n  export type PrismaAction =\n    | 'findUnique'\n    | 'findUniqueOrThrow'\n    | 'findMany'\n    | 'findFirst'\n    | 'findFirstOrThrow'\n    | 'create'\n    | 'createMany'\n    | 'createManyAndReturn'\n    | 'update'\n    | 'updateMany'\n    | 'updateManyAndReturn'\n    | 'upsert'\n    | 'delete'\n    | 'deleteMany'\n    | 'executeRaw'\n    | 'queryRaw'\n    | 'aggregate'\n    | 'count'\n    | 'runCommandRaw'\n    | 'findRaw'\n    | 'groupBy'\n\n  /**\n   * These options are being passed into the middleware as \"params\"\n   */\n  export type MiddlewareParams = {\n    model?: ModelName\n    action: PrismaAction\n    args: any\n    dataPath: string[]\n    runInTransaction: boolean\n  }\n\n  /**\n   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation\n   */\n  export type Middleware<T = any> = (\n    params: MiddlewareParams,\n    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,\n  ) => $Utils.JsPromise<T>\n\n  // tested in getLogLevel.test.ts\n  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;\n\n  /**\n   * `PrismaClient` proxy available in interactive transactions.\n   */\n  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>\n\n  export type Datasource = {\n    url?: string\n  }\n\n  /**\n   * Count Types\n   */\n\n\n  /**\n   * Count Type UserCountOutputType\n   */\n\n  export type UserCountOutputType = {\n    workflows: number\n  }\n\n  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflows?: boolean | UserCountOutputTypeCountWorkflowsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * UserCountOutputType without action\n   */\n  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the UserCountOutputType\n     */\n    select?: UserCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * UserCountOutputType without action\n   */\n  export type UserCountOutputTypeCountWorkflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: WorkflowWhereInput\n  }\n\n\n  /**\n   * Count Type WorkflowCountOutputType\n   */\n\n  export type WorkflowCountOutputType = {\n    nodes: number\n    edges: number\n    executions: number\n  }\n\n  export type WorkflowCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    nodes?: boolean | WorkflowCountOutputTypeCountNodesArgs\n    edges?: boolean | WorkflowCountOutputTypeCountEdgesArgs\n    executions?: boolean | WorkflowCountOutputTypeCountExecutionsArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * WorkflowCountOutputType without action\n   */\n  export type WorkflowCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the WorkflowCountOutputType\n     */\n    select?: WorkflowCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * WorkflowCountOutputType without action\n   */\n  export type WorkflowCountOutputTypeCountNodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: NodeWhereInput\n  }\n\n  /**\n   * WorkflowCountOutputType without action\n   */\n  export type WorkflowCountOutputTypeCountEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: EdgeWhereInput\n  }\n\n  /**\n   * WorkflowCountOutputType without action\n   */\n  export type WorkflowCountOutputTypeCountExecutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: ExecutionWhereInput\n  }\n\n\n  /**\n   * Count Type NodeCountOutputType\n   */\n\n  export type NodeCountOutputType = {\n    sourceEdges: number\n    targetEdges: number\n  }\n\n  export type NodeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    sourceEdges?: boolean | NodeCountOutputTypeCountSourceEdgesArgs\n    targetEdges?: boolean | NodeCountOutputTypeCountTargetEdgesArgs\n  }\n\n  // Custom InputTypes\n  /**\n   * NodeCountOutputType without action\n   */\n  export type NodeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the NodeCountOutputType\n     */\n    select?: NodeCountOutputTypeSelect<ExtArgs> | null\n  }\n\n  /**\n   * NodeCountOutputType without action\n   */\n  export type NodeCountOutputTypeCountSourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: EdgeWhereInput\n  }\n\n  /**\n   * NodeCountOutputType without action\n   */\n  export type NodeCountOutputTypeCountTargetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: EdgeWhereInput\n  }\n\n\n  /**\n   * Models\n   */\n\n  /**\n   * Model User\n   */\n\n  export type AggregateUser = {\n    _count: UserCountAggregateOutputType | null\n    _min: UserMinAggregateOutputType | null\n    _max: UserMaxAggregateOutputType | null\n  }\n\n  export type UserMinAggregateOutputType = {\n    id: string | null\n    email: string | null\n    name: string | null\n    password: string | null\n    createdAt: Date | null\n    updatedAt: Date | null\n  }\n\n  export type UserMaxAggregateOutputType = {\n    id: string | null\n    email: string | null\n    name: string | null\n    password: string | null\n    createdAt: Date | null\n    updatedAt: Date | null\n  }\n\n  export type UserCountAggregateOutputType = {\n    id: number\n    email: number\n    name: number\n    password: number\n    createdAt: number\n    updatedAt: number\n    _all: number\n  }\n\n\n  export type UserMinAggregateInputType = {\n    id?: true\n    email?: true\n    name?: true\n    password?: true\n    createdAt?: true\n    updatedAt?: true\n  }\n\n  export type UserMaxAggregateInputType = {\n    id?: true\n    email?: true\n    name?: true\n    password?: true\n    createdAt?: true\n    updatedAt?: true\n  }\n\n  export type UserCountAggregateInputType = {\n    id?: true\n    email?: true\n    name?: true\n    password?: true\n    createdAt?: true\n    updatedAt?: true\n    _all?: true\n  }\n\n  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which User to aggregate.\n     */\n    where?: UserWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Users to fetch.\n     */\n    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: UserWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned Users\n    **/\n    _count?: true | UserCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: UserMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: UserMaxAggregateInputType\n  }\n\n  export type GetUserAggregateType<T extends UserAggregateArgs> = {\n        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateUser[P]>\n      : GetScalarType<T[P], AggregateUser[P]>\n  }\n\n\n\n\n  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: UserWhereInput\n    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]\n    by: UserScalarFieldEnum[] | UserScalarFieldEnum\n    having?: UserScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: UserCountAggregateInputType | true\n    _min?: UserMinAggregateInputType\n    _max?: UserMaxAggregateInputType\n  }\n\n  export type UserGroupByOutputType = {\n    id: string\n    email: string\n    name: string | null\n    password: string\n    createdAt: Date\n    updatedAt: Date\n    _count: UserCountAggregateOutputType | null\n    _min: UserMinAggregateOutputType | null\n    _max: UserMaxAggregateOutputType | null\n  }\n\n  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<UserGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], UserGroupByOutputType[P]>\n            : GetScalarType<T[P], UserGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    name?: boolean\n    password?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n    workflows?: boolean | User$workflowsArgs<ExtArgs>\n    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"user\"]>\n\n  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    name?: boolean\n    password?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n  }, ExtArgs[\"result\"][\"user\"]>\n\n  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    email?: boolean\n    name?: boolean\n    password?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n  }, ExtArgs[\"result\"][\"user\"]>\n\n  export type UserSelectScalar = {\n    id?: boolean\n    email?: boolean\n    name?: boolean\n    password?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n  }\n\n  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"email\" | \"name\" | \"password\" | \"createdAt\" | \"updatedAt\", ExtArgs[\"result\"][\"user\"]>\n  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflows?: boolean | User$workflowsArgs<ExtArgs>\n    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}\n\n  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"User\"\n    objects: {\n      workflows: Prisma.$WorkflowPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      id: string\n      email: string\n      name: string | null\n      password: string\n      createdAt: Date\n      updatedAt: Date\n    }, ExtArgs[\"result\"][\"user\"]>\n    composites: {}\n  }\n\n  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>\n\n  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: UserCountAggregateInputType | true\n    }\n\n  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }\n    /**\n     * Find zero or one User that matches the filter.\n     * @param {UserFindUniqueArgs} args - Arguments to find a User\n     * @example\n     * // Get one User\n     * const user = await prisma.user.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one User that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User\n     * @example\n     * // Get one User\n     * const user = await prisma.user.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first User that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserFindFirstArgs} args - Arguments to find a User\n     * @example\n     * // Get one User\n     * const user = await prisma.user.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first User that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User\n     * @example\n     * // Get one User\n     * const user = await prisma.user.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Users that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Users\n     * const users = await prisma.user.findMany()\n     * \n     * // Get first 10 Users\n     * const users = await prisma.user.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a User.\n     * @param {UserCreateArgs} args - Arguments to create a User.\n     * @example\n     * // Create one User\n     * const User = await prisma.user.create({\n     *   data: {\n     *     // ... data to create a User\n     *   }\n     * })\n     * \n     */\n    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Users.\n     * @param {UserCreateManyArgs} args - Arguments to create many Users.\n     * @example\n     * // Create many Users\n     * const user = await prisma.user.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Users and returns the data saved in the database.\n     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.\n     * @example\n     * // Create many Users\n     * const user = await prisma.user.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Users and only return the `id`\n     * const userWithIdOnly = await prisma.user.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a User.\n     * @param {UserDeleteArgs} args - Arguments to delete one User.\n     * @example\n     * // Delete one User\n     * const User = await prisma.user.delete({\n     *   where: {\n     *     // ... filter to delete one User\n     *   }\n     * })\n     * \n     */\n    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one User.\n     * @param {UserUpdateArgs} args - Arguments to update one User.\n     * @example\n     * // Update one User\n     * const user = await prisma.user.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Users.\n     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.\n     * @example\n     * // Delete a few Users\n     * const { count } = await prisma.user.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Users\n     * const user = await prisma.user.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Users and returns the data updated in the database.\n     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.\n     * @example\n     * // Update many Users\n     * const user = await prisma.user.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Users and only return the `id`\n     * const userWithIdOnly = await prisma.user.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one User.\n     * @param {UserUpsertArgs} args - Arguments to update or create a User.\n     * @example\n     * // Update or create a User\n     * const user = await prisma.user.upsert({\n     *   create: {\n     *     // ... data to create a User\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the User we want to update\n     *   }\n     * })\n     */\n    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Users.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserCountArgs} args - Arguments to filter Users to count.\n     * @example\n     * // Count the number of Users\n     * const count = await prisma.user.count({\n     *   where: {\n     *     // ... the filter for the Users we want to count\n     *   }\n     * })\n    **/\n    count<T extends UserCountArgs>(\n      args?: Subset<T, UserCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], UserCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a User.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>\n\n    /**\n     * Group by User.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {UserGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends UserGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: UserGroupByArgs['orderBy'] }\n        : { orderBy?: UserGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the User model\n   */\n  readonly fields: UserFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for User.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    workflows<T extends User$workflowsArgs<ExtArgs> = {}>(args?: Subset<T, User$workflowsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the User model\n   */\n  interface UserFieldRefs {\n    readonly id: FieldRef<\"User\", 'String'>\n    readonly email: FieldRef<\"User\", 'String'>\n    readonly name: FieldRef<\"User\", 'String'>\n    readonly password: FieldRef<\"User\", 'String'>\n    readonly createdAt: FieldRef<\"User\", 'DateTime'>\n    readonly updatedAt: FieldRef<\"User\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * User findUnique\n   */\n  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * Filter, which User to fetch.\n     */\n    where: UserWhereUniqueInput\n  }\n\n  /**\n   * User findUniqueOrThrow\n   */\n  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * Filter, which User to fetch.\n     */\n    where: UserWhereUniqueInput\n  }\n\n  /**\n   * User findFirst\n   */\n  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * Filter, which User to fetch.\n     */\n    where?: UserWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Users to fetch.\n     */\n    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Users.\n     */\n    cursor?: UserWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Users.\n     */\n    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]\n  }\n\n  /**\n   * User findFirstOrThrow\n   */\n  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * Filter, which User to fetch.\n     */\n    where?: UserWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Users to fetch.\n     */\n    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Users.\n     */\n    cursor?: UserWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Users.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Users.\n     */\n    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]\n  }\n\n  /**\n   * User findMany\n   */\n  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * Filter, which Users to fetch.\n     */\n    where?: UserWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Users to fetch.\n     */\n    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing Users.\n     */\n    cursor?: UserWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Users from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Users.\n     */\n    skip?: number\n    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]\n  }\n\n  /**\n   * User create\n   */\n  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * The data needed to create a User.\n     */\n    data: XOR<UserCreateInput, UserUncheckedCreateInput>\n  }\n\n  /**\n   * User createMany\n   */\n  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many Users.\n     */\n    data: UserCreateManyInput | UserCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * User createManyAndReturn\n   */\n  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * The data used to create many Users.\n     */\n    data: UserCreateManyInput | UserCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * User update\n   */\n  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * The data needed to update a User.\n     */\n    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>\n    /**\n     * Choose, which User to update.\n     */\n    where: UserWhereUniqueInput\n  }\n\n  /**\n   * User updateMany\n   */\n  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update Users.\n     */\n    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>\n    /**\n     * Filter which Users to update\n     */\n    where?: UserWhereInput\n    /**\n     * Limit how many Users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * User updateManyAndReturn\n   */\n  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * The data used to update Users.\n     */\n    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>\n    /**\n     * Filter which Users to update\n     */\n    where?: UserWhereInput\n    /**\n     * Limit how many Users to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * User upsert\n   */\n  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * The filter to search for the User to update in case it exists.\n     */\n    where: UserWhereUniqueInput\n    /**\n     * In case the User found by the `where` argument doesn't exist, create a new User with this data.\n     */\n    create: XOR<UserCreateInput, UserUncheckedCreateInput>\n    /**\n     * In case the User was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>\n  }\n\n  /**\n   * User delete\n   */\n  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n    /**\n     * Filter which User to delete.\n     */\n    where: UserWhereUniqueInput\n  }\n\n  /**\n   * User deleteMany\n   */\n  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Users to delete\n     */\n    where?: UserWhereInput\n    /**\n     * Limit how many Users to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * User.workflows\n   */\n  export type User$workflowsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    where?: WorkflowWhereInput\n    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]\n    cursor?: WorkflowWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]\n  }\n\n  /**\n   * User without action\n   */\n  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the User\n     */\n    select?: UserSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the User\n     */\n    omit?: UserOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: UserInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model Workflow\n   */\n\n  export type AggregateWorkflow = {\n    _count: WorkflowCountAggregateOutputType | null\n    _min: WorkflowMinAggregateOutputType | null\n    _max: WorkflowMaxAggregateOutputType | null\n  }\n\n  export type WorkflowMinAggregateOutputType = {\n    id: string | null\n    name: string | null\n    userId: string | null\n    createdAt: Date | null\n    updatedAt: Date | null\n  }\n\n  export type WorkflowMaxAggregateOutputType = {\n    id: string | null\n    name: string | null\n    userId: string | null\n    createdAt: Date | null\n    updatedAt: Date | null\n  }\n\n  export type WorkflowCountAggregateOutputType = {\n    id: number\n    name: number\n    userId: number\n    createdAt: number\n    updatedAt: number\n    _all: number\n  }\n\n\n  export type WorkflowMinAggregateInputType = {\n    id?: true\n    name?: true\n    userId?: true\n    createdAt?: true\n    updatedAt?: true\n  }\n\n  export type WorkflowMaxAggregateInputType = {\n    id?: true\n    name?: true\n    userId?: true\n    createdAt?: true\n    updatedAt?: true\n  }\n\n  export type WorkflowCountAggregateInputType = {\n    id?: true\n    name?: true\n    userId?: true\n    createdAt?: true\n    updatedAt?: true\n    _all?: true\n  }\n\n  export type WorkflowAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Workflow to aggregate.\n     */\n    where?: WorkflowWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Workflows to fetch.\n     */\n    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: WorkflowWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Workflows from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Workflows.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned Workflows\n    **/\n    _count?: true | WorkflowCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: WorkflowMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: WorkflowMaxAggregateInputType\n  }\n\n  export type GetWorkflowAggregateType<T extends WorkflowAggregateArgs> = {\n        [P in keyof T & keyof AggregateWorkflow]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateWorkflow[P]>\n      : GetScalarType<T[P], AggregateWorkflow[P]>\n  }\n\n\n\n\n  export type WorkflowGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: WorkflowWhereInput\n    orderBy?: WorkflowOrderByWithAggregationInput | WorkflowOrderByWithAggregationInput[]\n    by: WorkflowScalarFieldEnum[] | WorkflowScalarFieldEnum\n    having?: WorkflowScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: WorkflowCountAggregateInputType | true\n    _min?: WorkflowMinAggregateInputType\n    _max?: WorkflowMaxAggregateInputType\n  }\n\n  export type WorkflowGroupByOutputType = {\n    id: string\n    name: string\n    userId: string\n    createdAt: Date\n    updatedAt: Date\n    _count: WorkflowCountAggregateOutputType | null\n    _min: WorkflowMinAggregateOutputType | null\n    _max: WorkflowMaxAggregateOutputType | null\n  }\n\n  type GetWorkflowGroupByPayload<T extends WorkflowGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<WorkflowGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof WorkflowGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], WorkflowGroupByOutputType[P]>\n            : GetScalarType<T[P], WorkflowGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type WorkflowSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    userId?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n    user?: boolean | UserDefaultArgs<ExtArgs>\n    nodes?: boolean | Workflow$nodesArgs<ExtArgs>\n    edges?: boolean | Workflow$edgesArgs<ExtArgs>\n    executions?: boolean | Workflow$executionsArgs<ExtArgs>\n    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"workflow\"]>\n\n  export type WorkflowSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    userId?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n    user?: boolean | UserDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"workflow\"]>\n\n  export type WorkflowSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    name?: boolean\n    userId?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n    user?: boolean | UserDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"workflow\"]>\n\n  export type WorkflowSelectScalar = {\n    id?: boolean\n    name?: boolean\n    userId?: boolean\n    createdAt?: boolean\n    updatedAt?: boolean\n  }\n\n  export type WorkflowOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"name\" | \"userId\" | \"createdAt\" | \"updatedAt\", ExtArgs[\"result\"][\"workflow\"]>\n  export type WorkflowInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | UserDefaultArgs<ExtArgs>\n    nodes?: boolean | Workflow$nodesArgs<ExtArgs>\n    edges?: boolean | Workflow$edgesArgs<ExtArgs>\n    executions?: boolean | Workflow$executionsArgs<ExtArgs>\n    _count?: boolean | WorkflowCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type WorkflowIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | UserDefaultArgs<ExtArgs>\n  }\n  export type WorkflowIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    user?: boolean | UserDefaultArgs<ExtArgs>\n  }\n\n  export type $WorkflowPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"Workflow\"\n    objects: {\n      user: Prisma.$UserPayload<ExtArgs>\n      nodes: Prisma.$NodePayload<ExtArgs>[]\n      edges: Prisma.$EdgePayload<ExtArgs>[]\n      executions: Prisma.$ExecutionPayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      id: string\n      name: string\n      userId: string\n      createdAt: Date\n      updatedAt: Date\n    }, ExtArgs[\"result\"][\"workflow\"]>\n    composites: {}\n  }\n\n  type WorkflowGetPayload<S extends boolean | null | undefined | WorkflowDefaultArgs> = $Result.GetResult<Prisma.$WorkflowPayload, S>\n\n  type WorkflowCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<WorkflowFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: WorkflowCountAggregateInputType | true\n    }\n\n  export interface WorkflowDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Workflow'], meta: { name: 'Workflow' } }\n    /**\n     * Find zero or one Workflow that matches the filter.\n     * @param {WorkflowFindUniqueArgs} args - Arguments to find a Workflow\n     * @example\n     * // Get one Workflow\n     * const workflow = await prisma.workflow.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends WorkflowFindUniqueArgs>(args: SelectSubset<T, WorkflowFindUniqueArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Workflow that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {WorkflowFindUniqueOrThrowArgs} args - Arguments to find a Workflow\n     * @example\n     * // Get one Workflow\n     * const workflow = await prisma.workflow.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends WorkflowFindUniqueOrThrowArgs>(args: SelectSubset<T, WorkflowFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Workflow that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {WorkflowFindFirstArgs} args - Arguments to find a Workflow\n     * @example\n     * // Get one Workflow\n     * const workflow = await prisma.workflow.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends WorkflowFindFirstArgs>(args?: SelectSubset<T, WorkflowFindFirstArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Workflow that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {WorkflowFindFirstOrThrowArgs} args - Arguments to find a Workflow\n     * @example\n     * // Get one Workflow\n     * const workflow = await prisma.workflow.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends WorkflowFindFirstOrThrowArgs>(args?: SelectSubset<T, WorkflowFindFirstOrThrowArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Workflows that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {WorkflowFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Workflows\n     * const workflows = await prisma.workflow.findMany()\n     * \n     * // Get first 10 Workflows\n     * const workflows = await prisma.workflow.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const workflowWithIdOnly = await prisma.workflow.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends WorkflowFindManyArgs>(args?: SelectSubset<T, WorkflowFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Workflow.\n     * @param {WorkflowCreateArgs} args - Arguments to create a Workflow.\n     * @example\n     * // Create one Workflow\n     * const Workflow = await prisma.workflow.create({\n     *   data: {\n     *     // ... data to create a Workflow\n     *   }\n     * })\n     * \n     */\n    create<T extends WorkflowCreateArgs>(args: SelectSubset<T, WorkflowCreateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Workflows.\n     * @param {WorkflowCreateManyArgs} args - Arguments to create many Workflows.\n     * @example\n     * // Create many Workflows\n     * const workflow = await prisma.workflow.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends WorkflowCreateManyArgs>(args?: SelectSubset<T, WorkflowCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Workflows and returns the data saved in the database.\n     * @param {WorkflowCreateManyAndReturnArgs} args - Arguments to create many Workflows.\n     * @example\n     * // Create many Workflows\n     * const workflow = await prisma.workflow.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Workflows and only return the `id`\n     * const workflowWithIdOnly = await prisma.workflow.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends WorkflowCreateManyAndReturnArgs>(args?: SelectSubset<T, WorkflowCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Workflow.\n     * @param {WorkflowDeleteArgs} args - Arguments to delete one Workflow.\n     * @example\n     * // Delete one Workflow\n     * const Workflow = await prisma.workflow.delete({\n     *   where: {\n     *     // ... filter to delete one Workflow\n     *   }\n     * })\n     * \n     */\n    delete<T extends WorkflowDeleteArgs>(args: SelectSubset<T, WorkflowDeleteArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Workflow.\n     * @param {WorkflowUpdateArgs} args - Arguments to update one Workflow.\n     * @example\n     * // Update one Workflow\n     * const workflow = await prisma.workflow.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends WorkflowUpdateArgs>(args: SelectSubset<T, WorkflowUpdateArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Workflows.\n     * @param {WorkflowDeleteManyArgs} args - Arguments to filter Workflows to delete.\n     * @example\n     * // Delete a few Workflows\n     * const { count } = await prisma.workflow.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends WorkflowDeleteManyArgs>(args?: SelectSubset<T, WorkflowDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Workflows.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {WorkflowUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Workflows\n     * const workflow = await prisma.workflow.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends WorkflowUpdateManyArgs>(args: SelectSubset<T, WorkflowUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Workflows and returns the data updated in the database.\n     * @param {WorkflowUpdateManyAndReturnArgs} args - Arguments to update many Workflows.\n     * @example\n     * // Update many Workflows\n     * const workflow = await prisma.workflow.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Workflows and only return the `id`\n     * const workflowWithIdOnly = await prisma.workflow.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends WorkflowUpdateManyAndReturnArgs>(args: SelectSubset<T, WorkflowUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Workflow.\n     * @param {WorkflowUpsertArgs} args - Arguments to update or create a Workflow.\n     * @example\n     * // Update or create a Workflow\n     * const workflow = await prisma.workflow.upsert({\n     *   create: {\n     *     // ... data to create a Workflow\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Workflow we want to update\n     *   }\n     * })\n     */\n    upsert<T extends WorkflowUpsertArgs>(args: SelectSubset<T, WorkflowUpsertArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Workflows.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {WorkflowCountArgs} args - Arguments to filter Workflows to count.\n     * @example\n     * // Count the number of Workflows\n     * const count = await prisma.workflow.count({\n     *   where: {\n     *     // ... the filter for the Workflows we want to count\n     *   }\n     * })\n    **/\n    count<T extends WorkflowCountArgs>(\n      args?: Subset<T, WorkflowCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], WorkflowCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Workflow.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {WorkflowAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends WorkflowAggregateArgs>(args: Subset<T, WorkflowAggregateArgs>): Prisma.PrismaPromise<GetWorkflowAggregateType<T>>\n\n    /**\n     * Group by Workflow.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {WorkflowGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends WorkflowGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: WorkflowGroupByArgs['orderBy'] }\n        : { orderBy?: WorkflowGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, WorkflowGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWorkflowGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the Workflow model\n   */\n  readonly fields: WorkflowFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for Workflow.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__WorkflowClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    nodes<T extends Workflow$nodesArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$nodesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    edges<T extends Workflow$edgesArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$edgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    executions<T extends Workflow$executionsArgs<ExtArgs> = {}>(args?: Subset<T, Workflow$executionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the Workflow model\n   */\n  interface WorkflowFieldRefs {\n    readonly id: FieldRef<\"Workflow\", 'String'>\n    readonly name: FieldRef<\"Workflow\", 'String'>\n    readonly userId: FieldRef<\"Workflow\", 'String'>\n    readonly createdAt: FieldRef<\"Workflow\", 'DateTime'>\n    readonly updatedAt: FieldRef<\"Workflow\", 'DateTime'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * Workflow findUnique\n   */\n  export type WorkflowFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * Filter, which Workflow to fetch.\n     */\n    where: WorkflowWhereUniqueInput\n  }\n\n  /**\n   * Workflow findUniqueOrThrow\n   */\n  export type WorkflowFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * Filter, which Workflow to fetch.\n     */\n    where: WorkflowWhereUniqueInput\n  }\n\n  /**\n   * Workflow findFirst\n   */\n  export type WorkflowFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * Filter, which Workflow to fetch.\n     */\n    where?: WorkflowWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Workflows to fetch.\n     */\n    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Workflows.\n     */\n    cursor?: WorkflowWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Workflows from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Workflows.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Workflows.\n     */\n    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]\n  }\n\n  /**\n   * Workflow findFirstOrThrow\n   */\n  export type WorkflowFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * Filter, which Workflow to fetch.\n     */\n    where?: WorkflowWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Workflows to fetch.\n     */\n    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Workflows.\n     */\n    cursor?: WorkflowWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Workflows from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Workflows.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Workflows.\n     */\n    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]\n  }\n\n  /**\n   * Workflow findMany\n   */\n  export type WorkflowFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * Filter, which Workflows to fetch.\n     */\n    where?: WorkflowWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Workflows to fetch.\n     */\n    orderBy?: WorkflowOrderByWithRelationInput | WorkflowOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing Workflows.\n     */\n    cursor?: WorkflowWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Workflows from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Workflows.\n     */\n    skip?: number\n    distinct?: WorkflowScalarFieldEnum | WorkflowScalarFieldEnum[]\n  }\n\n  /**\n   * Workflow create\n   */\n  export type WorkflowCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * The data needed to create a Workflow.\n     */\n    data: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>\n  }\n\n  /**\n   * Workflow createMany\n   */\n  export type WorkflowCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many Workflows.\n     */\n    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * Workflow createManyAndReturn\n   */\n  export type WorkflowCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * The data used to create many Workflows.\n     */\n    data: WorkflowCreateManyInput | WorkflowCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Workflow update\n   */\n  export type WorkflowUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * The data needed to update a Workflow.\n     */\n    data: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>\n    /**\n     * Choose, which Workflow to update.\n     */\n    where: WorkflowWhereUniqueInput\n  }\n\n  /**\n   * Workflow updateMany\n   */\n  export type WorkflowUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update Workflows.\n     */\n    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>\n    /**\n     * Filter which Workflows to update\n     */\n    where?: WorkflowWhereInput\n    /**\n     * Limit how many Workflows to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * Workflow updateManyAndReturn\n   */\n  export type WorkflowUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * The data used to update Workflows.\n     */\n    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyInput>\n    /**\n     * Filter which Workflows to update\n     */\n    where?: WorkflowWhereInput\n    /**\n     * Limit how many Workflows to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Workflow upsert\n   */\n  export type WorkflowUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * The filter to search for the Workflow to update in case it exists.\n     */\n    where: WorkflowWhereUniqueInput\n    /**\n     * In case the Workflow found by the `where` argument doesn't exist, create a new Workflow with this data.\n     */\n    create: XOR<WorkflowCreateInput, WorkflowUncheckedCreateInput>\n    /**\n     * In case the Workflow was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<WorkflowUpdateInput, WorkflowUncheckedUpdateInput>\n  }\n\n  /**\n   * Workflow delete\n   */\n  export type WorkflowDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n    /**\n     * Filter which Workflow to delete.\n     */\n    where: WorkflowWhereUniqueInput\n  }\n\n  /**\n   * Workflow deleteMany\n   */\n  export type WorkflowDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Workflows to delete\n     */\n    where?: WorkflowWhereInput\n    /**\n     * Limit how many Workflows to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * Workflow.nodes\n   */\n  export type Workflow$nodesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    where?: NodeWhereInput\n    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]\n    cursor?: NodeWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]\n  }\n\n  /**\n   * Workflow.edges\n   */\n  export type Workflow$edgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    where?: EdgeWhereInput\n    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]\n    cursor?: EdgeWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]\n  }\n\n  /**\n   * Workflow.executions\n   */\n  export type Workflow$executionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    where?: ExecutionWhereInput\n    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]\n    cursor?: ExecutionWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]\n  }\n\n  /**\n   * Workflow without action\n   */\n  export type WorkflowDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Workflow\n     */\n    select?: WorkflowSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Workflow\n     */\n    omit?: WorkflowOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: WorkflowInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model Node\n   */\n\n  export type AggregateNode = {\n    _count: NodeCountAggregateOutputType | null\n    _avg: NodeAvgAggregateOutputType | null\n    _sum: NodeSumAggregateOutputType | null\n    _min: NodeMinAggregateOutputType | null\n    _max: NodeMaxAggregateOutputType | null\n  }\n\n  export type NodeAvgAggregateOutputType = {\n    positionX: number | null\n    positionY: number | null\n  }\n\n  export type NodeSumAggregateOutputType = {\n    positionX: number | null\n    positionY: number | null\n  }\n\n  export type NodeMinAggregateOutputType = {\n    id: string | null\n    type: string | null\n    positionX: number | null\n    positionY: number | null\n    workflowId: string | null\n  }\n\n  export type NodeMaxAggregateOutputType = {\n    id: string | null\n    type: string | null\n    positionX: number | null\n    positionY: number | null\n    workflowId: string | null\n  }\n\n  export type NodeCountAggregateOutputType = {\n    id: number\n    type: number\n    data: number\n    positionX: number\n    positionY: number\n    workflowId: number\n    _all: number\n  }\n\n\n  export type NodeAvgAggregateInputType = {\n    positionX?: true\n    positionY?: true\n  }\n\n  export type NodeSumAggregateInputType = {\n    positionX?: true\n    positionY?: true\n  }\n\n  export type NodeMinAggregateInputType = {\n    id?: true\n    type?: true\n    positionX?: true\n    positionY?: true\n    workflowId?: true\n  }\n\n  export type NodeMaxAggregateInputType = {\n    id?: true\n    type?: true\n    positionX?: true\n    positionY?: true\n    workflowId?: true\n  }\n\n  export type NodeCountAggregateInputType = {\n    id?: true\n    type?: true\n    data?: true\n    positionX?: true\n    positionY?: true\n    workflowId?: true\n    _all?: true\n  }\n\n  export type NodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Node to aggregate.\n     */\n    where?: NodeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Nodes to fetch.\n     */\n    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: NodeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Nodes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Nodes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned Nodes\n    **/\n    _count?: true | NodeCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to average\n    **/\n    _avg?: NodeAvgAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to sum\n    **/\n    _sum?: NodeSumAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: NodeMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: NodeMaxAggregateInputType\n  }\n\n  export type GetNodeAggregateType<T extends NodeAggregateArgs> = {\n        [P in keyof T & keyof AggregateNode]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateNode[P]>\n      : GetScalarType<T[P], AggregateNode[P]>\n  }\n\n\n\n\n  export type NodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: NodeWhereInput\n    orderBy?: NodeOrderByWithAggregationInput | NodeOrderByWithAggregationInput[]\n    by: NodeScalarFieldEnum[] | NodeScalarFieldEnum\n    having?: NodeScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: NodeCountAggregateInputType | true\n    _avg?: NodeAvgAggregateInputType\n    _sum?: NodeSumAggregateInputType\n    _min?: NodeMinAggregateInputType\n    _max?: NodeMaxAggregateInputType\n  }\n\n  export type NodeGroupByOutputType = {\n    id: string\n    type: string\n    data: JsonValue\n    positionX: number\n    positionY: number\n    workflowId: string\n    _count: NodeCountAggregateOutputType | null\n    _avg: NodeAvgAggregateOutputType | null\n    _sum: NodeSumAggregateOutputType | null\n    _min: NodeMinAggregateOutputType | null\n    _max: NodeMaxAggregateOutputType | null\n  }\n\n  type GetNodeGroupByPayload<T extends NodeGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<NodeGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof NodeGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], NodeGroupByOutputType[P]>\n            : GetScalarType<T[P], NodeGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type NodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    type?: boolean\n    data?: boolean\n    positionX?: boolean\n    positionY?: boolean\n    workflowId?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceEdges?: boolean | Node$sourceEdgesArgs<ExtArgs>\n    targetEdges?: boolean | Node$targetEdgesArgs<ExtArgs>\n    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"node\"]>\n\n  export type NodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    type?: boolean\n    data?: boolean\n    positionX?: boolean\n    positionY?: boolean\n    workflowId?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"node\"]>\n\n  export type NodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    type?: boolean\n    data?: boolean\n    positionX?: boolean\n    positionY?: boolean\n    workflowId?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"node\"]>\n\n  export type NodeSelectScalar = {\n    id?: boolean\n    type?: boolean\n    data?: boolean\n    positionX?: boolean\n    positionY?: boolean\n    workflowId?: boolean\n  }\n\n  export type NodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"type\" | \"data\" | \"positionX\" | \"positionY\" | \"workflowId\", ExtArgs[\"result\"][\"node\"]>\n  export type NodeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceEdges?: boolean | Node$sourceEdgesArgs<ExtArgs>\n    targetEdges?: boolean | Node$targetEdgesArgs<ExtArgs>\n    _count?: boolean | NodeCountOutputTypeDefaultArgs<ExtArgs>\n  }\n  export type NodeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }\n  export type NodeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }\n\n  export type $NodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"Node\"\n    objects: {\n      workflow: Prisma.$WorkflowPayload<ExtArgs>\n      sourceEdges: Prisma.$EdgePayload<ExtArgs>[]\n      targetEdges: Prisma.$EdgePayload<ExtArgs>[]\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      id: string\n      type: string\n      data: Prisma.JsonValue\n      positionX: number\n      positionY: number\n      workflowId: string\n    }, ExtArgs[\"result\"][\"node\"]>\n    composites: {}\n  }\n\n  type NodeGetPayload<S extends boolean | null | undefined | NodeDefaultArgs> = $Result.GetResult<Prisma.$NodePayload, S>\n\n  type NodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<NodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: NodeCountAggregateInputType | true\n    }\n\n  export interface NodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Node'], meta: { name: 'Node' } }\n    /**\n     * Find zero or one Node that matches the filter.\n     * @param {NodeFindUniqueArgs} args - Arguments to find a Node\n     * @example\n     * // Get one Node\n     * const node = await prisma.node.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends NodeFindUniqueArgs>(args: SelectSubset<T, NodeFindUniqueArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Node that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {NodeFindUniqueOrThrowArgs} args - Arguments to find a Node\n     * @example\n     * // Get one Node\n     * const node = await prisma.node.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends NodeFindUniqueOrThrowArgs>(args: SelectSubset<T, NodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Node that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {NodeFindFirstArgs} args - Arguments to find a Node\n     * @example\n     * // Get one Node\n     * const node = await prisma.node.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends NodeFindFirstArgs>(args?: SelectSubset<T, NodeFindFirstArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Node that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {NodeFindFirstOrThrowArgs} args - Arguments to find a Node\n     * @example\n     * // Get one Node\n     * const node = await prisma.node.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends NodeFindFirstOrThrowArgs>(args?: SelectSubset<T, NodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Nodes that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {NodeFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Nodes\n     * const nodes = await prisma.node.findMany()\n     * \n     * // Get first 10 Nodes\n     * const nodes = await prisma.node.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const nodeWithIdOnly = await prisma.node.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends NodeFindManyArgs>(args?: SelectSubset<T, NodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Node.\n     * @param {NodeCreateArgs} args - Arguments to create a Node.\n     * @example\n     * // Create one Node\n     * const Node = await prisma.node.create({\n     *   data: {\n     *     // ... data to create a Node\n     *   }\n     * })\n     * \n     */\n    create<T extends NodeCreateArgs>(args: SelectSubset<T, NodeCreateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Nodes.\n     * @param {NodeCreateManyArgs} args - Arguments to create many Nodes.\n     * @example\n     * // Create many Nodes\n     * const node = await prisma.node.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends NodeCreateManyArgs>(args?: SelectSubset<T, NodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Nodes and returns the data saved in the database.\n     * @param {NodeCreateManyAndReturnArgs} args - Arguments to create many Nodes.\n     * @example\n     * // Create many Nodes\n     * const node = await prisma.node.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Nodes and only return the `id`\n     * const nodeWithIdOnly = await prisma.node.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends NodeCreateManyAndReturnArgs>(args?: SelectSubset<T, NodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Node.\n     * @param {NodeDeleteArgs} args - Arguments to delete one Node.\n     * @example\n     * // Delete one Node\n     * const Node = await prisma.node.delete({\n     *   where: {\n     *     // ... filter to delete one Node\n     *   }\n     * })\n     * \n     */\n    delete<T extends NodeDeleteArgs>(args: SelectSubset<T, NodeDeleteArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Node.\n     * @param {NodeUpdateArgs} args - Arguments to update one Node.\n     * @example\n     * // Update one Node\n     * const node = await prisma.node.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends NodeUpdateArgs>(args: SelectSubset<T, NodeUpdateArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Nodes.\n     * @param {NodeDeleteManyArgs} args - Arguments to filter Nodes to delete.\n     * @example\n     * // Delete a few Nodes\n     * const { count } = await prisma.node.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends NodeDeleteManyArgs>(args?: SelectSubset<T, NodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Nodes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {NodeUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Nodes\n     * const node = await prisma.node.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends NodeUpdateManyArgs>(args: SelectSubset<T, NodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Nodes and returns the data updated in the database.\n     * @param {NodeUpdateManyAndReturnArgs} args - Arguments to update many Nodes.\n     * @example\n     * // Update many Nodes\n     * const node = await prisma.node.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Nodes and only return the `id`\n     * const nodeWithIdOnly = await prisma.node.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends NodeUpdateManyAndReturnArgs>(args: SelectSubset<T, NodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Node.\n     * @param {NodeUpsertArgs} args - Arguments to update or create a Node.\n     * @example\n     * // Update or create a Node\n     * const node = await prisma.node.upsert({\n     *   create: {\n     *     // ... data to create a Node\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Node we want to update\n     *   }\n     * })\n     */\n    upsert<T extends NodeUpsertArgs>(args: SelectSubset<T, NodeUpsertArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Nodes.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {NodeCountArgs} args - Arguments to filter Nodes to count.\n     * @example\n     * // Count the number of Nodes\n     * const count = await prisma.node.count({\n     *   where: {\n     *     // ... the filter for the Nodes we want to count\n     *   }\n     * })\n    **/\n    count<T extends NodeCountArgs>(\n      args?: Subset<T, NodeCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], NodeCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Node.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {NodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends NodeAggregateArgs>(args: Subset<T, NodeAggregateArgs>): Prisma.PrismaPromise<GetNodeAggregateType<T>>\n\n    /**\n     * Group by Node.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {NodeGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends NodeGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: NodeGroupByArgs['orderBy'] }\n        : { orderBy?: NodeGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, NodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the Node model\n   */\n  readonly fields: NodeFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for Node.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__NodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    sourceEdges<T extends Node$sourceEdgesArgs<ExtArgs> = {}>(args?: Subset<T, Node$sourceEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    targetEdges<T extends Node$targetEdgesArgs<ExtArgs> = {}>(args?: Subset<T, Node$targetEdgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions> | Null>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the Node model\n   */\n  interface NodeFieldRefs {\n    readonly id: FieldRef<\"Node\", 'String'>\n    readonly type: FieldRef<\"Node\", 'String'>\n    readonly data: FieldRef<\"Node\", 'Json'>\n    readonly positionX: FieldRef<\"Node\", 'Float'>\n    readonly positionY: FieldRef<\"Node\", 'Float'>\n    readonly workflowId: FieldRef<\"Node\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * Node findUnique\n   */\n  export type NodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * Filter, which Node to fetch.\n     */\n    where: NodeWhereUniqueInput\n  }\n\n  /**\n   * Node findUniqueOrThrow\n   */\n  export type NodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * Filter, which Node to fetch.\n     */\n    where: NodeWhereUniqueInput\n  }\n\n  /**\n   * Node findFirst\n   */\n  export type NodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * Filter, which Node to fetch.\n     */\n    where?: NodeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Nodes to fetch.\n     */\n    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Nodes.\n     */\n    cursor?: NodeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Nodes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Nodes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Nodes.\n     */\n    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]\n  }\n\n  /**\n   * Node findFirstOrThrow\n   */\n  export type NodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * Filter, which Node to fetch.\n     */\n    where?: NodeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Nodes to fetch.\n     */\n    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Nodes.\n     */\n    cursor?: NodeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Nodes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Nodes.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Nodes.\n     */\n    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]\n  }\n\n  /**\n   * Node findMany\n   */\n  export type NodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * Filter, which Nodes to fetch.\n     */\n    where?: NodeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Nodes to fetch.\n     */\n    orderBy?: NodeOrderByWithRelationInput | NodeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing Nodes.\n     */\n    cursor?: NodeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Nodes from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Nodes.\n     */\n    skip?: number\n    distinct?: NodeScalarFieldEnum | NodeScalarFieldEnum[]\n  }\n\n  /**\n   * Node create\n   */\n  export type NodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * The data needed to create a Node.\n     */\n    data: XOR<NodeCreateInput, NodeUncheckedCreateInput>\n  }\n\n  /**\n   * Node createMany\n   */\n  export type NodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many Nodes.\n     */\n    data: NodeCreateManyInput | NodeCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * Node createManyAndReturn\n   */\n  export type NodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * The data used to create many Nodes.\n     */\n    data: NodeCreateManyInput | NodeCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Node update\n   */\n  export type NodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * The data needed to update a Node.\n     */\n    data: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>\n    /**\n     * Choose, which Node to update.\n     */\n    where: NodeWhereUniqueInput\n  }\n\n  /**\n   * Node updateMany\n   */\n  export type NodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update Nodes.\n     */\n    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyInput>\n    /**\n     * Filter which Nodes to update\n     */\n    where?: NodeWhereInput\n    /**\n     * Limit how many Nodes to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * Node updateManyAndReturn\n   */\n  export type NodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * The data used to update Nodes.\n     */\n    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyInput>\n    /**\n     * Filter which Nodes to update\n     */\n    where?: NodeWhereInput\n    /**\n     * Limit how many Nodes to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Node upsert\n   */\n  export type NodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * The filter to search for the Node to update in case it exists.\n     */\n    where: NodeWhereUniqueInput\n    /**\n     * In case the Node found by the `where` argument doesn't exist, create a new Node with this data.\n     */\n    create: XOR<NodeCreateInput, NodeUncheckedCreateInput>\n    /**\n     * In case the Node was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<NodeUpdateInput, NodeUncheckedUpdateInput>\n  }\n\n  /**\n   * Node delete\n   */\n  export type NodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n    /**\n     * Filter which Node to delete.\n     */\n    where: NodeWhereUniqueInput\n  }\n\n  /**\n   * Node deleteMany\n   */\n  export type NodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Nodes to delete\n     */\n    where?: NodeWhereInput\n    /**\n     * Limit how many Nodes to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * Node.sourceEdges\n   */\n  export type Node$sourceEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    where?: EdgeWhereInput\n    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]\n    cursor?: EdgeWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]\n  }\n\n  /**\n   * Node.targetEdges\n   */\n  export type Node$targetEdgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    where?: EdgeWhereInput\n    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]\n    cursor?: EdgeWhereUniqueInput\n    take?: number\n    skip?: number\n    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]\n  }\n\n  /**\n   * Node without action\n   */\n  export type NodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Node\n     */\n    select?: NodeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Node\n     */\n    omit?: NodeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: NodeInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model Edge\n   */\n\n  export type AggregateEdge = {\n    _count: EdgeCountAggregateOutputType | null\n    _min: EdgeMinAggregateOutputType | null\n    _max: EdgeMaxAggregateOutputType | null\n  }\n\n  export type EdgeMinAggregateOutputType = {\n    id: string | null\n    sourceId: string | null\n    targetId: string | null\n    workflowId: string | null\n  }\n\n  export type EdgeMaxAggregateOutputType = {\n    id: string | null\n    sourceId: string | null\n    targetId: string | null\n    workflowId: string | null\n  }\n\n  export type EdgeCountAggregateOutputType = {\n    id: number\n    sourceId: number\n    targetId: number\n    workflowId: number\n    _all: number\n  }\n\n\n  export type EdgeMinAggregateInputType = {\n    id?: true\n    sourceId?: true\n    targetId?: true\n    workflowId?: true\n  }\n\n  export type EdgeMaxAggregateInputType = {\n    id?: true\n    sourceId?: true\n    targetId?: true\n    workflowId?: true\n  }\n\n  export type EdgeCountAggregateInputType = {\n    id?: true\n    sourceId?: true\n    targetId?: true\n    workflowId?: true\n    _all?: true\n  }\n\n  export type EdgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Edge to aggregate.\n     */\n    where?: EdgeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Edges to fetch.\n     */\n    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: EdgeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Edges from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Edges.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned Edges\n    **/\n    _count?: true | EdgeCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: EdgeMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: EdgeMaxAggregateInputType\n  }\n\n  export type GetEdgeAggregateType<T extends EdgeAggregateArgs> = {\n        [P in keyof T & keyof AggregateEdge]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateEdge[P]>\n      : GetScalarType<T[P], AggregateEdge[P]>\n  }\n\n\n\n\n  export type EdgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: EdgeWhereInput\n    orderBy?: EdgeOrderByWithAggregationInput | EdgeOrderByWithAggregationInput[]\n    by: EdgeScalarFieldEnum[] | EdgeScalarFieldEnum\n    having?: EdgeScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: EdgeCountAggregateInputType | true\n    _min?: EdgeMinAggregateInputType\n    _max?: EdgeMaxAggregateInputType\n  }\n\n  export type EdgeGroupByOutputType = {\n    id: string\n    sourceId: string\n    targetId: string\n    workflowId: string\n    _count: EdgeCountAggregateOutputType | null\n    _min: EdgeMinAggregateOutputType | null\n    _max: EdgeMaxAggregateOutputType | null\n  }\n\n  type GetEdgeGroupByPayload<T extends EdgeGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<EdgeGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof EdgeGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], EdgeGroupByOutputType[P]>\n            : GetScalarType<T[P], EdgeGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type EdgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    sourceId?: boolean\n    targetId?: boolean\n    workflowId?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceNode?: boolean | NodeDefaultArgs<ExtArgs>\n    targetNode?: boolean | NodeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"edge\"]>\n\n  export type EdgeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    sourceId?: boolean\n    targetId?: boolean\n    workflowId?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceNode?: boolean | NodeDefaultArgs<ExtArgs>\n    targetNode?: boolean | NodeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"edge\"]>\n\n  export type EdgeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    sourceId?: boolean\n    targetId?: boolean\n    workflowId?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceNode?: boolean | NodeDefaultArgs<ExtArgs>\n    targetNode?: boolean | NodeDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"edge\"]>\n\n  export type EdgeSelectScalar = {\n    id?: boolean\n    sourceId?: boolean\n    targetId?: boolean\n    workflowId?: boolean\n  }\n\n  export type EdgeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"sourceId\" | \"targetId\" | \"workflowId\", ExtArgs[\"result\"][\"edge\"]>\n  export type EdgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceNode?: boolean | NodeDefaultArgs<ExtArgs>\n    targetNode?: boolean | NodeDefaultArgs<ExtArgs>\n  }\n  export type EdgeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceNode?: boolean | NodeDefaultArgs<ExtArgs>\n    targetNode?: boolean | NodeDefaultArgs<ExtArgs>\n  }\n  export type EdgeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n    sourceNode?: boolean | NodeDefaultArgs<ExtArgs>\n    targetNode?: boolean | NodeDefaultArgs<ExtArgs>\n  }\n\n  export type $EdgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"Edge\"\n    objects: {\n      workflow: Prisma.$WorkflowPayload<ExtArgs>\n      sourceNode: Prisma.$NodePayload<ExtArgs>\n      targetNode: Prisma.$NodePayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      id: string\n      sourceId: string\n      targetId: string\n      workflowId: string\n    }, ExtArgs[\"result\"][\"edge\"]>\n    composites: {}\n  }\n\n  type EdgeGetPayload<S extends boolean | null | undefined | EdgeDefaultArgs> = $Result.GetResult<Prisma.$EdgePayload, S>\n\n  type EdgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<EdgeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: EdgeCountAggregateInputType | true\n    }\n\n  export interface EdgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Edge'], meta: { name: 'Edge' } }\n    /**\n     * Find zero or one Edge that matches the filter.\n     * @param {EdgeFindUniqueArgs} args - Arguments to find a Edge\n     * @example\n     * // Get one Edge\n     * const edge = await prisma.edge.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends EdgeFindUniqueArgs>(args: SelectSubset<T, EdgeFindUniqueArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Edge that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {EdgeFindUniqueOrThrowArgs} args - Arguments to find a Edge\n     * @example\n     * // Get one Edge\n     * const edge = await prisma.edge.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends EdgeFindUniqueOrThrowArgs>(args: SelectSubset<T, EdgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Edge that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {EdgeFindFirstArgs} args - Arguments to find a Edge\n     * @example\n     * // Get one Edge\n     * const edge = await prisma.edge.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends EdgeFindFirstArgs>(args?: SelectSubset<T, EdgeFindFirstArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Edge that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {EdgeFindFirstOrThrowArgs} args - Arguments to find a Edge\n     * @example\n     * // Get one Edge\n     * const edge = await prisma.edge.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends EdgeFindFirstOrThrowArgs>(args?: SelectSubset<T, EdgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Edges that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {EdgeFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Edges\n     * const edges = await prisma.edge.findMany()\n     * \n     * // Get first 10 Edges\n     * const edges = await prisma.edge.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const edgeWithIdOnly = await prisma.edge.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends EdgeFindManyArgs>(args?: SelectSubset<T, EdgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Edge.\n     * @param {EdgeCreateArgs} args - Arguments to create a Edge.\n     * @example\n     * // Create one Edge\n     * const Edge = await prisma.edge.create({\n     *   data: {\n     *     // ... data to create a Edge\n     *   }\n     * })\n     * \n     */\n    create<T extends EdgeCreateArgs>(args: SelectSubset<T, EdgeCreateArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Edges.\n     * @param {EdgeCreateManyArgs} args - Arguments to create many Edges.\n     * @example\n     * // Create many Edges\n     * const edge = await prisma.edge.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends EdgeCreateManyArgs>(args?: SelectSubset<T, EdgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Edges and returns the data saved in the database.\n     * @param {EdgeCreateManyAndReturnArgs} args - Arguments to create many Edges.\n     * @example\n     * // Create many Edges\n     * const edge = await prisma.edge.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Edges and only return the `id`\n     * const edgeWithIdOnly = await prisma.edge.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends EdgeCreateManyAndReturnArgs>(args?: SelectSubset<T, EdgeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Edge.\n     * @param {EdgeDeleteArgs} args - Arguments to delete one Edge.\n     * @example\n     * // Delete one Edge\n     * const Edge = await prisma.edge.delete({\n     *   where: {\n     *     // ... filter to delete one Edge\n     *   }\n     * })\n     * \n     */\n    delete<T extends EdgeDeleteArgs>(args: SelectSubset<T, EdgeDeleteArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Edge.\n     * @param {EdgeUpdateArgs} args - Arguments to update one Edge.\n     * @example\n     * // Update one Edge\n     * const edge = await prisma.edge.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends EdgeUpdateArgs>(args: SelectSubset<T, EdgeUpdateArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Edges.\n     * @param {EdgeDeleteManyArgs} args - Arguments to filter Edges to delete.\n     * @example\n     * // Delete a few Edges\n     * const { count } = await prisma.edge.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends EdgeDeleteManyArgs>(args?: SelectSubset<T, EdgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Edges.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {EdgeUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Edges\n     * const edge = await prisma.edge.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends EdgeUpdateManyArgs>(args: SelectSubset<T, EdgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Edges and returns the data updated in the database.\n     * @param {EdgeUpdateManyAndReturnArgs} args - Arguments to update many Edges.\n     * @example\n     * // Update many Edges\n     * const edge = await prisma.edge.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Edges and only return the `id`\n     * const edgeWithIdOnly = await prisma.edge.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends EdgeUpdateManyAndReturnArgs>(args: SelectSubset<T, EdgeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Edge.\n     * @param {EdgeUpsertArgs} args - Arguments to update or create a Edge.\n     * @example\n     * // Update or create a Edge\n     * const edge = await prisma.edge.upsert({\n     *   create: {\n     *     // ... data to create a Edge\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Edge we want to update\n     *   }\n     * })\n     */\n    upsert<T extends EdgeUpsertArgs>(args: SelectSubset<T, EdgeUpsertArgs<ExtArgs>>): Prisma__EdgeClient<$Result.GetResult<Prisma.$EdgePayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Edges.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {EdgeCountArgs} args - Arguments to filter Edges to count.\n     * @example\n     * // Count the number of Edges\n     * const count = await prisma.edge.count({\n     *   where: {\n     *     // ... the filter for the Edges we want to count\n     *   }\n     * })\n    **/\n    count<T extends EdgeCountArgs>(\n      args?: Subset<T, EdgeCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], EdgeCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Edge.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {EdgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends EdgeAggregateArgs>(args: Subset<T, EdgeAggregateArgs>): Prisma.PrismaPromise<GetEdgeAggregateType<T>>\n\n    /**\n     * Group by Edge.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {EdgeGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends EdgeGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: EdgeGroupByArgs['orderBy'] }\n        : { orderBy?: EdgeGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, EdgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEdgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the Edge model\n   */\n  readonly fields: EdgeFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for Edge.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__EdgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    sourceNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    targetNode<T extends NodeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, NodeDefaultArgs<ExtArgs>>): Prisma__NodeClient<$Result.GetResult<Prisma.$NodePayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the Edge model\n   */\n  interface EdgeFieldRefs {\n    readonly id: FieldRef<\"Edge\", 'String'>\n    readonly sourceId: FieldRef<\"Edge\", 'String'>\n    readonly targetId: FieldRef<\"Edge\", 'String'>\n    readonly workflowId: FieldRef<\"Edge\", 'String'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * Edge findUnique\n   */\n  export type EdgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * Filter, which Edge to fetch.\n     */\n    where: EdgeWhereUniqueInput\n  }\n\n  /**\n   * Edge findUniqueOrThrow\n   */\n  export type EdgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * Filter, which Edge to fetch.\n     */\n    where: EdgeWhereUniqueInput\n  }\n\n  /**\n   * Edge findFirst\n   */\n  export type EdgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * Filter, which Edge to fetch.\n     */\n    where?: EdgeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Edges to fetch.\n     */\n    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Edges.\n     */\n    cursor?: EdgeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Edges from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Edges.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Edges.\n     */\n    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]\n  }\n\n  /**\n   * Edge findFirstOrThrow\n   */\n  export type EdgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * Filter, which Edge to fetch.\n     */\n    where?: EdgeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Edges to fetch.\n     */\n    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Edges.\n     */\n    cursor?: EdgeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Edges from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Edges.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Edges.\n     */\n    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]\n  }\n\n  /**\n   * Edge findMany\n   */\n  export type EdgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * Filter, which Edges to fetch.\n     */\n    where?: EdgeWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Edges to fetch.\n     */\n    orderBy?: EdgeOrderByWithRelationInput | EdgeOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing Edges.\n     */\n    cursor?: EdgeWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Edges from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Edges.\n     */\n    skip?: number\n    distinct?: EdgeScalarFieldEnum | EdgeScalarFieldEnum[]\n  }\n\n  /**\n   * Edge create\n   */\n  export type EdgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * The data needed to create a Edge.\n     */\n    data: XOR<EdgeCreateInput, EdgeUncheckedCreateInput>\n  }\n\n  /**\n   * Edge createMany\n   */\n  export type EdgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many Edges.\n     */\n    data: EdgeCreateManyInput | EdgeCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * Edge createManyAndReturn\n   */\n  export type EdgeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * The data used to create many Edges.\n     */\n    data: EdgeCreateManyInput | EdgeCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Edge update\n   */\n  export type EdgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * The data needed to update a Edge.\n     */\n    data: XOR<EdgeUpdateInput, EdgeUncheckedUpdateInput>\n    /**\n     * Choose, which Edge to update.\n     */\n    where: EdgeWhereUniqueInput\n  }\n\n  /**\n   * Edge updateMany\n   */\n  export type EdgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update Edges.\n     */\n    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyInput>\n    /**\n     * Filter which Edges to update\n     */\n    where?: EdgeWhereInput\n    /**\n     * Limit how many Edges to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * Edge updateManyAndReturn\n   */\n  export type EdgeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * The data used to update Edges.\n     */\n    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyInput>\n    /**\n     * Filter which Edges to update\n     */\n    where?: EdgeWhereInput\n    /**\n     * Limit how many Edges to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Edge upsert\n   */\n  export type EdgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * The filter to search for the Edge to update in case it exists.\n     */\n    where: EdgeWhereUniqueInput\n    /**\n     * In case the Edge found by the `where` argument doesn't exist, create a new Edge with this data.\n     */\n    create: XOR<EdgeCreateInput, EdgeUncheckedCreateInput>\n    /**\n     * In case the Edge was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<EdgeUpdateInput, EdgeUncheckedUpdateInput>\n  }\n\n  /**\n   * Edge delete\n   */\n  export type EdgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n    /**\n     * Filter which Edge to delete.\n     */\n    where: EdgeWhereUniqueInput\n  }\n\n  /**\n   * Edge deleteMany\n   */\n  export type EdgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Edges to delete\n     */\n    where?: EdgeWhereInput\n    /**\n     * Limit how many Edges to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * Edge without action\n   */\n  export type EdgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Edge\n     */\n    select?: EdgeSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Edge\n     */\n    omit?: EdgeOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: EdgeInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Model Execution\n   */\n\n  export type AggregateExecution = {\n    _count: ExecutionCountAggregateOutputType | null\n    _min: ExecutionMinAggregateOutputType | null\n    _max: ExecutionMaxAggregateOutputType | null\n  }\n\n  export type ExecutionMinAggregateOutputType = {\n    id: string | null\n    workflowId: string | null\n    status: string | null\n    startedAt: Date | null\n    finishedAt: Date | null\n  }\n\n  export type ExecutionMaxAggregateOutputType = {\n    id: string | null\n    workflowId: string | null\n    status: string | null\n    startedAt: Date | null\n    finishedAt: Date | null\n  }\n\n  export type ExecutionCountAggregateOutputType = {\n    id: number\n    workflowId: number\n    status: number\n    startedAt: number\n    finishedAt: number\n    results: number\n    error: number\n    _all: number\n  }\n\n\n  export type ExecutionMinAggregateInputType = {\n    id?: true\n    workflowId?: true\n    status?: true\n    startedAt?: true\n    finishedAt?: true\n  }\n\n  export type ExecutionMaxAggregateInputType = {\n    id?: true\n    workflowId?: true\n    status?: true\n    startedAt?: true\n    finishedAt?: true\n  }\n\n  export type ExecutionCountAggregateInputType = {\n    id?: true\n    workflowId?: true\n    status?: true\n    startedAt?: true\n    finishedAt?: true\n    results?: true\n    error?: true\n    _all?: true\n  }\n\n  export type ExecutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Execution to aggregate.\n     */\n    where?: ExecutionWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Executions to fetch.\n     */\n    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the start position\n     */\n    cursor?: ExecutionWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Executions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Executions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Count returned Executions\n    **/\n    _count?: true | ExecutionCountAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the minimum value\n    **/\n    _min?: ExecutionMinAggregateInputType\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}\n     * \n     * Select which fields to find the maximum value\n    **/\n    _max?: ExecutionMaxAggregateInputType\n  }\n\n  export type GetExecutionAggregateType<T extends ExecutionAggregateArgs> = {\n        [P in keyof T & keyof AggregateExecution]: P extends '_count' | 'count'\n      ? T[P] extends true\n        ? number\n        : GetScalarType<T[P], AggregateExecution[P]>\n      : GetScalarType<T[P], AggregateExecution[P]>\n  }\n\n\n\n\n  export type ExecutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    where?: ExecutionWhereInput\n    orderBy?: ExecutionOrderByWithAggregationInput | ExecutionOrderByWithAggregationInput[]\n    by: ExecutionScalarFieldEnum[] | ExecutionScalarFieldEnum\n    having?: ExecutionScalarWhereWithAggregatesInput\n    take?: number\n    skip?: number\n    _count?: ExecutionCountAggregateInputType | true\n    _min?: ExecutionMinAggregateInputType\n    _max?: ExecutionMaxAggregateInputType\n  }\n\n  export type ExecutionGroupByOutputType = {\n    id: string\n    workflowId: string\n    status: string\n    startedAt: Date\n    finishedAt: Date | null\n    results: JsonValue | null\n    error: JsonValue | null\n    _count: ExecutionCountAggregateOutputType | null\n    _min: ExecutionMinAggregateOutputType | null\n    _max: ExecutionMaxAggregateOutputType | null\n  }\n\n  type GetExecutionGroupByPayload<T extends ExecutionGroupByArgs> = Prisma.PrismaPromise<\n    Array<\n      PickEnumerable<ExecutionGroupByOutputType, T['by']> &\n        {\n          [P in ((keyof T) & (keyof ExecutionGroupByOutputType))]: P extends '_count'\n            ? T[P] extends boolean\n              ? number\n              : GetScalarType<T[P], ExecutionGroupByOutputType[P]>\n            : GetScalarType<T[P], ExecutionGroupByOutputType[P]>\n        }\n      >\n    >\n\n\n  export type ExecutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    workflowId?: boolean\n    status?: boolean\n    startedAt?: boolean\n    finishedAt?: boolean\n    results?: boolean\n    error?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"execution\"]>\n\n  export type ExecutionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    workflowId?: boolean\n    status?: boolean\n    startedAt?: boolean\n    finishedAt?: boolean\n    results?: boolean\n    error?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"execution\"]>\n\n  export type ExecutionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{\n    id?: boolean\n    workflowId?: boolean\n    status?: boolean\n    startedAt?: boolean\n    finishedAt?: boolean\n    results?: boolean\n    error?: boolean\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }, ExtArgs[\"result\"][\"execution\"]>\n\n  export type ExecutionSelectScalar = {\n    id?: boolean\n    workflowId?: boolean\n    status?: boolean\n    startedAt?: boolean\n    finishedAt?: boolean\n    results?: boolean\n    error?: boolean\n  }\n\n  export type ExecutionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<\"id\" | \"workflowId\" | \"status\" | \"startedAt\" | \"finishedAt\" | \"results\" | \"error\", ExtArgs[\"result\"][\"execution\"]>\n  export type ExecutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }\n  export type ExecutionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }\n  export type ExecutionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    workflow?: boolean | WorkflowDefaultArgs<ExtArgs>\n  }\n\n  export type $ExecutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    name: \"Execution\"\n    objects: {\n      workflow: Prisma.$WorkflowPayload<ExtArgs>\n    }\n    scalars: $Extensions.GetPayloadResult<{\n      id: string\n      workflowId: string\n      status: string\n      startedAt: Date\n      finishedAt: Date | null\n      results: Prisma.JsonValue | null\n      error: Prisma.JsonValue | null\n    }, ExtArgs[\"result\"][\"execution\"]>\n    composites: {}\n  }\n\n  type ExecutionGetPayload<S extends boolean | null | undefined | ExecutionDefaultArgs> = $Result.GetResult<Prisma.$ExecutionPayload, S>\n\n  type ExecutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =\n    Omit<ExecutionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {\n      select?: ExecutionCountAggregateInputType | true\n    }\n\n  export interface ExecutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {\n    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Execution'], meta: { name: 'Execution' } }\n    /**\n     * Find zero or one Execution that matches the filter.\n     * @param {ExecutionFindUniqueArgs} args - Arguments to find a Execution\n     * @example\n     * // Get one Execution\n     * const execution = await prisma.execution.findUnique({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUnique<T extends ExecutionFindUniqueArgs>(args: SelectSubset<T, ExecutionFindUniqueArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"findUnique\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find one Execution that matches the filter or throw an error with `error.code='P2025'`\n     * if no matches were found.\n     * @param {ExecutionFindUniqueOrThrowArgs} args - Arguments to find a Execution\n     * @example\n     * // Get one Execution\n     * const execution = await prisma.execution.findUniqueOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findUniqueOrThrow<T extends ExecutionFindUniqueOrThrowArgs>(args: SelectSubset<T, ExecutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Execution that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {ExecutionFindFirstArgs} args - Arguments to find a Execution\n     * @example\n     * // Get one Execution\n     * const execution = await prisma.execution.findFirst({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirst<T extends ExecutionFindFirstArgs>(args?: SelectSubset<T, ExecutionFindFirstArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"findFirst\", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find the first Execution that matches the filter or\n     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {ExecutionFindFirstOrThrowArgs} args - Arguments to find a Execution\n     * @example\n     * // Get one Execution\n     * const execution = await prisma.execution.findFirstOrThrow({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     */\n    findFirstOrThrow<T extends ExecutionFindFirstOrThrowArgs>(args?: SelectSubset<T, ExecutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"findFirstOrThrow\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Find zero or more Executions that matches the filter.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {ExecutionFindManyArgs} args - Arguments to filter and select certain fields only.\n     * @example\n     * // Get all Executions\n     * const executions = await prisma.execution.findMany()\n     * \n     * // Get first 10 Executions\n     * const executions = await prisma.execution.findMany({ take: 10 })\n     * \n     * // Only select the `id`\n     * const executionWithIdOnly = await prisma.execution.findMany({ select: { id: true } })\n     * \n     */\n    findMany<T extends ExecutionFindManyArgs>(args?: SelectSubset<T, ExecutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"findMany\", GlobalOmitOptions>>\n\n    /**\n     * Create a Execution.\n     * @param {ExecutionCreateArgs} args - Arguments to create a Execution.\n     * @example\n     * // Create one Execution\n     * const Execution = await prisma.execution.create({\n     *   data: {\n     *     // ... data to create a Execution\n     *   }\n     * })\n     * \n     */\n    create<T extends ExecutionCreateArgs>(args: SelectSubset<T, ExecutionCreateArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"create\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Create many Executions.\n     * @param {ExecutionCreateManyArgs} args - Arguments to create many Executions.\n     * @example\n     * // Create many Executions\n     * const execution = await prisma.execution.createMany({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     *     \n     */\n    createMany<T extends ExecutionCreateManyArgs>(args?: SelectSubset<T, ExecutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Create many Executions and returns the data saved in the database.\n     * @param {ExecutionCreateManyAndReturnArgs} args - Arguments to create many Executions.\n     * @example\n     * // Create many Executions\n     * const execution = await prisma.execution.createManyAndReturn({\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Create many Executions and only return the `id`\n     * const executionWithIdOnly = await prisma.execution.createManyAndReturn({\n     *   select: { id: true },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    createManyAndReturn<T extends ExecutionCreateManyAndReturnArgs>(args?: SelectSubset<T, ExecutionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"createManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Delete a Execution.\n     * @param {ExecutionDeleteArgs} args - Arguments to delete one Execution.\n     * @example\n     * // Delete one Execution\n     * const Execution = await prisma.execution.delete({\n     *   where: {\n     *     // ... filter to delete one Execution\n     *   }\n     * })\n     * \n     */\n    delete<T extends ExecutionDeleteArgs>(args: SelectSubset<T, ExecutionDeleteArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"delete\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Update one Execution.\n     * @param {ExecutionUpdateArgs} args - Arguments to update one Execution.\n     * @example\n     * // Update one Execution\n     * const execution = await prisma.execution.update({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    update<T extends ExecutionUpdateArgs>(args: SelectSubset<T, ExecutionUpdateArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"update\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n    /**\n     * Delete zero or more Executions.\n     * @param {ExecutionDeleteManyArgs} args - Arguments to filter Executions to delete.\n     * @example\n     * // Delete a few Executions\n     * const { count } = await prisma.execution.deleteMany({\n     *   where: {\n     *     // ... provide filter here\n     *   }\n     * })\n     * \n     */\n    deleteMany<T extends ExecutionDeleteManyArgs>(args?: SelectSubset<T, ExecutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Executions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {ExecutionUpdateManyArgs} args - Arguments to update one or more rows.\n     * @example\n     * // Update many Executions\n     * const execution = await prisma.execution.updateMany({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: {\n     *     // ... provide data here\n     *   }\n     * })\n     * \n     */\n    updateMany<T extends ExecutionUpdateManyArgs>(args: SelectSubset<T, ExecutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>\n\n    /**\n     * Update zero or more Executions and returns the data updated in the database.\n     * @param {ExecutionUpdateManyAndReturnArgs} args - Arguments to update many Executions.\n     * @example\n     * // Update many Executions\n     * const execution = await prisma.execution.updateManyAndReturn({\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * \n     * // Update zero or more Executions and only return the `id`\n     * const executionWithIdOnly = await prisma.execution.updateManyAndReturn({\n     *   select: { id: true },\n     *   where: {\n     *     // ... provide filter here\n     *   },\n     *   data: [\n     *     // ... provide data here\n     *   ]\n     * })\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * \n     */\n    updateManyAndReturn<T extends ExecutionUpdateManyAndReturnArgs>(args: SelectSubset<T, ExecutionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"updateManyAndReturn\", GlobalOmitOptions>>\n\n    /**\n     * Create or update one Execution.\n     * @param {ExecutionUpsertArgs} args - Arguments to update or create a Execution.\n     * @example\n     * // Update or create a Execution\n     * const execution = await prisma.execution.upsert({\n     *   create: {\n     *     // ... data to create a Execution\n     *   },\n     *   update: {\n     *     // ... in case it already exists, update\n     *   },\n     *   where: {\n     *     // ... the filter for the Execution we want to update\n     *   }\n     * })\n     */\n    upsert<T extends ExecutionUpsertArgs>(args: SelectSubset<T, ExecutionUpsertArgs<ExtArgs>>): Prisma__ExecutionClient<$Result.GetResult<Prisma.$ExecutionPayload<ExtArgs>, T, \"upsert\", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>\n\n\n    /**\n     * Count the number of Executions.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {ExecutionCountArgs} args - Arguments to filter Executions to count.\n     * @example\n     * // Count the number of Executions\n     * const count = await prisma.execution.count({\n     *   where: {\n     *     // ... the filter for the Executions we want to count\n     *   }\n     * })\n    **/\n    count<T extends ExecutionCountArgs>(\n      args?: Subset<T, ExecutionCountArgs>,\n    ): Prisma.PrismaPromise<\n      T extends $Utils.Record<'select', any>\n        ? T['select'] extends true\n          ? number\n          : GetScalarType<T['select'], ExecutionCountAggregateOutputType>\n        : number\n    >\n\n    /**\n     * Allows you to perform aggregations operations on a Execution.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {ExecutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.\n     * @example\n     * // Ordered by age ascending\n     * // Where email contains prisma.io\n     * // Limited to the 10 users\n     * const aggregations = await prisma.user.aggregate({\n     *   _avg: {\n     *     age: true,\n     *   },\n     *   where: {\n     *     email: {\n     *       contains: \"prisma.io\",\n     *     },\n     *   },\n     *   orderBy: {\n     *     age: \"asc\",\n     *   },\n     *   take: 10,\n     * })\n    **/\n    aggregate<T extends ExecutionAggregateArgs>(args: Subset<T, ExecutionAggregateArgs>): Prisma.PrismaPromise<GetExecutionAggregateType<T>>\n\n    /**\n     * Group by Execution.\n     * Note, that providing `undefined` is treated as the value not being there.\n     * Read more here: https://pris.ly/d/null-undefined\n     * @param {ExecutionGroupByArgs} args - Group by arguments.\n     * @example\n     * // Group by city, order by createdAt, get count\n     * const result = await prisma.user.groupBy({\n     *   by: ['city', 'createdAt'],\n     *   orderBy: {\n     *     createdAt: true\n     *   },\n     *   _count: {\n     *     _all: true\n     *   },\n     * })\n     * \n    **/\n    groupBy<\n      T extends ExecutionGroupByArgs,\n      HasSelectOrTake extends Or<\n        Extends<'skip', Keys<T>>,\n        Extends<'take', Keys<T>>\n      >,\n      OrderByArg extends True extends HasSelectOrTake\n        ? { orderBy: ExecutionGroupByArgs['orderBy'] }\n        : { orderBy?: ExecutionGroupByArgs['orderBy'] },\n      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,\n      ByFields extends MaybeTupleToUnion<T['by']>,\n      ByValid extends Has<ByFields, OrderFields>,\n      HavingFields extends GetHavingFields<T['having']>,\n      HavingValid extends Has<ByFields, HavingFields>,\n      ByEmpty extends T['by'] extends never[] ? True : False,\n      InputErrors extends ByEmpty extends True\n      ? `Error: \"by\" must not be empty.`\n      : HavingValid extends False\n      ? {\n          [P in HavingFields]: P extends ByFields\n            ? never\n            : P extends string\n            ? `Error: Field \"${P}\" used in \"having\" needs to be provided in \"by\".`\n            : [\n                Error,\n                'Field ',\n                P,\n                ` in \"having\" needs to be provided in \"by\"`,\n              ]\n        }[HavingFields]\n      : 'take' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"take\", you also need to provide \"orderBy\"'\n      : 'skip' extends Keys<T>\n      ? 'orderBy' extends Keys<T>\n        ? ByValid extends True\n          ? {}\n          : {\n              [P in OrderFields]: P extends ByFields\n                ? never\n                : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n            }[OrderFields]\n        : 'Error: If you provide \"skip\", you also need to provide \"orderBy\"'\n      : ByValid extends True\n      ? {}\n      : {\n          [P in OrderFields]: P extends ByFields\n            ? never\n            : `Error: Field \"${P}\" in \"orderBy\" needs to be provided in \"by\"`\n        }[OrderFields]\n    >(args: SubsetIntersection<T, ExecutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExecutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>\n  /**\n   * Fields of the Execution model\n   */\n  readonly fields: ExecutionFieldRefs;\n  }\n\n  /**\n   * The delegate class that acts as a \"Promise-like\" for Execution.\n   * Why is this prefixed with `Prisma__`?\n   * Because we want to prevent naming conflicts as mentioned in\n   * https://github.com/prisma/prisma-client-js/issues/707\n   */\n  export interface Prisma__ExecutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {\n    readonly [Symbol.toStringTag]: \"PrismaPromise\"\n    workflow<T extends WorkflowDefaultArgs<ExtArgs> = {}>(args?: Subset<T, WorkflowDefaultArgs<ExtArgs>>): Prisma__WorkflowClient<$Result.GetResult<Prisma.$WorkflowPayload<ExtArgs>, T, \"findUniqueOrThrow\", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>\n    /**\n     * Attaches callbacks for the resolution and/or rejection of the Promise.\n     * @param onfulfilled The callback to execute when the Promise is resolved.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of which ever callback is executed.\n     */\n    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>\n    /**\n     * Attaches a callback for only the rejection of the Promise.\n     * @param onrejected The callback to execute when the Promise is rejected.\n     * @returns A Promise for the completion of the callback.\n     */\n    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>\n    /**\n     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The\n     * resolved value cannot be modified from the callback.\n     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).\n     * @returns A Promise for the completion of the callback.\n     */\n    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>\n  }\n\n\n\n\n  /**\n   * Fields of the Execution model\n   */\n  interface ExecutionFieldRefs {\n    readonly id: FieldRef<\"Execution\", 'String'>\n    readonly workflowId: FieldRef<\"Execution\", 'String'>\n    readonly status: FieldRef<\"Execution\", 'String'>\n    readonly startedAt: FieldRef<\"Execution\", 'DateTime'>\n    readonly finishedAt: FieldRef<\"Execution\", 'DateTime'>\n    readonly results: FieldRef<\"Execution\", 'Json'>\n    readonly error: FieldRef<\"Execution\", 'Json'>\n  }\n    \n\n  // Custom InputTypes\n  /**\n   * Execution findUnique\n   */\n  export type ExecutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * Filter, which Execution to fetch.\n     */\n    where: ExecutionWhereUniqueInput\n  }\n\n  /**\n   * Execution findUniqueOrThrow\n   */\n  export type ExecutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * Filter, which Execution to fetch.\n     */\n    where: ExecutionWhereUniqueInput\n  }\n\n  /**\n   * Execution findFirst\n   */\n  export type ExecutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * Filter, which Execution to fetch.\n     */\n    where?: ExecutionWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Executions to fetch.\n     */\n    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Executions.\n     */\n    cursor?: ExecutionWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Executions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Executions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Executions.\n     */\n    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]\n  }\n\n  /**\n   * Execution findFirstOrThrow\n   */\n  export type ExecutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * Filter, which Execution to fetch.\n     */\n    where?: ExecutionWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Executions to fetch.\n     */\n    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for searching for Executions.\n     */\n    cursor?: ExecutionWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Executions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Executions.\n     */\n    skip?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}\n     * \n     * Filter by unique combinations of Executions.\n     */\n    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]\n  }\n\n  /**\n   * Execution findMany\n   */\n  export type ExecutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * Filter, which Executions to fetch.\n     */\n    where?: ExecutionWhereInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}\n     * \n     * Determine the order of Executions to fetch.\n     */\n    orderBy?: ExecutionOrderByWithRelationInput | ExecutionOrderByWithRelationInput[]\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}\n     * \n     * Sets the position for listing Executions.\n     */\n    cursor?: ExecutionWhereUniqueInput\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Take `┬▒n` Executions from the position of the cursor.\n     */\n    take?: number\n    /**\n     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}\n     * \n     * Skip the first `n` Executions.\n     */\n    skip?: number\n    distinct?: ExecutionScalarFieldEnum | ExecutionScalarFieldEnum[]\n  }\n\n  /**\n   * Execution create\n   */\n  export type ExecutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * The data needed to create a Execution.\n     */\n    data: XOR<ExecutionCreateInput, ExecutionUncheckedCreateInput>\n  }\n\n  /**\n   * Execution createMany\n   */\n  export type ExecutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to create many Executions.\n     */\n    data: ExecutionCreateManyInput | ExecutionCreateManyInput[]\n    skipDuplicates?: boolean\n  }\n\n  /**\n   * Execution createManyAndReturn\n   */\n  export type ExecutionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelectCreateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * The data used to create many Executions.\n     */\n    data: ExecutionCreateManyInput | ExecutionCreateManyInput[]\n    skipDuplicates?: boolean\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionIncludeCreateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Execution update\n   */\n  export type ExecutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * The data needed to update a Execution.\n     */\n    data: XOR<ExecutionUpdateInput, ExecutionUncheckedUpdateInput>\n    /**\n     * Choose, which Execution to update.\n     */\n    where: ExecutionWhereUniqueInput\n  }\n\n  /**\n   * Execution updateMany\n   */\n  export type ExecutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * The data used to update Executions.\n     */\n    data: XOR<ExecutionUpdateManyMutationInput, ExecutionUncheckedUpdateManyInput>\n    /**\n     * Filter which Executions to update\n     */\n    where?: ExecutionWhereInput\n    /**\n     * Limit how many Executions to update.\n     */\n    limit?: number\n  }\n\n  /**\n   * Execution updateManyAndReturn\n   */\n  export type ExecutionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelectUpdateManyAndReturn<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * The data used to update Executions.\n     */\n    data: XOR<ExecutionUpdateManyMutationInput, ExecutionUncheckedUpdateManyInput>\n    /**\n     * Filter which Executions to update\n     */\n    where?: ExecutionWhereInput\n    /**\n     * Limit how many Executions to update.\n     */\n    limit?: number\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionIncludeUpdateManyAndReturn<ExtArgs> | null\n  }\n\n  /**\n   * Execution upsert\n   */\n  export type ExecutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * The filter to search for the Execution to update in case it exists.\n     */\n    where: ExecutionWhereUniqueInput\n    /**\n     * In case the Execution found by the `where` argument doesn't exist, create a new Execution with this data.\n     */\n    create: XOR<ExecutionCreateInput, ExecutionUncheckedCreateInput>\n    /**\n     * In case the Execution was found with the provided `where` argument, update it with this data.\n     */\n    update: XOR<ExecutionUpdateInput, ExecutionUncheckedUpdateInput>\n  }\n\n  /**\n   * Execution delete\n   */\n  export type ExecutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n    /**\n     * Filter which Execution to delete.\n     */\n    where: ExecutionWhereUniqueInput\n  }\n\n  /**\n   * Execution deleteMany\n   */\n  export type ExecutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Filter which Executions to delete\n     */\n    where?: ExecutionWhereInput\n    /**\n     * Limit how many Executions to delete.\n     */\n    limit?: number\n  }\n\n  /**\n   * Execution without action\n   */\n  export type ExecutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {\n    /**\n     * Select specific fields to fetch from the Execution\n     */\n    select?: ExecutionSelect<ExtArgs> | null\n    /**\n     * Omit specific fields from the Execution\n     */\n    omit?: ExecutionOmit<ExtArgs> | null\n    /**\n     * Choose, which related nodes to fetch as well\n     */\n    include?: ExecutionInclude<ExtArgs> | null\n  }\n\n\n  /**\n   * Enums\n   */\n\n  export const TransactionIsolationLevel: {\n    ReadUncommitted: 'ReadUncommitted',\n    ReadCommitted: 'ReadCommitted',\n    RepeatableRead: 'RepeatableRead',\n    Serializable: 'Serializable'\n  };\n\n  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]\n\n\n  export const UserScalarFieldEnum: {\n    id: 'id',\n    email: 'email',\n    name: 'name',\n    password: 'password',\n    createdAt: 'createdAt',\n    updatedAt: 'updatedAt'\n  };\n\n  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]\n\n\n  export const WorkflowScalarFieldEnum: {\n    id: 'id',\n    name: 'name',\n    userId: 'userId',\n    createdAt: 'createdAt',\n    updatedAt: 'updatedAt'\n  };\n\n  export type WorkflowScalarFieldEnum = (typeof WorkflowScalarFieldEnum)[keyof typeof WorkflowScalarFieldEnum]\n\n\n  export const NodeScalarFieldEnum: {\n    id: 'id',\n    type: 'type',\n    data: 'data',\n    positionX: 'positionX',\n    positionY: 'positionY',\n    workflowId: 'workflowId'\n  };\n\n  export type NodeScalarFieldEnum = (typeof NodeScalarFieldEnum)[keyof typeof NodeScalarFieldEnum]\n\n\n  export const EdgeScalarFieldEnum: {\n    id: 'id',\n    sourceId: 'sourceId',\n    targetId: 'targetId',\n    workflowId: 'workflowId'\n  };\n\n  export type EdgeScalarFieldEnum = (typeof EdgeScalarFieldEnum)[keyof typeof EdgeScalarFieldEnum]\n\n\n  export const ExecutionScalarFieldEnum: {\n    id: 'id',\n    workflowId: 'workflowId',\n    status: 'status',\n    startedAt: 'startedAt',\n    finishedAt: 'finishedAt',\n    results: 'results',\n    error: 'error'\n  };\n\n  export type ExecutionScalarFieldEnum = (typeof ExecutionScalarFieldEnum)[keyof typeof ExecutionScalarFieldEnum]\n\n\n  export const SortOrder: {\n    asc: 'asc',\n    desc: 'desc'\n  };\n\n  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]\n\n\n  export const JsonNullValueInput: {\n    JsonNull: typeof JsonNull\n  };\n\n  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]\n\n\n  export const NullableJsonNullValueInput: {\n    DbNull: typeof DbNull,\n    JsonNull: typeof JsonNull\n  };\n\n  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]\n\n\n  export const QueryMode: {\n    default: 'default',\n    insensitive: 'insensitive'\n  };\n\n  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]\n\n\n  export const NullsOrder: {\n    first: 'first',\n    last: 'last'\n  };\n\n  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]\n\n\n  export const JsonNullValueFilter: {\n    DbNull: typeof DbNull,\n    JsonNull: typeof JsonNull,\n    AnyNull: typeof AnyNull\n  };\n\n  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]\n\n\n  /**\n   * Field references\n   */\n\n\n  /**\n   * Reference to a field of type 'String'\n   */\n  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>\n    \n\n\n  /**\n   * Reference to a field of type 'String[]'\n   */\n  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime'\n   */\n  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>\n    \n\n\n  /**\n   * Reference to a field of type 'DateTime[]'\n   */\n  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Json'\n   */\n  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>\n    \n\n\n  /**\n   * Reference to a field of type 'QueryMode'\n   */\n  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float'\n   */\n  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>\n    \n\n\n  /**\n   * Reference to a field of type 'Float[]'\n   */\n  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int'\n   */\n  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>\n    \n\n\n  /**\n   * Reference to a field of type 'Int[]'\n   */\n  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>\n    \n  /**\n   * Deep Input Types\n   */\n\n\n  export type UserWhereInput = {\n    AND?: UserWhereInput | UserWhereInput[]\n    OR?: UserWhereInput[]\n    NOT?: UserWhereInput | UserWhereInput[]\n    id?: StringFilter<\"User\"> | string\n    email?: StringFilter<\"User\"> | string\n    name?: StringNullableFilter<\"User\"> | string | null\n    password?: StringFilter<\"User\"> | string\n    createdAt?: DateTimeFilter<\"User\"> | Date | string\n    updatedAt?: DateTimeFilter<\"User\"> | Date | string\n    workflows?: WorkflowListRelationFilter\n  }\n\n  export type UserOrderByWithRelationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    name?: SortOrderInput | SortOrder\n    password?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n    workflows?: WorkflowOrderByRelationAggregateInput\n  }\n\n  export type UserWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    email?: string\n    AND?: UserWhereInput | UserWhereInput[]\n    OR?: UserWhereInput[]\n    NOT?: UserWhereInput | UserWhereInput[]\n    name?: StringNullableFilter<\"User\"> | string | null\n    password?: StringFilter<\"User\"> | string\n    createdAt?: DateTimeFilter<\"User\"> | Date | string\n    updatedAt?: DateTimeFilter<\"User\"> | Date | string\n    workflows?: WorkflowListRelationFilter\n  }, \"id\" | \"email\">\n\n  export type UserOrderByWithAggregationInput = {\n    id?: SortOrder\n    email?: SortOrder\n    name?: SortOrderInput | SortOrder\n    password?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n    _count?: UserCountOrderByAggregateInput\n    _max?: UserMaxOrderByAggregateInput\n    _min?: UserMinOrderByAggregateInput\n  }\n\n  export type UserScalarWhereWithAggregatesInput = {\n    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]\n    OR?: UserScalarWhereWithAggregatesInput[]\n    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]\n    id?: StringWithAggregatesFilter<\"User\"> | string\n    email?: StringWithAggregatesFilter<\"User\"> | string\n    name?: StringNullableWithAggregatesFilter<\"User\"> | string | null\n    password?: StringWithAggregatesFilter<\"User\"> | string\n    createdAt?: DateTimeWithAggregatesFilter<\"User\"> | Date | string\n    updatedAt?: DateTimeWithAggregatesFilter<\"User\"> | Date | string\n  }\n\n  export type WorkflowWhereInput = {\n    AND?: WorkflowWhereInput | WorkflowWhereInput[]\n    OR?: WorkflowWhereInput[]\n    NOT?: WorkflowWhereInput | WorkflowWhereInput[]\n    id?: StringFilter<\"Workflow\"> | string\n    name?: StringFilter<\"Workflow\"> | string\n    userId?: StringFilter<\"Workflow\"> | string\n    createdAt?: DateTimeFilter<\"Workflow\"> | Date | string\n    updatedAt?: DateTimeFilter<\"Workflow\"> | Date | string\n    user?: XOR<UserScalarRelationFilter, UserWhereInput>\n    nodes?: NodeListRelationFilter\n    edges?: EdgeListRelationFilter\n    executions?: ExecutionListRelationFilter\n  }\n\n  export type WorkflowOrderByWithRelationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    userId?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n    user?: UserOrderByWithRelationInput\n    nodes?: NodeOrderByRelationAggregateInput\n    edges?: EdgeOrderByRelationAggregateInput\n    executions?: ExecutionOrderByRelationAggregateInput\n  }\n\n  export type WorkflowWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: WorkflowWhereInput | WorkflowWhereInput[]\n    OR?: WorkflowWhereInput[]\n    NOT?: WorkflowWhereInput | WorkflowWhereInput[]\n    name?: StringFilter<\"Workflow\"> | string\n    userId?: StringFilter<\"Workflow\"> | string\n    createdAt?: DateTimeFilter<\"Workflow\"> | Date | string\n    updatedAt?: DateTimeFilter<\"Workflow\"> | Date | string\n    user?: XOR<UserScalarRelationFilter, UserWhereInput>\n    nodes?: NodeListRelationFilter\n    edges?: EdgeListRelationFilter\n    executions?: ExecutionListRelationFilter\n  }, \"id\">\n\n  export type WorkflowOrderByWithAggregationInput = {\n    id?: SortOrder\n    name?: SortOrder\n    userId?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n    _count?: WorkflowCountOrderByAggregateInput\n    _max?: WorkflowMaxOrderByAggregateInput\n    _min?: WorkflowMinOrderByAggregateInput\n  }\n\n  export type WorkflowScalarWhereWithAggregatesInput = {\n    AND?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]\n    OR?: WorkflowScalarWhereWithAggregatesInput[]\n    NOT?: WorkflowScalarWhereWithAggregatesInput | WorkflowScalarWhereWithAggregatesInput[]\n    id?: StringWithAggregatesFilter<\"Workflow\"> | string\n    name?: StringWithAggregatesFilter<\"Workflow\"> | string\n    userId?: StringWithAggregatesFilter<\"Workflow\"> | string\n    createdAt?: DateTimeWithAggregatesFilter<\"Workflow\"> | Date | string\n    updatedAt?: DateTimeWithAggregatesFilter<\"Workflow\"> | Date | string\n  }\n\n  export type NodeWhereInput = {\n    AND?: NodeWhereInput | NodeWhereInput[]\n    OR?: NodeWhereInput[]\n    NOT?: NodeWhereInput | NodeWhereInput[]\n    id?: StringFilter<\"Node\"> | string\n    type?: StringFilter<\"Node\"> | string\n    data?: JsonFilter<\"Node\">\n    positionX?: FloatFilter<\"Node\"> | number\n    positionY?: FloatFilter<\"Node\"> | number\n    workflowId?: StringFilter<\"Node\"> | string\n    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>\n    sourceEdges?: EdgeListRelationFilter\n    targetEdges?: EdgeListRelationFilter\n  }\n\n  export type NodeOrderByWithRelationInput = {\n    id?: SortOrder\n    type?: SortOrder\n    data?: SortOrder\n    positionX?: SortOrder\n    positionY?: SortOrder\n    workflowId?: SortOrder\n    workflow?: WorkflowOrderByWithRelationInput\n    sourceEdges?: EdgeOrderByRelationAggregateInput\n    targetEdges?: EdgeOrderByRelationAggregateInput\n  }\n\n  export type NodeWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: NodeWhereInput | NodeWhereInput[]\n    OR?: NodeWhereInput[]\n    NOT?: NodeWhereInput | NodeWhereInput[]\n    type?: StringFilter<\"Node\"> | string\n    data?: JsonFilter<\"Node\">\n    positionX?: FloatFilter<\"Node\"> | number\n    positionY?: FloatFilter<\"Node\"> | number\n    workflowId?: StringFilter<\"Node\"> | string\n    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>\n    sourceEdges?: EdgeListRelationFilter\n    targetEdges?: EdgeListRelationFilter\n  }, \"id\">\n\n  export type NodeOrderByWithAggregationInput = {\n    id?: SortOrder\n    type?: SortOrder\n    data?: SortOrder\n    positionX?: SortOrder\n    positionY?: SortOrder\n    workflowId?: SortOrder\n    _count?: NodeCountOrderByAggregateInput\n    _avg?: NodeAvgOrderByAggregateInput\n    _max?: NodeMaxOrderByAggregateInput\n    _min?: NodeMinOrderByAggregateInput\n    _sum?: NodeSumOrderByAggregateInput\n  }\n\n  export type NodeScalarWhereWithAggregatesInput = {\n    AND?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]\n    OR?: NodeScalarWhereWithAggregatesInput[]\n    NOT?: NodeScalarWhereWithAggregatesInput | NodeScalarWhereWithAggregatesInput[]\n    id?: StringWithAggregatesFilter<\"Node\"> | string\n    type?: StringWithAggregatesFilter<\"Node\"> | string\n    data?: JsonWithAggregatesFilter<\"Node\">\n    positionX?: FloatWithAggregatesFilter<\"Node\"> | number\n    positionY?: FloatWithAggregatesFilter<\"Node\"> | number\n    workflowId?: StringWithAggregatesFilter<\"Node\"> | string\n  }\n\n  export type EdgeWhereInput = {\n    AND?: EdgeWhereInput | EdgeWhereInput[]\n    OR?: EdgeWhereInput[]\n    NOT?: EdgeWhereInput | EdgeWhereInput[]\n    id?: StringFilter<\"Edge\"> | string\n    sourceId?: StringFilter<\"Edge\"> | string\n    targetId?: StringFilter<\"Edge\"> | string\n    workflowId?: StringFilter<\"Edge\"> | string\n    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>\n    sourceNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>\n    targetNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>\n  }\n\n  export type EdgeOrderByWithRelationInput = {\n    id?: SortOrder\n    sourceId?: SortOrder\n    targetId?: SortOrder\n    workflowId?: SortOrder\n    workflow?: WorkflowOrderByWithRelationInput\n    sourceNode?: NodeOrderByWithRelationInput\n    targetNode?: NodeOrderByWithRelationInput\n  }\n\n  export type EdgeWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: EdgeWhereInput | EdgeWhereInput[]\n    OR?: EdgeWhereInput[]\n    NOT?: EdgeWhereInput | EdgeWhereInput[]\n    sourceId?: StringFilter<\"Edge\"> | string\n    targetId?: StringFilter<\"Edge\"> | string\n    workflowId?: StringFilter<\"Edge\"> | string\n    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>\n    sourceNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>\n    targetNode?: XOR<NodeScalarRelationFilter, NodeWhereInput>\n  }, \"id\">\n\n  export type EdgeOrderByWithAggregationInput = {\n    id?: SortOrder\n    sourceId?: SortOrder\n    targetId?: SortOrder\n    workflowId?: SortOrder\n    _count?: EdgeCountOrderByAggregateInput\n    _max?: EdgeMaxOrderByAggregateInput\n    _min?: EdgeMinOrderByAggregateInput\n  }\n\n  export type EdgeScalarWhereWithAggregatesInput = {\n    AND?: EdgeScalarWhereWithAggregatesInput | EdgeScalarWhereWithAggregatesInput[]\n    OR?: EdgeScalarWhereWithAggregatesInput[]\n    NOT?: EdgeScalarWhereWithAggregatesInput | EdgeScalarWhereWithAggregatesInput[]\n    id?: StringWithAggregatesFilter<\"Edge\"> | string\n    sourceId?: StringWithAggregatesFilter<\"Edge\"> | string\n    targetId?: StringWithAggregatesFilter<\"Edge\"> | string\n    workflowId?: StringWithAggregatesFilter<\"Edge\"> | string\n  }\n\n  export type ExecutionWhereInput = {\n    AND?: ExecutionWhereInput | ExecutionWhereInput[]\n    OR?: ExecutionWhereInput[]\n    NOT?: ExecutionWhereInput | ExecutionWhereInput[]\n    id?: StringFilter<\"Execution\"> | string\n    workflowId?: StringFilter<\"Execution\"> | string\n    status?: StringFilter<\"Execution\"> | string\n    startedAt?: DateTimeFilter<\"Execution\"> | Date | string\n    finishedAt?: DateTimeNullableFilter<\"Execution\"> | Date | string | null\n    results?: JsonNullableFilter<\"Execution\">\n    error?: JsonNullableFilter<\"Execution\">\n    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>\n  }\n\n  export type ExecutionOrderByWithRelationInput = {\n    id?: SortOrder\n    workflowId?: SortOrder\n    status?: SortOrder\n    startedAt?: SortOrder\n    finishedAt?: SortOrderInput | SortOrder\n    results?: SortOrderInput | SortOrder\n    error?: SortOrderInput | SortOrder\n    workflow?: WorkflowOrderByWithRelationInput\n  }\n\n  export type ExecutionWhereUniqueInput = Prisma.AtLeast<{\n    id?: string\n    AND?: ExecutionWhereInput | ExecutionWhereInput[]\n    OR?: ExecutionWhereInput[]\n    NOT?: ExecutionWhereInput | ExecutionWhereInput[]\n    workflowId?: StringFilter<\"Execution\"> | string\n    status?: StringFilter<\"Execution\"> | string\n    startedAt?: DateTimeFilter<\"Execution\"> | Date | string\n    finishedAt?: DateTimeNullableFilter<\"Execution\"> | Date | string | null\n    results?: JsonNullableFilter<\"Execution\">\n    error?: JsonNullableFilter<\"Execution\">\n    workflow?: XOR<WorkflowScalarRelationFilter, WorkflowWhereInput>\n  }, \"id\">\n\n  export type ExecutionOrderByWithAggregationInput = {\n    id?: SortOrder\n    workflowId?: SortOrder\n    status?: SortOrder\n    startedAt?: SortOrder\n    finishedAt?: SortOrderInput | SortOrder\n    results?: SortOrderInput | SortOrder\n    error?: SortOrderInput | SortOrder\n    _count?: ExecutionCountOrderByAggregateInput\n    _max?: ExecutionMaxOrderByAggregateInput\n    _min?: ExecutionMinOrderByAggregateInput\n  }\n\n  export type ExecutionScalarWhereWithAggregatesInput = {\n    AND?: ExecutionScalarWhereWithAggregatesInput | ExecutionScalarWhereWithAggregatesInput[]\n    OR?: ExecutionScalarWhereWithAggregatesInput[]\n    NOT?: ExecutionScalarWhereWithAggregatesInput | ExecutionScalarWhereWithAggregatesInput[]\n    id?: StringWithAggregatesFilter<\"Execution\"> | string\n    workflowId?: StringWithAggregatesFilter<\"Execution\"> | string\n    status?: StringWithAggregatesFilter<\"Execution\"> | string\n    startedAt?: DateTimeWithAggregatesFilter<\"Execution\"> | Date | string\n    finishedAt?: DateTimeNullableWithAggregatesFilter<\"Execution\"> | Date | string | null\n    results?: JsonNullableWithAggregatesFilter<\"Execution\">\n    error?: JsonNullableWithAggregatesFilter<\"Execution\">\n  }\n\n  export type UserCreateInput = {\n    id?: string\n    email: string\n    name?: string | null\n    password: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    workflows?: WorkflowCreateNestedManyWithoutUserInput\n  }\n\n  export type UserUncheckedCreateInput = {\n    id?: string\n    email: string\n    name?: string | null\n    password: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    workflows?: WorkflowUncheckedCreateNestedManyWithoutUserInput\n  }\n\n  export type UserUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    password?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    workflows?: WorkflowUpdateManyWithoutUserNestedInput\n  }\n\n  export type UserUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    password?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    workflows?: WorkflowUncheckedUpdateManyWithoutUserNestedInput\n  }\n\n  export type UserCreateManyInput = {\n    id?: string\n    email: string\n    name?: string | null\n    password: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n  }\n\n  export type UserUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    password?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UserUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    password?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type WorkflowCreateInput = {\n    id?: string\n    name: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    user: UserCreateNestedOneWithoutWorkflowsInput\n    nodes?: NodeCreateNestedManyWithoutWorkflowInput\n    edges?: EdgeCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowUncheckedCreateInput = {\n    id?: string\n    name: string\n    userId: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput\n    edges?: EdgeUncheckedCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput\n    nodes?: NodeUpdateManyWithoutWorkflowNestedInput\n    edges?: EdgeUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    userId?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput\n    edges?: EdgeUncheckedUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowCreateManyInput = {\n    id?: string\n    name: string\n    userId: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n  }\n\n  export type WorkflowUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type WorkflowUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    userId?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type NodeCreateInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    workflow: WorkflowCreateNestedOneWithoutNodesInput\n    sourceEdges?: EdgeCreateNestedManyWithoutSourceNodeInput\n    targetEdges?: EdgeCreateNestedManyWithoutTargetNodeInput\n  }\n\n  export type NodeUncheckedCreateInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    workflowId: string\n    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourceNodeInput\n    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetNodeInput\n  }\n\n  export type NodeUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput\n    sourceEdges?: EdgeUpdateManyWithoutSourceNodeNestedInput\n    targetEdges?: EdgeUpdateManyWithoutTargetNodeNestedInput\n  }\n\n  export type NodeUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    workflowId?: StringFieldUpdateOperationsInput | string\n    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput\n    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput\n  }\n\n  export type NodeCreateManyInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    workflowId: string\n  }\n\n  export type NodeUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n  }\n\n  export type NodeUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    workflowId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type EdgeCreateInput = {\n    id: string\n    workflow: WorkflowCreateNestedOneWithoutEdgesInput\n    sourceNode: NodeCreateNestedOneWithoutSourceEdgesInput\n    targetNode: NodeCreateNestedOneWithoutTargetEdgesInput\n  }\n\n  export type EdgeUncheckedCreateInput = {\n    id: string\n    sourceId: string\n    targetId: string\n    workflowId: string\n  }\n\n  export type EdgeUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    workflow?: WorkflowUpdateOneRequiredWithoutEdgesNestedInput\n    sourceNode?: NodeUpdateOneRequiredWithoutSourceEdgesNestedInput\n    targetNode?: NodeUpdateOneRequiredWithoutTargetEdgesNestedInput\n  }\n\n  export type EdgeUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sourceId?: StringFieldUpdateOperationsInput | string\n    targetId?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type EdgeCreateManyInput = {\n    id: string\n    sourceId: string\n    targetId: string\n    workflowId: string\n  }\n\n  export type EdgeUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type EdgeUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sourceId?: StringFieldUpdateOperationsInput | string\n    targetId?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type ExecutionCreateInput = {\n    id?: string\n    status: string\n    startedAt?: Date | string\n    finishedAt?: Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n    workflow: WorkflowCreateNestedOneWithoutExecutionsInput\n  }\n\n  export type ExecutionUncheckedCreateInput = {\n    id?: string\n    workflowId: string\n    status: string\n    startedAt?: Date | string\n    finishedAt?: Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n    workflow?: WorkflowUpdateOneRequiredWithoutExecutionsNestedInput\n  }\n\n  export type ExecutionUncheckedUpdateInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionCreateManyInput = {\n    id?: string\n    workflowId: string\n    status: string\n    startedAt?: Date | string\n    finishedAt?: Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionUpdateManyMutationInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionUncheckedUpdateManyInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type StringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type StringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type DateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type WorkflowListRelationFilter = {\n    every?: WorkflowWhereInput\n    some?: WorkflowWhereInput\n    none?: WorkflowWhereInput\n  }\n\n  export type SortOrderInput = {\n    sort: SortOrder\n    nulls?: NullsOrder\n  }\n\n  export type WorkflowOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type UserCountOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    name?: SortOrder\n    password?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n  }\n\n  export type UserMaxOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    name?: SortOrder\n    password?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n  }\n\n  export type UserMinOrderByAggregateInput = {\n    id?: SortOrder\n    email?: SortOrder\n    name?: SortOrder\n    password?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n  }\n\n  export type StringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    mode?: QueryMode\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type UserScalarRelationFilter = {\n    is?: UserWhereInput\n    isNot?: UserWhereInput\n  }\n\n  export type NodeListRelationFilter = {\n    every?: NodeWhereInput\n    some?: NodeWhereInput\n    none?: NodeWhereInput\n  }\n\n  export type EdgeListRelationFilter = {\n    every?: EdgeWhereInput\n    some?: EdgeWhereInput\n    none?: EdgeWhereInput\n  }\n\n  export type ExecutionListRelationFilter = {\n    every?: ExecutionWhereInput\n    some?: ExecutionWhereInput\n    none?: ExecutionWhereInput\n  }\n\n  export type NodeOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type EdgeOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type ExecutionOrderByRelationAggregateInput = {\n    _count?: SortOrder\n  }\n\n  export type WorkflowCountOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    userId?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n  }\n\n  export type WorkflowMaxOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    userId?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n  }\n\n  export type WorkflowMinOrderByAggregateInput = {\n    id?: SortOrder\n    name?: SortOrder\n    userId?: SortOrder\n    createdAt?: SortOrder\n    updatedAt?: SortOrder\n  }\n  export type JsonFilter<$PrismaModel = never> =\n    | PatchUndefined<\n        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,\n        Required<JsonFilterBase<$PrismaModel>>\n      >\n    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>\n\n  export type JsonFilterBase<$PrismaModel = never> = {\n    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    path?: string[]\n    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>\n    string_contains?: string | StringFieldRefInput<$PrismaModel>\n    string_starts_with?: string | StringFieldRefInput<$PrismaModel>\n    string_ends_with?: string | StringFieldRefInput<$PrismaModel>\n    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n  }\n\n  export type FloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n\n  export type WorkflowScalarRelationFilter = {\n    is?: WorkflowWhereInput\n    isNot?: WorkflowWhereInput\n  }\n\n  export type NodeCountOrderByAggregateInput = {\n    id?: SortOrder\n    type?: SortOrder\n    data?: SortOrder\n    positionX?: SortOrder\n    positionY?: SortOrder\n    workflowId?: SortOrder\n  }\n\n  export type NodeAvgOrderByAggregateInput = {\n    positionX?: SortOrder\n    positionY?: SortOrder\n  }\n\n  export type NodeMaxOrderByAggregateInput = {\n    id?: SortOrder\n    type?: SortOrder\n    positionX?: SortOrder\n    positionY?: SortOrder\n    workflowId?: SortOrder\n  }\n\n  export type NodeMinOrderByAggregateInput = {\n    id?: SortOrder\n    type?: SortOrder\n    positionX?: SortOrder\n    positionY?: SortOrder\n    workflowId?: SortOrder\n  }\n\n  export type NodeSumOrderByAggregateInput = {\n    positionX?: SortOrder\n    positionY?: SortOrder\n  }\n  export type JsonWithAggregatesFilter<$PrismaModel = never> =\n    | PatchUndefined<\n        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,\n        Required<JsonWithAggregatesFilterBase<$PrismaModel>>\n      >\n    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>\n\n  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {\n    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    path?: string[]\n    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>\n    string_contains?: string | StringFieldRefInput<$PrismaModel>\n    string_starts_with?: string | StringFieldRefInput<$PrismaModel>\n    string_ends_with?: string | StringFieldRefInput<$PrismaModel>\n    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedJsonFilter<$PrismaModel>\n    _max?: NestedJsonFilter<$PrismaModel>\n  }\n\n  export type FloatWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedFloatFilter<$PrismaModel>\n    _min?: NestedFloatFilter<$PrismaModel>\n    _max?: NestedFloatFilter<$PrismaModel>\n  }\n\n  export type NodeScalarRelationFilter = {\n    is?: NodeWhereInput\n    isNot?: NodeWhereInput\n  }\n\n  export type EdgeCountOrderByAggregateInput = {\n    id?: SortOrder\n    sourceId?: SortOrder\n    targetId?: SortOrder\n    workflowId?: SortOrder\n  }\n\n  export type EdgeMaxOrderByAggregateInput = {\n    id?: SortOrder\n    sourceId?: SortOrder\n    targetId?: SortOrder\n    workflowId?: SortOrder\n  }\n\n  export type EdgeMinOrderByAggregateInput = {\n    id?: SortOrder\n    sourceId?: SortOrder\n    targetId?: SortOrder\n    workflowId?: SortOrder\n  }\n\n  export type DateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n  export type JsonNullableFilter<$PrismaModel = never> =\n    | PatchUndefined<\n        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,\n        Required<JsonNullableFilterBase<$PrismaModel>>\n      >\n    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>\n\n  export type JsonNullableFilterBase<$PrismaModel = never> = {\n    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    path?: string[]\n    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>\n    string_contains?: string | StringFieldRefInput<$PrismaModel>\n    string_starts_with?: string | StringFieldRefInput<$PrismaModel>\n    string_ends_with?: string | StringFieldRefInput<$PrismaModel>\n    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n  }\n\n  export type ExecutionCountOrderByAggregateInput = {\n    id?: SortOrder\n    workflowId?: SortOrder\n    status?: SortOrder\n    startedAt?: SortOrder\n    finishedAt?: SortOrder\n    results?: SortOrder\n    error?: SortOrder\n  }\n\n  export type ExecutionMaxOrderByAggregateInput = {\n    id?: SortOrder\n    workflowId?: SortOrder\n    status?: SortOrder\n    startedAt?: SortOrder\n    finishedAt?: SortOrder\n  }\n\n  export type ExecutionMinOrderByAggregateInput = {\n    id?: SortOrder\n    workflowId?: SortOrder\n    status?: SortOrder\n    startedAt?: SortOrder\n    finishedAt?: SortOrder\n  }\n\n  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =\n    | PatchUndefined<\n        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,\n        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>\n      >\n    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>\n\n  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {\n    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    path?: string[]\n    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>\n    string_contains?: string | StringFieldRefInput<$PrismaModel>\n    string_starts_with?: string | StringFieldRefInput<$PrismaModel>\n    string_ends_with?: string | StringFieldRefInput<$PrismaModel>\n    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedJsonNullableFilter<$PrismaModel>\n    _max?: NestedJsonNullableFilter<$PrismaModel>\n  }\n\n  export type WorkflowCreateNestedManyWithoutUserInput = {\n    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]\n    createMany?: WorkflowCreateManyUserInputEnvelope\n    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n  }\n\n  export type WorkflowUncheckedCreateNestedManyWithoutUserInput = {\n    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]\n    createMany?: WorkflowCreateManyUserInputEnvelope\n    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n  }\n\n  export type StringFieldUpdateOperationsInput = {\n    set?: string\n  }\n\n  export type NullableStringFieldUpdateOperationsInput = {\n    set?: string | null\n  }\n\n  export type DateTimeFieldUpdateOperationsInput = {\n    set?: Date | string\n  }\n\n  export type WorkflowUpdateManyWithoutUserNestedInput = {\n    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]\n    upsert?: WorkflowUpsertWithWhereUniqueWithoutUserInput | WorkflowUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: WorkflowCreateManyUserInputEnvelope\n    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    update?: WorkflowUpdateWithWhereUniqueWithoutUserInput | WorkflowUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: WorkflowUpdateManyWithWhereWithoutUserInput | WorkflowUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]\n  }\n\n  export type WorkflowUncheckedUpdateManyWithoutUserNestedInput = {\n    create?: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput> | WorkflowCreateWithoutUserInput[] | WorkflowUncheckedCreateWithoutUserInput[]\n    connectOrCreate?: WorkflowCreateOrConnectWithoutUserInput | WorkflowCreateOrConnectWithoutUserInput[]\n    upsert?: WorkflowUpsertWithWhereUniqueWithoutUserInput | WorkflowUpsertWithWhereUniqueWithoutUserInput[]\n    createMany?: WorkflowCreateManyUserInputEnvelope\n    set?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    disconnect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    delete?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    connect?: WorkflowWhereUniqueInput | WorkflowWhereUniqueInput[]\n    update?: WorkflowUpdateWithWhereUniqueWithoutUserInput | WorkflowUpdateWithWhereUniqueWithoutUserInput[]\n    updateMany?: WorkflowUpdateManyWithWhereWithoutUserInput | WorkflowUpdateManyWithWhereWithoutUserInput[]\n    deleteMany?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]\n  }\n\n  export type UserCreateNestedOneWithoutWorkflowsInput = {\n    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>\n    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput\n    connect?: UserWhereUniqueInput\n  }\n\n  export type NodeCreateNestedManyWithoutWorkflowInput = {\n    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]\n    createMany?: NodeCreateManyWorkflowInputEnvelope\n    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n  }\n\n  export type EdgeCreateNestedManyWithoutWorkflowInput = {\n    create?: XOR<EdgeCreateWithoutWorkflowInput, EdgeUncheckedCreateWithoutWorkflowInput> | EdgeCreateWithoutWorkflowInput[] | EdgeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutWorkflowInput | EdgeCreateOrConnectWithoutWorkflowInput[]\n    createMany?: EdgeCreateManyWorkflowInputEnvelope\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n  }\n\n  export type ExecutionCreateNestedManyWithoutWorkflowInput = {\n    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]\n    createMany?: ExecutionCreateManyWorkflowInputEnvelope\n    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n  }\n\n  export type NodeUncheckedCreateNestedManyWithoutWorkflowInput = {\n    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]\n    createMany?: NodeCreateManyWorkflowInputEnvelope\n    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n  }\n\n  export type EdgeUncheckedCreateNestedManyWithoutWorkflowInput = {\n    create?: XOR<EdgeCreateWithoutWorkflowInput, EdgeUncheckedCreateWithoutWorkflowInput> | EdgeCreateWithoutWorkflowInput[] | EdgeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutWorkflowInput | EdgeCreateOrConnectWithoutWorkflowInput[]\n    createMany?: EdgeCreateManyWorkflowInputEnvelope\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n  }\n\n  export type ExecutionUncheckedCreateNestedManyWithoutWorkflowInput = {\n    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]\n    createMany?: ExecutionCreateManyWorkflowInputEnvelope\n    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n  }\n\n  export type UserUpdateOneRequiredWithoutWorkflowsNestedInput = {\n    create?: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>\n    connectOrCreate?: UserCreateOrConnectWithoutWorkflowsInput\n    upsert?: UserUpsertWithoutWorkflowsInput\n    connect?: UserWhereUniqueInput\n    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutWorkflowsInput, UserUpdateWithoutWorkflowsInput>, UserUncheckedUpdateWithoutWorkflowsInput>\n  }\n\n  export type NodeUpdateManyWithoutWorkflowNestedInput = {\n    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]\n    upsert?: NodeUpsertWithWhereUniqueWithoutWorkflowInput | NodeUpsertWithWhereUniqueWithoutWorkflowInput[]\n    createMany?: NodeCreateManyWorkflowInputEnvelope\n    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    update?: NodeUpdateWithWhereUniqueWithoutWorkflowInput | NodeUpdateWithWhereUniqueWithoutWorkflowInput[]\n    updateMany?: NodeUpdateManyWithWhereWithoutWorkflowInput | NodeUpdateManyWithWhereWithoutWorkflowInput[]\n    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]\n  }\n\n  export type EdgeUpdateManyWithoutWorkflowNestedInput = {\n    create?: XOR<EdgeCreateWithoutWorkflowInput, EdgeUncheckedCreateWithoutWorkflowInput> | EdgeCreateWithoutWorkflowInput[] | EdgeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutWorkflowInput | EdgeCreateOrConnectWithoutWorkflowInput[]\n    upsert?: EdgeUpsertWithWhereUniqueWithoutWorkflowInput | EdgeUpsertWithWhereUniqueWithoutWorkflowInput[]\n    createMany?: EdgeCreateManyWorkflowInputEnvelope\n    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    update?: EdgeUpdateWithWhereUniqueWithoutWorkflowInput | EdgeUpdateWithWhereUniqueWithoutWorkflowInput[]\n    updateMany?: EdgeUpdateManyWithWhereWithoutWorkflowInput | EdgeUpdateManyWithWhereWithoutWorkflowInput[]\n    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n  }\n\n  export type ExecutionUpdateManyWithoutWorkflowNestedInput = {\n    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]\n    upsert?: ExecutionUpsertWithWhereUniqueWithoutWorkflowInput | ExecutionUpsertWithWhereUniqueWithoutWorkflowInput[]\n    createMany?: ExecutionCreateManyWorkflowInputEnvelope\n    set?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    disconnect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    delete?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    update?: ExecutionUpdateWithWhereUniqueWithoutWorkflowInput | ExecutionUpdateWithWhereUniqueWithoutWorkflowInput[]\n    updateMany?: ExecutionUpdateManyWithWhereWithoutWorkflowInput | ExecutionUpdateManyWithWhereWithoutWorkflowInput[]\n    deleteMany?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]\n  }\n\n  export type NodeUncheckedUpdateManyWithoutWorkflowNestedInput = {\n    create?: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput> | NodeCreateWithoutWorkflowInput[] | NodeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: NodeCreateOrConnectWithoutWorkflowInput | NodeCreateOrConnectWithoutWorkflowInput[]\n    upsert?: NodeUpsertWithWhereUniqueWithoutWorkflowInput | NodeUpsertWithWhereUniqueWithoutWorkflowInput[]\n    createMany?: NodeCreateManyWorkflowInputEnvelope\n    set?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    disconnect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    delete?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    connect?: NodeWhereUniqueInput | NodeWhereUniqueInput[]\n    update?: NodeUpdateWithWhereUniqueWithoutWorkflowInput | NodeUpdateWithWhereUniqueWithoutWorkflowInput[]\n    updateMany?: NodeUpdateManyWithWhereWithoutWorkflowInput | NodeUpdateManyWithWhereWithoutWorkflowInput[]\n    deleteMany?: NodeScalarWhereInput | NodeScalarWhereInput[]\n  }\n\n  export type EdgeUncheckedUpdateManyWithoutWorkflowNestedInput = {\n    create?: XOR<EdgeCreateWithoutWorkflowInput, EdgeUncheckedCreateWithoutWorkflowInput> | EdgeCreateWithoutWorkflowInput[] | EdgeUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutWorkflowInput | EdgeCreateOrConnectWithoutWorkflowInput[]\n    upsert?: EdgeUpsertWithWhereUniqueWithoutWorkflowInput | EdgeUpsertWithWhereUniqueWithoutWorkflowInput[]\n    createMany?: EdgeCreateManyWorkflowInputEnvelope\n    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    update?: EdgeUpdateWithWhereUniqueWithoutWorkflowInput | EdgeUpdateWithWhereUniqueWithoutWorkflowInput[]\n    updateMany?: EdgeUpdateManyWithWhereWithoutWorkflowInput | EdgeUpdateManyWithWhereWithoutWorkflowInput[]\n    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n  }\n\n  export type ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput = {\n    create?: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput> | ExecutionCreateWithoutWorkflowInput[] | ExecutionUncheckedCreateWithoutWorkflowInput[]\n    connectOrCreate?: ExecutionCreateOrConnectWithoutWorkflowInput | ExecutionCreateOrConnectWithoutWorkflowInput[]\n    upsert?: ExecutionUpsertWithWhereUniqueWithoutWorkflowInput | ExecutionUpsertWithWhereUniqueWithoutWorkflowInput[]\n    createMany?: ExecutionCreateManyWorkflowInputEnvelope\n    set?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    disconnect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    delete?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    connect?: ExecutionWhereUniqueInput | ExecutionWhereUniqueInput[]\n    update?: ExecutionUpdateWithWhereUniqueWithoutWorkflowInput | ExecutionUpdateWithWhereUniqueWithoutWorkflowInput[]\n    updateMany?: ExecutionUpdateManyWithWhereWithoutWorkflowInput | ExecutionUpdateManyWithWhereWithoutWorkflowInput[]\n    deleteMany?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]\n  }\n\n  export type WorkflowCreateNestedOneWithoutNodesInput = {\n    create?: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>\n    connectOrCreate?: WorkflowCreateOrConnectWithoutNodesInput\n    connect?: WorkflowWhereUniqueInput\n  }\n\n  export type EdgeCreateNestedManyWithoutSourceNodeInput = {\n    create?: XOR<EdgeCreateWithoutSourceNodeInput, EdgeUncheckedCreateWithoutSourceNodeInput> | EdgeCreateWithoutSourceNodeInput[] | EdgeUncheckedCreateWithoutSourceNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutSourceNodeInput | EdgeCreateOrConnectWithoutSourceNodeInput[]\n    createMany?: EdgeCreateManySourceNodeInputEnvelope\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n  }\n\n  export type EdgeCreateNestedManyWithoutTargetNodeInput = {\n    create?: XOR<EdgeCreateWithoutTargetNodeInput, EdgeUncheckedCreateWithoutTargetNodeInput> | EdgeCreateWithoutTargetNodeInput[] | EdgeUncheckedCreateWithoutTargetNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutTargetNodeInput | EdgeCreateOrConnectWithoutTargetNodeInput[]\n    createMany?: EdgeCreateManyTargetNodeInputEnvelope\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n  }\n\n  export type EdgeUncheckedCreateNestedManyWithoutSourceNodeInput = {\n    create?: XOR<EdgeCreateWithoutSourceNodeInput, EdgeUncheckedCreateWithoutSourceNodeInput> | EdgeCreateWithoutSourceNodeInput[] | EdgeUncheckedCreateWithoutSourceNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutSourceNodeInput | EdgeCreateOrConnectWithoutSourceNodeInput[]\n    createMany?: EdgeCreateManySourceNodeInputEnvelope\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n  }\n\n  export type EdgeUncheckedCreateNestedManyWithoutTargetNodeInput = {\n    create?: XOR<EdgeCreateWithoutTargetNodeInput, EdgeUncheckedCreateWithoutTargetNodeInput> | EdgeCreateWithoutTargetNodeInput[] | EdgeUncheckedCreateWithoutTargetNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutTargetNodeInput | EdgeCreateOrConnectWithoutTargetNodeInput[]\n    createMany?: EdgeCreateManyTargetNodeInputEnvelope\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n  }\n\n  export type FloatFieldUpdateOperationsInput = {\n    set?: number\n    increment?: number\n    decrement?: number\n    multiply?: number\n    divide?: number\n  }\n\n  export type WorkflowUpdateOneRequiredWithoutNodesNestedInput = {\n    create?: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>\n    connectOrCreate?: WorkflowCreateOrConnectWithoutNodesInput\n    upsert?: WorkflowUpsertWithoutNodesInput\n    connect?: WorkflowWhereUniqueInput\n    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutNodesInput, WorkflowUpdateWithoutNodesInput>, WorkflowUncheckedUpdateWithoutNodesInput>\n  }\n\n  export type EdgeUpdateManyWithoutSourceNodeNestedInput = {\n    create?: XOR<EdgeCreateWithoutSourceNodeInput, EdgeUncheckedCreateWithoutSourceNodeInput> | EdgeCreateWithoutSourceNodeInput[] | EdgeUncheckedCreateWithoutSourceNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutSourceNodeInput | EdgeCreateOrConnectWithoutSourceNodeInput[]\n    upsert?: EdgeUpsertWithWhereUniqueWithoutSourceNodeInput | EdgeUpsertWithWhereUniqueWithoutSourceNodeInput[]\n    createMany?: EdgeCreateManySourceNodeInputEnvelope\n    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    update?: EdgeUpdateWithWhereUniqueWithoutSourceNodeInput | EdgeUpdateWithWhereUniqueWithoutSourceNodeInput[]\n    updateMany?: EdgeUpdateManyWithWhereWithoutSourceNodeInput | EdgeUpdateManyWithWhereWithoutSourceNodeInput[]\n    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n  }\n\n  export type EdgeUpdateManyWithoutTargetNodeNestedInput = {\n    create?: XOR<EdgeCreateWithoutTargetNodeInput, EdgeUncheckedCreateWithoutTargetNodeInput> | EdgeCreateWithoutTargetNodeInput[] | EdgeUncheckedCreateWithoutTargetNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutTargetNodeInput | EdgeCreateOrConnectWithoutTargetNodeInput[]\n    upsert?: EdgeUpsertWithWhereUniqueWithoutTargetNodeInput | EdgeUpsertWithWhereUniqueWithoutTargetNodeInput[]\n    createMany?: EdgeCreateManyTargetNodeInputEnvelope\n    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    update?: EdgeUpdateWithWhereUniqueWithoutTargetNodeInput | EdgeUpdateWithWhereUniqueWithoutTargetNodeInput[]\n    updateMany?: EdgeUpdateManyWithWhereWithoutTargetNodeInput | EdgeUpdateManyWithWhereWithoutTargetNodeInput[]\n    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n  }\n\n  export type EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput = {\n    create?: XOR<EdgeCreateWithoutSourceNodeInput, EdgeUncheckedCreateWithoutSourceNodeInput> | EdgeCreateWithoutSourceNodeInput[] | EdgeUncheckedCreateWithoutSourceNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutSourceNodeInput | EdgeCreateOrConnectWithoutSourceNodeInput[]\n    upsert?: EdgeUpsertWithWhereUniqueWithoutSourceNodeInput | EdgeUpsertWithWhereUniqueWithoutSourceNodeInput[]\n    createMany?: EdgeCreateManySourceNodeInputEnvelope\n    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    update?: EdgeUpdateWithWhereUniqueWithoutSourceNodeInput | EdgeUpdateWithWhereUniqueWithoutSourceNodeInput[]\n    updateMany?: EdgeUpdateManyWithWhereWithoutSourceNodeInput | EdgeUpdateManyWithWhereWithoutSourceNodeInput[]\n    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n  }\n\n  export type EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput = {\n    create?: XOR<EdgeCreateWithoutTargetNodeInput, EdgeUncheckedCreateWithoutTargetNodeInput> | EdgeCreateWithoutTargetNodeInput[] | EdgeUncheckedCreateWithoutTargetNodeInput[]\n    connectOrCreate?: EdgeCreateOrConnectWithoutTargetNodeInput | EdgeCreateOrConnectWithoutTargetNodeInput[]\n    upsert?: EdgeUpsertWithWhereUniqueWithoutTargetNodeInput | EdgeUpsertWithWhereUniqueWithoutTargetNodeInput[]\n    createMany?: EdgeCreateManyTargetNodeInputEnvelope\n    set?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    disconnect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    delete?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    connect?: EdgeWhereUniqueInput | EdgeWhereUniqueInput[]\n    update?: EdgeUpdateWithWhereUniqueWithoutTargetNodeInput | EdgeUpdateWithWhereUniqueWithoutTargetNodeInput[]\n    updateMany?: EdgeUpdateManyWithWhereWithoutTargetNodeInput | EdgeUpdateManyWithWhereWithoutTargetNodeInput[]\n    deleteMany?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n  }\n\n  export type WorkflowCreateNestedOneWithoutEdgesInput = {\n    create?: XOR<WorkflowCreateWithoutEdgesInput, WorkflowUncheckedCreateWithoutEdgesInput>\n    connectOrCreate?: WorkflowCreateOrConnectWithoutEdgesInput\n    connect?: WorkflowWhereUniqueInput\n  }\n\n  export type NodeCreateNestedOneWithoutSourceEdgesInput = {\n    create?: XOR<NodeCreateWithoutSourceEdgesInput, NodeUncheckedCreateWithoutSourceEdgesInput>\n    connectOrCreate?: NodeCreateOrConnectWithoutSourceEdgesInput\n    connect?: NodeWhereUniqueInput\n  }\n\n  export type NodeCreateNestedOneWithoutTargetEdgesInput = {\n    create?: XOR<NodeCreateWithoutTargetEdgesInput, NodeUncheckedCreateWithoutTargetEdgesInput>\n    connectOrCreate?: NodeCreateOrConnectWithoutTargetEdgesInput\n    connect?: NodeWhereUniqueInput\n  }\n\n  export type WorkflowUpdateOneRequiredWithoutEdgesNestedInput = {\n    create?: XOR<WorkflowCreateWithoutEdgesInput, WorkflowUncheckedCreateWithoutEdgesInput>\n    connectOrCreate?: WorkflowCreateOrConnectWithoutEdgesInput\n    upsert?: WorkflowUpsertWithoutEdgesInput\n    connect?: WorkflowWhereUniqueInput\n    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutEdgesInput, WorkflowUpdateWithoutEdgesInput>, WorkflowUncheckedUpdateWithoutEdgesInput>\n  }\n\n  export type NodeUpdateOneRequiredWithoutSourceEdgesNestedInput = {\n    create?: XOR<NodeCreateWithoutSourceEdgesInput, NodeUncheckedCreateWithoutSourceEdgesInput>\n    connectOrCreate?: NodeCreateOrConnectWithoutSourceEdgesInput\n    upsert?: NodeUpsertWithoutSourceEdgesInput\n    connect?: NodeWhereUniqueInput\n    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutSourceEdgesInput, NodeUpdateWithoutSourceEdgesInput>, NodeUncheckedUpdateWithoutSourceEdgesInput>\n  }\n\n  export type NodeUpdateOneRequiredWithoutTargetEdgesNestedInput = {\n    create?: XOR<NodeCreateWithoutTargetEdgesInput, NodeUncheckedCreateWithoutTargetEdgesInput>\n    connectOrCreate?: NodeCreateOrConnectWithoutTargetEdgesInput\n    upsert?: NodeUpsertWithoutTargetEdgesInput\n    connect?: NodeWhereUniqueInput\n    update?: XOR<XOR<NodeUpdateToOneWithWhereWithoutTargetEdgesInput, NodeUpdateWithoutTargetEdgesInput>, NodeUncheckedUpdateWithoutTargetEdgesInput>\n  }\n\n  export type WorkflowCreateNestedOneWithoutExecutionsInput = {\n    create?: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>\n    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput\n    connect?: WorkflowWhereUniqueInput\n  }\n\n  export type NullableDateTimeFieldUpdateOperationsInput = {\n    set?: Date | string | null\n  }\n\n  export type WorkflowUpdateOneRequiredWithoutExecutionsNestedInput = {\n    create?: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>\n    connectOrCreate?: WorkflowCreateOrConnectWithoutExecutionsInput\n    upsert?: WorkflowUpsertWithoutExecutionsInput\n    connect?: WorkflowWhereUniqueInput\n    update?: XOR<XOR<WorkflowUpdateToOneWithWhereWithoutExecutionsInput, WorkflowUpdateWithoutExecutionsInput>, WorkflowUncheckedUpdateWithoutExecutionsInput>\n  }\n\n  export type NestedStringFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringFilter<$PrismaModel> | string\n  }\n\n  export type NestedStringNullableFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableFilter<$PrismaModel> | string | null\n  }\n\n  export type NestedDateTimeFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeFilter<$PrismaModel> | Date | string\n  }\n\n  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel>\n    in?: string[] | ListStringFieldRefInput<$PrismaModel>\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedStringFilter<$PrismaModel>\n    _max?: NestedStringFilter<$PrismaModel>\n  }\n\n  export type NestedIntFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel>\n    in?: number[] | ListIntFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntFilter<$PrismaModel> | number\n  }\n\n  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: string | StringFieldRefInput<$PrismaModel> | null\n    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null\n    lt?: string | StringFieldRefInput<$PrismaModel>\n    lte?: string | StringFieldRefInput<$PrismaModel>\n    gt?: string | StringFieldRefInput<$PrismaModel>\n    gte?: string | StringFieldRefInput<$PrismaModel>\n    contains?: string | StringFieldRefInput<$PrismaModel>\n    startsWith?: string | StringFieldRefInput<$PrismaModel>\n    endsWith?: string | StringFieldRefInput<$PrismaModel>\n    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedStringNullableFilter<$PrismaModel>\n    _max?: NestedStringNullableFilter<$PrismaModel>\n  }\n\n  export type NestedIntNullableFilter<$PrismaModel = never> = {\n    equals?: number | IntFieldRefInput<$PrismaModel> | null\n    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null\n    lt?: number | IntFieldRefInput<$PrismaModel>\n    lte?: number | IntFieldRefInput<$PrismaModel>\n    gt?: number | IntFieldRefInput<$PrismaModel>\n    gte?: number | IntFieldRefInput<$PrismaModel>\n    not?: NestedIntNullableFilter<$PrismaModel> | number | null\n  }\n\n  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string\n    _count?: NestedIntFilter<$PrismaModel>\n    _min?: NestedDateTimeFilter<$PrismaModel>\n    _max?: NestedDateTimeFilter<$PrismaModel>\n  }\n\n  export type NestedFloatFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatFilter<$PrismaModel> | number\n  }\n  export type NestedJsonFilter<$PrismaModel = never> =\n    | PatchUndefined<\n        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,\n        Required<NestedJsonFilterBase<$PrismaModel>>\n      >\n    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>\n\n  export type NestedJsonFilterBase<$PrismaModel = never> = {\n    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    path?: string[]\n    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>\n    string_contains?: string | StringFieldRefInput<$PrismaModel>\n    string_starts_with?: string | StringFieldRefInput<$PrismaModel>\n    string_ends_with?: string | StringFieldRefInput<$PrismaModel>\n    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n  }\n\n  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: number | FloatFieldRefInput<$PrismaModel>\n    in?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>\n    lt?: number | FloatFieldRefInput<$PrismaModel>\n    lte?: number | FloatFieldRefInput<$PrismaModel>\n    gt?: number | FloatFieldRefInput<$PrismaModel>\n    gte?: number | FloatFieldRefInput<$PrismaModel>\n    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number\n    _count?: NestedIntFilter<$PrismaModel>\n    _avg?: NestedFloatFilter<$PrismaModel>\n    _sum?: NestedFloatFilter<$PrismaModel>\n    _min?: NestedFloatFilter<$PrismaModel>\n    _max?: NestedFloatFilter<$PrismaModel>\n  }\n\n  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null\n  }\n\n  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {\n    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null\n    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null\n    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>\n    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null\n    _count?: NestedIntNullableFilter<$PrismaModel>\n    _min?: NestedDateTimeNullableFilter<$PrismaModel>\n    _max?: NestedDateTimeNullableFilter<$PrismaModel>\n  }\n  export type NestedJsonNullableFilter<$PrismaModel = never> =\n    | PatchUndefined<\n        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,\n        Required<NestedJsonNullableFilterBase<$PrismaModel>>\n      >\n    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>\n\n  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {\n    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n    path?: string[]\n    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>\n    string_contains?: string | StringFieldRefInput<$PrismaModel>\n    string_starts_with?: string | StringFieldRefInput<$PrismaModel>\n    string_ends_with?: string | StringFieldRefInput<$PrismaModel>\n    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null\n    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>\n    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter\n  }\n\n  export type WorkflowCreateWithoutUserInput = {\n    id?: string\n    name: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    nodes?: NodeCreateNestedManyWithoutWorkflowInput\n    edges?: EdgeCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowUncheckedCreateWithoutUserInput = {\n    id?: string\n    name: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput\n    edges?: EdgeUncheckedCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowCreateOrConnectWithoutUserInput = {\n    where: WorkflowWhereUniqueInput\n    create: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput>\n  }\n\n  export type WorkflowCreateManyUserInputEnvelope = {\n    data: WorkflowCreateManyUserInput | WorkflowCreateManyUserInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type WorkflowUpsertWithWhereUniqueWithoutUserInput = {\n    where: WorkflowWhereUniqueInput\n    update: XOR<WorkflowUpdateWithoutUserInput, WorkflowUncheckedUpdateWithoutUserInput>\n    create: XOR<WorkflowCreateWithoutUserInput, WorkflowUncheckedCreateWithoutUserInput>\n  }\n\n  export type WorkflowUpdateWithWhereUniqueWithoutUserInput = {\n    where: WorkflowWhereUniqueInput\n    data: XOR<WorkflowUpdateWithoutUserInput, WorkflowUncheckedUpdateWithoutUserInput>\n  }\n\n  export type WorkflowUpdateManyWithWhereWithoutUserInput = {\n    where: WorkflowScalarWhereInput\n    data: XOR<WorkflowUpdateManyMutationInput, WorkflowUncheckedUpdateManyWithoutUserInput>\n  }\n\n  export type WorkflowScalarWhereInput = {\n    AND?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]\n    OR?: WorkflowScalarWhereInput[]\n    NOT?: WorkflowScalarWhereInput | WorkflowScalarWhereInput[]\n    id?: StringFilter<\"Workflow\"> | string\n    name?: StringFilter<\"Workflow\"> | string\n    userId?: StringFilter<\"Workflow\"> | string\n    createdAt?: DateTimeFilter<\"Workflow\"> | Date | string\n    updatedAt?: DateTimeFilter<\"Workflow\"> | Date | string\n  }\n\n  export type UserCreateWithoutWorkflowsInput = {\n    id?: string\n    email: string\n    name?: string | null\n    password: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n  }\n\n  export type UserUncheckedCreateWithoutWorkflowsInput = {\n    id?: string\n    email: string\n    name?: string | null\n    password: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n  }\n\n  export type UserCreateOrConnectWithoutWorkflowsInput = {\n    where: UserWhereUniqueInput\n    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>\n  }\n\n  export type NodeCreateWithoutWorkflowInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    sourceEdges?: EdgeCreateNestedManyWithoutSourceNodeInput\n    targetEdges?: EdgeCreateNestedManyWithoutTargetNodeInput\n  }\n\n  export type NodeUncheckedCreateWithoutWorkflowInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourceNodeInput\n    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetNodeInput\n  }\n\n  export type NodeCreateOrConnectWithoutWorkflowInput = {\n    where: NodeWhereUniqueInput\n    create: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput>\n  }\n\n  export type NodeCreateManyWorkflowInputEnvelope = {\n    data: NodeCreateManyWorkflowInput | NodeCreateManyWorkflowInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type EdgeCreateWithoutWorkflowInput = {\n    id: string\n    sourceNode: NodeCreateNestedOneWithoutSourceEdgesInput\n    targetNode: NodeCreateNestedOneWithoutTargetEdgesInput\n  }\n\n  export type EdgeUncheckedCreateWithoutWorkflowInput = {\n    id: string\n    sourceId: string\n    targetId: string\n  }\n\n  export type EdgeCreateOrConnectWithoutWorkflowInput = {\n    where: EdgeWhereUniqueInput\n    create: XOR<EdgeCreateWithoutWorkflowInput, EdgeUncheckedCreateWithoutWorkflowInput>\n  }\n\n  export type EdgeCreateManyWorkflowInputEnvelope = {\n    data: EdgeCreateManyWorkflowInput | EdgeCreateManyWorkflowInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type ExecutionCreateWithoutWorkflowInput = {\n    id?: string\n    status: string\n    startedAt?: Date | string\n    finishedAt?: Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionUncheckedCreateWithoutWorkflowInput = {\n    id?: string\n    status: string\n    startedAt?: Date | string\n    finishedAt?: Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionCreateOrConnectWithoutWorkflowInput = {\n    where: ExecutionWhereUniqueInput\n    create: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput>\n  }\n\n  export type ExecutionCreateManyWorkflowInputEnvelope = {\n    data: ExecutionCreateManyWorkflowInput | ExecutionCreateManyWorkflowInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type UserUpsertWithoutWorkflowsInput = {\n    update: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>\n    create: XOR<UserCreateWithoutWorkflowsInput, UserUncheckedCreateWithoutWorkflowsInput>\n    where?: UserWhereInput\n  }\n\n  export type UserUpdateToOneWithWhereWithoutWorkflowsInput = {\n    where?: UserWhereInput\n    data: XOR<UserUpdateWithoutWorkflowsInput, UserUncheckedUpdateWithoutWorkflowsInput>\n  }\n\n  export type UserUpdateWithoutWorkflowsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    password?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type UserUncheckedUpdateWithoutWorkflowsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    email?: StringFieldUpdateOperationsInput | string\n    name?: NullableStringFieldUpdateOperationsInput | string | null\n    password?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type NodeUpsertWithWhereUniqueWithoutWorkflowInput = {\n    where: NodeWhereUniqueInput\n    update: XOR<NodeUpdateWithoutWorkflowInput, NodeUncheckedUpdateWithoutWorkflowInput>\n    create: XOR<NodeCreateWithoutWorkflowInput, NodeUncheckedCreateWithoutWorkflowInput>\n  }\n\n  export type NodeUpdateWithWhereUniqueWithoutWorkflowInput = {\n    where: NodeWhereUniqueInput\n    data: XOR<NodeUpdateWithoutWorkflowInput, NodeUncheckedUpdateWithoutWorkflowInput>\n  }\n\n  export type NodeUpdateManyWithWhereWithoutWorkflowInput = {\n    where: NodeScalarWhereInput\n    data: XOR<NodeUpdateManyMutationInput, NodeUncheckedUpdateManyWithoutWorkflowInput>\n  }\n\n  export type NodeScalarWhereInput = {\n    AND?: NodeScalarWhereInput | NodeScalarWhereInput[]\n    OR?: NodeScalarWhereInput[]\n    NOT?: NodeScalarWhereInput | NodeScalarWhereInput[]\n    id?: StringFilter<\"Node\"> | string\n    type?: StringFilter<\"Node\"> | string\n    data?: JsonFilter<\"Node\">\n    positionX?: FloatFilter<\"Node\"> | number\n    positionY?: FloatFilter<\"Node\"> | number\n    workflowId?: StringFilter<\"Node\"> | string\n  }\n\n  export type EdgeUpsertWithWhereUniqueWithoutWorkflowInput = {\n    where: EdgeWhereUniqueInput\n    update: XOR<EdgeUpdateWithoutWorkflowInput, EdgeUncheckedUpdateWithoutWorkflowInput>\n    create: XOR<EdgeCreateWithoutWorkflowInput, EdgeUncheckedCreateWithoutWorkflowInput>\n  }\n\n  export type EdgeUpdateWithWhereUniqueWithoutWorkflowInput = {\n    where: EdgeWhereUniqueInput\n    data: XOR<EdgeUpdateWithoutWorkflowInput, EdgeUncheckedUpdateWithoutWorkflowInput>\n  }\n\n  export type EdgeUpdateManyWithWhereWithoutWorkflowInput = {\n    where: EdgeScalarWhereInput\n    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutWorkflowInput>\n  }\n\n  export type EdgeScalarWhereInput = {\n    AND?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n    OR?: EdgeScalarWhereInput[]\n    NOT?: EdgeScalarWhereInput | EdgeScalarWhereInput[]\n    id?: StringFilter<\"Edge\"> | string\n    sourceId?: StringFilter<\"Edge\"> | string\n    targetId?: StringFilter<\"Edge\"> | string\n    workflowId?: StringFilter<\"Edge\"> | string\n  }\n\n  export type ExecutionUpsertWithWhereUniqueWithoutWorkflowInput = {\n    where: ExecutionWhereUniqueInput\n    update: XOR<ExecutionUpdateWithoutWorkflowInput, ExecutionUncheckedUpdateWithoutWorkflowInput>\n    create: XOR<ExecutionCreateWithoutWorkflowInput, ExecutionUncheckedCreateWithoutWorkflowInput>\n  }\n\n  export type ExecutionUpdateWithWhereUniqueWithoutWorkflowInput = {\n    where: ExecutionWhereUniqueInput\n    data: XOR<ExecutionUpdateWithoutWorkflowInput, ExecutionUncheckedUpdateWithoutWorkflowInput>\n  }\n\n  export type ExecutionUpdateManyWithWhereWithoutWorkflowInput = {\n    where: ExecutionScalarWhereInput\n    data: XOR<ExecutionUpdateManyMutationInput, ExecutionUncheckedUpdateManyWithoutWorkflowInput>\n  }\n\n  export type ExecutionScalarWhereInput = {\n    AND?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]\n    OR?: ExecutionScalarWhereInput[]\n    NOT?: ExecutionScalarWhereInput | ExecutionScalarWhereInput[]\n    id?: StringFilter<\"Execution\"> | string\n    workflowId?: StringFilter<\"Execution\"> | string\n    status?: StringFilter<\"Execution\"> | string\n    startedAt?: DateTimeFilter<\"Execution\"> | Date | string\n    finishedAt?: DateTimeNullableFilter<\"Execution\"> | Date | string | null\n    results?: JsonNullableFilter<\"Execution\">\n    error?: JsonNullableFilter<\"Execution\">\n  }\n\n  export type WorkflowCreateWithoutNodesInput = {\n    id?: string\n    name: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    user: UserCreateNestedOneWithoutWorkflowsInput\n    edges?: EdgeCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowUncheckedCreateWithoutNodesInput = {\n    id?: string\n    name: string\n    userId: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    edges?: EdgeUncheckedCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowCreateOrConnectWithoutNodesInput = {\n    where: WorkflowWhereUniqueInput\n    create: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>\n  }\n\n  export type EdgeCreateWithoutSourceNodeInput = {\n    id: string\n    workflow: WorkflowCreateNestedOneWithoutEdgesInput\n    targetNode: NodeCreateNestedOneWithoutTargetEdgesInput\n  }\n\n  export type EdgeUncheckedCreateWithoutSourceNodeInput = {\n    id: string\n    targetId: string\n    workflowId: string\n  }\n\n  export type EdgeCreateOrConnectWithoutSourceNodeInput = {\n    where: EdgeWhereUniqueInput\n    create: XOR<EdgeCreateWithoutSourceNodeInput, EdgeUncheckedCreateWithoutSourceNodeInput>\n  }\n\n  export type EdgeCreateManySourceNodeInputEnvelope = {\n    data: EdgeCreateManySourceNodeInput | EdgeCreateManySourceNodeInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type EdgeCreateWithoutTargetNodeInput = {\n    id: string\n    workflow: WorkflowCreateNestedOneWithoutEdgesInput\n    sourceNode: NodeCreateNestedOneWithoutSourceEdgesInput\n  }\n\n  export type EdgeUncheckedCreateWithoutTargetNodeInput = {\n    id: string\n    sourceId: string\n    workflowId: string\n  }\n\n  export type EdgeCreateOrConnectWithoutTargetNodeInput = {\n    where: EdgeWhereUniqueInput\n    create: XOR<EdgeCreateWithoutTargetNodeInput, EdgeUncheckedCreateWithoutTargetNodeInput>\n  }\n\n  export type EdgeCreateManyTargetNodeInputEnvelope = {\n    data: EdgeCreateManyTargetNodeInput | EdgeCreateManyTargetNodeInput[]\n    skipDuplicates?: boolean\n  }\n\n  export type WorkflowUpsertWithoutNodesInput = {\n    update: XOR<WorkflowUpdateWithoutNodesInput, WorkflowUncheckedUpdateWithoutNodesInput>\n    create: XOR<WorkflowCreateWithoutNodesInput, WorkflowUncheckedCreateWithoutNodesInput>\n    where?: WorkflowWhereInput\n  }\n\n  export type WorkflowUpdateToOneWithWhereWithoutNodesInput = {\n    where?: WorkflowWhereInput\n    data: XOR<WorkflowUpdateWithoutNodesInput, WorkflowUncheckedUpdateWithoutNodesInput>\n  }\n\n  export type WorkflowUpdateWithoutNodesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput\n    edges?: EdgeUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowUncheckedUpdateWithoutNodesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    userId?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    edges?: EdgeUncheckedUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type EdgeUpsertWithWhereUniqueWithoutSourceNodeInput = {\n    where: EdgeWhereUniqueInput\n    update: XOR<EdgeUpdateWithoutSourceNodeInput, EdgeUncheckedUpdateWithoutSourceNodeInput>\n    create: XOR<EdgeCreateWithoutSourceNodeInput, EdgeUncheckedCreateWithoutSourceNodeInput>\n  }\n\n  export type EdgeUpdateWithWhereUniqueWithoutSourceNodeInput = {\n    where: EdgeWhereUniqueInput\n    data: XOR<EdgeUpdateWithoutSourceNodeInput, EdgeUncheckedUpdateWithoutSourceNodeInput>\n  }\n\n  export type EdgeUpdateManyWithWhereWithoutSourceNodeInput = {\n    where: EdgeScalarWhereInput\n    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutSourceNodeInput>\n  }\n\n  export type EdgeUpsertWithWhereUniqueWithoutTargetNodeInput = {\n    where: EdgeWhereUniqueInput\n    update: XOR<EdgeUpdateWithoutTargetNodeInput, EdgeUncheckedUpdateWithoutTargetNodeInput>\n    create: XOR<EdgeCreateWithoutTargetNodeInput, EdgeUncheckedCreateWithoutTargetNodeInput>\n  }\n\n  export type EdgeUpdateWithWhereUniqueWithoutTargetNodeInput = {\n    where: EdgeWhereUniqueInput\n    data: XOR<EdgeUpdateWithoutTargetNodeInput, EdgeUncheckedUpdateWithoutTargetNodeInput>\n  }\n\n  export type EdgeUpdateManyWithWhereWithoutTargetNodeInput = {\n    where: EdgeScalarWhereInput\n    data: XOR<EdgeUpdateManyMutationInput, EdgeUncheckedUpdateManyWithoutTargetNodeInput>\n  }\n\n  export type WorkflowCreateWithoutEdgesInput = {\n    id?: string\n    name: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    user: UserCreateNestedOneWithoutWorkflowsInput\n    nodes?: NodeCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowUncheckedCreateWithoutEdgesInput = {\n    id?: string\n    name: string\n    userId: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput\n    executions?: ExecutionUncheckedCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowCreateOrConnectWithoutEdgesInput = {\n    where: WorkflowWhereUniqueInput\n    create: XOR<WorkflowCreateWithoutEdgesInput, WorkflowUncheckedCreateWithoutEdgesInput>\n  }\n\n  export type NodeCreateWithoutSourceEdgesInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    workflow: WorkflowCreateNestedOneWithoutNodesInput\n    targetEdges?: EdgeCreateNestedManyWithoutTargetNodeInput\n  }\n\n  export type NodeUncheckedCreateWithoutSourceEdgesInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    workflowId: string\n    targetEdges?: EdgeUncheckedCreateNestedManyWithoutTargetNodeInput\n  }\n\n  export type NodeCreateOrConnectWithoutSourceEdgesInput = {\n    where: NodeWhereUniqueInput\n    create: XOR<NodeCreateWithoutSourceEdgesInput, NodeUncheckedCreateWithoutSourceEdgesInput>\n  }\n\n  export type NodeCreateWithoutTargetEdgesInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    workflow: WorkflowCreateNestedOneWithoutNodesInput\n    sourceEdges?: EdgeCreateNestedManyWithoutSourceNodeInput\n  }\n\n  export type NodeUncheckedCreateWithoutTargetEdgesInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n    workflowId: string\n    sourceEdges?: EdgeUncheckedCreateNestedManyWithoutSourceNodeInput\n  }\n\n  export type NodeCreateOrConnectWithoutTargetEdgesInput = {\n    where: NodeWhereUniqueInput\n    create: XOR<NodeCreateWithoutTargetEdgesInput, NodeUncheckedCreateWithoutTargetEdgesInput>\n  }\n\n  export type WorkflowUpsertWithoutEdgesInput = {\n    update: XOR<WorkflowUpdateWithoutEdgesInput, WorkflowUncheckedUpdateWithoutEdgesInput>\n    create: XOR<WorkflowCreateWithoutEdgesInput, WorkflowUncheckedCreateWithoutEdgesInput>\n    where?: WorkflowWhereInput\n  }\n\n  export type WorkflowUpdateToOneWithWhereWithoutEdgesInput = {\n    where?: WorkflowWhereInput\n    data: XOR<WorkflowUpdateWithoutEdgesInput, WorkflowUncheckedUpdateWithoutEdgesInput>\n  }\n\n  export type WorkflowUpdateWithoutEdgesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput\n    nodes?: NodeUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowUncheckedUpdateWithoutEdgesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    userId?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type NodeUpsertWithoutSourceEdgesInput = {\n    update: XOR<NodeUpdateWithoutSourceEdgesInput, NodeUncheckedUpdateWithoutSourceEdgesInput>\n    create: XOR<NodeCreateWithoutSourceEdgesInput, NodeUncheckedCreateWithoutSourceEdgesInput>\n    where?: NodeWhereInput\n  }\n\n  export type NodeUpdateToOneWithWhereWithoutSourceEdgesInput = {\n    where?: NodeWhereInput\n    data: XOR<NodeUpdateWithoutSourceEdgesInput, NodeUncheckedUpdateWithoutSourceEdgesInput>\n  }\n\n  export type NodeUpdateWithoutSourceEdgesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput\n    targetEdges?: EdgeUpdateManyWithoutTargetNodeNestedInput\n  }\n\n  export type NodeUncheckedUpdateWithoutSourceEdgesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    workflowId?: StringFieldUpdateOperationsInput | string\n    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput\n  }\n\n  export type NodeUpsertWithoutTargetEdgesInput = {\n    update: XOR<NodeUpdateWithoutTargetEdgesInput, NodeUncheckedUpdateWithoutTargetEdgesInput>\n    create: XOR<NodeCreateWithoutTargetEdgesInput, NodeUncheckedCreateWithoutTargetEdgesInput>\n    where?: NodeWhereInput\n  }\n\n  export type NodeUpdateToOneWithWhereWithoutTargetEdgesInput = {\n    where?: NodeWhereInput\n    data: XOR<NodeUpdateWithoutTargetEdgesInput, NodeUncheckedUpdateWithoutTargetEdgesInput>\n  }\n\n  export type NodeUpdateWithoutTargetEdgesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    workflow?: WorkflowUpdateOneRequiredWithoutNodesNestedInput\n    sourceEdges?: EdgeUpdateManyWithoutSourceNodeNestedInput\n  }\n\n  export type NodeUncheckedUpdateWithoutTargetEdgesInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    workflowId?: StringFieldUpdateOperationsInput | string\n    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput\n  }\n\n  export type WorkflowCreateWithoutExecutionsInput = {\n    id?: string\n    name: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    user: UserCreateNestedOneWithoutWorkflowsInput\n    nodes?: NodeCreateNestedManyWithoutWorkflowInput\n    edges?: EdgeCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowUncheckedCreateWithoutExecutionsInput = {\n    id?: string\n    name: string\n    userId: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n    nodes?: NodeUncheckedCreateNestedManyWithoutWorkflowInput\n    edges?: EdgeUncheckedCreateNestedManyWithoutWorkflowInput\n  }\n\n  export type WorkflowCreateOrConnectWithoutExecutionsInput = {\n    where: WorkflowWhereUniqueInput\n    create: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>\n  }\n\n  export type WorkflowUpsertWithoutExecutionsInput = {\n    update: XOR<WorkflowUpdateWithoutExecutionsInput, WorkflowUncheckedUpdateWithoutExecutionsInput>\n    create: XOR<WorkflowCreateWithoutExecutionsInput, WorkflowUncheckedCreateWithoutExecutionsInput>\n    where?: WorkflowWhereInput\n  }\n\n  export type WorkflowUpdateToOneWithWhereWithoutExecutionsInput = {\n    where?: WorkflowWhereInput\n    data: XOR<WorkflowUpdateWithoutExecutionsInput, WorkflowUncheckedUpdateWithoutExecutionsInput>\n  }\n\n  export type WorkflowUpdateWithoutExecutionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    user?: UserUpdateOneRequiredWithoutWorkflowsNestedInput\n    nodes?: NodeUpdateManyWithoutWorkflowNestedInput\n    edges?: EdgeUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowUncheckedUpdateWithoutExecutionsInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    userId?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput\n    edges?: EdgeUncheckedUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowCreateManyUserInput = {\n    id?: string\n    name: string\n    createdAt?: Date | string\n    updatedAt?: Date | string\n  }\n\n  export type WorkflowUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    nodes?: NodeUpdateManyWithoutWorkflowNestedInput\n    edges?: EdgeUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowUncheckedUpdateWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    nodes?: NodeUncheckedUpdateManyWithoutWorkflowNestedInput\n    edges?: EdgeUncheckedUpdateManyWithoutWorkflowNestedInput\n    executions?: ExecutionUncheckedUpdateManyWithoutWorkflowNestedInput\n  }\n\n  export type WorkflowUncheckedUpdateManyWithoutUserInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    name?: StringFieldUpdateOperationsInput | string\n    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n  }\n\n  export type NodeCreateManyWorkflowInput = {\n    id: string\n    type: string\n    data: JsonNullValueInput | InputJsonValue\n    positionX: number\n    positionY: number\n  }\n\n  export type EdgeCreateManyWorkflowInput = {\n    id: string\n    sourceId: string\n    targetId: string\n  }\n\n  export type ExecutionCreateManyWorkflowInput = {\n    id?: string\n    status: string\n    startedAt?: Date | string\n    finishedAt?: Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type NodeUpdateWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    sourceEdges?: EdgeUpdateManyWithoutSourceNodeNestedInput\n    targetEdges?: EdgeUpdateManyWithoutTargetNodeNestedInput\n  }\n\n  export type NodeUncheckedUpdateWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n    sourceEdges?: EdgeUncheckedUpdateManyWithoutSourceNodeNestedInput\n    targetEdges?: EdgeUncheckedUpdateManyWithoutTargetNodeNestedInput\n  }\n\n  export type NodeUncheckedUpdateManyWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    type?: StringFieldUpdateOperationsInput | string\n    data?: JsonNullValueInput | InputJsonValue\n    positionX?: FloatFieldUpdateOperationsInput | number\n    positionY?: FloatFieldUpdateOperationsInput | number\n  }\n\n  export type EdgeUpdateWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sourceNode?: NodeUpdateOneRequiredWithoutSourceEdgesNestedInput\n    targetNode?: NodeUpdateOneRequiredWithoutTargetEdgesNestedInput\n  }\n\n  export type EdgeUncheckedUpdateWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sourceId?: StringFieldUpdateOperationsInput | string\n    targetId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type EdgeUncheckedUpdateManyWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sourceId?: StringFieldUpdateOperationsInput | string\n    targetId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type ExecutionUpdateWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionUncheckedUpdateWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type ExecutionUncheckedUpdateManyWithoutWorkflowInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    status?: StringFieldUpdateOperationsInput | string\n    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string\n    finishedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null\n    results?: NullableJsonNullValueInput | InputJsonValue\n    error?: NullableJsonNullValueInput | InputJsonValue\n  }\n\n  export type EdgeCreateManySourceNodeInput = {\n    id: string\n    targetId: string\n    workflowId: string\n  }\n\n  export type EdgeCreateManyTargetNodeInput = {\n    id: string\n    sourceId: string\n    workflowId: string\n  }\n\n  export type EdgeUpdateWithoutSourceNodeInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    workflow?: WorkflowUpdateOneRequiredWithoutEdgesNestedInput\n    targetNode?: NodeUpdateOneRequiredWithoutTargetEdgesNestedInput\n  }\n\n  export type EdgeUncheckedUpdateWithoutSourceNodeInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    targetId?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type EdgeUncheckedUpdateManyWithoutSourceNodeInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    targetId?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type EdgeUpdateWithoutTargetNodeInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    workflow?: WorkflowUpdateOneRequiredWithoutEdgesNestedInput\n    sourceNode?: NodeUpdateOneRequiredWithoutSourceEdgesNestedInput\n  }\n\n  export type EdgeUncheckedUpdateWithoutTargetNodeInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sourceId?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n  }\n\n  export type EdgeUncheckedUpdateManyWithoutTargetNodeInput = {\n    id?: StringFieldUpdateOperationsInput | string\n    sourceId?: StringFieldUpdateOperationsInput | string\n    workflowId?: StringFieldUpdateOperationsInput | string\n  }\n\n\n\n  /**\n   * Batch Payload for updateMany & deleteMany & createMany\n   */\n\n  export type BatchPayload = {\n    count: number\n  }\n\n  /**\n   * DMMF\n   */\n  export const dmmf: runtime.BaseDMMF\n}","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\index.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\edge-esm.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\edge.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\index-browser.d.ts","messages":[{"ruleId":"no-unused-private-class-members","severity":2,"message":"'#private' is defined but never used.","line":2,"column":5,"nodeType":"PropertyDefinition","messageId":"unusedPrivateClassMember","endLine":2,"endColumn":13},{"ruleId":"no-unused-private-class-members","severity":2,"message":"'#private' is defined but never used.","line":18,"column":5,"nodeType":"PropertyDefinition","messageId":"unusedPrivateClassMember","endLine":18,"endColumn":13},{"ruleId":"no-unused-private-class-members","severity":2,"message":"'#private' is defined but never used.","line":303,"column":5,"nodeType":"PropertyDefinition","messageId":"unusedPrivateClassMember","endLine":303,"endColumn":13}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"declare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\ndeclare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\ndeclare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\ndeclare type Narrowable = string | number | bigint | boolean | [];\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\ndeclare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\nexport { }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\index-browser.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\library.d.ts","messages":[{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":47,"column":5,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":47,"endColumn":7,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[1742,1744],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[1742,1744],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"no-unused-private-class-members","severity":2,"message":"'#private' is defined but never used.","line":50,"column":5,"nodeType":"PropertyDefinition","messageId":"unusedPrivateClassMember","endLine":50,"endColumn":13},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'ColumnTypeEnum' is defined but only used as a type. Allowed unused vars must match /^_/u.","line":175,"column":15,"nodeType":null,"messageId":"usedOnlyAsType","endLine":175,"endColumn":29},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":212,"column":11,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":212,"endColumn":13,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[6850,6852],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[6850,6852],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":213,"column":31,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":213,"endColumn":33,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[6885,6887],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[6885,6887],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":237,"column":44,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":237,"endColumn":52},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":241,"column":48,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":241,"endColumn":56},{"ruleId":"no-unused-private-class-members","severity":2,"message":"'#private' is defined but never used.","line":388,"column":5,"nodeType":"PropertyDefinition","messageId":"unusedPrivateClassMember","endLine":388,"endColumn":13},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":396,"column":17,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":396,"endColumn":19,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[12806,12808],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[12806,12808],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'debugCreate' is defined but only used as a type. Allowed unused vars must match /^_/u.","line":409,"column":18,"nodeType":null,"messageId":"usedOnlyAsType","endLine":409,"endColumn":29},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":698,"column":48,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":698,"endColumn":50,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[21945,21947],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[21945,21947],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":698,"column":52,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":698,"endColumn":54,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[21949,21951],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[21949,21951],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":698,"column":56,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":698,"endColumn":58,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[21953,21955],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[21953,21955],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":698,"column":60,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":698,"endColumn":62,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[21957,21959],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[21957,21959],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":700,"column":79,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":700,"endColumn":81,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[22043,22045],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[22043,22045],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":700,"column":103,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":700,"endColumn":105,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[22067,22069],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[22067,22069],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'denylist' is defined but only used as a type. Allowed unused vars must match /^_/u.","line":712,"column":15,"nodeType":null,"messageId":"usedOnlyAsType","endLine":712,"endColumn":23},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":893,"column":22,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":893,"endColumn":24,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[28100,28102],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[28100,28102],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":926,"column":130,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":926,"endColumn":132,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[30149,30151],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[30149,30151],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":979,"column":4,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":979,"endColumn":6,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[34288,34290],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[34288,34290],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1162,"column":21,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1162,"endColumn":23,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[40974,40976],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[40974,40976],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1171,"column":21,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1171,"endColumn":23,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[41145,41147],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[41145,41147],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1180,"column":21,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1180,"endColumn":23,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[41322,41324],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[41322,41324],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1328,"column":58,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1328,"endColumn":60,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[45475,45477],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[45475,45477],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1405,"column":18,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1405,"endColumn":20,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[47922,47924],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[47922,47924],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'getBatchRequestPayload' is defined but only used as a type. Allowed unused vars must match /^_/u.","line":1506,"column":18,"nodeType":null,"messageId":"usedOnlyAsType","endLine":1506,"endColumn":40},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1523,"column":622,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1523,"endColumn":624,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[52629,52631],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[52629,52631],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1523,"column":761,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1523,"endColumn":763,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[52768,52770],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[52768,52770],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1542,"column":6,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1542,"endColumn":8,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[53471,53473],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[53471,53473],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":1777,"column":146,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":1777,"endColumn":148,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[63258,63260],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[63258,63260],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":1873,"column":26,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":1873,"endColumn":40,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[66812,66894],"text":"type InputJsonArray = ReadonlyArray<InputJsonValue | null>"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":2034,"column":26,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":2034,"endColumn":35,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[72064,72121],"text":"type JsonArray = Array<JsonValue>"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"no-unused-private-class-members","severity":2,"message":"'#private' is defined but never used.","line":2054,"column":5,"nodeType":"PropertyDefinition","messageId":"unusedPrivateClassMember","endLine":2054,"endColumn":13},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":2283,"column":43,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":2283,"endColumn":51},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":2380,"column":34,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":2380,"endColumn":42},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'officialPrismaAdapters' is defined but only used as a type. Allowed unused vars must match /^_/u.","line":2414,"column":15,"nodeType":null,"messageId":"usedOnlyAsType","endLine":2414,"endColumn":37},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2451,"column":23,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2451,"endColumn":25,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[85695,85697],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[85695,85697],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'$Type' is defined but never used. Allowed unused vars must match /^_/u.","line":2492,"column":31,"nodeType":null,"messageId":"unusedVar","endLine":2492,"endColumn":36},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'F' is defined but never used. Allowed unused vars must match /^_/u.","line":2500,"column":32,"nodeType":null,"messageId":"unusedVar","endLine":2500,"endColumn":33},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'prismaGraphQLToJSError' is defined but only used as a type. Allowed unused vars must match /^_/u.","line":2616,"column":18,"nodeType":null,"messageId":"usedOnlyAsType","endLine":2616,"endColumn":40},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2730,"column":31,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2730,"endColumn":33,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[94829,94831],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[94829,94831],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2966,"column":23,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2966,"endColumn":25,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[102553,102555],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[102553,102555],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'resolveDatasourceUrl' is defined but only used as a type. Allowed unused vars must match /^_/u.","line":2969,"column":18,"nodeType":null,"messageId":"usedOnlyAsType","endLine":2969,"endColumn":38},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2983,"column":17,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2983,"endColumn":19,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[103144,103146],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[103144,103146],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2984,"column":14,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2984,"endColumn":16,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[103162,103164],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[103162,103164],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2985,"column":14,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2985,"endColumn":16,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[103180,103182],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[103180,103182],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":2987,"column":4,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":2987,"endColumn":6,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[103203,103205],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[103203,103205],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"An interface declaring no members is equivalent to its supertype.","line":3441,"column":19,"nodeType":"Identifier","messageId":"noEmptyInterfaceWithSuper","endLine":3441,"endColumn":31,"suggestions":[{"messageId":"replaceEmptyInterfaceWithSuper","fix":{"range":[117311,117388],"text":"type SqlQueryable = Queryable<SqlQuery, SqlResultSet>"},"desc":"Replace empty interface with a type alias."}]},{"ruleId":"@typescript-eslint/no-empty-object-type","severity":2,"message":"The `{}` (\"empty object\") type allows any non-nullish value, including literals like `0` and `\"\"`.\n- If that's what you want, disable this lint rule with an inline comment or configure the 'allowObjectTypes' rule option.\n- If you want a type meaning \"any object\", you probably want `object` instead.\n- If you want a type meaning \"any value\", you probably want `unknown` instead.","line":3616,"column":40,"nodeType":"TSTypeLiteral","messageId":"noEmptyObject","endLine":3616,"endColumn":42,"suggestions":[{"messageId":"replaceEmptyObjectType","data":{"replacement":"object"},"fix":{"range":[122479,122481],"text":"object"},"desc":"Replace `{}` with `object`."},{"messageId":"replaceEmptyObjectType","data":{"replacement":"unknown"},"fix":{"range":[122479,122481],"text":"unknown"},"desc":"Replace `{}` with `unknown`."}]}],"suppressedMessages":[],"errorCount":40,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * @param this\r\n */\r\ndeclare function $extends(this: Client, extension: ExtensionArgs | ((client: Client) => Client)): Client;\r\n\r\ndeclare type AccelerateEngineConfig = {\r\n    inlineSchema: EngineConfig['inlineSchema'];\r\n    inlineSchemaHash: EngineConfig['inlineSchemaHash'];\r\n    env: EngineConfig['env'];\r\n    generator?: {\r\n        previewFeatures: string[];\r\n    };\r\n    inlineDatasources: EngineConfig['inlineDatasources'];\r\n    overrideDatasources: EngineConfig['overrideDatasources'];\r\n    clientVersion: EngineConfig['clientVersion'];\r\n    engineVersion: EngineConfig['engineVersion'];\r\n    logEmitter: EngineConfig['logEmitter'];\r\n    logQueries?: EngineConfig['logQueries'];\r\n    logLevel?: EngineConfig['logLevel'];\r\n    tracingHelper: EngineConfig['tracingHelper'];\r\n    accelerateUtils?: AccelerateUtils;\r\n};\r\n\r\ndeclare type AccelerateUtils = EngineConfig['accelerateUtils'];\r\n\r\nexport declare type Action = keyof typeof DMMF_2.ModelAction | 'executeRaw' | 'queryRaw' | 'runCommandRaw';\r\n\r\ndeclare type ActiveConnectorType = Exclude<ConnectorType, 'postgres' | 'prisma+postgres'>;\r\n\r\n/**\r\n * An interface that exposes some basic information about the\r\n * adapter like its name and provider type.\r\n */\r\ndeclare interface AdapterInfo {\r\n    readonly provider: Provider;\r\n    readonly adapterName: (typeof officialPrismaAdapters)[number] | (string & {});\r\n}\r\n\r\nexport declare type Aggregate = '_count' | '_max' | '_min' | '_avg' | '_sum';\r\n\r\nexport declare type AllModelsToStringIndex<TypeMap extends TypeMapDef, Args extends Record<string, any>, K extends PropertyKey> = Args extends {\r\n    [P in K]: {\r\n        $allModels: infer AllModels;\r\n    };\r\n} ? {\r\n    [P in K]: Record<TypeMap['meta']['modelProps'], AllModels>;\r\n} : {};\r\n\r\ndeclare class AnyNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare type ApplyOmit<T, OmitConfig> = Compute<{\r\n    [K in keyof T as OmitValue<OmitConfig, K> extends true ? never : K]: T[K];\r\n}>;\r\n\r\nexport declare type Args<T, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            operations: {\r\n                [K in F]: {\r\n                    args: any;\r\n                };\r\n            };\r\n        };\r\n    };\r\n} ? T[symbol]['types']['operations'][F]['args'] : any;\r\n\r\nexport declare type Args_3<T, F extends Operation> = Args<T, F>;\r\n\r\n/**\r\n * Original `quaint::ValueType` enum tag from Prisma's `quaint`.\r\n * Query arguments marked with this type are sanitized before being sent to the database.\r\n * Notice while a query argument may be `null`, `ArgType` is guaranteed to be defined.\r\n */\r\ndeclare type ArgType = 'Int32' | 'Int64' | 'Float' | 'Double' | 'Text' | 'Enum' | 'EnumArray' | 'Bytes' | 'Boolean' | 'Char' | 'Array' | 'Numeric' | 'Json' | 'Xml' | 'Uuid' | 'DateTime' | 'Date' | 'Time' | 'Unknown';\r\n\r\n/**\r\n * Attributes is a map from string to attribute values.\r\n *\r\n * Note: only the own enumerable keys are counted as valid attribute keys.\r\n */\r\ndeclare interface Attributes {\r\n    [attributeKey: string]: AttributeValue | undefined;\r\n}\r\n\r\n/**\r\n * Attribute values may be any non-nullish primitive value except an object.\r\n *\r\n * null or undefined attribute values are invalid and will result in undefined behavior.\r\n */\r\ndeclare type AttributeValue = string | number | boolean | Array<null | undefined | string> | Array<null | undefined | number> | Array<null | undefined | boolean>;\r\n\r\nexport declare type BaseDMMF = {\r\n    readonly datamodel: Omit<DMMF_2.Datamodel, 'indexes'>;\r\n};\r\n\r\ndeclare type BatchArgs = {\r\n    queries: BatchQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\ndeclare type BatchInternalParams = {\r\n    requests: RequestParams[];\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type BatchQuery = {\r\n    model: string | undefined;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n};\r\n\r\ndeclare type BatchQueryEngineResult<T> = QueryEngineResultData<T> | Error;\r\n\r\ndeclare type BatchQueryOptionsCb = (args: BatchQueryOptionsCbArgs) => Promise<any>;\r\n\r\ndeclare type BatchQueryOptionsCbArgs = {\r\n    args: BatchArgs;\r\n    query: (args: BatchArgs, __internalParams?: BatchInternalParams) => Promise<unknown[]>;\r\n    __internalParams: BatchInternalParams;\r\n};\r\n\r\ndeclare type BatchResponse = MultiBatchResponse | CompactedBatchResponse;\r\n\r\ndeclare type BatchTransactionOptions = {\r\n    isolationLevel?: Transaction_2.IsolationLevel;\r\n};\r\n\r\ndeclare interface BinaryTargetsEnvValue {\r\n    fromEnvVar: string | null;\r\n    value: string;\r\n    native?: boolean;\r\n}\r\n\r\nexport declare type Call<F extends Fn, P> = (F & {\r\n    params: P;\r\n})['returns'];\r\n\r\ndeclare interface CallSite {\r\n    getLocation(): LocationInFile | null;\r\n}\r\n\r\nexport declare type Cast<A, W> = A extends W ? A : W;\r\n\r\ndeclare type Client = ReturnType<typeof getPrismaClient> extends new () => infer T ? T : never;\r\n\r\nexport declare type ClientArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ClientArgs = {\r\n    client: ClientArg;\r\n};\r\n\r\nexport declare type ClientBuiltInProp = keyof DynamicClientExtensionThisBuiltin<never, never, never>;\r\n\r\nexport declare type ClientOptionDef = undefined | {\r\n    [K in string]: any;\r\n};\r\n\r\nexport declare type ClientOtherOps = {\r\n    $queryRaw<T = unknown>(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<T>;\r\n    $queryRawTyped<T>(query: TypedSql<unknown[], T>): PrismaPromise<T[]>;\r\n    $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): PrismaPromise<T>;\r\n    $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise<number>;\r\n    $executeRawUnsafe(query: string, ...values: any[]): PrismaPromise<number>;\r\n    $runCommandRaw(command: InputJsonObject): PrismaPromise<JsonObject>;\r\n};\r\n\r\ndeclare type ColumnType = (typeof ColumnTypeEnum)[keyof typeof ColumnTypeEnum];\r\n\r\ndeclare const ColumnTypeEnum: {\r\n    readonly Int32: 0;\r\n    readonly Int64: 1;\r\n    readonly Float: 2;\r\n    readonly Double: 3;\r\n    readonly Numeric: 4;\r\n    readonly Boolean: 5;\r\n    readonly Character: 6;\r\n    readonly Text: 7;\r\n    readonly Date: 8;\r\n    readonly Time: 9;\r\n    readonly DateTime: 10;\r\n    readonly Json: 11;\r\n    readonly Enum: 12;\r\n    readonly Bytes: 13;\r\n    readonly Set: 14;\r\n    readonly Uuid: 15;\r\n    readonly Int32Array: 64;\r\n    readonly Int64Array: 65;\r\n    readonly FloatArray: 66;\r\n    readonly DoubleArray: 67;\r\n    readonly NumericArray: 68;\r\n    readonly BooleanArray: 69;\r\n    readonly CharacterArray: 70;\r\n    readonly TextArray: 71;\r\n    readonly DateArray: 72;\r\n    readonly TimeArray: 73;\r\n    readonly DateTimeArray: 74;\r\n    readonly JsonArray: 75;\r\n    readonly EnumArray: 76;\r\n    readonly BytesArray: 77;\r\n    readonly UuidArray: 78;\r\n    readonly UnknownNumber: 128;\r\n};\r\n\r\ndeclare type CompactedBatchResponse = {\r\n    type: 'compacted';\r\n    plan: {};\r\n    arguments: Record<string, {}>[];\r\n    nestedSelection: string[];\r\n    keys: string[];\r\n    expectNonEmpty: boolean;\r\n};\r\n\r\ndeclare type CompilerWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryCompiler: QueryCompilerConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm compiler engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by ClientEngine\r\n     */\r\n    getQueryCompilerWasmModule: () => Promise<unknown>;\r\n};\r\n\r\nexport declare type Compute<T> = T extends Function ? T : {\r\n    [K in keyof T]: T[K];\r\n} & unknown;\r\n\r\nexport declare type ComputeDeep<T> = T extends Function ? T : {\r\n    [K in keyof T]: ComputeDeep<T[K]>;\r\n} & unknown;\r\n\r\ndeclare type ComputedField = {\r\n    name: string;\r\n    needs: string[];\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\ndeclare type ComputedFieldsMap = {\r\n    [fieldName: string]: ComputedField;\r\n};\r\n\r\ndeclare type ConnectionInfo = {\r\n    schemaName?: string;\r\n    maxBindValues?: number;\r\n    supportsRelationJoins: boolean;\r\n};\r\n\r\ndeclare type ConnectorType = 'mysql' | 'mongodb' | 'sqlite' | 'postgresql' | 'postgres' | 'prisma+postgres' | 'sqlserver' | 'cockroachdb';\r\n\r\ndeclare interface Context {\r\n    /**\r\n     * Get a value from the context.\r\n     *\r\n     * @param key key which identifies a context value\r\n     */\r\n    getValue(key: symbol): unknown;\r\n    /**\r\n     * Create a new context which inherits from this context and has\r\n     * the given key set to the given value.\r\n     *\r\n     * @param key context key for which to set the value\r\n     * @param value value to set for the given key\r\n     */\r\n    setValue(key: symbol, value: unknown): Context;\r\n    /**\r\n     * Return a new context which inherits from this context but does\r\n     * not contain a value for the given key.\r\n     *\r\n     * @param key context key for which to clear a value\r\n     */\r\n    deleteValue(key: symbol): Context;\r\n}\r\n\r\ndeclare type Context_2<T> = T extends {\r\n    [K: symbol]: {\r\n        ctx: infer C;\r\n    };\r\n} ? C & T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n} : T & {\r\n    /**\r\n     * @deprecated Use `$name` instead.\r\n     */\r\n    name?: string;\r\n    $name?: string;\r\n    $parent?: unknown;\r\n};\r\n\r\nexport declare type Count<O> = {\r\n    [K in keyof O]: Count<number>;\r\n} & {};\r\n\r\nexport declare function createParam(name: string): Param<unknown, string>;\r\n\r\n/**\r\n * Custom fetch function for `DataProxyEngine`.\r\n *\r\n * We can't use the actual type of `globalThis.fetch` because this will result\r\n * in API Extractor referencing Node.js type definitions in the `.d.ts` bundle\r\n * for the client runtime. We can only use such types in internal types that\r\n * don't end up exported anywhere.\r\n\r\n * It's also not possible to write a definition of `fetch` that would accept the\r\n * actual `fetch` function from different environments such as Node.js and\r\n * Cloudflare Workers (with their extensions to `RequestInit` and `Response`).\r\n * `fetch` is used in both covariant and contravariant positions in\r\n * `CustomDataProxyFetch`, making it invariant, so we need the exact same type.\r\n * Even if we removed the argument and left `fetch` in covariant position only,\r\n * then for an extension-supplied function to be assignable to `customDataProxyFetch`,\r\n * the platform-specific (or custom) `fetch` function needs to be assignable\r\n * to our `fetch` definition. This, in turn, requires the third-party `Response`\r\n * to be a subtype of our `Response` (which is not a problem, we could declare\r\n * a minimal `Response` type that only includes what we use) *and* requires the\r\n * third-party `RequestInit` to be a supertype of our `RequestInit` (i.e. we\r\n * have to declare all properties any `RequestInit` implementation in existence\r\n * could possibly have), which is not possible.\r\n *\r\n * Since `@prisma/extension-accelerate` redefines the type of\r\n * `__internalParams.customDataProxyFetch` to its own type anyway (probably for\r\n * exactly this reason), our definition is never actually used and is completely\r\n * ignored, so it doesn't matter, and we can just use `unknown` as the type of\r\n * `fetch` here.\r\n */\r\ndeclare type CustomDataProxyFetch = (fetch: unknown) => unknown;\r\n\r\ndeclare class DataLoader<T = unknown> {\r\n    private options;\r\n    batches: {\r\n        [key: string]: Job[];\r\n    };\r\n    private tickActive;\r\n    constructor(options: DataLoaderOptions<T>);\r\n    request(request: T): Promise<any>;\r\n    private dispatchBatches;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type DataLoaderOptions<T> = {\r\n    singleLoader: (request: T) => Promise<any>;\r\n    batchLoader: (request: T[]) => Promise<any[]>;\r\n    batchBy: (request: T) => string | undefined;\r\n    batchOrder: (requestA: T, requestB: T) => number;\r\n};\r\n\r\ndeclare type Datamodel = ReadonlyDeep_2<{\r\n    models: Model[];\r\n    enums: DatamodelEnum[];\r\n    types: Model[];\r\n    indexes: Index[];\r\n}>;\r\n\r\ndeclare type DatamodelEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: EnumValue[];\r\n    dbName?: string | null;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare function datamodelEnumToSchemaEnum(datamodelEnum: DatamodelEnum): SchemaEnum;\r\n\r\ndeclare type Datasource = {\r\n    url?: string;\r\n};\r\n\r\ndeclare type Datasources = {\r\n    [name in string]: Datasource;\r\n};\r\n\r\ndeclare class DbNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\nexport declare const Debug: typeof debugCreate & {\r\n    enable(namespace: any): void;\r\n    disable(): any;\r\n    enabled(namespace: string): boolean;\r\n    log: (...args: string[]) => void;\r\n    formatters: {};\r\n};\r\n\r\n/**\r\n * Create a new debug instance with the given namespace.\r\n *\r\n * @example\r\n * ```ts\r\n * import Debug from '@prisma/debug'\r\n * const debug = Debug('prisma:client')\r\n * debug('Hello World')\r\n * ```\r\n */\r\ndeclare function debugCreate(namespace: string): ((...args: any[]) => void) & {\r\n    color: string;\r\n    enabled: boolean;\r\n    namespace: string;\r\n    log: (...args: string[]) => void;\r\n    extend: () => void;\r\n};\r\n\r\nexport declare function Decimal(n: Decimal.Value): Decimal;\r\n\r\nexport declare namespace Decimal {\r\n    export type Constructor = typeof Decimal;\r\n    export type Instance = Decimal;\r\n    export type Rounding = 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8;\r\n    export type Modulo = Rounding | 9;\r\n    export type Value = string | number | Decimal;\r\n\r\n    // http://mikemcl.github.io/decimal.js/#constructor-properties\r\n    export interface Config {\r\n        precision?: number;\r\n        rounding?: Rounding;\r\n        toExpNeg?: number;\r\n        toExpPos?: number;\r\n        minE?: number;\r\n        maxE?: number;\r\n        crypto?: boolean;\r\n        modulo?: Modulo;\r\n        defaults?: boolean;\r\n    }\r\n}\r\n\r\nexport declare class Decimal {\r\n    readonly d: number[];\r\n    readonly e: number;\r\n    readonly s: number;\r\n\r\n    constructor(n: Decimal.Value);\r\n\r\n    absoluteValue(): Decimal;\r\n    abs(): Decimal;\r\n\r\n    ceil(): Decimal;\r\n\r\n    clampedTo(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    clamp(min: Decimal.Value, max: Decimal.Value): Decimal;\r\n\r\n    comparedTo(n: Decimal.Value): number;\r\n    cmp(n: Decimal.Value): number;\r\n\r\n    cosine(): Decimal;\r\n    cos(): Decimal;\r\n\r\n    cubeRoot(): Decimal;\r\n    cbrt(): Decimal;\r\n\r\n    decimalPlaces(): number;\r\n    dp(): number;\r\n\r\n    dividedBy(n: Decimal.Value): Decimal;\r\n    div(n: Decimal.Value): Decimal;\r\n\r\n    dividedToIntegerBy(n: Decimal.Value): Decimal;\r\n    divToInt(n: Decimal.Value): Decimal;\r\n\r\n    equals(n: Decimal.Value): boolean;\r\n    eq(n: Decimal.Value): boolean;\r\n\r\n    floor(): Decimal;\r\n\r\n    greaterThan(n: Decimal.Value): boolean;\r\n    gt(n: Decimal.Value): boolean;\r\n\r\n    greaterThanOrEqualTo(n: Decimal.Value): boolean;\r\n    gte(n: Decimal.Value): boolean;\r\n\r\n    hyperbolicCosine(): Decimal;\r\n    cosh(): Decimal;\r\n\r\n    hyperbolicSine(): Decimal;\r\n    sinh(): Decimal;\r\n\r\n    hyperbolicTangent(): Decimal;\r\n    tanh(): Decimal;\r\n\r\n    inverseCosine(): Decimal;\r\n    acos(): Decimal;\r\n\r\n    inverseHyperbolicCosine(): Decimal;\r\n    acosh(): Decimal;\r\n\r\n    inverseHyperbolicSine(): Decimal;\r\n    asinh(): Decimal;\r\n\r\n    inverseHyperbolicTangent(): Decimal;\r\n    atanh(): Decimal;\r\n\r\n    inverseSine(): Decimal;\r\n    asin(): Decimal;\r\n\r\n    inverseTangent(): Decimal;\r\n    atan(): Decimal;\r\n\r\n    isFinite(): boolean;\r\n\r\n    isInteger(): boolean;\r\n    isInt(): boolean;\r\n\r\n    isNaN(): boolean;\r\n\r\n    isNegative(): boolean;\r\n    isNeg(): boolean;\r\n\r\n    isPositive(): boolean;\r\n    isPos(): boolean;\r\n\r\n    isZero(): boolean;\r\n\r\n    lessThan(n: Decimal.Value): boolean;\r\n    lt(n: Decimal.Value): boolean;\r\n\r\n    lessThanOrEqualTo(n: Decimal.Value): boolean;\r\n    lte(n: Decimal.Value): boolean;\r\n\r\n    logarithm(n?: Decimal.Value): Decimal;\r\n    log(n?: Decimal.Value): Decimal;\r\n\r\n    minus(n: Decimal.Value): Decimal;\r\n    sub(n: Decimal.Value): Decimal;\r\n\r\n    modulo(n: Decimal.Value): Decimal;\r\n    mod(n: Decimal.Value): Decimal;\r\n\r\n    naturalExponential(): Decimal;\r\n    exp(): Decimal;\r\n\r\n    naturalLogarithm(): Decimal;\r\n    ln(): Decimal;\r\n\r\n    negated(): Decimal;\r\n    neg(): Decimal;\r\n\r\n    plus(n: Decimal.Value): Decimal;\r\n    add(n: Decimal.Value): Decimal;\r\n\r\n    precision(includeZeros?: boolean): number;\r\n    sd(includeZeros?: boolean): number;\r\n\r\n    round(): Decimal;\r\n\r\n    sine() : Decimal;\r\n    sin() : Decimal;\r\n\r\n    squareRoot(): Decimal;\r\n    sqrt(): Decimal;\r\n\r\n    tangent() : Decimal;\r\n    tan() : Decimal;\r\n\r\n    times(n: Decimal.Value): Decimal;\r\n    mul(n: Decimal.Value) : Decimal;\r\n\r\n    toBinary(significantDigits?: number): string;\r\n    toBinary(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toDecimalPlaces(decimalPlaces?: number): Decimal;\r\n    toDecimalPlaces(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n    toDP(decimalPlaces?: number): Decimal;\r\n    toDP(decimalPlaces: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toExponential(decimalPlaces?: number): string;\r\n    toExponential(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFixed(decimalPlaces?: number): string;\r\n    toFixed(decimalPlaces: number, rounding: Decimal.Rounding): string;\r\n\r\n    toFraction(max_denominator?: Decimal.Value): Decimal[];\r\n\r\n    toHexadecimal(significantDigits?: number): string;\r\n    toHexadecimal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n    toHex(significantDigits?: number): string;\r\n    toHex(significantDigits: number, rounding?: Decimal.Rounding): string;\r\n\r\n    toJSON(): string;\r\n\r\n    toNearest(n: Decimal.Value, rounding?: Decimal.Rounding): Decimal;\r\n\r\n    toNumber(): number;\r\n\r\n    toOctal(significantDigits?: number): string;\r\n    toOctal(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toPower(n: Decimal.Value): Decimal;\r\n    pow(n: Decimal.Value): Decimal;\r\n\r\n    toPrecision(significantDigits?: number): string;\r\n    toPrecision(significantDigits: number, rounding: Decimal.Rounding): string;\r\n\r\n    toSignificantDigits(significantDigits?: number): Decimal;\r\n    toSignificantDigits(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n    toSD(significantDigits?: number): Decimal;\r\n    toSD(significantDigits: number, rounding: Decimal.Rounding): Decimal;\r\n\r\n    toString(): string;\r\n\r\n    truncated(): Decimal;\r\n    trunc(): Decimal;\r\n\r\n    valueOf(): string;\r\n\r\n    static abs(n: Decimal.Value): Decimal;\r\n    static acos(n: Decimal.Value): Decimal;\r\n    static acosh(n: Decimal.Value): Decimal;\r\n    static add(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static asin(n: Decimal.Value): Decimal;\r\n    static asinh(n: Decimal.Value): Decimal;\r\n    static atan(n: Decimal.Value): Decimal;\r\n    static atanh(n: Decimal.Value): Decimal;\r\n    static atan2(y: Decimal.Value, x: Decimal.Value): Decimal;\r\n    static cbrt(n: Decimal.Value): Decimal;\r\n    static ceil(n: Decimal.Value): Decimal;\r\n    static clamp(n: Decimal.Value, min: Decimal.Value, max: Decimal.Value): Decimal;\r\n    static clone(object?: Decimal.Config): Decimal.Constructor;\r\n    static config(object: Decimal.Config): Decimal.Constructor;\r\n    static cos(n: Decimal.Value): Decimal;\r\n    static cosh(n: Decimal.Value): Decimal;\r\n    static div(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static exp(n: Decimal.Value): Decimal;\r\n    static floor(n: Decimal.Value): Decimal;\r\n    static hypot(...n: Decimal.Value[]): Decimal;\r\n    static isDecimal(object: any): object is Decimal;\r\n    static ln(n: Decimal.Value): Decimal;\r\n    static log(n: Decimal.Value, base?: Decimal.Value): Decimal;\r\n    static log2(n: Decimal.Value): Decimal;\r\n    static log10(n: Decimal.Value): Decimal;\r\n    static max(...n: Decimal.Value[]): Decimal;\r\n    static min(...n: Decimal.Value[]): Decimal;\r\n    static mod(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static mul(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static noConflict(): Decimal.Constructor;   // Browser only\r\n    static pow(base: Decimal.Value, exponent: Decimal.Value): Decimal;\r\n    static random(significantDigits?: number): Decimal;\r\n    static round(n: Decimal.Value): Decimal;\r\n    static set(object: Decimal.Config): Decimal.Constructor;\r\n    static sign(n: Decimal.Value): number;\r\n    static sin(n: Decimal.Value): Decimal;\r\n    static sinh(n: Decimal.Value): Decimal;\r\n    static sqrt(n: Decimal.Value): Decimal;\r\n    static sub(x: Decimal.Value, y: Decimal.Value): Decimal;\r\n    static sum(...n: Decimal.Value[]): Decimal;\r\n    static tan(n: Decimal.Value): Decimal;\r\n    static tanh(n: Decimal.Value): Decimal;\r\n    static trunc(n: Decimal.Value): Decimal;\r\n\r\n    static readonly default?: Decimal.Constructor;\r\n    static readonly Decimal?: Decimal.Constructor;\r\n\r\n    static readonly precision: number;\r\n    static readonly rounding: Decimal.Rounding;\r\n    static readonly toExpNeg: number;\r\n    static readonly toExpPos: number;\r\n    static readonly minE: number;\r\n    static readonly maxE: number;\r\n    static readonly crypto: boolean;\r\n    static readonly modulo: Decimal.Modulo;\r\n\r\n    static readonly ROUND_UP: 0;\r\n    static readonly ROUND_DOWN: 1;\r\n    static readonly ROUND_CEIL: 2;\r\n    static readonly ROUND_FLOOR: 3;\r\n    static readonly ROUND_HALF_UP: 4;\r\n    static readonly ROUND_HALF_DOWN: 5;\r\n    static readonly ROUND_HALF_EVEN: 6;\r\n    static readonly ROUND_HALF_CEIL: 7;\r\n    static readonly ROUND_HALF_FLOOR: 8;\r\n    static readonly EUCLID: 9;\r\n}\r\n\r\n/**\r\n * Interface for any Decimal.js-like library\r\n * Allows us to accept Decimal.js from different\r\n * versions and some compatible alternatives\r\n */\r\nexport declare interface DecimalJsLike {\r\n    d: number[];\r\n    e: number;\r\n    s: number;\r\n    toFixed(): string;\r\n}\r\n\r\nexport declare type DefaultArgs = InternalArgs<{}, {}, {}, {}>;\r\n\r\nexport declare type DefaultSelection<Payload extends OperationPayload, Args = {}, GlobalOmitOptions = {}> = Args extends {\r\n    omit: infer LocalOmit;\r\n} ? ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], PatchFlat<LocalOmit, ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>> : ApplyOmit<UnwrapPayload<{\r\n    default: Payload;\r\n}>['default'], ExtractGlobalOmit<GlobalOmitOptions, Uncapitalize<Payload['name']>>>;\r\n\r\nexport declare function defineDmmfProperty(target: object, runtimeDataModel: RuntimeDataModel): void;\r\n\r\ndeclare function defineExtension(ext: ExtensionArgs | ((client: Client) => Client)): (client: Client) => Client;\r\n\r\ndeclare const denylist: readonly [\"$connect\", \"$disconnect\", \"$on\", \"$transaction\", \"$use\", \"$extends\"];\r\n\r\ndeclare type Deprecation = ReadonlyDeep_2<{\r\n    sinceVersion: string;\r\n    reason: string;\r\n    plannedRemovalVersion?: string;\r\n}>;\r\n\r\ndeclare type DeserializedResponse = Array<Record<string, unknown>>;\r\n\r\nexport declare function deserializeJsonResponse(result: unknown): unknown;\r\n\r\nexport declare function deserializeRawResult(response: RawResponse): DeserializedResponse;\r\n\r\nexport declare type DevTypeMapDef = {\r\n    meta: {\r\n        modelProps: string;\r\n    };\r\n    model: {\r\n        [Model in PropertyKey]: {\r\n            [Operation in PropertyKey]: DevTypeMapFnDef;\r\n        };\r\n    };\r\n    other: {\r\n        [Operation in PropertyKey]: DevTypeMapFnDef;\r\n    };\r\n};\r\n\r\nexport declare type DevTypeMapFnDef = {\r\n    args: any;\r\n    result: any;\r\n    payload: OperationPayload;\r\n};\r\n\r\nexport declare namespace DMMF {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\ndeclare namespace DMMF_2 {\r\n    export {\r\n        datamodelEnumToSchemaEnum,\r\n        Document_2 as Document,\r\n        Mappings,\r\n        OtherOperationMappings,\r\n        DatamodelEnum,\r\n        SchemaEnum,\r\n        EnumValue,\r\n        Datamodel,\r\n        uniqueIndex,\r\n        PrimaryKey,\r\n        Model,\r\n        FieldKind,\r\n        FieldNamespace,\r\n        FieldLocation,\r\n        Field,\r\n        FieldDefault,\r\n        FieldDefaultScalar,\r\n        Index,\r\n        IndexType,\r\n        IndexField,\r\n        SortOrder,\r\n        Schema,\r\n        Query,\r\n        QueryOutput,\r\n        TypeRef,\r\n        InputTypeRef,\r\n        SchemaArg,\r\n        OutputType,\r\n        SchemaField,\r\n        OutputTypeRef,\r\n        Deprecation,\r\n        InputType,\r\n        FieldRefType,\r\n        FieldRefAllowType,\r\n        ModelMapping,\r\n        ModelAction\r\n    }\r\n}\r\n\r\nexport declare function dmmfToRuntimeDataModel(dmmfDataModel: DMMF_2.Datamodel): RuntimeDataModel;\r\n\r\ndeclare type Document_2 = ReadonlyDeep_2<{\r\n    datamodel: Datamodel;\r\n    schema: Schema;\r\n    mappings: Mappings;\r\n}>;\r\n\r\n/**\r\n * A generic driver adapter factory that allows the user to instantiate a\r\n * driver adapter. The query and result types are specific to the adapter.\r\n */\r\ndeclare interface DriverAdapterFactory<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Instantiate a driver adapter.\r\n     */\r\n    connect(): Promise<Queryable<Query, Result>>;\r\n}\r\n\r\n/** Client */\r\nexport declare type DynamicClientExtensionArgs<C_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof C_]: unknown;\r\n} & {\r\n    [K: symbol]: {\r\n        ctx: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList> & {\r\n            $parent: Optional<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThis<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['client']]: Return<ExtArgs['client'][P]>;\r\n} & {\r\n    [P in Exclude<TypeMap['meta']['modelProps'], keyof ExtArgs['client']>]: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, P>, ExtArgs>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['other']['operations'], keyof ExtArgs['client']>]: P extends keyof ClientOtherOps ? ClientOtherOps[P] : never;\r\n} & {\r\n    [P in Exclude<ClientBuiltInProp, keyof ExtArgs['client']>]: DynamicClientExtensionThisBuiltin<TypeMap, TypeMapCb, ExtArgs>[P];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['other'];\r\n    };\r\n};\r\n\r\nexport declare type DynamicClientExtensionThisBuiltin<TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    $extends: ExtendsHook<'extends', TypeMapCb, ExtArgs, Call<TypeMapCb, {\r\n        extArgs: ExtArgs;\r\n    }>>;\r\n    $transaction<P extends PrismaPromise<any>[]>(arg: [...P], options?: {\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<UnwrapTuple<P>>;\r\n    $transaction<R>(fn: (client: Omit<DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>, ITXClientDenyList>) => Promise<R>, options?: {\r\n        maxWait?: number;\r\n        timeout?: number;\r\n        isolationLevel?: TypeMap['meta']['txIsolationLevel'];\r\n    }): Promise<R>;\r\n    $disconnect(): Promise<void>;\r\n    $connect(): Promise<void>;\r\n};\r\n\r\n/** Model */\r\nexport declare type DynamicModelExtensionArgs<M_, TypeMap extends TypeMapDef, TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>> = {\r\n    [K in keyof M_]: K extends '$allModels' ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {};\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof M_[K]]?: unknown;\r\n    } & {\r\n        [K: symbol]: {\r\n            ctx: DynamicModelExtensionThis<TypeMap, ModelKey<TypeMap, K>, ExtArgs> & {\r\n                $parent: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>;\r\n            } & {\r\n                $name: ModelKey<TypeMap, K>;\r\n            } & {\r\n                /**\r\n                 * @deprecated Use `$name` instead.\r\n                 */\r\n                name: ModelKey<TypeMap, K>;\r\n            };\r\n        };\r\n    } : never;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFluentApi<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey, Null> = {\r\n    [K in keyof TypeMap['model'][M]['payload']['objects']]: <A>(args?: Exact<A, Path<TypeMap['model'][M]['operations'][P]['args']['select'], [K]>>) => PrismaPromise<Path<DynamicModelExtensionFnResultBase<TypeMap, M, {\r\n        select: {\r\n            [P in K]: A;\r\n        };\r\n    }, P>, [K]> | Null> & DynamicModelExtensionFluentApi<TypeMap, (TypeMap['model'][M]['payload']['objects'][K] & {})['name'], P, Null | Select<TypeMap['model'][M]['payload']['objects'][K], null>>;\r\n};\r\n\r\nexport declare type DynamicModelExtensionFnResult<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey, Null> = P extends FluentOperation ? DynamicModelExtensionFluentApi<TypeMap, M, P, Null> & PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P> | Null> : PrismaPromise<DynamicModelExtensionFnResultBase<TypeMap, M, A, P>>;\r\n\r\nexport declare type DynamicModelExtensionFnResultBase<TypeMap extends TypeMapDef, M extends PropertyKey, A, P extends PropertyKey> = GetResult<TypeMap['model'][M]['payload'], A, P & Operation, TypeMap['globalOmitOptions']>;\r\n\r\nexport declare type DynamicModelExtensionFnResultNull<P extends PropertyKey> = P extends 'findUnique' | 'findFirst' ? null : never;\r\n\r\nexport declare type DynamicModelExtensionOperationFn<TypeMap extends TypeMapDef, M extends PropertyKey, P extends PropertyKey> = {} extends TypeMap['model'][M]['operations'][P]['args'] ? <A extends TypeMap['model'][M]['operations'][P]['args']>(args?: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>> : <A extends TypeMap['model'][M]['operations'][P]['args']>(args: Exact<A, TypeMap['model'][M]['operations'][P]['args']>) => DynamicModelExtensionFnResult<TypeMap, M, A, P, DynamicModelExtensionFnResultNull<P>>;\r\n\r\nexport declare type DynamicModelExtensionThis<TypeMap extends TypeMapDef, M extends PropertyKey, ExtArgs extends Record<string, any>> = {\r\n    [P in keyof ExtArgs['model'][Uncapitalize<M & string>]]: Return<ExtArgs['model'][Uncapitalize<M & string>][P]>;\r\n} & {\r\n    [P in Exclude<keyof TypeMap['model'][M]['operations'], keyof ExtArgs['model'][Uncapitalize<M & string>]>]: DynamicModelExtensionOperationFn<TypeMap, M, P>;\r\n} & {\r\n    [P in Exclude<'fields', keyof ExtArgs['model'][Uncapitalize<M & string>]>]: TypeMap['model'][M]['fields'];\r\n} & {\r\n    [K: symbol]: {\r\n        types: TypeMap['model'][M];\r\n    };\r\n};\r\n\r\n/** Query */\r\nexport declare type DynamicQueryExtensionArgs<Q_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof Q_]: K extends '$allOperations' ? (args: {\r\n        model?: string;\r\n        operation: string;\r\n        args: any;\r\n        query: (args: any) => PrismaPromise<any>;\r\n    }) => Promise<any> : K extends '$allModels' ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][keyof TypeMap['model']]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], keyof TypeMap['model'][keyof TypeMap['model']]['operations']> : P extends keyof TypeMap['model'][keyof TypeMap['model']]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', keyof TypeMap['model'], P> : never;\r\n    } : K extends TypeMap['meta']['modelProps'] ? {\r\n        [P in keyof Q_[K] | keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] | '$allOperations']?: P extends '$allOperations' ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations']> : P extends keyof TypeMap['model'][ModelKey<TypeMap, K>]['operations'] ? DynamicQueryExtensionCb<TypeMap, 'model', ModelKey<TypeMap, K>, P> : never;\r\n    } : K extends keyof TypeMap['other']['operations'] ? DynamicQueryExtensionCb<[TypeMap], 0, 'other', K> : never;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCb<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = <A extends DynamicQueryExtensionCbArgs<TypeMap, _0, _1, _2>>(args: A) => Promise<TypeMap[_0][_1][_2]['result']>;\r\n\r\nexport declare type DynamicQueryExtensionCbArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = (_1 extends unknown ? _2 extends unknown ? {\r\n    args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>;\r\n    model: _0 extends 0 ? undefined : _1;\r\n    operation: _2;\r\n    query: <A extends DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>>(args: A) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n} : never : never) & {\r\n    query: (args: DynamicQueryExtensionCbArgsArgs<TypeMap, _0, _1, _2>) => PrismaPromise<TypeMap[_0][_1]['operations'][_2]['result']>;\r\n};\r\n\r\nexport declare type DynamicQueryExtensionCbArgsArgs<TypeMap extends TypeMapDef, _0 extends PropertyKey, _1 extends PropertyKey, _2 extends PropertyKey> = _2 extends '$queryRaw' | '$executeRaw' ? Sql : TypeMap[_0][_1]['operations'][_2]['args'];\r\n\r\n/** Result */\r\nexport declare type DynamicResultExtensionArgs<R_, TypeMap extends TypeMapDef> = {\r\n    [K in keyof R_]: {\r\n        [P in keyof R_[K]]?: {\r\n            needs?: DynamicResultExtensionNeeds<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>;\r\n            compute(data: DynamicResultExtensionData<TypeMap, ModelKey<TypeMap, K>, R_[K][P]>): any;\r\n        };\r\n    };\r\n};\r\n\r\nexport declare type DynamicResultExtensionData<TypeMap extends TypeMapDef, M extends PropertyKey, S> = GetFindResult<TypeMap['model'][M]['payload'], {\r\n    select: S;\r\n}, {}>;\r\n\r\nexport declare type DynamicResultExtensionNeeds<TypeMap extends TypeMapDef, M extends PropertyKey, S> = {\r\n    [K in keyof S]: K extends keyof TypeMap['model'][M]['payload']['scalars'] ? S[K] : never;\r\n} & {\r\n    [N in keyof TypeMap['model'][M]['payload']['scalars']]?: boolean;\r\n};\r\n\r\n/**\r\n * Placeholder value for \"no text\".\r\n */\r\nexport declare const empty: Sql;\r\n\r\nexport declare type EmptyToUnknown<T> = T;\r\n\r\ndeclare interface Engine<InteractiveTransactionPayload = unknown> {\r\n    /** The name of the engine. This is meant to be consumed externally */\r\n    readonly name: string;\r\n    onBeforeExit(callback: () => Promise<void>): void;\r\n    start(): Promise<void>;\r\n    stop(): Promise<void>;\r\n    version(forceRun?: boolean): Promise<string> | string;\r\n    request<T>(query: JsonQuery, options: RequestOptions<InteractiveTransactionPayload>): Promise<QueryEngineResultData<T>>;\r\n    requestBatch<T>(queries: JsonQuery[], options: RequestBatchOptions<InteractiveTransactionPayload>): Promise<BatchQueryEngineResult<T>[]>;\r\n    transaction(action: 'start', headers: Transaction_2.TransactionHeaders, options: Transaction_2.Options): Promise<Transaction_2.InteractiveTransactionInfo<unknown>>;\r\n    transaction(action: 'commit', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    transaction(action: 'rollback', headers: Transaction_2.TransactionHeaders, info: Transaction_2.InteractiveTransactionInfo<unknown>): Promise<void>;\r\n    metrics(options: MetricsOptionsJson): Promise<Metrics>;\r\n    metrics(options: MetricsOptionsPrometheus): Promise<string>;\r\n    applyPendingMigrations(): Promise<void>;\r\n}\r\n\r\ndeclare interface EngineConfig {\r\n    cwd: string;\r\n    dirname: string;\r\n    enableDebugLogs?: boolean;\r\n    allowTriggerPanic?: boolean;\r\n    prismaPath?: string;\r\n    generator?: GeneratorConfig;\r\n    /**\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    overrideDatasources: Datasources;\r\n    showColors?: boolean;\r\n    logQueries?: boolean;\r\n    logLevel?: 'info' | 'warn';\r\n    env: Record<string, string>;\r\n    flags?: string[];\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    previewFeatures?: string[];\r\n    engineEndpoint?: string;\r\n    activeProvider?: string;\r\n    logEmitter: LogEmitter;\r\n    transactionOptions: Transaction_2.Options;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`.\r\n     * If set, this is only used in the library engine, and all queries would be performed through it,\r\n     * rather than Prisma's Rust drivers.\r\n     * @remarks only used by LibraryEngine.ts\r\n     */\r\n    adapter?: SqlDriverAdapterFactory;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * The contents of the datasource url saved in a string\r\n     * @remarks only used by DataProxyEngine.ts\r\n     * @remarks this field is used internally by Policy, do not rename or remove\r\n     */\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used by DataProxyEngine.ts\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * The helper for interaction with OTEL tracing\r\n     * @remarks enabling is determined by the client and @prisma/instrumentation package\r\n     */\r\n    tracingHelper: TracingHelper;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * Web Assembly module loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n    /**\r\n     * Allows Accelerate to use runtime utilities from the client. These are\r\n     * necessary for the AccelerateEngine to function correctly.\r\n     */\r\n    accelerateUtils?: {\r\n        resolveDatasourceUrl: typeof resolveDatasourceUrl;\r\n        getBatchRequestPayload: typeof getBatchRequestPayload;\r\n        prismaGraphQLToJSError: typeof prismaGraphQLToJSError;\r\n        PrismaClientUnknownRequestError: typeof PrismaClientUnknownRequestError;\r\n        PrismaClientInitializationError: typeof PrismaClientInitializationError;\r\n        PrismaClientKnownRequestError: typeof PrismaClientKnownRequestError;\r\n        debug: (...args: any[]) => void;\r\n        engineVersion: string;\r\n        clientVersion: string;\r\n    };\r\n}\r\n\r\ndeclare type EngineEvent<E extends EngineEventType> = E extends QueryEventType ? QueryEvent : LogEvent;\r\n\r\ndeclare type EngineEventType = QueryEventType | LogEventType;\r\n\r\ndeclare type EngineSpan = {\r\n    id: EngineSpanId;\r\n    parentId: string | null;\r\n    name: string;\r\n    startTime: HrTime;\r\n    endTime: HrTime;\r\n    kind: EngineSpanKind;\r\n    attributes?: Record<string, unknown>;\r\n    links?: EngineSpanId[];\r\n};\r\n\r\ndeclare type EngineSpanId = string;\r\n\r\ndeclare type EngineSpanKind = 'client' | 'internal';\r\n\r\ndeclare type EngineWasmLoadingConfig = {\r\n    /**\r\n     * WASM-bindgen runtime for corresponding module\r\n     */\r\n    getRuntime: () => Promise<{\r\n        __wbg_set_wasm(exports: unknown): void;\r\n        QueryEngine: QueryEngineConstructor;\r\n    }>;\r\n    /**\r\n     * Loads the raw wasm module for the wasm query engine. This configuration is\r\n     * generated specifically for each type of client, eg. Node.js client and Edge\r\n     * clients will have different implementations.\r\n     * @remarks this is a callback on purpose, we only load the wasm if needed.\r\n     * @remarks only used by LibraryEngine\r\n     */\r\n    getQueryEngineWasmModule: () => Promise<unknown>;\r\n};\r\n\r\ndeclare type EnumValue = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n}>;\r\n\r\ndeclare type EnvPaths = {\r\n    rootEnvPath: string | null;\r\n    schemaEnvPath: string | undefined;\r\n};\r\n\r\ndeclare interface EnvValue {\r\n    fromEnvVar: null | string;\r\n    value: null | string;\r\n}\r\n\r\nexport declare type Equals<A, B> = (<T>() => T extends A ? 1 : 2) extends (<T>() => T extends B ? 1 : 2) ? 1 : 0;\r\n\r\ndeclare type Error_2 = {\r\n    kind: 'GenericJs';\r\n    id: number;\r\n} | {\r\n    kind: 'UnsupportedNativeDataType';\r\n    type: string;\r\n} | {\r\n    kind: 'InvalidIsolationLevel';\r\n    level: string;\r\n} | {\r\n    kind: 'LengthMismatch';\r\n    column?: string;\r\n} | {\r\n    kind: 'UniqueConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'NullConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'ForeignKeyConstraintViolation';\r\n    constraint?: {\r\n        fields: string[];\r\n    } | {\r\n        index: string;\r\n    } | {\r\n        foreignKey: {};\r\n    };\r\n} | {\r\n    kind: 'DatabaseDoesNotExist';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAlreadyExists';\r\n    db?: string;\r\n} | {\r\n    kind: 'DatabaseAccessDenied';\r\n    db?: string;\r\n} | {\r\n    kind: 'AuthenticationFailed';\r\n    user?: string;\r\n} | {\r\n    kind: 'TransactionWriteConflict';\r\n} | {\r\n    kind: 'TableDoesNotExist';\r\n    table?: string;\r\n} | {\r\n    kind: 'ColumnNotFound';\r\n    column?: string;\r\n} | {\r\n    kind: 'TooManyConnections';\r\n    cause: string;\r\n} | {\r\n    kind: 'ValueOutOfRange';\r\n    cause: string;\r\n} | {\r\n    kind: 'MissingFullTextSearchIndex';\r\n} | {\r\n    kind: 'SocketTimeout';\r\n} | {\r\n    kind: 'InconsistentColumnData';\r\n    cause: string;\r\n} | {\r\n    kind: 'TransactionAlreadyClosed';\r\n    cause: string;\r\n} | {\r\n    kind: 'postgres';\r\n    code: string;\r\n    severity: string;\r\n    message: string;\r\n    detail: string | undefined;\r\n    column: string | undefined;\r\n    hint: string | undefined;\r\n} | {\r\n    kind: 'mysql';\r\n    code: number;\r\n    message: string;\r\n    state: string;\r\n} | {\r\n    kind: 'sqlite';\r\n    /**\r\n     * Sqlite extended error code: https://www.sqlite.org/rescode.html\r\n     */\r\n    extendedCode: number;\r\n    message: string;\r\n} | {\r\n    kind: 'mssql';\r\n    code: number;\r\n    message: string;\r\n};\r\n\r\ndeclare type ErrorCapturingFunction<T> = T extends (...args: infer A) => Promise<infer R> ? (...args: A) => Promise<Result_4<ErrorCapturingInterface<R>>> : T extends (...args: infer A) => infer R ? (...args: A) => Result_4<ErrorCapturingInterface<R>> : T;\r\n\r\ndeclare type ErrorCapturingInterface<T> = {\r\n    [K in keyof T]: ErrorCapturingFunction<T[K]>;\r\n};\r\n\r\ndeclare interface ErrorCapturingSqlDriverAdapter extends ErrorCapturingInterface<SqlDriverAdapter> {\r\n    readonly errorRegistry: ErrorRegistry;\r\n}\r\n\r\ndeclare type ErrorFormat = 'pretty' | 'colorless' | 'minimal';\r\n\r\ndeclare type ErrorRecord = {\r\n    error: unknown;\r\n};\r\n\r\ndeclare interface ErrorRegistry {\r\n    consumeError(id: number): ErrorRecord | undefined;\r\n}\r\n\r\ndeclare interface ErrorWithBatchIndex {\r\n    batchRequestIdx?: number;\r\n}\r\n\r\ndeclare type EventCallback<E extends ExtendedEventType> = [E] extends ['beforeExit'] ? () => Promise<void> : [E] extends [LogLevel] ? (event: EngineEvent<E>) => void : never;\r\n\r\nexport declare type Exact<A, W> = (A extends unknown ? (W extends A ? {\r\n    [K in keyof A]: Exact<A[K], W[K]>;\r\n} : W) : never) | (A extends Narrowable ? A : never);\r\n\r\n/**\r\n * Defines Exception.\r\n *\r\n * string or an object with one of (message or name or code) and optional stack\r\n */\r\ndeclare type Exception = ExceptionWithCode | ExceptionWithMessage | ExceptionWithName | string;\r\n\r\ndeclare interface ExceptionWithCode {\r\n    code: string | number;\r\n    name?: string;\r\n    message?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithMessage {\r\n    code?: string | number;\r\n    message: string;\r\n    name?: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare interface ExceptionWithName {\r\n    code?: string | number;\r\n    message?: string;\r\n    name: string;\r\n    stack?: string;\r\n}\r\n\r\ndeclare type ExtendedEventType = LogLevel | 'beforeExit';\r\n\r\ndeclare type ExtendedSpanOptions = SpanOptions & {\r\n    /** The name of the span */\r\n    name: string;\r\n    internal?: boolean;\r\n    middleware?: boolean;\r\n    /** Whether it propagates context (?=true) */\r\n    active?: boolean;\r\n    /** The context to append the span to */\r\n    context?: Context;\r\n};\r\n\r\n/** $extends, defineExtension */\r\nexport declare interface ExtendsHook<Variant extends 'extends' | 'define', TypeMapCb extends TypeMapCbDef, ExtArgs extends Record<string, any>, TypeMap extends TypeMapDef = Call<TypeMapCb, {\r\n    extArgs: ExtArgs;\r\n}>> {\r\n    extArgs: ExtArgs;\r\n    <R_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, R, M_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels']?: unknown;\r\n    }, M, Q_ extends {\r\n        [K in TypeMap['meta']['modelProps'] | '$allModels' | keyof TypeMap['other']['operations'] | '$allOperations']?: unknown;\r\n    }, C_ extends {\r\n        [K in string]?: unknown;\r\n    }, C, Args extends InternalArgs = InternalArgs<R, M, {}, C>, MergedArgs extends InternalArgs = MergeExtArgs<TypeMap, ExtArgs, Args>>(extension: ((client: DynamicClientExtensionThis<TypeMap, TypeMapCb, ExtArgs>) => {\r\n        $extends: {\r\n            extArgs: Args;\r\n        };\r\n    }) | {\r\n        name?: string;\r\n        query?: DynamicQueryExtensionArgs<Q_, TypeMap>;\r\n        result?: DynamicResultExtensionArgs<R_, TypeMap> & R;\r\n        model?: DynamicModelExtensionArgs<M_, TypeMap, TypeMapCb, ExtArgs> & M;\r\n        client?: DynamicClientExtensionArgs<C_, TypeMap, TypeMapCb, ExtArgs> & C;\r\n    }): {\r\n        extends: DynamicClientExtensionThis<Call<TypeMapCb, {\r\n            extArgs: MergedArgs;\r\n        }>, TypeMapCb, MergedArgs>;\r\n        define: (client: any) => {\r\n            $extends: {\r\n                extArgs: Args;\r\n            };\r\n        };\r\n    }[Variant];\r\n}\r\n\r\nexport declare type ExtensionArgs = Optional<RequiredExtensionArgs>;\r\n\r\ndeclare namespace Extensions {\r\n    export {\r\n        defineExtension,\r\n        getExtensionContext\r\n    }\r\n}\r\nexport { Extensions }\r\n\r\ndeclare namespace Extensions_2 {\r\n    export {\r\n        InternalArgs,\r\n        DefaultArgs,\r\n        GetPayloadResultExtensionKeys,\r\n        GetPayloadResultExtensionObject,\r\n        GetPayloadResult,\r\n        GetSelect,\r\n        GetOmit,\r\n        DynamicQueryExtensionArgs,\r\n        DynamicQueryExtensionCb,\r\n        DynamicQueryExtensionCbArgs,\r\n        DynamicQueryExtensionCbArgsArgs,\r\n        DynamicResultExtensionArgs,\r\n        DynamicResultExtensionNeeds,\r\n        DynamicResultExtensionData,\r\n        DynamicModelExtensionArgs,\r\n        DynamicModelExtensionThis,\r\n        DynamicModelExtensionOperationFn,\r\n        DynamicModelExtensionFnResult,\r\n        DynamicModelExtensionFnResultBase,\r\n        DynamicModelExtensionFluentApi,\r\n        DynamicModelExtensionFnResultNull,\r\n        DynamicClientExtensionArgs,\r\n        DynamicClientExtensionThis,\r\n        ClientBuiltInProp,\r\n        DynamicClientExtensionThisBuiltin,\r\n        ExtendsHook,\r\n        MergeExtArgs,\r\n        AllModelsToStringIndex,\r\n        TypeMapDef,\r\n        DevTypeMapDef,\r\n        DevTypeMapFnDef,\r\n        ClientOptionDef,\r\n        ClientOtherOps,\r\n        TypeMapCbDef,\r\n        ModelKey,\r\n        RequiredExtensionArgs as UserArgs\r\n    }\r\n}\r\n\r\nexport declare type ExtractGlobalOmit<Options, ModelName extends string> = Options extends {\r\n    omit: {\r\n        [K in ModelName]: infer GlobalOmit;\r\n    };\r\n} ? GlobalOmit : {};\r\n\r\ndeclare type Field = ReadonlyDeep_2<{\r\n    kind: FieldKind;\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n    isUnique: boolean;\r\n    isId: boolean;\r\n    isReadOnly: boolean;\r\n    isGenerated?: boolean;\r\n    isUpdatedAt?: boolean;\r\n    /**\r\n     * Describes the data type in the same the way it is defined in the Prisma schema:\r\n     * BigInt, Boolean, Bytes, DateTime, Decimal, Float, Int, JSON, String, $ModelName\r\n     */\r\n    type: string;\r\n    /**\r\n     * Native database type, if specified.\r\n     * For example, `@db.VarChar(191)` is encoded as `['VarChar', ['191']]`,\r\n     * `@db.Text` is encoded as `['Text', []]`.\r\n     */\r\n    nativeType?: [string, string[]] | null;\r\n    dbName?: string | null;\r\n    hasDefaultValue: boolean;\r\n    default?: FieldDefault | FieldDefaultScalar | FieldDefaultScalar[];\r\n    relationFromFields?: string[];\r\n    relationToFields?: string[];\r\n    relationOnDelete?: string;\r\n    relationOnUpdate?: string;\r\n    relationName?: string;\r\n    documentation?: string;\r\n}>;\r\n\r\ndeclare type FieldDefault = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: Array<string | number>;\r\n}>;\r\n\r\ndeclare type FieldDefaultScalar = string | boolean | number;\r\n\r\ndeclare type FieldKind = 'scalar' | 'object' | 'enum' | 'unsupported';\r\n\r\ndeclare type FieldLocation = 'scalar' | 'inputObjectTypes' | 'outputObjectTypes' | 'enumTypes' | 'fieldRefTypes';\r\n\r\ndeclare type FieldNamespace = 'model' | 'prisma';\r\n\r\n/**\r\n * A reference to a specific field of a specific model\r\n */\r\nexport declare interface FieldRef<Model, FieldType> {\r\n    readonly modelName: Model;\r\n    readonly name: string;\r\n    readonly typeName: FieldType;\r\n    readonly isList: boolean;\r\n}\r\n\r\ndeclare type FieldRefAllowType = TypeRef<'scalar' | 'enumTypes'>;\r\n\r\ndeclare type FieldRefType = ReadonlyDeep_2<{\r\n    name: string;\r\n    allowTypes: FieldRefAllowType[];\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type FluentOperation = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'create' | 'update' | 'upsert' | 'delete';\r\n\r\nexport declare interface Fn<Params = unknown, Returns = unknown> {\r\n    params: Params;\r\n    returns: Returns;\r\n}\r\n\r\ndeclare interface GeneratorConfig {\r\n    name: string;\r\n    output: EnvValue | null;\r\n    isCustomOutput?: boolean;\r\n    provider: EnvValue;\r\n    config: {\r\n        /** `output` is a reserved name and will only be available directly at `generator.output` */\r\n        output?: never;\r\n        /** `provider` is a reserved name and will only be available directly at `generator.provider` */\r\n        provider?: never;\r\n        /** `binaryTargets` is a reserved name and will only be available directly at `generator.binaryTargets` */\r\n        binaryTargets?: never;\r\n        /** `previewFeatures` is a reserved name and will only be available directly at `generator.previewFeatures` */\r\n        previewFeatures?: never;\r\n    } & {\r\n        [key: string]: string | string[] | undefined;\r\n    };\r\n    binaryTargets: BinaryTargetsEnvValue[];\r\n    previewFeatures: string[];\r\n    envPaths?: EnvPaths;\r\n    sourceFilePath: string;\r\n}\r\n\r\nexport declare type GetAggregateResult<P extends OperationPayload, A> = {\r\n    [K in keyof A as K extends Aggregate ? K : never]: K extends '_count' ? A[K] extends true ? number : Count<A[K]> : {\r\n        [J in keyof A[K] & string]: P['scalars'][J] | null;\r\n    };\r\n};\r\n\r\ndeclare function getBatchRequestPayload(batch: JsonQuery[], transaction?: TransactionOptions_2<unknown>): QueryEngineBatchRequest;\r\n\r\nexport declare type GetBatchResult = {\r\n    count: number;\r\n};\r\n\r\nexport declare type GetCountResult<A> = A extends {\r\n    select: infer S;\r\n} ? (S extends true ? number : Count<S>) : number;\r\n\r\ndeclare function getExtensionContext<T>(that: T): Context_2<T>;\r\n\r\nexport declare type GetFindResult<P extends OperationPayload, A, GlobalOmitOptions> = Equals<A, any> extends 1 ? DefaultSelection<P, A, GlobalOmitOptions> : A extends {\r\n    select: infer S extends object;\r\n} & Record<string, unknown> | {\r\n    include: infer I extends object;\r\n} & Record<string, unknown> ? {\r\n    [K in keyof S | keyof I as (S & I)[K] extends false | undefined | Skip | null ? never : K]: (S & I)[K] extends object ? P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? GetFindResult<O, (S & I)[K], GlobalOmitOptions> | SelectField<P, K> & null : never : K extends '_count' ? Count<GetFindResult<P, (S & I)[K], GlobalOmitOptions>> : never : P extends SelectablePayloadFields<K, (infer O)[]> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions>[] : never : P extends SelectablePayloadFields<K, infer O | null> ? O extends OperationPayload ? DefaultSelection<O, {}, GlobalOmitOptions> | SelectField<P, K> & null : never : P extends {\r\n        scalars: {\r\n            [k in K]: infer O;\r\n        };\r\n    } ? O : K extends '_count' ? Count<P['objects']> : never;\r\n} & (A extends {\r\n    include: any;\r\n} & Record<string, unknown> ? DefaultSelection<P, A & {\r\n    omit: A['omit'];\r\n}, GlobalOmitOptions> : unknown) : DefaultSelection<P, A, GlobalOmitOptions>;\r\n\r\nexport declare type GetGroupByResult<P extends OperationPayload, A> = A extends {\r\n    by: string[];\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by'][number]]: P['scalars'][K];\r\n}> : A extends {\r\n    by: string;\r\n} ? Array<GetAggregateResult<P, A> & {\r\n    [K in A['by']]: P['scalars'][K];\r\n}> : {}[];\r\n\r\nexport declare type GetOmit<BaseKeys extends string, R extends InternalArgs['result'][string], ExtraType = never> = {\r\n    [K in (string extends keyof R ? never : keyof R) | BaseKeys]?: boolean | ExtraType;\r\n};\r\n\r\nexport declare type GetPayloadResult<Base extends Record<any, any>, R extends InternalArgs['result'][string]> = Omit<Base, GetPayloadResultExtensionKeys<R>> & GetPayloadResultExtensionObject<R>;\r\n\r\nexport declare type GetPayloadResultExtensionKeys<R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = KR;\r\n\r\nexport declare type GetPayloadResultExtensionObject<R extends InternalArgs['result'][string]> = {\r\n    [K in GetPayloadResultExtensionKeys<R>]: R[K] extends () => {\r\n        compute: (...args: any) => infer C;\r\n    } ? C : never;\r\n};\r\n\r\nexport declare function getPrismaClient(config: GetPrismaClientConfig): {\r\n    new (optionsArg?: PrismaClientOptions): {\r\n        _originalClient: any;\r\n        _runtimeDataModel: RuntimeDataModel;\r\n        _requestHandler: RequestHandler;\r\n        _connectionPromise?: Promise<any> | undefined;\r\n        _disconnectionPromise?: Promise<any> | undefined;\r\n        _engineConfig: EngineConfig;\r\n        _accelerateEngineConfig: AccelerateEngineConfig;\r\n        _clientVersion: string;\r\n        _errorFormat: ErrorFormat;\r\n        _tracingHelper: TracingHelper;\r\n        _middlewares: MiddlewareHandler<QueryMiddleware>;\r\n        _previewFeatures: string[];\r\n        _activeProvider: string;\r\n        _globalOmit?: GlobalOmitOptions | undefined;\r\n        _extensions: MergedExtensionsList;\r\n        /**\r\n         * @remarks This is used internally by Policy, do not rename or remove\r\n         */\r\n        _engine: Engine;\r\n        /**\r\n         * A fully constructed/applied Client that references the parent\r\n         * PrismaClient. This is used for Client extensions only.\r\n         */\r\n        _appliedParent: any;\r\n        _createPrismaPromise: PrismaPromiseFactory;\r\n        /**\r\n         * Hook a middleware into the client\r\n         * @param middleware to hook\r\n         */\r\n        $use(middleware: QueryMiddleware): void;\r\n        $on<E extends ExtendedEventType>(eventType: E, callback: EventCallback<E>): any;\r\n        $connect(): Promise<void>;\r\n        /**\r\n         * Disconnect from the database\r\n         */\r\n        $disconnect(): Promise<void>;\r\n        /**\r\n         * Executes a raw query and always returns a number\r\n         */\r\n        $executeRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<number>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$executeRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $executeRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw command only for MongoDB\r\n         *\r\n         * @param command\r\n         * @returns\r\n         */\r\n        $runCommandRaw(command: Record<string, JsInputValue>): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Executes a raw query and returns selected data\r\n         */\r\n        $queryRawInternal(transaction: PrismaPromiseTransaction | undefined, clientMethod: string, args: RawQueryArgs, middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>): Promise<any>;\r\n        /**\r\n         * Executes a raw query provided through a safe tag function\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRaw(query: TemplateStringsArray | Sql, ...values: any[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Counterpart to $queryRaw, that returns strongly typed results\r\n         * @param typedSql\r\n         */\r\n        $queryRawTyped(typedSql: UnknownTypedSql): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Unsafe counterpart of `$queryRaw` that is susceptible to SQL injections\r\n         * @see https://github.com/prisma/prisma/issues/7142\r\n         *\r\n         * @param query\r\n         * @param values\r\n         * @returns\r\n         */\r\n        $queryRawUnsafe(query: string, ...values: RawValue[]): PrismaPromise_2<unknown, any>;\r\n        /**\r\n         * Execute a batch of requests in a transaction\r\n         * @param requests\r\n         * @param options\r\n         */\r\n        _transactionWithArray({ promises, options, }: {\r\n            promises: Array<PrismaPromise_2<any>>;\r\n            options?: BatchTransactionOptions;\r\n        }): Promise<any>;\r\n        /**\r\n         * Perform a long-running transaction\r\n         * @param callback\r\n         * @param options\r\n         * @returns\r\n         */\r\n        _transactionWithCallback({ callback, options, }: {\r\n            callback: (client: Client) => Promise<unknown>;\r\n            options?: Options;\r\n        }): Promise<unknown>;\r\n        _createItxClient(transaction: PrismaPromiseInteractiveTransaction): Client;\r\n        /**\r\n         * Execute queries within a transaction\r\n         * @param input a callback or a query list\r\n         * @param options to set timeouts (callback)\r\n         * @returns\r\n         */\r\n        $transaction(input: any, options?: any): Promise<any>;\r\n        /**\r\n         * Runs the middlewares over params before executing a request\r\n         * @param internalParams\r\n         * @returns\r\n         */\r\n        _request(internalParams: InternalRequestParams): Promise<any>;\r\n        _executeRequest({ args, clientMethod, dataPath, callsite, action, model, argsMapper, transaction, unpacker, otelParentCtx, customDataProxyFetch, }: InternalRequestParams): Promise<any>;\r\n        $metrics: MetricsClient;\r\n        /**\r\n         * Shortcut for checking a preview flag\r\n         * @param feature preview flag\r\n         * @returns\r\n         */\r\n        _hasPreviewFlag(feature: string): boolean;\r\n        $applyPendingMigrations(): Promise<void>;\r\n        $extends: typeof $extends;\r\n        readonly [Symbol.toStringTag]: string;\r\n    };\r\n};\r\n\r\n/**\r\n * Config that is stored into the generated client. When the generated client is\r\n * loaded, this same config is passed to {@link getPrismaClient} which creates a\r\n * closure with that config around a non-instantiated [[PrismaClient]].\r\n */\r\nexport declare type GetPrismaClientConfig = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    generator?: GeneratorConfig;\r\n    relativeEnvPaths?: {\r\n        rootEnvPath?: string | null;\r\n        schemaEnvPath?: string | null;\r\n    };\r\n    relativePath: string;\r\n    dirname: string;\r\n    clientVersion: string;\r\n    engineVersion: string;\r\n    datasourceNames: string[];\r\n    activeProvider: ActiveConnectorType;\r\n    /**\r\n     * The contents of the schema encoded into a string\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchema: string;\r\n    /**\r\n     * A special env object just for the data proxy edge runtime.\r\n     * Allows bundlers to inject their own env variables (Vercel).\r\n     * Allows platforms to declare global variables as env (Workers).\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    injectableEdgeEnv?: () => LoadedEnv;\r\n    /**\r\n     * The contents of the datasource url saved in a string.\r\n     * This can either be an env var name or connection string.\r\n     * It is needed by the client to connect to the Data Proxy.\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineDatasources: {\r\n        [name in string]: {\r\n            url: EnvValue;\r\n        };\r\n    };\r\n    /**\r\n     * The string hash that was produced for a given schema\r\n     * @remarks only used for the purpose of data proxy\r\n     */\r\n    inlineSchemaHash: string;\r\n    /**\r\n     * A marker to indicate that the client was not generated via `prisma\r\n     * generate` but was generated via `generate --postinstall` script instead.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    postinstall?: boolean;\r\n    /**\r\n     * Information about the CI where the Prisma Client has been generated. The\r\n     * name of the CI environment is stored at generation time because CI\r\n     * information is not always available at runtime. Moreover, the edge client\r\n     * has no notion of environment variables, so this works around that.\r\n     * @remarks used to error for Vercel/Netlify for schema caching issues\r\n     */\r\n    ciName?: string;\r\n    /**\r\n     * Information about whether we have not found a schema.prisma file in the\r\n     * default location, and that we fell back to finding the schema.prisma file\r\n     * in the current working directory. This usually means it has been bundled.\r\n     */\r\n    isBundled?: boolean;\r\n    /**\r\n     * A boolean that is `false` when the client was generated with --no-engine. At\r\n     * runtime, this means the client will be bound to be using the Data Proxy.\r\n     */\r\n    copyEngine?: boolean;\r\n    /**\r\n     * Optional wasm loading configuration\r\n     */\r\n    engineWasm?: EngineWasmLoadingConfig;\r\n    compilerWasm?: CompilerWasmLoadingConfig;\r\n};\r\n\r\nexport declare type GetResult<Payload extends OperationPayload, Args, OperationName extends Operation = 'findUniqueOrThrow', GlobalOmitOptions = {}> = {\r\n    findUnique: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findUniqueOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findFirst: GetFindResult<Payload, Args, GlobalOmitOptions> | null;\r\n    findFirstOrThrow: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    findMany: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    create: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    createMany: GetBatchResult;\r\n    createManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    update: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    updateMany: GetBatchResult;\r\n    updateManyAndReturn: GetFindResult<Payload, Args, GlobalOmitOptions>[];\r\n    upsert: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    delete: GetFindResult<Payload, Args, GlobalOmitOptions>;\r\n    deleteMany: GetBatchResult;\r\n    aggregate: GetAggregateResult<Payload, Args>;\r\n    count: GetCountResult<Args>;\r\n    groupBy: GetGroupByResult<Payload, Args>;\r\n    $queryRaw: unknown;\r\n    $queryRawTyped: unknown;\r\n    $executeRaw: number;\r\n    $queryRawUnsafe: unknown;\r\n    $executeRawUnsafe: number;\r\n    $runCommandRaw: JsonObject;\r\n    findRaw: JsonObject;\r\n    aggregateRaw: JsonObject;\r\n}[OperationName];\r\n\r\nexport declare function getRuntime(): GetRuntimeOutput;\r\n\r\ndeclare type GetRuntimeOutput = {\r\n    id: RuntimeName;\r\n    prettyName: string;\r\n    isEdge: boolean;\r\n};\r\n\r\nexport declare type GetSelect<Base extends Record<any, any>, R extends InternalArgs['result'][string], KR extends keyof R = string extends keyof R ? never : keyof R> = {\r\n    [K in KR | keyof Base]?: K extends KR ? boolean : Base[K];\r\n};\r\n\r\ndeclare type GlobalOmitOptions = {\r\n    [modelName: string]: {\r\n        [fieldName: string]: boolean;\r\n    };\r\n};\r\n\r\ndeclare type HandleErrorParams = {\r\n    args: JsArgs;\r\n    error: any;\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    modelName?: string;\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare type HrTime = [number, number];\r\n\r\n/**\r\n * Defines High-Resolution Time.\r\n *\r\n * The first number, HrTime[0], is UNIX Epoch time in seconds since 00:00:00 UTC on 1 January 1970.\r\n * The second number, HrTime[1], represents the partial second elapsed since Unix Epoch time represented by first number in nanoseconds.\r\n * For example, 2021-01-01T12:30:10.150Z in UNIX Epoch time in milliseconds is represented as 1609504210150.\r\n * The first number is calculated by converting and truncating the Epoch time in milliseconds to seconds:\r\n * HrTime[0] = Math.trunc(1609504210150 / 1000) = 1609504210.\r\n * The second number is calculated by converting the digits after the decimal point of the subtraction, (1609504210150 / 1000) - HrTime[0], to nanoseconds:\r\n * HrTime[1] = Number((1609504210.150 - HrTime[0]).toFixed(9)) * 1e9 = 150000000.\r\n * This is represented in HrTime format as [1609504210, 150000000].\r\n */\r\ndeclare type HrTime_2 = [number, number];\r\n\r\ndeclare type Index = ReadonlyDeep_2<{\r\n    model: string;\r\n    type: IndexType;\r\n    isDefinedOnField: boolean;\r\n    name?: string;\r\n    dbName?: string;\r\n    algorithm?: string;\r\n    clustered?: boolean;\r\n    fields: IndexField[];\r\n}>;\r\n\r\ndeclare type IndexField = ReadonlyDeep_2<{\r\n    name: string;\r\n    sortOrder?: SortOrder;\r\n    length?: number;\r\n    operatorClass?: string;\r\n}>;\r\n\r\ndeclare type IndexType = 'id' | 'normal' | 'unique' | 'fulltext';\r\n\r\n/**\r\n * Matches a JSON array.\r\n * Unlike \\`JsonArray\\`, readonly arrays are assignable to this type.\r\n */\r\nexport declare interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {\r\n}\r\n\r\n/**\r\n * Matches a JSON object.\r\n * Unlike \\`JsonObject\\`, this type allows undefined and read-only properties.\r\n */\r\nexport declare type InputJsonObject = {\r\n    readonly [Key in string]?: InputJsonValue | null;\r\n};\r\n\r\n/**\r\n * Matches any valid value that can be used as an input for operations like\r\n * create and update as the value of a JSON field. Unlike \\`JsonValue\\`, this\r\n * type allows read-only arrays and read-only object properties and disallows\r\n * \\`null\\` at the top level.\r\n *\r\n * \\`null\\` cannot be used as the value of a JSON field because its meaning\r\n * would be ambiguous. Use \\`Prisma.JsonNull\\` to store the JSON null value or\r\n * \\`Prisma.DbNull\\` to clear the JSON value and set the field to the database\r\n * NULL value instead.\r\n *\r\n * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values\r\n */\r\nexport declare type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | {\r\n    toJSON(): unknown;\r\n};\r\n\r\ndeclare type InputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    constraints: {\r\n        maxNumFields: number | null;\r\n        minNumFields: number | null;\r\n        fields?: string[];\r\n    };\r\n    meta?: {\r\n        source?: string;\r\n        grouping?: string;\r\n    };\r\n    fields: SchemaArg[];\r\n}>;\r\n\r\ndeclare type InputTypeRef = TypeRef<'scalar' | 'inputObjectTypes' | 'enumTypes' | 'fieldRefTypes'>;\r\n\r\ndeclare type InteractiveTransactionInfo<Payload = unknown> = {\r\n    /**\r\n     * Transaction ID returned by the query engine.\r\n     */\r\n    id: string;\r\n    /**\r\n     * Arbitrary payload the meaning of which depends on the `Engine` implementation.\r\n     * For example, `DataProxyEngine` needs to associate different API endpoints with transactions.\r\n     * In `LibraryEngine` and `BinaryEngine` it is currently not used.\r\n     */\r\n    payload: Payload;\r\n};\r\n\r\ndeclare type InteractiveTransactionOptions<Payload> = Transaction_2.InteractiveTransactionInfo<Payload>;\r\n\r\nexport declare type InternalArgs<R = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, M = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, Q = {\r\n    [K in string]: {\r\n        [K in string]: unknown;\r\n    };\r\n}, C = {\r\n    [K in string]: unknown;\r\n}> = {\r\n    result: {\r\n        [K in keyof R]: {\r\n            [P in keyof R[K]]: () => R[K][P];\r\n        };\r\n    };\r\n    model: {\r\n        [K in keyof M]: {\r\n            [P in keyof M[K]]: () => M[K][P];\r\n        };\r\n    };\r\n    query: {\r\n        [K in keyof Q]: {\r\n            [P in keyof Q[K]]: () => Q[K][P];\r\n        };\r\n    };\r\n    client: {\r\n        [K in keyof C]: () => C[K];\r\n    };\r\n};\r\n\r\ndeclare type InternalRequestParams = {\r\n    /**\r\n     * The original client method being called.\r\n     * Even though the rootField / operation can be changed,\r\n     * this method stays as it is, as it's what the user's\r\n     * code looks like\r\n     */\r\n    clientMethod: string;\r\n    /**\r\n     * Name of js model that triggered the request. Might be used\r\n     * for warnings or error messages\r\n     */\r\n    jsModelName?: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    /** Used to \"desugar\" a user input into an \"expanded\" one */\r\n    argsMapper?: (args?: UserArgs_2) => UserArgs_2;\r\n    /** Used to convert args for middleware and back */\r\n    middlewareArgsMapper?: MiddlewareArgsMapper<unknown, unknown>;\r\n    /** Used for Accelerate client extension via Data Proxy */\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n} & Omit<QueryMiddlewareParams, 'runInTransaction'>;\r\n\r\ndeclare type IsolationLevel = 'READ UNCOMMITTED' | 'READ COMMITTED' | 'REPEATABLE READ' | 'SNAPSHOT' | 'SERIALIZABLE';\r\n\r\ndeclare type IsolationLevel_2 = 'ReadUncommitted' | 'ReadCommitted' | 'RepeatableRead' | 'Snapshot' | 'Serializable';\r\n\r\ndeclare function isSkip(value: unknown): value is Skip;\r\n\r\nexport declare function isTypedSql(value: unknown): value is UnknownTypedSql;\r\n\r\nexport declare type ITXClientDenyList = (typeof denylist)[number];\r\n\r\nexport declare const itxClientDenyList: readonly (string | symbol)[];\r\n\r\ndeclare interface Job {\r\n    resolve: (data: any) => void;\r\n    reject: (data: any) => void;\r\n    request: any;\r\n}\r\n\r\n/**\r\n * Create a SQL query for a list of values.\r\n */\r\nexport declare function join(values: readonly RawValue[], separator?: string, prefix?: string, suffix?: string): Sql;\r\n\r\nexport declare type JsArgs = {\r\n    select?: Selection_2;\r\n    include?: Selection_2;\r\n    omit?: Omission;\r\n    [argName: string]: JsInputValue;\r\n};\r\n\r\nexport declare type JsInputValue = null | undefined | string | number | boolean | bigint | Uint8Array | Date | DecimalJsLike | ObjectEnumValue | RawParameters | JsonConvertible | FieldRef<string, unknown> | JsInputValue[] | Skip | {\r\n    [key: string]: JsInputValue;\r\n};\r\n\r\ndeclare type JsonArgumentValue = number | string | boolean | null | RawTaggedValue | JsonArgumentValue[] | {\r\n    [key: string]: JsonArgumentValue;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON array.\r\n */\r\nexport declare interface JsonArray extends Array<JsonValue> {\r\n}\r\n\r\nexport declare type JsonBatchQuery = {\r\n    batch: JsonQuery[];\r\n    transaction?: {\r\n        isolationLevel?: IsolationLevel_2;\r\n    };\r\n};\r\n\r\nexport declare interface JsonConvertible {\r\n    toJSON(): unknown;\r\n}\r\n\r\ndeclare type JsonFieldSelection = {\r\n    arguments?: Record<string, JsonArgumentValue> | RawTaggedValue;\r\n    selection: JsonSelectionSet;\r\n};\r\n\r\ndeclare class JsonNull extends NullTypesEnumValue {\r\n    #private;\r\n}\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches a JSON object.\r\n * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from.\r\n */\r\nexport declare type JsonObject = {\r\n    [Key in string]?: JsonValue;\r\n};\r\n\r\nexport declare type JsonQuery = {\r\n    modelName?: string;\r\n    action: JsonQueryAction;\r\n    query: JsonFieldSelection;\r\n};\r\n\r\ndeclare type JsonQueryAction = 'findUnique' | 'findUniqueOrThrow' | 'findFirst' | 'findFirstOrThrow' | 'findMany' | 'createOne' | 'createMany' | 'createManyAndReturn' | 'updateOne' | 'updateMany' | 'updateManyAndReturn' | 'deleteOne' | 'deleteMany' | 'upsertOne' | 'aggregate' | 'groupBy' | 'executeRaw' | 'queryRaw' | 'runCommandRaw' | 'findRaw' | 'aggregateRaw';\r\n\r\ndeclare type JsonSelectionSet = {\r\n    $scalars?: boolean;\r\n    $composites?: boolean;\r\n} & {\r\n    [fieldName: string]: boolean | JsonFieldSelection;\r\n};\r\n\r\n/**\r\n * From https://github.com/sindresorhus/type-fest/\r\n * Matches any valid JSON value.\r\n */\r\nexport declare type JsonValue = string | number | boolean | JsonObject | JsonArray | null;\r\n\r\nexport declare type JsOutputValue = null | string | number | boolean | bigint | Uint8Array | Date | Decimal | JsOutputValue[] | {\r\n    [key: string]: JsOutputValue;\r\n};\r\n\r\nexport declare type JsPromise<T> = Promise<T> & {};\r\n\r\ndeclare type KnownErrorParams = {\r\n    code: string;\r\n    clientVersion: string;\r\n    meta?: Record<string, unknown>;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\n/**\r\n * A pointer from the current {@link Span} to another span in the same trace or\r\n * in a different trace.\r\n * Few examples of Link usage.\r\n * 1. Batch Processing: A batch of elements may contain elements associated\r\n *    with one or more traces/spans. Since there can only be one parent\r\n *    SpanContext, Link is used to keep reference to SpanContext of all\r\n *    elements in the batch.\r\n * 2. Public Endpoint: A SpanContext in incoming client request on a public\r\n *    endpoint is untrusted from service provider perspective. In such case it\r\n *    is advisable to start a new trace with appropriate sampling decision.\r\n *    However, it is desirable to associate incoming SpanContext to new trace\r\n *    initiated on service provider side so two traces (from Client and from\r\n *    Service Provider) can be correlated.\r\n */\r\ndeclare interface Link {\r\n    /** The {@link SpanContext} of a linked span. */\r\n    context: SpanContext;\r\n    /** A set of {@link SpanAttributes} on the link. */\r\n    attributes?: SpanAttributes;\r\n    /** Count of attributes of the link that were dropped due to collection limits */\r\n    droppedAttributesCount?: number;\r\n}\r\n\r\ndeclare type LoadedEnv = {\r\n    message?: string;\r\n    parsed: {\r\n        [x: string]: string;\r\n    };\r\n} | undefined;\r\n\r\ndeclare type LocationInFile = {\r\n    fileName: string;\r\n    lineNumber: number | null;\r\n    columnNumber: number | null;\r\n};\r\n\r\ndeclare type LogDefinition = {\r\n    level: LogLevel;\r\n    emit: 'stdout' | 'event';\r\n};\r\n\r\n/**\r\n * Typings for the events we emit.\r\n *\r\n * @remarks\r\n * If this is updated, our edge runtime shim needs to be updated as well.\r\n */\r\ndeclare type LogEmitter = {\r\n    on<E extends EngineEventType>(event: E, listener: (event: EngineEvent<E>) => void): LogEmitter;\r\n    emit(event: QueryEventType, payload: QueryEvent): boolean;\r\n    emit(event: LogEventType, payload: LogEvent): boolean;\r\n};\r\n\r\ndeclare type LogEvent = {\r\n    timestamp: Date;\r\n    message: string;\r\n    target: string;\r\n};\r\n\r\ndeclare type LogEventType = 'info' | 'warn' | 'error';\r\n\r\ndeclare type LogLevel = 'info' | 'query' | 'warn' | 'error';\r\n\r\n/**\r\n * Generates more strict variant of an enum which, unlike regular enum,\r\n * throws on non-existing property access. This can be useful in following situations:\r\n * - we have an API, that accepts both `undefined` and `SomeEnumType` as an input\r\n * - enum values are generated dynamically from DMMF.\r\n *\r\n * In that case, if using normal enums and no compile-time typechecking, using non-existing property\r\n * will result in `undefined` value being used, which will be accepted. Using strict enum\r\n * in this case will help to have a runtime exception, telling you that you are probably doing something wrong.\r\n *\r\n * Note: if you need to check for existence of a value in the enum you can still use either\r\n * `in` operator or `hasOwnProperty` function.\r\n *\r\n * @param definition\r\n * @returns\r\n */\r\nexport declare function makeStrictEnum<T extends Record<PropertyKey, string | number>>(definition: T): T;\r\n\r\nexport declare function makeTypedQueryFactory(sql: string): (...values: any[]) => TypedSql<any[], unknown>;\r\n\r\ndeclare type Mappings = ReadonlyDeep_2<{\r\n    modelOperations: ModelMapping[];\r\n    otherOperations: {\r\n        read: string[];\r\n        write: string[];\r\n    };\r\n}>;\r\n\r\n/**\r\n * Class that holds the list of all extensions, applied to particular instance,\r\n * as well as resolved versions of the components that need to apply on\r\n * different levels. Main idea of this class: avoid re-resolving as much of the\r\n * stuff as possible when new extensions are added while also delaying the\r\n * resolve until the point it is actually needed. For example, computed fields\r\n * of the model won't be resolved unless the model is actually queried. Neither\r\n * adding extensions with `client` component only cause other components to\r\n * recompute.\r\n */\r\ndeclare class MergedExtensionsList {\r\n    private head?;\r\n    private constructor();\r\n    static empty(): MergedExtensionsList;\r\n    static single(extension: ExtensionArgs): MergedExtensionsList;\r\n    isEmpty(): boolean;\r\n    append(extension: ExtensionArgs): MergedExtensionsList;\r\n    getAllComputedFields(dmmfModelName: string): ComputedFieldsMap | undefined;\r\n    getAllClientExtensions(): ClientArg | undefined;\r\n    getAllModelExtensions(dmmfModelName: string): ModelArg | undefined;\r\n    getAllQueryCallbacks(jsModelName: string, operation: string): any;\r\n    getAllBatchQueryCallbacks(): BatchQueryOptionsCb[];\r\n}\r\n\r\nexport declare type MergeExtArgs<TypeMap extends TypeMapDef, ExtArgs extends Record<any, any>, Args extends Record<any, any>> = ComputeDeep<ExtArgs & Args & AllModelsToStringIndex<TypeMap, Args, 'result'> & AllModelsToStringIndex<TypeMap, Args, 'model'>>;\r\n\r\nexport declare type Metric<T> = {\r\n    key: string;\r\n    value: T;\r\n    labels: Record<string, string>;\r\n    description: string;\r\n};\r\n\r\nexport declare type MetricHistogram = {\r\n    buckets: MetricHistogramBucket[];\r\n    sum: number;\r\n    count: number;\r\n};\r\n\r\nexport declare type MetricHistogramBucket = [maxValue: number, count: number];\r\n\r\nexport declare type Metrics = {\r\n    counters: Metric<number>[];\r\n    gauges: Metric<number>[];\r\n    histograms: Metric<MetricHistogram>[];\r\n};\r\n\r\nexport declare class MetricsClient {\r\n    private _client;\r\n    constructor(client: Client);\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     * Result of this call can be exposed directly to prometheus scraping endpoint\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    prometheus(options?: MetricsOptions): Promise<string>;\r\n    /**\r\n     * Returns all metrics gathered up to this point in prometheus format.\r\n     *\r\n     * @param options\r\n     * @returns\r\n     */\r\n    json(options?: MetricsOptions): Promise<Metrics>;\r\n}\r\n\r\ndeclare type MetricsOptions = {\r\n    /**\r\n     * Labels to add to every metrics in key-value format\r\n     */\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsCommon = {\r\n    globalLabels?: Record<string, string>;\r\n};\r\n\r\ndeclare type MetricsOptionsJson = {\r\n    format: 'json';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MetricsOptionsPrometheus = {\r\n    format: 'prometheus';\r\n} & MetricsOptionsCommon;\r\n\r\ndeclare type MiddlewareArgsMapper<RequestArgs, MiddlewareArgs> = {\r\n    requestArgsToMiddlewareArgs(requestArgs: RequestArgs): MiddlewareArgs;\r\n    middlewareArgsToRequestArgs(middlewareArgs: MiddlewareArgs): RequestArgs;\r\n};\r\n\r\ndeclare class MiddlewareHandler<M extends Function> {\r\n    private _middlewares;\r\n    use(middleware: M): void;\r\n    get(id: number): M | undefined;\r\n    has(id: number): boolean;\r\n    length(): number;\r\n}\r\n\r\ndeclare type Model = ReadonlyDeep_2<{\r\n    name: string;\r\n    dbName: string | null;\r\n    schema: string | null;\r\n    fields: Field[];\r\n    uniqueFields: string[][];\r\n    uniqueIndexes: uniqueIndex[];\r\n    documentation?: string;\r\n    primaryKey: PrimaryKey | null;\r\n    isGenerated?: boolean;\r\n}>;\r\n\r\ndeclare enum ModelAction {\r\n    findUnique = \"findUnique\",\r\n    findUniqueOrThrow = \"findUniqueOrThrow\",\r\n    findFirst = \"findFirst\",\r\n    findFirstOrThrow = \"findFirstOrThrow\",\r\n    findMany = \"findMany\",\r\n    create = \"create\",\r\n    createMany = \"createMany\",\r\n    createManyAndReturn = \"createManyAndReturn\",\r\n    update = \"update\",\r\n    updateMany = \"updateMany\",\r\n    updateManyAndReturn = \"updateManyAndReturn\",\r\n    upsert = \"upsert\",\r\n    delete = \"delete\",\r\n    deleteMany = \"deleteMany\",\r\n    groupBy = \"groupBy\",\r\n    count = \"count\",// TODO: count does not actually exist in DMMF\r\n    aggregate = \"aggregate\",\r\n    findRaw = \"findRaw\",\r\n    aggregateRaw = \"aggregateRaw\"\r\n}\r\n\r\nexport declare type ModelArg = {\r\n    [MethodName in string]: unknown;\r\n};\r\n\r\nexport declare type ModelArgs = {\r\n    model: {\r\n        [ModelName in string]: ModelArg;\r\n    };\r\n};\r\n\r\nexport declare type ModelKey<TypeMap extends TypeMapDef, M extends PropertyKey> = M extends keyof TypeMap['model'] ? M : Capitalize<M & string>;\r\n\r\ndeclare type ModelMapping = ReadonlyDeep_2<{\r\n    model: string;\r\n    plural: string;\r\n    findUnique?: string | null;\r\n    findUniqueOrThrow?: string | null;\r\n    findFirst?: string | null;\r\n    findFirstOrThrow?: string | null;\r\n    findMany?: string | null;\r\n    create?: string | null;\r\n    createMany?: string | null;\r\n    createManyAndReturn?: string | null;\r\n    update?: string | null;\r\n    updateMany?: string | null;\r\n    updateManyAndReturn?: string | null;\r\n    upsert?: string | null;\r\n    delete?: string | null;\r\n    deleteMany?: string | null;\r\n    aggregate?: string | null;\r\n    groupBy?: string | null;\r\n    count?: string | null;\r\n    findRaw?: string | null;\r\n    aggregateRaw?: string | null;\r\n}>;\r\n\r\nexport declare type ModelQueryOptionsCb = (args: ModelQueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type ModelQueryOptionsCbArgs = {\r\n    model: string;\r\n    operation: string;\r\n    args: JsArgs;\r\n    query: (args: JsArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type MultiBatchResponse = {\r\n    type: 'multi';\r\n    plans: object[];\r\n};\r\n\r\nexport declare type NameArgs = {\r\n    name?: string;\r\n};\r\n\r\nexport declare type Narrow<A> = {\r\n    [K in keyof A]: A[K] extends Function ? A[K] : Narrow<A[K]>;\r\n} | (A extends Narrowable ? A : never);\r\n\r\nexport declare type Narrowable = string | number | bigint | boolean | [];\r\n\r\nexport declare type NeverToUnknown<T> = [T] extends [never] ? unknown : T;\r\n\r\ndeclare class NullTypesEnumValue extends ObjectEnumValue {\r\n    _getNamespace(): string;\r\n}\r\n\r\n/**\r\n * Base class for unique values of object-valued enums.\r\n */\r\nexport declare abstract class ObjectEnumValue {\r\n    constructor(arg?: symbol);\r\n    abstract _getNamespace(): string;\r\n    _getName(): string;\r\n    toString(): string;\r\n}\r\n\r\nexport declare const objectEnumValues: {\r\n    classes: {\r\n        DbNull: typeof DbNull;\r\n        JsonNull: typeof JsonNull;\r\n        AnyNull: typeof AnyNull;\r\n    };\r\n    instances: {\r\n        DbNull: DbNull;\r\n        JsonNull: JsonNull;\r\n        AnyNull: AnyNull;\r\n    };\r\n};\r\n\r\ndeclare const officialPrismaAdapters: readonly [\"@prisma/adapter-planetscale\", \"@prisma/adapter-neon\", \"@prisma/adapter-libsql\", \"@prisma/adapter-better-sqlite3\", \"@prisma/adapter-d1\", \"@prisma/adapter-pg\", \"@prisma/adapter-mssql\", \"@prisma/adapter-mariadb\"];\r\n\r\nexport declare type Omission = Record<string, boolean | Skip>;\r\n\r\ndeclare type Omit_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? never : P]: T[P];\r\n};\r\nexport { Omit_2 as Omit }\r\n\r\nexport declare type OmitValue<Omit, Key> = Key extends keyof Omit ? Omit[Key] : false;\r\n\r\nexport declare type Operation = 'findFirst' | 'findFirstOrThrow' | 'findUnique' | 'findUniqueOrThrow' | 'findMany' | 'create' | 'createMany' | 'createManyAndReturn' | 'update' | 'updateMany' | 'updateManyAndReturn' | 'upsert' | 'delete' | 'deleteMany' | 'aggregate' | 'count' | 'groupBy' | '$queryRaw' | '$executeRaw' | '$queryRawUnsafe' | '$executeRawUnsafe' | 'findRaw' | 'aggregateRaw' | '$runCommandRaw';\r\n\r\nexport declare type OperationPayload = {\r\n    name: string;\r\n    scalars: {\r\n        [ScalarName in string]: unknown;\r\n    };\r\n    objects: {\r\n        [ObjectName in string]: unknown;\r\n    };\r\n    composites: {\r\n        [CompositeName in string]: unknown;\r\n    };\r\n};\r\n\r\nexport declare type Optional<O, K extends keyof any = keyof O> = {\r\n    [P in K & keyof O]?: O[P];\r\n} & {\r\n    [P in Exclude<keyof O, K>]: O[P];\r\n};\r\n\r\nexport declare type OptionalFlat<T> = {\r\n    [K in keyof T]?: T[K];\r\n};\r\n\r\nexport declare type OptionalKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? K : never;\r\n}[keyof O];\r\n\r\ndeclare type Options = {\r\n    /** Timeout for starting the transaction */\r\n    maxWait?: number;\r\n    /** Timeout for the transaction body */\r\n    timeout?: number;\r\n    /** Transaction isolation level */\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type Options_2 = {\r\n    clientVersion: string;\r\n};\r\n\r\nexport declare type Or<A extends 1 | 0, B extends 1 | 0> = {\r\n    0: {\r\n        0: 0;\r\n        1: 1;\r\n    };\r\n    1: {\r\n        0: 1;\r\n        1: 1;\r\n    };\r\n}[A][B];\r\n\r\ndeclare type OtherOperationMappings = ReadonlyDeep_2<{\r\n    read: string[];\r\n    write: string[];\r\n}>;\r\n\r\ndeclare type OutputType = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: SchemaField[];\r\n}>;\r\n\r\ndeclare type OutputTypeRef = TypeRef<'scalar' | 'outputObjectTypes' | 'enumTypes'>;\r\n\r\nexport declare function Param<$Type, $Value extends string>(name: $Value): Param<$Type, $Value>;\r\n\r\nexport declare type Param<out $Type, $Value extends string> = {\r\n    readonly name: $Value;\r\n};\r\n\r\nexport declare type PatchFlat<O1, O2> = O1 & Omit_2<O2, keyof O1>;\r\n\r\nexport declare type Path<O, P, Default = never> = O extends unknown ? P extends [infer K, ...infer R] ? K extends keyof O ? Path<O[K], R> : Default : O : never;\r\n\r\nexport declare type Payload<T, F extends Operation = never> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? T[symbol]['types']['payload'] : any;\r\n\r\nexport declare type PayloadToResult<P, O extends Record_2<any, any> = RenameAndNestPayloadKeys<P>> = {\r\n    [K in keyof O]?: O[K][K] extends any[] ? PayloadToResult<O[K][K][number]>[] : O[K][K] extends object ? PayloadToResult<O[K][K]> : O[K][K];\r\n};\r\n\r\ndeclare type Pick_2<T, K extends string | number | symbol> = {\r\n    [P in keyof T as P extends K ? P : never]: T[P];\r\n};\r\nexport { Pick_2 as Pick }\r\n\r\ndeclare type PrimaryKey = ReadonlyDeep_2<{\r\n    name: string | null;\r\n    fields: string[];\r\n}>;\r\n\r\nexport declare class PrismaClientInitializationError extends Error {\r\n    clientVersion: string;\r\n    errorCode?: string;\r\n    retryable?: boolean;\r\n    constructor(message: string, clientVersion: string, errorCode?: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientKnownRequestError extends Error implements ErrorWithBatchIndex {\r\n    code: string;\r\n    meta?: Record<string, unknown>;\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { code, clientVersion, meta, batchRequestIdx }: KnownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare type PrismaClientOptions = {\r\n    /**\r\n     * Overwrites the primary datasource url from your schema.prisma file\r\n     */\r\n    datasourceUrl?: string;\r\n    /**\r\n     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale.\r\n     */\r\n    adapter?: SqlDriverAdapterFactory | null;\r\n    /**\r\n     * Overwrites the datasource url from your schema.prisma file\r\n     */\r\n    datasources?: Datasources;\r\n    /**\r\n     * @default \"colorless\"\r\n     */\r\n    errorFormat?: ErrorFormat;\r\n    /**\r\n     * The default values for Transaction options\r\n     * maxWait ?= 2000\r\n     * timeout ?= 5000\r\n     */\r\n    transactionOptions?: Transaction_2.Options;\r\n    /**\r\n     * @example\r\n     * \\`\\`\\`\r\n     * // Defaults to stdout\r\n     * log: ['query', 'info', 'warn']\r\n     *\r\n     * // Emit as events\r\n     * log: [\r\n     *  { emit: 'stdout', level: 'query' },\r\n     *  { emit: 'stdout', level: 'info' },\r\n     *  { emit: 'stdout', level: 'warn' }\r\n     * ]\r\n     * \\`\\`\\`\r\n     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).\r\n     */\r\n    log?: Array<LogLevel | LogDefinition>;\r\n    omit?: GlobalOmitOptions;\r\n    /**\r\n     * @internal\r\n     * You probably don't want to use this. \\`__internal\\` is used by internal tooling.\r\n     */\r\n    __internal?: {\r\n        debug?: boolean;\r\n        engine?: {\r\n            cwd?: string;\r\n            binaryPath?: string;\r\n            endpoint?: string;\r\n            allowTriggerPanic?: boolean;\r\n        };\r\n        /** This can be used for testing purposes */\r\n        configOverride?: (config: GetPrismaClientConfig) => GetPrismaClientConfig;\r\n    };\r\n};\r\n\r\nexport declare class PrismaClientRustPanicError extends Error {\r\n    clientVersion: string;\r\n    constructor(message: string, clientVersion: string);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientUnknownRequestError extends Error implements ErrorWithBatchIndex {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n    constructor(message: string, { clientVersion, batchRequestIdx }: UnknownErrorParams);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\nexport declare class PrismaClientValidationError extends Error {\r\n    name: string;\r\n    clientVersion: string;\r\n    constructor(message: string, { clientVersion }: Options_2);\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare function prismaGraphQLToJSError({ error, user_facing_error }: RequestError, clientVersion: string, activeProvider: string): PrismaClientKnownRequestError | PrismaClientUnknownRequestError;\r\n\r\ndeclare type PrismaOperationSpec<TArgs, TAction = string> = {\r\n    args: TArgs;\r\n    action: TAction;\r\n    model: string;\r\n};\r\n\r\nexport declare interface PrismaPromise<T> extends Promise<T> {\r\n    [Symbol.toStringTag]: 'PrismaPromise';\r\n}\r\n\r\n/**\r\n * Prisma's `Promise` that is backwards-compatible. All additions on top of the\r\n * original `Promise` are optional so that it can be backwards-compatible.\r\n * @see [[createPrismaPromise]]\r\n */\r\ndeclare interface PrismaPromise_2<TResult, TSpec extends PrismaOperationSpec<unknown> = any> extends Promise<TResult> {\r\n    get spec(): TSpec;\r\n    /**\r\n     * Extension of the original `.then` function\r\n     * @param onfulfilled same as regular promises\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    then<R1 = TResult, R2 = never>(onfulfilled?: (value: TResult) => R1 | PromiseLike<R1>, onrejected?: (error: unknown) => R2 | PromiseLike<R2>, transaction?: PrismaPromiseTransaction): Promise<R1 | R2>;\r\n    /**\r\n     * Extension of the original `.catch` function\r\n     * @param onrejected same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    catch<R = never>(onrejected?: ((reason: any) => R | PromiseLike<R>) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult | R>;\r\n    /**\r\n     * Extension of the original `.finally` function\r\n     * @param onfinally same as regular promises\r\n     * @param transaction transaction options\r\n     */\r\n    finally(onfinally?: (() => void) | undefined | null, transaction?: PrismaPromiseTransaction): Promise<TResult>;\r\n    /**\r\n     * Called when executing a batch of regular tx\r\n     * @param transaction transaction options for batch tx\r\n     */\r\n    requestTransaction?(transaction: PrismaPromiseBatchTransaction): PromiseLike<unknown>;\r\n}\r\n\r\ndeclare type PrismaPromiseBatchTransaction = {\r\n    kind: 'batch';\r\n    id: number;\r\n    isolationLevel?: IsolationLevel_2;\r\n    index: number;\r\n    lock: PromiseLike<void>;\r\n};\r\n\r\ndeclare type PrismaPromiseCallback = (transaction?: PrismaPromiseTransaction) => Promise<unknown>;\r\n\r\n/**\r\n * Creates a [[PrismaPromise]]. It is Prisma's implementation of `Promise` which\r\n * is essentially a proxy for `Promise`. All the transaction-compatible client\r\n * methods return one, this allows for pre-preparing queries without executing\r\n * them until `.then` is called. It's the foundation of Prisma's query batching.\r\n * @param callback that will be wrapped within our promise implementation\r\n * @see [[PrismaPromise]]\r\n * @returns\r\n */\r\ndeclare type PrismaPromiseFactory = <T extends PrismaOperationSpec<unknown>>(callback: PrismaPromiseCallback, op?: T) => PrismaPromise_2<unknown>;\r\n\r\ndeclare type PrismaPromiseInteractiveTransaction<PayloadType = unknown> = {\r\n    kind: 'itx';\r\n    id: string;\r\n    payload: PayloadType;\r\n};\r\n\r\ndeclare type PrismaPromiseTransaction<PayloadType = unknown> = PrismaPromiseBatchTransaction | PrismaPromiseInteractiveTransaction<PayloadType>;\r\n\r\nexport declare const PrivateResultType: unique symbol;\r\n\r\ndeclare type Provider = 'mysql' | 'postgres' | 'sqlite' | 'sqlserver';\r\n\r\ndeclare namespace Public {\r\n    export {\r\n        validator\r\n    }\r\n}\r\nexport { Public }\r\n\r\ndeclare namespace Public_2 {\r\n    export {\r\n        Args,\r\n        Result,\r\n        Payload,\r\n        PrismaPromise,\r\n        Operation,\r\n        Exact\r\n    }\r\n}\r\n\r\ndeclare type Query = ReadonlyDeep_2<{\r\n    name: string;\r\n    args: SchemaArg[];\r\n    output: QueryOutput;\r\n}>;\r\n\r\ndeclare interface Queryable<Query, Result> extends AdapterInfo {\r\n    /**\r\n     * Execute a query and return its result.\r\n     */\r\n    queryRaw(params: Query): Promise<Result>;\r\n    /**\r\n     * Execute a query and return the number of affected rows.\r\n     */\r\n    executeRaw(params: Query): Promise<number>;\r\n}\r\n\r\ndeclare type QueryCompiler = {\r\n    compile(request: string): {};\r\n    compileBatch(batchRequest: string): BatchResponse;\r\n    free(): void;\r\n};\r\n\r\ndeclare interface QueryCompilerConstructor {\r\n    new (options: QueryCompilerOptions): QueryCompiler;\r\n}\r\n\r\ndeclare type QueryCompilerOptions = {\r\n    datamodel: string;\r\n    provider: Provider;\r\n    connectionInfo: ConnectionInfo;\r\n};\r\n\r\ndeclare type QueryEngineBatchGraphQLRequest = {\r\n    batch: QueryEngineRequest[];\r\n    transaction?: boolean;\r\n    isolationLevel?: IsolationLevel_2;\r\n};\r\n\r\ndeclare type QueryEngineBatchRequest = QueryEngineBatchGraphQLRequest | JsonBatchQuery;\r\n\r\ndeclare type QueryEngineConfig = {\r\n    datamodel: string;\r\n    configDir: string;\r\n    logQueries: boolean;\r\n    ignoreEnvVarErrors: boolean;\r\n    datasourceOverrides: Record<string, string>;\r\n    env: Record<string, string | undefined>;\r\n    logLevel: QueryEngineLogLevel;\r\n    engineProtocol: QueryEngineProtocol;\r\n    enableTracing: boolean;\r\n};\r\n\r\ndeclare interface QueryEngineConstructor {\r\n    new (config: QueryEngineConfig, logger: (log: string) => void, adapter?: ErrorCapturingSqlDriverAdapter): QueryEngineInstance;\r\n}\r\n\r\ndeclare type QueryEngineInstance = {\r\n    connect(headers: string, requestId: string): Promise<void>;\r\n    disconnect(headers: string, requestId: string): Promise<void>;\r\n    /**\r\n     * Frees any resources allocated by the engine's WASM instance. This method is automatically created by WASM bindgen.\r\n     * Noop for other engines.\r\n     */\r\n    free?(): void;\r\n    /**\r\n     * @param requestStr JSON.stringified `QueryEngineRequest | QueryEngineBatchRequest`\r\n     * @param headersStr JSON.stringified `QueryEngineRequestHeaders`\r\n     */\r\n    query(requestStr: string, headersStr: string, transactionId: string | undefined, requestId: string): Promise<string>;\r\n    sdlSchema?(): Promise<string>;\r\n    startTransaction(options: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    commitTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    rollbackTransaction(id: string, traceHeaders: string, requestId: string): Promise<string>;\r\n    metrics?(options: string): Promise<string>;\r\n    applyPendingMigrations?(): Promise<void>;\r\n    trace(requestId: string): Promise<string | null>;\r\n};\r\n\r\ndeclare type QueryEngineLogLevel = 'trace' | 'debug' | 'info' | 'warn' | 'error' | 'off';\r\n\r\ndeclare type QueryEngineProtocol = 'graphql' | 'json';\r\n\r\ndeclare type QueryEngineRequest = {\r\n    query: string;\r\n    variables: object;\r\n};\r\n\r\ndeclare type QueryEngineResultData<T> = {\r\n    data: T;\r\n};\r\n\r\ndeclare type QueryEvent = {\r\n    timestamp: Date;\r\n    query: string;\r\n    params: string;\r\n    duration: number;\r\n    target: string;\r\n};\r\n\r\ndeclare type QueryEventType = 'query';\r\n\r\ndeclare type QueryIntrospectionBuiltinType = 'int' | 'bigint' | 'float' | 'double' | 'string' | 'enum' | 'bytes' | 'bool' | 'char' | 'decimal' | 'json' | 'xml' | 'uuid' | 'datetime' | 'date' | 'time' | 'int-array' | 'bigint-array' | 'float-array' | 'double-array' | 'string-array' | 'char-array' | 'bytes-array' | 'bool-array' | 'decimal-array' | 'json-array' | 'xml-array' | 'uuid-array' | 'datetime-array' | 'date-array' | 'time-array' | 'null' | 'unknown';\r\n\r\ndeclare type QueryMiddleware = (params: QueryMiddlewareParams, next: (params: QueryMiddlewareParams) => Promise<unknown>) => Promise<unknown>;\r\n\r\ndeclare type QueryMiddlewareParams = {\r\n    /** The model this is executed on */\r\n    model?: string;\r\n    /** The action that is being handled */\r\n    action: Action;\r\n    /** TODO what is this */\r\n    dataPath: string[];\r\n    /** TODO what is this */\r\n    runInTransaction: boolean;\r\n    args?: UserArgs_2;\r\n};\r\n\r\nexport declare type QueryOptions = {\r\n    query: {\r\n        [ModelName in string]: {\r\n            [ModelAction in string]: ModelQueryOptionsCb;\r\n        } | QueryOptionsCb;\r\n    };\r\n};\r\n\r\nexport declare type QueryOptionsCb = (args: QueryOptionsCbArgs) => Promise<any>;\r\n\r\nexport declare type QueryOptionsCbArgs = {\r\n    model?: string;\r\n    operation: string;\r\n    args: JsArgs | RawQueryArgs;\r\n    query: (args: JsArgs | RawQueryArgs) => Promise<unknown>;\r\n};\r\n\r\ndeclare type QueryOutput = ReadonlyDeep_2<{\r\n    name: string;\r\n    isRequired: boolean;\r\n    isList: boolean;\r\n}>;\r\n\r\n/**\r\n * Create raw SQL statement.\r\n */\r\nexport declare function raw(value: string): Sql;\r\n\r\nexport declare type RawParameters = {\r\n    __prismaRawParameters__: true;\r\n    values: string;\r\n};\r\n\r\nexport declare type RawQueryArgs = Sql | UnknownTypedSql | [query: string, ...values: RawValue[]];\r\n\r\ndeclare type RawResponse = {\r\n    columns: string[];\r\n    types: QueryIntrospectionBuiltinType[];\r\n    rows: unknown[][];\r\n};\r\n\r\ndeclare type RawTaggedValue = {\r\n    $type: 'Raw';\r\n    value: unknown;\r\n};\r\n\r\n/**\r\n * Supported value or SQL instance.\r\n */\r\nexport declare type RawValue = Value | Sql;\r\n\r\nexport declare type ReadonlyDeep<T> = {\r\n    readonly [K in keyof T]: ReadonlyDeep<T[K]>;\r\n};\r\n\r\ndeclare type ReadonlyDeep_2<O> = {\r\n    +readonly [K in keyof O]: ReadonlyDeep_2<O[K]>;\r\n};\r\n\r\ndeclare type Record_2<T extends string | number | symbol, U> = {\r\n    [P in T]: U;\r\n};\r\nexport { Record_2 as Record }\r\n\r\nexport declare type RenameAndNestPayloadKeys<P> = {\r\n    [K in keyof P as K extends 'scalars' | 'objects' | 'composites' ? keyof P[K] : never]: P[K];\r\n};\r\n\r\ndeclare type RequestBatchOptions<InteractiveTransactionPayload> = {\r\n    transaction?: TransactionOptions_2<InteractiveTransactionPayload>;\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    containsWrite: boolean;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare interface RequestError {\r\n    error: string;\r\n    user_facing_error: {\r\n        is_panic: boolean;\r\n        message: string;\r\n        meta?: Record<string, unknown>;\r\n        error_code?: string;\r\n        batch_request_idx?: number;\r\n    };\r\n}\r\n\r\ndeclare class RequestHandler {\r\n    client: Client;\r\n    dataloader: DataLoader<RequestParams>;\r\n    private logEmitter?;\r\n    constructor(client: Client, logEmitter?: LogEmitter);\r\n    request(params: RequestParams): Promise<any>;\r\n    mapQueryEngineResult({ dataPath, unpacker }: RequestParams, response: QueryEngineResultData<any>): any;\r\n    /**\r\n     * Handles the error and logs it, logging the error is done synchronously waiting for the event\r\n     * handlers to finish.\r\n     */\r\n    handleAndLogRequestError(params: HandleErrorParams): never;\r\n    handleRequestError({ error, clientMethod, callsite, transaction, args, modelName, globalOmit, }: HandleErrorParams): never;\r\n    sanitizeMessage(message: any): any;\r\n    unpack(data: unknown, dataPath: string[], unpacker?: Unpacker): any;\r\n    get [Symbol.toStringTag](): string;\r\n}\r\n\r\ndeclare type RequestOptions<InteractiveTransactionPayload> = {\r\n    traceparent?: string;\r\n    numTry?: number;\r\n    interactiveTransaction?: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n    isWrite: boolean;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type RequestParams = {\r\n    modelName?: string;\r\n    action: Action;\r\n    protocolQuery: JsonQuery;\r\n    dataPath: string[];\r\n    clientMethod: string;\r\n    callsite?: CallSite;\r\n    transaction?: PrismaPromiseTransaction;\r\n    extensions: MergedExtensionsList;\r\n    args?: any;\r\n    headers?: Record<string, string>;\r\n    unpacker?: Unpacker;\r\n    otelParentCtx?: Context;\r\n    otelChildCtx?: Context;\r\n    globalOmit?: GlobalOmitOptions;\r\n    customDataProxyFetch?: CustomDataProxyFetch;\r\n};\r\n\r\ndeclare type RequiredExtensionArgs = NameArgs & ResultArgs & ModelArgs & ClientArgs & QueryOptions;\r\nexport { RequiredExtensionArgs }\r\nexport { RequiredExtensionArgs as UserArgs }\r\n\r\nexport declare type RequiredKeys<O> = {\r\n    [K in keyof O]-?: {} extends Pick_2<O, K> ? never : K;\r\n}[keyof O];\r\n\r\ndeclare function resolveDatasourceUrl({ inlineDatasources, overrideDatasources, env, clientVersion, }: {\r\n    inlineDatasources: GetPrismaClientConfig['inlineDatasources'];\r\n    overrideDatasources: Datasources;\r\n    env: Record<string, string | undefined>;\r\n    clientVersion: string;\r\n}): string;\r\n\r\nexport declare type Result<T, A, F extends Operation> = T extends {\r\n    [K: symbol]: {\r\n        types: {\r\n            payload: any;\r\n        };\r\n    };\r\n} ? GetResult<T[symbol]['types']['payload'], A, F> : GetResult<{\r\n    composites: {};\r\n    objects: {};\r\n    scalars: {};\r\n    name: '';\r\n}, {}, F>;\r\n\r\nexport declare type Result_2<T, A, F extends Operation> = Result<T, A, F>;\r\n\r\ndeclare namespace Result_3 {\r\n    export {\r\n        Count,\r\n        GetFindResult,\r\n        SelectablePayloadFields,\r\n        SelectField,\r\n        DefaultSelection,\r\n        UnwrapPayload,\r\n        ApplyOmit,\r\n        OmitValue,\r\n        GetCountResult,\r\n        Aggregate,\r\n        GetAggregateResult,\r\n        GetBatchResult,\r\n        GetGroupByResult,\r\n        GetResult,\r\n        ExtractGlobalOmit\r\n    }\r\n}\r\n\r\ndeclare type Result_4<T> = {\r\n    map<U>(fn: (value: T) => U): Result_4<U>;\r\n    flatMap<U>(fn: (value: T) => Result_4<U>): Result_4<U>;\r\n} & ({\r\n    readonly ok: true;\r\n    readonly value: T;\r\n} | {\r\n    readonly ok: false;\r\n    readonly error: Error_2;\r\n});\r\n\r\nexport declare type ResultArg = {\r\n    [FieldName in string]: ResultFieldDefinition;\r\n};\r\n\r\nexport declare type ResultArgs = {\r\n    result: {\r\n        [ModelName in string]: ResultArg;\r\n    };\r\n};\r\n\r\nexport declare type ResultArgsFieldCompute = (model: any) => unknown;\r\n\r\nexport declare type ResultFieldDefinition = {\r\n    needs?: {\r\n        [FieldName in string]: boolean;\r\n    };\r\n    compute: ResultArgsFieldCompute;\r\n};\r\n\r\nexport declare type Return<T> = T extends (...args: any[]) => infer R ? R : T;\r\n\r\nexport declare type RuntimeDataModel = {\r\n    readonly models: Record<string, RuntimeModel>;\r\n    readonly enums: Record<string, RuntimeEnum>;\r\n    readonly types: Record<string, RuntimeModel>;\r\n};\r\n\r\ndeclare type RuntimeEnum = Omit<DMMF_2.DatamodelEnum, 'name'>;\r\n\r\ndeclare type RuntimeModel = Omit<DMMF_2.Model, 'name'>;\r\n\r\ndeclare type RuntimeName = 'workerd' | 'deno' | 'netlify' | 'node' | 'bun' | 'edge-light' | '';\r\n\r\ndeclare type Schema = ReadonlyDeep_2<{\r\n    rootQueryType?: string;\r\n    rootMutationType?: string;\r\n    inputObjectTypes: {\r\n        model?: InputType[];\r\n        prisma: InputType[];\r\n    };\r\n    outputObjectTypes: {\r\n        model: OutputType[];\r\n        prisma: OutputType[];\r\n    };\r\n    enumTypes: {\r\n        model?: SchemaEnum[];\r\n        prisma: SchemaEnum[];\r\n    };\r\n    fieldRefTypes: {\r\n        prisma?: FieldRefType[];\r\n    };\r\n}>;\r\n\r\ndeclare type SchemaArg = ReadonlyDeep_2<{\r\n    name: string;\r\n    comment?: string;\r\n    isNullable: boolean;\r\n    isRequired: boolean;\r\n    inputTypes: InputTypeRef[];\r\n    deprecation?: Deprecation;\r\n}>;\r\n\r\ndeclare type SchemaEnum = ReadonlyDeep_2<{\r\n    name: string;\r\n    values: string[];\r\n}>;\r\n\r\ndeclare type SchemaField = ReadonlyDeep_2<{\r\n    name: string;\r\n    isNullable?: boolean;\r\n    outputType: OutputTypeRef;\r\n    args: SchemaArg[];\r\n    deprecation?: Deprecation;\r\n    documentation?: string;\r\n}>;\r\n\r\nexport declare type Select<T, U> = T extends U ? T : never;\r\n\r\nexport declare type SelectablePayloadFields<K extends PropertyKey, O> = {\r\n    objects: {\r\n        [k in K]: O;\r\n    };\r\n} | {\r\n    composites: {\r\n        [k in K]: O;\r\n    };\r\n};\r\n\r\nexport declare type SelectField<P extends SelectablePayloadFields<any, any>, K extends PropertyKey> = P extends {\r\n    objects: Record<K, any>;\r\n} ? P['objects'][K] : P extends {\r\n    composites: Record<K, any>;\r\n} ? P['composites'][K] : never;\r\n\r\ndeclare type Selection_2 = Record<string, boolean | Skip | JsArgs>;\r\nexport { Selection_2 as Selection }\r\n\r\nexport declare function serializeJsonQuery({ modelName, action, args, runtimeDataModel, extensions, callsite, clientMethod, errorFormat, clientVersion, previewFeatures, globalOmit, }: SerializeParams): JsonQuery;\r\n\r\ndeclare type SerializeParams = {\r\n    runtimeDataModel: RuntimeDataModel;\r\n    modelName?: string;\r\n    action: Action;\r\n    args?: JsArgs;\r\n    extensions?: MergedExtensionsList;\r\n    callsite?: CallSite;\r\n    clientMethod: string;\r\n    clientVersion: string;\r\n    errorFormat: ErrorFormat;\r\n    previewFeatures: string[];\r\n    globalOmit?: GlobalOmitOptions;\r\n};\r\n\r\ndeclare class Skip {\r\n    constructor(param?: symbol);\r\n    ifUndefined<T>(value: T | undefined): T | Skip;\r\n}\r\n\r\nexport declare const skip: Skip;\r\n\r\ndeclare type SortOrder = 'asc' | 'desc';\r\n\r\n/**\r\n * An interface that represents a span. A span represents a single operation\r\n * within a trace. Examples of span might include remote procedure calls or a\r\n * in-process function calls to sub-components. A Trace has a single, top-level\r\n * \"root\" Span that in turn may have zero or more child Spans, which in turn\r\n * may have children.\r\n *\r\n * Spans are created by the {@link Tracer.startSpan} method.\r\n */\r\ndeclare interface Span {\r\n    /**\r\n     * Returns the {@link SpanContext} object associated with this Span.\r\n     *\r\n     * Get an immutable, serializable identifier for this span that can be used\r\n     * to create new child spans. Returned SpanContext is usable even after the\r\n     * span ends.\r\n     *\r\n     * @returns the SpanContext object associated with this Span.\r\n     */\r\n    spanContext(): SpanContext;\r\n    /**\r\n     * Sets an attribute to the span.\r\n     *\r\n     * Sets a single Attribute with the key and value passed as arguments.\r\n     *\r\n     * @param key the key for this attribute.\r\n     * @param value the value for this attribute. Setting a value null or\r\n     *              undefined is invalid and will result in undefined behavior.\r\n     */\r\n    setAttribute(key: string, value: SpanAttributeValue): this;\r\n    /**\r\n     * Sets attributes to the span.\r\n     *\r\n     * @param attributes the attributes that will be added.\r\n     *                   null or undefined attribute values\r\n     *                   are invalid and will result in undefined behavior.\r\n     */\r\n    setAttributes(attributes: SpanAttributes): this;\r\n    /**\r\n     * Adds an event to the Span.\r\n     *\r\n     * @param name the name of the event.\r\n     * @param [attributesOrStartTime] the attributes that will be added; these are\r\n     *     associated with this event. Can be also a start time\r\n     *     if type is {@type TimeInput} and 3rd param is undefined\r\n     * @param [startTime] start time of the event.\r\n     */\r\n    addEvent(name: string, attributesOrStartTime?: SpanAttributes | TimeInput, startTime?: TimeInput): this;\r\n    /**\r\n     * Adds a single link to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param link the link to add.\r\n     */\r\n    addLink(link: Link): this;\r\n    /**\r\n     * Adds multiple links to the span.\r\n     *\r\n     * Links added after the creation will not affect the sampling decision.\r\n     * It is preferred span links be added at span creation.\r\n     *\r\n     * @param links the links to add.\r\n     */\r\n    addLinks(links: Link[]): this;\r\n    /**\r\n     * Sets a status to the span. If used, this will override the default Span\r\n     * status. Default is {@link SpanStatusCode.UNSET}. SetStatus overrides the value\r\n     * of previous calls to SetStatus on the Span.\r\n     *\r\n     * @param status the SpanStatus to set.\r\n     */\r\n    setStatus(status: SpanStatus): this;\r\n    /**\r\n     * Updates the Span name.\r\n     *\r\n     * This will override the name provided via {@link Tracer.startSpan}.\r\n     *\r\n     * Upon this update, any sampling behavior based on Span name will depend on\r\n     * the implementation.\r\n     *\r\n     * @param name the Span name.\r\n     */\r\n    updateName(name: string): this;\r\n    /**\r\n     * Marks the end of Span execution.\r\n     *\r\n     * Call to End of a Span MUST not have any effects on child spans. Those may\r\n     * still be running and can be ended later.\r\n     *\r\n     * Do not return `this`. The Span generally should not be used after it\r\n     * is ended so chaining is not desired in this context.\r\n     *\r\n     * @param [endTime] the time to set as Span's end time. If not provided,\r\n     *     use the current time as the span's end time.\r\n     */\r\n    end(endTime?: TimeInput): void;\r\n    /**\r\n     * Returns the flag whether this span will be recorded.\r\n     *\r\n     * @returns true if this Span is active and recording information like events\r\n     *     with the `AddEvent` operation and attributes using `setAttributes`.\r\n     */\r\n    isRecording(): boolean;\r\n    /**\r\n     * Sets exception as a span event\r\n     * @param exception the exception the only accepted values are string or Error\r\n     * @param [time] the time to set as Span's event time. If not provided,\r\n     *     use the current time.\r\n     */\r\n    recordException(exception: Exception, time?: TimeInput): void;\r\n}\r\n\r\n/**\r\n * @deprecated please use {@link Attributes}\r\n */\r\ndeclare type SpanAttributes = Attributes;\r\n\r\n/**\r\n * @deprecated please use {@link AttributeValue}\r\n */\r\ndeclare type SpanAttributeValue = AttributeValue;\r\n\r\ndeclare type SpanCallback<R> = (span?: Span, context?: Context) => R;\r\n\r\n/**\r\n * A SpanContext represents the portion of a {@link Span} which must be\r\n * serialized and propagated along side of a {@link Baggage}.\r\n */\r\ndeclare interface SpanContext {\r\n    /**\r\n     * The ID of the trace that this span belongs to. It is worldwide unique\r\n     * with practically sufficient probability by being made as 16 randomly\r\n     * generated bytes, encoded as a 32 lowercase hex characters corresponding to\r\n     * 128 bits.\r\n     */\r\n    traceId: string;\r\n    /**\r\n     * The ID of the Span. It is globally unique with practically sufficient\r\n     * probability by being made as 8 randomly generated bytes, encoded as a 16\r\n     * lowercase hex characters corresponding to 64 bits.\r\n     */\r\n    spanId: string;\r\n    /**\r\n     * Only true if the SpanContext was propagated from a remote parent.\r\n     */\r\n    isRemote?: boolean;\r\n    /**\r\n     * Trace flags to propagate.\r\n     *\r\n     * It is represented as 1 byte (bitmap). Bit to represent whether trace is\r\n     * sampled or not. When set, the least significant bit documents that the\r\n     * caller may have recorded trace data. A caller who does not record trace\r\n     * data out-of-band leaves this flag unset.\r\n     *\r\n     * see {@link TraceFlags} for valid flag values.\r\n     */\r\n    traceFlags: number;\r\n    /**\r\n     * Tracing-system-specific info to propagate.\r\n     *\r\n     * The tracestate field value is a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     * More Info: https://www.w3.org/TR/trace-context/#tracestate-field\r\n     *\r\n     * Examples:\r\n     *     Single tracing system (generic format):\r\n     *         tracestate: rojo=00f067aa0ba902b7\r\n     *     Multiple tracing systems (with different formatting):\r\n     *         tracestate: rojo=00f067aa0ba902b7,congo=t61rcWkgMzE\r\n     */\r\n    traceState?: TraceState;\r\n}\r\n\r\ndeclare enum SpanKind {\r\n    /** Default value. Indicates that the span is used internally. */\r\n    INTERNAL = 0,\r\n    /**\r\n     * Indicates that the span covers server-side handling of an RPC or other\r\n     * remote request.\r\n     */\r\n    SERVER = 1,\r\n    /**\r\n     * Indicates that the span covers the client-side wrapper around an RPC or\r\n     * other remote request.\r\n     */\r\n    CLIENT = 2,\r\n    /**\r\n     * Indicates that the span describes producer sending a message to a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    PRODUCER = 3,\r\n    /**\r\n     * Indicates that the span describes consumer receiving a message from a\r\n     * broker. Unlike client and server, there is no direct critical path latency\r\n     * relationship between producer and consumer spans.\r\n     */\r\n    CONSUMER = 4\r\n}\r\n\r\n/**\r\n * Options needed for span creation\r\n */\r\ndeclare interface SpanOptions {\r\n    /**\r\n     * The SpanKind of a span\r\n     * @default {@link SpanKind.INTERNAL}\r\n     */\r\n    kind?: SpanKind;\r\n    /** A span's attributes */\r\n    attributes?: SpanAttributes;\r\n    /** {@link Link}s span to other spans */\r\n    links?: Link[];\r\n    /** A manually specified start time for the created `Span` object. */\r\n    startTime?: TimeInput;\r\n    /** The new span should be a root span. (Ignore parent from context). */\r\n    root?: boolean;\r\n}\r\n\r\ndeclare interface SpanStatus {\r\n    /** The status code of this message. */\r\n    code: SpanStatusCode;\r\n    /** A developer-facing error message. */\r\n    message?: string;\r\n}\r\n\r\n/**\r\n * An enumeration of status codes.\r\n */\r\ndeclare enum SpanStatusCode {\r\n    /**\r\n     * The default status.\r\n     */\r\n    UNSET = 0,\r\n    /**\r\n     * The operation has been validated by an Application developer or\r\n     * Operator to have completed successfully.\r\n     */\r\n    OK = 1,\r\n    /**\r\n     * The operation contains an error.\r\n     */\r\n    ERROR = 2\r\n}\r\n\r\n/**\r\n * A SQL instance can be nested within each other to build SQL strings.\r\n */\r\nexport declare class Sql {\r\n    readonly values: Value[];\r\n    readonly strings: string[];\r\n    constructor(rawStrings: readonly string[], rawValues: readonly RawValue[]);\r\n    get sql(): string;\r\n    get statement(): string;\r\n    get text(): string;\r\n    inspect(): {\r\n        sql: string;\r\n        statement: string;\r\n        text: string;\r\n        values: unknown[];\r\n    };\r\n}\r\n\r\ndeclare interface SqlDriverAdapter extends SqlQueryable {\r\n    /**\r\n     * Execute multiple SQL statements separated by semicolon.\r\n     */\r\n    executeScript(script: string): Promise<void>;\r\n    /**\r\n     * Start new transaction.\r\n     */\r\n    startTransaction(isolationLevel?: IsolationLevel): Promise<Transaction>;\r\n    /**\r\n     * Optional method that returns extra connection info\r\n     */\r\n    getConnectionInfo?(): ConnectionInfo;\r\n    /**\r\n     * Dispose of the connection and release any resources.\r\n     */\r\n    dispose(): Promise<void>;\r\n}\r\n\r\nexport declare interface SqlDriverAdapterFactory extends DriverAdapterFactory<SqlQuery, SqlResultSet> {\r\n    connect(): Promise<SqlDriverAdapter>;\r\n}\r\n\r\ndeclare type SqlQuery = {\r\n    sql: string;\r\n    args: Array<unknown>;\r\n    argTypes: Array<ArgType>;\r\n};\r\n\r\ndeclare interface SqlQueryable extends Queryable<SqlQuery, SqlResultSet> {\r\n}\r\n\r\ndeclare interface SqlResultSet {\r\n    /**\r\n     * List of column types appearing in a database query, in the same order as `columnNames`.\r\n     * They are used within the Query Engine to convert values from JS to Quaint values.\r\n     */\r\n    columnTypes: Array<ColumnType>;\r\n    /**\r\n     * List of column names appearing in a database query, in the same order as `columnTypes`.\r\n     */\r\n    columnNames: Array<string>;\r\n    /**\r\n     * List of rows retrieved from a database query.\r\n     * Each row is a list of values, whose length matches `columnNames` and `columnTypes`.\r\n     */\r\n    rows: Array<Array<unknown>>;\r\n    /**\r\n     * The last ID of an `INSERT` statement, if any.\r\n     * This is required for `AUTO_INCREMENT` columns in databases based on MySQL and SQLite.\r\n     */\r\n    lastInsertId?: string;\r\n}\r\n\r\n/**\r\n * Create a SQL object from a template string.\r\n */\r\nexport declare function sqltag(strings: readonly string[], ...values: readonly RawValue[]): Sql;\r\n\r\n/**\r\n * Defines TimeInput.\r\n *\r\n * hrtime, epoch milliseconds, performance.now() or Date\r\n */\r\ndeclare type TimeInput = HrTime_2 | number | Date;\r\n\r\nexport declare type ToTuple<T> = T extends any[] ? T : [T];\r\n\r\ndeclare interface TraceState {\r\n    /**\r\n     * Create a new TraceState which inherits from this TraceState and has the\r\n     * given key set.\r\n     * The new entry will always be added in the front of the list of states.\r\n     *\r\n     * @param key key of the TraceState entry.\r\n     * @param value value of the TraceState entry.\r\n     */\r\n    set(key: string, value: string): TraceState;\r\n    /**\r\n     * Return a new TraceState which inherits from this TraceState but does not\r\n     * contain the given key.\r\n     *\r\n     * @param key the key for the TraceState entry to be removed.\r\n     */\r\n    unset(key: string): TraceState;\r\n    /**\r\n     * Returns the value to which the specified key is mapped, or `undefined` if\r\n     * this map contains no mapping for the key.\r\n     *\r\n     * @param key with which the specified value is to be associated.\r\n     * @returns the value to which the specified key is mapped, or `undefined` if\r\n     *     this map contains no mapping for the key.\r\n     */\r\n    get(key: string): string | undefined;\r\n    /**\r\n     * Serializes the TraceState to a `list` as defined below. The `list` is a\r\n     * series of `list-members` separated by commas `,`, and a list-member is a\r\n     * key/value pair separated by an equals sign `=`. Spaces and horizontal tabs\r\n     * surrounding `list-members` are ignored. There can be a maximum of 32\r\n     * `list-members` in a `list`.\r\n     *\r\n     * @returns the serialized string.\r\n     */\r\n    serialize(): string;\r\n}\r\n\r\ndeclare interface TracingHelper {\r\n    isEnabled(): boolean;\r\n    getTraceParent(context?: Context): string;\r\n    dispatchEngineSpans(spans: EngineSpan[]): void;\r\n    getActiveContext(): Context | undefined;\r\n    runInChildSpan<R>(nameOrOptions: string | ExtendedSpanOptions, callback: SpanCallback<R>): R;\r\n}\r\n\r\ndeclare interface Transaction extends AdapterInfo, SqlQueryable {\r\n    /**\r\n     * Transaction options.\r\n     */\r\n    readonly options: TransactionOptions;\r\n    /**\r\n     * Commit the transaction.\r\n     */\r\n    commit(): Promise<void>;\r\n    /**\r\n     * Roll back the transaction.\r\n     */\r\n    rollback(): Promise<void>;\r\n}\r\n\r\ndeclare namespace Transaction_2 {\r\n    export {\r\n        Options,\r\n        IsolationLevel_2 as IsolationLevel,\r\n        InteractiveTransactionInfo,\r\n        TransactionHeaders\r\n    }\r\n}\r\n\r\ndeclare type TransactionHeaders = {\r\n    traceparent?: string;\r\n};\r\n\r\ndeclare type TransactionOptions = {\r\n    usePhantomQuery: boolean;\r\n};\r\n\r\ndeclare type TransactionOptions_2<InteractiveTransactionPayload> = {\r\n    kind: 'itx';\r\n    options: InteractiveTransactionOptions<InteractiveTransactionPayload>;\r\n} | {\r\n    kind: 'batch';\r\n    options: BatchTransactionOptions;\r\n};\r\n\r\nexport declare class TypedSql<Values extends readonly unknown[], Result> {\r\n    [PrivateResultType]: Result;\r\n    constructor(sql: string, values: Values);\r\n    get sql(): string;\r\n    get values(): Values;\r\n}\r\n\r\nexport declare type TypeMapCbDef = Fn<{\r\n    extArgs: InternalArgs;\r\n}, TypeMapDef>;\r\n\r\n/** Shared */\r\nexport declare type TypeMapDef = Record<any, any>;\r\n\r\ndeclare type TypeRef<AllowedLocations extends FieldLocation> = {\r\n    isList: boolean;\r\n    type: string;\r\n    location: AllowedLocations;\r\n    namespace?: FieldNamespace;\r\n};\r\n\r\ndeclare namespace Types {\r\n    export {\r\n        Result_3 as Result,\r\n        Extensions_2 as Extensions,\r\n        Utils,\r\n        Public_2 as Public,\r\n        isSkip,\r\n        Skip,\r\n        skip,\r\n        UnknownTypedSql,\r\n        OperationPayload as Payload\r\n    }\r\n}\r\nexport { Types }\r\n\r\ndeclare type uniqueIndex = ReadonlyDeep_2<{\r\n    name: string;\r\n    fields: string[];\r\n}>;\r\n\r\ndeclare type UnknownErrorParams = {\r\n    clientVersion: string;\r\n    batchRequestIdx?: number;\r\n};\r\n\r\nexport declare type UnknownTypedSql = TypedSql<unknown[], unknown>;\r\n\r\ndeclare type Unpacker = (data: any) => any;\r\n\r\nexport declare type UnwrapPayload<P> = {} extends P ? unknown : {\r\n    [K in keyof P]: P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    }[] ? Array<S & UnwrapPayload<C>> : P[K] extends {\r\n        scalars: infer S;\r\n        composites: infer C;\r\n    } | null ? S & UnwrapPayload<C> | Select<P[K], null> : never;\r\n};\r\n\r\nexport declare type UnwrapPromise<P> = P extends Promise<infer R> ? R : P;\r\n\r\nexport declare type UnwrapTuple<Tuple extends readonly unknown[]> = {\r\n    [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>;\r\n};\r\n\r\n/**\r\n * Input that flows from the user into the Client.\r\n */\r\ndeclare type UserArgs_2 = any;\r\n\r\ndeclare namespace Utils {\r\n    export {\r\n        EmptyToUnknown,\r\n        NeverToUnknown,\r\n        PatchFlat,\r\n        Omit_2 as Omit,\r\n        Pick_2 as Pick,\r\n        ComputeDeep,\r\n        Compute,\r\n        OptionalFlat,\r\n        ReadonlyDeep,\r\n        Narrowable,\r\n        Narrow,\r\n        Exact,\r\n        Cast,\r\n        Record_2 as Record,\r\n        UnwrapPromise,\r\n        UnwrapTuple,\r\n        Path,\r\n        Fn,\r\n        Call,\r\n        RequiredKeys,\r\n        OptionalKeys,\r\n        Optional,\r\n        Return,\r\n        ToTuple,\r\n        RenameAndNestPayloadKeys,\r\n        PayloadToResult,\r\n        Select,\r\n        Equals,\r\n        Or,\r\n        JsPromise\r\n    }\r\n}\r\n\r\ndeclare function validator<V>(): <S>(select: Exact<S, V>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation>(client: C, model: M, operation: O): <S>(select: Exact<S, Args<C[M], O>>) => S;\r\n\r\ndeclare function validator<C, M extends Exclude<keyof C, `$${string}`>, O extends keyof C[M] & Operation, P extends keyof Args<C[M], O>>(client: C, model: M, operation: O, prop: P): <S>(select: Exact<S, Args<C[M], O>[P]>) => S;\r\n\r\n/**\r\n * Values supported by SQL engine.\r\n */\r\nexport declare type Value = unknown;\r\n\r\nexport declare function warnEnvConflicts(envPaths: any): void;\r\n\r\nexport declare const warnOnce: (key: string, message: string, ...args: unknown[]) => void;\r\n\r\nexport { }\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\library.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\react-native.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\wasm-compiler-edge.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\runtime\\wasm-engine-edge.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\wasm.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\generated\\prisma\\wasm.js","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\__tests__\\useGoogleCalendar.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\__tests__\\voiceCalendarIntegration.test.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\tests\\useAIChat.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\tests\\useSilenceTriggers.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useAIChat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useAlarmTimerScheduler.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.","line":64,"column":6,"nodeType":"ArrayExpression","endLine":64,"endColumn":57,"suggestions":[{"desc":"Update the dependencies array to be: [alarms, timers, sendNotification, permissionState, setState]","fix":{"range":[2377,2428],"text":"[alarms, timers, sendNotification, permissionState, setState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect } from 'react';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport { useNotifications } from './useNotifications';\n\nexport default function useAlarmTimerScheduler() {\n  const alarms = useVisionAudioStore(s => s.alarms);\n  const timers = useVisionAudioStore(s => s.timers);\n  const setState = useVisionAudioStore(s => s.setState);\n  const { sendNotification, permissionState } = useNotifications();\n\n  useEffect(() => {\n    const id = setInterval(() => {\n      const now = Date.now();\n      let triggered = false;\n\n      const newAlarms = alarms.map((a) =>\n        !a.triggered && a.time <= now ? { ...a, triggered: true } : a\n      );\n      const newTimers = timers.map((t) =>\n        !t.triggered && t.finish <= now ? { ...t, triggered: true } : t\n      );\n\n      if (newAlarms.some((a) => a.triggered && !alarms.find((o) => o.id === a.id)?.triggered)) {\n        triggered = true;\n      }\n      if (newTimers.some((t) => t.triggered && !timers.find((o) => o.id === t.id)?.triggered)) {\n        triggered = true;\n      }\n\n      if (triggered) {\n        setState({ alarms: newAlarms, timers: newTimers });\n        \n        // Speak notification\n        speechSynthesis.speak(new SpeechSynthesisUtterance('Time\\'s up'));\n        \n        // Send notification if permission granted\n        if (permissionState === 'granted') {\n          // Find what triggered - alarm or timer\n          const triggeredAlarm = newAlarms.find(a => a.triggered && !alarms.find(o => o.id === a.id)?.triggered);\n          const triggeredTimer = newTimers.find(t => t.triggered && !timers.find(o => o.id === t.id)?.triggered);\n          \n          if (triggeredAlarm) {\n            sendNotification({\n              title: 'Lisa Alarm',\n              body: triggeredAlarm.label || 'Your alarm is ringing!',\n              tag: `alarm-${triggeredAlarm.id}`,\n              actions: [{ action: 'snooze', title: 'Snooze' }]\n            });\n          }\n          \n          if (triggeredTimer) {\n            sendNotification({\n              title: 'Lisa Timer',\n              body: triggeredTimer.label \n                ? `Your timer \"${triggeredTimer.label}\" is complete!` \n                : 'Your timer is complete!',\n              tag: `timer-${triggeredTimer.id}`\n            });\n          }\n        }\n      }\n    }, 1000);\n    return () => clearInterval(id);\n  }, [alarms, timers, sendNotification, permissionState]);\n  \n  // Request notification permission on mount\n  useEffect(() => {\n    if (permissionState === 'default') {\n      // We don't auto-request permission as it should be triggered by user interaction\n      console.log('Notification permission should be requested after user interaction');\n    }\n  }, [permissionState]);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useAudioClassifier.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.","line":45,"column":6,"nodeType":"ArrayExpression","endLine":45,"endColumn":44,"suggestions":[{"desc":"Update the dependencies array to be: [audioCtx, micStream, audioClassifier, setState]","fix":{"range":[1707,1745],"text":"[audioCtx, micStream, audioClassifier, setState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\nimport type { AudioClassifier, AudioClassifierResult } from '@mediapipe/tasks-audio';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n\n/**\n * Classify microphone audio and publish to Zustand, handles silence timer.\n */\nexport function useAudioClassifier(audioCtx?: AudioContext, micStream?: MediaStream, audioClassifier?: AudioClassifier | null) {\n  const setState = useVisionAudioStore((s) => s.setState);\n  const silenceTimeout = useRef<number>(0);\n\n  // Connect to mic\n  useEffect(() => {\n    if (!audioCtx || !micStream || !audioClassifier) return;\n\n    const source = audioCtx.createMediaStreamSource(micStream);\n    const processor = audioCtx.createScriptProcessor(4096, 1, 1);\n    source.connect(processor);\n    processor.connect(audioCtx.destination);\n\n    let frame = 0;\n    processor.onaudioprocess = (e) => {\n      if ((frame++ & 1) === 1) return;\n      const buffer = e.inputBuffer.getChannelData(0);\n      const results: AudioClassifierResult[] = audioClassifier.classify(buffer);\n      if (results && results.length && results[0].classifications.length) {\n        const top = results[0].classifications[0].categories[0];\n        setState({\n          audio: { category: top.categoryName, score: top.score, timestamp: Date.now() },\n          speechDetected: top.categoryName === 'Speech',\n        });\n\n        // Reset silence timer\n        if (silenceTimeout.current) clearTimeout(silenceTimeout.current);\n        silenceTimeout.current = window.setTimeout(() => {\n          setState({ lastSilenceMs: 10000 });\n        }, 10000);\n      }\n    };\n\n    return () => {\n      processor.disconnect();\n      source.disconnect();\n    };\n  }, [audioCtx, micStream, audioClassifier]);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useAuth.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":72,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":72,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":119,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":119,"endColumn":19},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":166,"column":14,"nodeType":null,"messageId":"unusedVar","endLine":166,"endColumn":19}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook d'authentification pour la gestion des tokens JWT\n */\n\nimport { useState, useEffect, useCallback } from 'react';\n\ninterface User {\n  id: string;\n  email: string;\n  name?: string;\n}\n\ninterface AuthState {\n  user: User | null;\n  token: string | null;\n  isAuthenticated: boolean;\n  isLoading: boolean;\n  error: string | null;\n}\n\ninterface LoginCredentials {\n  email: string;\n  password: string;\n}\n\ninterface RegisterCredentials {\n  email: string;\n  password: string;\n  name?: string;\n}\n\ninterface UseAuthReturn extends AuthState {\n  login: (credentials: LoginCredentials) => Promise<boolean>;\n  register: (credentials: RegisterCredentials) => Promise<boolean>;\n  logout: () => void;\n  clearError: () => void;\n}\n\nconst API_BASE_URL = `http://localhost:${import.meta.env.VITE_API_PORT || 3001}`;\n\nexport const useAuth = (): UseAuthReturn => {\n  const [authState, setAuthState] = useState<AuthState>({\n    user: null,\n    token: null,\n    isAuthenticated: false,\n    isLoading: true,\n    error: null,\n  });\n\n  // V├®rifier le token au chargement\n  useEffect(() => {\n    const token = localStorage.getItem('authToken');\n    if (token) {\n      try {\n        // D├®coder le token JWT pour extraire les infos utilisateur\n        const payload = JSON.parse(atob(token.split('.')[1]));\n        \n        // V├®rifier si le token n'est pas expir├®\n        if (payload.exp * 1000 > Date.now()) {\n          setAuthState({\n            user: { id: payload.userId, email: payload.email, name: payload.name },\n            token,\n            isAuthenticated: true,\n            isLoading: false,\n            error: null,\n          });\n        } else {\n          // Token expir├®\n          localStorage.removeItem('authToken');\n          setAuthState(prev => ({ ...prev, isLoading: false }));\n        }\n      } catch (error) {\n        // Token invalide\n        localStorage.removeItem('authToken');\n        setAuthState(prev => ({ ...prev, isLoading: false }));\n      }\n    } else {\n      setAuthState(prev => ({ ...prev, isLoading: false }));\n    }\n  }, []);\n\n  const login = useCallback(async (credentials: LoginCredentials): Promise<boolean> => {\n    setAuthState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/auth/login`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(credentials),\n      });\n\n      const data = await response.json();\n\n      if (data.success && data.data?.token) {\n        const { token, user } = data.data;\n        \n        // Stocker le token\n        localStorage.setItem('authToken', token);\n        \n        setAuthState({\n          user,\n          token,\n          isAuthenticated: true,\n          isLoading: false,\n          error: null,\n        });\n        \n        return true;\n      } else {\n        setAuthState(prev => ({\n          ...prev,\n          isLoading: false,\n          error: data.error || 'Erreur de connexion',\n        }));\n        return false;\n      }\n    } catch (error) {\n      setAuthState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Erreur de connexion au serveur',\n      }));\n      return false;\n    }\n  }, []);\n\n  const register = useCallback(async (credentials: RegisterCredentials): Promise<boolean> => {\n    setAuthState(prev => ({ ...prev, isLoading: true, error: null }));\n\n    try {\n      const response = await fetch(`${API_BASE_URL}/api/auth/register`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(credentials),\n      });\n\n      const data = await response.json();\n\n      if (data.success && data.data?.token) {\n        const { token, user } = data.data;\n        \n        // Stocker le token\n        localStorage.setItem('authToken', token);\n        \n        setAuthState({\n          user,\n          token,\n          isAuthenticated: true,\n          isLoading: false,\n          error: null,\n        });\n        \n        return true;\n      } else {\n        setAuthState(prev => ({\n          ...prev,\n          isLoading: false,\n          error: data.error || 'Erreur lors de l\\'inscription',\n        }));\n        return false;\n      }\n    } catch (error) {\n      setAuthState(prev => ({\n        ...prev,\n        isLoading: false,\n        error: 'Erreur de connexion au serveur',\n      }));\n      return false;\n    }\n  }, []);\n\n  const logout = useCallback(() => {\n    localStorage.removeItem('authToken');\n    setAuthState({\n      user: null,\n      token: null,\n      isAuthenticated: false,\n      isLoading: false,\n      error: null,\n    });\n  }, []);\n\n  const clearError = useCallback(() => {\n    setAuthState(prev => ({ ...prev, error: null }));\n  }, []);\n\n  return {\n    ...authState,\n    login,\n    register,\n    logout,\n    clearError,\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useChatInterface.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useClipboardSummarizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useContextManager.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useVisionAudioStore' is defined but never used. Allowed unused vars must match /^_/u.","line":7,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":7,"endColumn":29},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":69,"column":6,"nodeType":"ArrayExpression","endLine":69,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[2008,2025],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":128,"column":6,"nodeType":"ArrayExpression","endLine":128,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[3694,3711],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":159,"column":6,"nodeType":"ArrayExpression","endLine":159,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[4539,4556],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":237,"column":6,"nodeType":"ArrayExpression","endLine":237,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[6831,6848],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":245,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":245,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7030,7033],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7030,7033],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":260,"column":6,"nodeType":"ArrayExpression","endLine":260,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[7495,7512],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":267,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":267,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7675,7678],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7675,7678],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":283,"column":6,"nodeType":"ArrayExpression","endLine":283,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[8182,8199],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":313,"column":6,"nodeType":"ArrayExpression","endLine":313,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[8987,9004],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":343,"column":6,"nodeType":"ArrayExpression","endLine":343,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[9788,9805],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":374,"column":6,"nodeType":"ArrayExpression","endLine":374,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[10645,10662],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":379,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":379,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10779,10782],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10779,10782],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'refreshRecentContexts'. Either include it or remove the dependency array.","line":459,"column":6,"nodeType":"ArrayExpression","endLine":459,"endColumn":23,"suggestions":[{"desc":"Update the dependencies array to be: [getContextAgent, refreshRecentContexts]","fix":{"range":[12951,12968],"text":"[getContextAgent, refreshRecentContexts]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":493,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":493,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13942,13945],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13942,13945],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":494,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":494,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[13996,13999],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[13996,13999],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":514,"column":7,"nodeType":"MemberExpression","endLine":514,"endColumn":32},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":514,"column":17,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":514,"endColumn":20,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14566,14569],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14566,14569],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a complex expression in the dependency array. Extract it to a separate variable so it can be statically checked.","line":514,"column":34,"nodeType":"MemberExpression","endLine":514,"endColumn":63},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":514,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":514,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[14593,14596],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[14593,14596],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":20,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * hooks/useContextManager.ts\n * Hook React pour acc├®der au gestionnaire de contexte\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport { agentRegistry } from '../agents/registry';\nimport { ContextAgent } from '../agents/ContextAgent';\nimport type {\n  ContextItem,\n  ContextType,\n  ContextQueryOptions,\n  ConversationContextItem,\n  EntityContextItem,\n  IntentHistoryContextItem\n} from '../context/types';\n\n/**\n * Hook pour acc├®der au gestionnaire de contexte\n */\nexport function useContextManager() {\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [recentContexts, setRecentContexts] = useState<ContextItem[]>([]);\n  \n  // Note: store supprim├® car non utilis├®\n  \n  /**\n   * Obtient l'agent de contexte du registre\n   */\n  const getContextAgent = useCallback((): ContextAgent => {\n    const agent = agentRegistry.getAgent('context-agent');\n    if (!agent) {\n      throw new Error(\"Agent de contexte non disponible\");\n    }\n    return agent as ContextAgent;\n  }, []);\n  \n  /**\n   * Ajoute un ├®l├®ment au contexte\n   */\n  const addContext = useCallback(async (contextItem: Omit<ContextItem, 'id' | 'timestamp'>): Promise<ContextItem | null> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'add_context',\n        parameters: { contextItem }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'ajout du contexte\");\n      }\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result.output?.contextItem || null;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Obtient un ├®l├®ment de contexte par ID\n   */\n  const getContext = useCallback(async (id: string): Promise<ContextItem | null> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'get_context',\n        parameters: { id }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la r├®cup├®ration du contexte\");\n      }\n      \n      return result.output?.contextItem || null;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Met ├á jour un ├®l├®ment de contexte\n   */\n  const updateContext = useCallback(async (id: string, updates: Partial<Omit<ContextItem, 'id' | 'type'>>): Promise<ContextItem | null> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'update_context',\n        parameters: { id, updates }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la mise ├á jour du contexte\");\n      }\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result.output?.contextItem || null;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Supprime un ├®l├®ment de contexte\n   */\n  const removeContext = useCallback(async (id: string): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'delete_context',\n        parameters: { id }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la suppression du contexte\");\n      }\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result.output?.deleted || false;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Recherche des ├®l├®ments de contexte\n   */\n  const queryContext = useCallback(async (options?: ContextQueryOptions): Promise<ContextItem[]> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'query_context',\n        parameters: { options }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la recherche de contexte\");\n      }\n      \n      return result.output?.results || [];\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Obtient le contexte pertinent pour une entr├®e\n   */\n  const getRelevantContext = useCallback(async (input: string, maxItems: number = 10): Promise<ContextItem[]> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'get_relevant_context',\n        parameters: { input, maxItems }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la r├®cup├®ration du contexte pertinent\");\n      }\n      \n      return result.output?.relevantContexts || [];\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Ajoute un ├®l├®ment de contexte de conversation\n   */\n  const addConversationContext = useCallback(async (\n    text: string,\n    role: 'user' | 'assistant',\n    metadata: { intent?: string; sentiment?: string; language?: string } = {}\n  ): Promise<ConversationContextItem | null> => {\n    try {\n      const agent = getContextAgent();\n      const result = await agent.addConversationContext(text, role, metadata);\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return null;\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Ajoute un ├®l├®ment de contexte d'entit├®\n   */\n  const addEntityContext = useCallback(async (\n    entityType: string,\n    name: string,\n    attributes: Record<string, any> = {},\n    references: string[] = []\n  ): Promise<EntityContextItem | null> => {\n    try {\n      const agent = getContextAgent();\n      const result = await agent.addEntityContext(entityType, name, attributes, references);\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return null;\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Ajoute un ├®l├®ment de contexte d'intention\n   */\n  const addIntentContext = useCallback(async (\n    intent: string,\n    parameters: Record<string, any> = {},\n    fulfilled: boolean = false,\n    followUpIntent?: string\n  ): Promise<IntentHistoryContextItem | null> => {\n    try {\n      const agent = getContextAgent();\n      const result = await agent.addIntentContext(intent, parameters, fulfilled, followUpIntent);\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return null;\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Fusionne les contextes similaires\n   */\n  const mergeContexts = useCallback(async (): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'merge_contexts'\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la fusion des contextes\");\n      }\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result.output?.merged || false;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Nettoie les contextes expir├®s\n   */\n  const pruneContexts = useCallback(async (): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'prune_contexts'\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec du nettoyage des contextes\");\n      }\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result.output?.pruned || false;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Supprime tous les contextes\n   */\n  const clearContexts = useCallback(async (types?: ContextType[]): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'clear_contexts',\n        parameters: { types }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la suppression des contextes\");\n      }\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result.output?.cleared || false;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * R├®cup├¿re les statistiques du contexte\n   */\n  const getContextStats = useCallback(async (): Promise<any> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'get_stats'\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la r├®cup├®ration des statistiques\");\n      }\n      \n      return result.output?.stats || null;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Exporte tous les ├®l├®ments de contexte\n   */\n  const exportContexts = useCallback(async (): Promise<ContextItem[]> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'export_contexts'\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'exportation des contextes\");\n      }\n      \n      return result.output?.contexts || [];\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Importe des ├®l├®ments de contexte\n   */\n  const importContexts = useCallback(async (contexts: ContextItem[]): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'import_contexts',\n        parameters: { contexts }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'importation des contextes\");\n      }\n      \n      // Rafra├«chit la liste des contextes r├®cents\n      void refreshRecentContexts();\n      \n      return result.output?.imported || false;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  /**\n   * Rafra├«chit la liste des contextes r├®cents\n   */\n  const refreshRecentContexts = useCallback(async (): Promise<ContextItem[]> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getContextAgent();\n      const props = {\n        intent: 'get_recent_contexts',\n        parameters: { limit: 5 }\n      };\n      \n      const result = await agent.execute(props);\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la r├®cup├®ration des contextes r├®cents\");\n      }\n      \n      const contexts = result.output?.contexts || [];\n      setRecentContexts(contexts);\n      return contexts;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getContextAgent]);\n  \n  useEffect(() => {\n    // V├®rifier si les propri├®t├®s existent avant de les utiliser\n    const lastIntent = (store as any).lastIntent;\n    const lastSpokenText = (store as any).lastSpokenText;\n    \n    if (lastIntent) {\n      // Ajoute l'intention d├®tect├®e au contexte de la conversation\n      void addIntentContext(\n        lastIntent.intent,\n        lastIntent.entities || {},\n        true\n      );\n      \n      // Ajoute au contexte de conversation si lastSpokenText est disponible\n      if (lastSpokenText) {\n        void addConversationContext({\n          type: 'conversation',\n          text: lastSpokenText,\n          intent: lastIntent.intent,\n          parameters: lastIntent.entities || {}\n        });\n      }\n    }\n  }, [(store as any).lastIntent, (store as any).lastSpokenText, addConversationContext, addIntentContext]);\n  \n  /**\n   * Initialisation: rafra├«chit la liste des contextes r├®cents\n   */\n  useEffect(() => {\n    void refreshRecentContexts();\n  }, [refreshRecentContexts]);\n  \n  return {\n    // ├ëtat\n    isLoading,\n    error,\n    recentContexts,\n    \n    // Actions de base\n    addContext,\n    getContext,\n    updateContext,\n    removeContext,\n    queryContext,\n    getRelevantContext,\n    mergeContexts,\n    pruneContexts,\n    clearContexts,\n    \n    // Actions sp├®cifiques\n    addConversationContext,\n    addEntityContext,\n    addIntentContext,\n    \n    // Actions d'administration\n    getContextStats,\n    exportContexts,\n    importContexts,\n    refreshRecentContexts\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useContextualFollowup.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'handleIntent'. Either include it or remove the dependency array.","line":68,"column":6,"nodeType":"ArrayExpression","endLine":68,"endColumn":30,"suggestions":[{"desc":"Update the dependencies array to be: [context.lastIntent, handleIntent, i18n.language]","fix":{"range":[2859,2883],"text":"[context.lastIntent, handleIntent, i18n.language]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useVisionAudioStore } from '../store/visionAudioStore';\nimport { useTranslation } from 'react-i18next';\nimport { useEffect, useRef, useCallback } from 'react';\nimport { useIntentHandler } from './useIntentHandler';\n\n/**\n * A hook to handle contextual follow-up questions based on conversation context\n */\nexport function useContextualFollowup() {\n  const { i18n } = useTranslation();\n  const context = useVisionAudioStore(s => s.conversationContext);\n  const setState = useVisionAudioStore(s => s.setState);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n  const { handleIntent } = useIntentHandler();\n\n  // Determine if a phrase is a follow-up question based on content and context\n  const isFollowupQuestion = useCallback((phrase: string) => {\n    const lower = phrase.toLowerCase();\n    const isFrench = i18n.language.startsWith('fr');\n    \n    // Common follow-up question starters\n    const followUpStarters = isFrench \n      ? ['et pour', 'et demain', 'qu\\'en est-il', 'et apr├¿s', 'et ensuite', 'et']\n      : ['and for', 'what about', 'and tomorrow', 'and then', 'and'];\n    \n    // Check if the phrase starts with one of the follow-up patterns\n    return followUpStarters.some(starter => lower.startsWith(starter));\n  }, [i18n.language]);\n\n  // Process a follow-up question in context of the previous interaction\n  const processFollowupQuestion = useCallback(async (phrase: string) => {\n    if (!context?.lastIntent) return null;\n\n    const lower = phrase.toLowerCase();\n    const isFrench = i18n.language.startsWith('fr');\n    \n    // Handle weather-related follow-ups\n    if (context.lastIntent === 'weather_now' && \n        ((isFrench && lower.includes('demain')) || (!isFrench && lower.includes('tomorrow')))) {\n      return { type: 'weather_forecast', period: 'tomorrow' };\n    }\n\n    // Handle todo-related follow-ups\n    if ((context.lastIntent === 'add_todo' || context.lastIntent === 'list_todos') && \n        ((isFrench && lower.includes('supprime')) || (!isFrench && lower.includes('delete')))) {\n      // Extract the item to remove from the follow-up\n      const match = isFrench \n        ? lower.match(/(?:supprime|enl├¿ve|retire)\\s+(.+)$/i) \n        : lower.match(/(?:delete|remove)\\s+(.+)$/i);\n      \n      if (match && match[1]) {\n        return { type: 'remove_todo', text: match[1].trim() };\n      }\n    }\n\n    // Handle calendar-related follow-ups\n    if (context.lastIntent === 'list_events') {\n      if ((isFrench && lower.includes('ajoute')) || (!isFrench && lower.includes('add'))) {\n        // Process through the PlannerAgent directly\n        const fullPhrase = `${isFrench ? 'ajoute un ├®v├®nement' : 'add an event'} ${phrase}`;\n        // Execute the intent through PlannerAgent\n        handleIntent(fullPhrase, true);\n        return { type: 'add_event', text: phrase };\n      }\n    }\n\n    return null;\n  }, [context, i18n.language]);\n\n  // Set up a timeout to clear the conversation context after a period of inactivity\n  useEffect(() => {\n    if (context && context.timestamp) {\n      // Clear any existing timeout\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      \n      // Set a new timeout to clear context after 2 minutes of inactivity\n      timeoutRef.current = setTimeout(() => {\n        setState({ conversationContext: undefined });\n      }, 2 * 60 * 1000);\n    }\n    \n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, [context, setState]);\n\n  return {\n    isFollowupQuestion,\n    processFollowupQuestion,\n    hasRecentContext: !!context && (Date.now() - (context.timestamp || 0) < 2 * 60 * 1000),\n    // Export direct access to handleIntent for convenience\n    handleFollowupWithPlannerAgent: handleIntent\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useDataAnalysis.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useEmail.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useFaceLandmarker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useGestureRecognizer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useGoogleCalendar.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":34,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":37,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1905,1908],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1905,1908],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2150,2153],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2150,2153],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":73,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":73,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2522,2525],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2522,2525],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":74,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":74,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2554,2557],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2554,2557],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'fetchUserProfile' is assigned a value but never used. Allowed unused vars must match /^_/u.","line":77,"column":9,"nodeType":null,"messageId":"unusedVar","endLine":77,"endColumn":25},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'signOut'. Either include it or remove the dependency array.","line":89,"column":6,"nodeType":"ArrayExpression","endLine":89,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [signOut]","fix":{"range":[3060,3062],"text":"[signOut]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":100,"column":46,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":100,"endColumn":49,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3365,3368],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3365,3368],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3419,3422],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3419,3422],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":106,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":106,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3591,3594],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3591,3594],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":107,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":107,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3627,3630],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3627,3630],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":10,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback, useRef } from 'react';\n\n// Google OAuth2 configuration\nconst GOOGLE_CLIENT_ID = import.meta.env.VITE_GOOGLE_CLIENT_ID || '';\nconst SCOPES = 'https://www.googleapis.com/auth/calendar.readonly';\n\ninterface CreateEventInput {\n  summary: string;\n  start: { dateTime: string; timeZone?: string };\n  end: { dateTime: string; timeZone?: string };\n  description?: string;\n  location?: string;\n}\n\ninterface UseGoogleCalendarReturn {\n  isSignedIn: boolean;\n  user: GoogleUser | null;\n  events: GoogleCalendarEvent[];\n  signIn: () => Promise<void>;\n  signOut: () => void;\n  createEvent: (event: CreateEventInput) => Promise<GoogleCalendarEvent>;\n  isLoading: boolean;\n  error: unknown;\n}\n\nexport function useGoogleCalendar(): UseGoogleCalendarReturn {\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<unknown>(null);\n  const [user, setUser] = useState<GoogleUser | null>(null);\n  const [events, setEvents] = useState<GoogleCalendarEvent[]>([]);\n  const tokenClientRef = useRef<unknown>(null);\n\n  // Load Google API client\n  useEffect(() => {\n    const script = document.createElement('script');\n    script.src = 'https://accounts.google.com/gsi/client';\n    script.async = true;\n    script.defer = true;\n    script.onload = () => {\n      // Google API client is loaded\n    };\n    document.body.appendChild(script);\n\n    return () => {\n      document.body.removeChild(script);\n    };\n  }, []);\n\n  // Check for existing token on mount (lightweight to satisfy tests)\n  useEffect(() => {\n    const token = sessionStorage.getItem('google_access_token');\n    if (token) {\n      // Marquer comme connect├® sans requ├¬tes r├®seau pour ├®viter des d├®pendances ici\n      setUser({} as GoogleUser);\n    }\n  }, []);\n\n  // Initialize Google Token Client when available (tests mock window.google)\n  useEffect(() => {\n    const googleAny = (window as any);\n    if (!googleAny?.google?.accounts?.oauth2?.initTokenClient) return;\n    tokenClientRef.current = googleAny.google.accounts.oauth2.initTokenClient({\n      client_id: GOOGLE_CLIENT_ID,\n      scope: SCOPES,\n      callback: (tokenResponse: any) => {\n        if (tokenResponse?.access_token) {\n          sessionStorage.setItem('google_access_token', tokenResponse.access_token);\n          // Marquer comme connect├® imm├®diatement; les chargements d├®taill├®s sont d├®clench├®s ailleurs\n          setUser({} as GoogleUser);\n        }\n      },\n      // Pr├®sent pour les tests; types inconnus\n      error_callback: (err: any) => setError(err),\n    } as any);\n  }, []);\n\n  const fetchUserProfile = useCallback(async (accessToken: string) => {\n    try {\n      const response = await fetch('https://www.googleapis.com/oauth2/v2/userinfo', {\n        headers: { Authorization: `Bearer ${accessToken}` },\n      });\n      if (!response.ok) throw new Error('Failed to fetch user profile');\n      const userData = await response.json();\n      setUser(userData);\n    } catch (err) {\n      console.error('Error fetching user profile:', err);\n      signOut();\n    }\n  }, []);\n\n  const signIn = useCallback(async () => {\n    if (!window.google) {\n      setError(new Error('Google API client not loaded'));\n      return;\n    }\n\n    setIsLoading(true);\n    try {\n      // Trigger token request; resolution happens via callback effect\n      let client = tokenClientRef.current as any;\n      if (!client) {\n        client = (window as any).google.accounts.oauth2.initTokenClient({\n          client_id: GOOGLE_CLIENT_ID,\n          scope: SCOPES,\n          callback: () => {},\n          error_callback: (err: any) => setError(err),\n        } as any);\n        tokenClientRef.current = client;\n      }\n      client.requestAccessToken();\n    } catch (err) {\n      console.error('Sign-in error:', err);\n      setError(err instanceof Error ? err : new Error('Failed to sign in'));\n    } finally {\n      setIsLoading(false);\n    }\n  }, []);\n\n  const createEvent = useCallback(async (event: CreateEventInput) => {\n    const token = sessionStorage.getItem('google_access_token');\n    const tz = 'Europe/Paris';\n    const body = {\n      ...event,\n      start: { ...event.start, timeZone: tz },\n      end: { ...event.end, timeZone: tz },\n    };\n    const resp = await fetch('https://www.googleapis.com/calendar/v3/calendars/primary/events', {\n      method: 'POST',\n      headers: {\n        ...(token ? { 'Authorization': `Bearer ${token}` } : {}),\n        'Content-Type': 'application/json',\n      },\n      body: JSON.stringify(body),\n    });\n    if (!resp.ok) throw new Error('Failed to create event');\n    const created = await resp.json();\n    return created;\n  }, []);\n\n  const signOut = useCallback(() => {\n    const token = sessionStorage.getItem('google_access_token');\n    sessionStorage.removeItem('google_access_token');\n    setUser(null);\n    setEvents([]);\n    // Revoke token with Google\n    if (token) {\n      fetch(`https://accounts.google.com/o/oauth2/revoke?token=${token}`).catch(console.error);\n    }\n  }, []);\n\n  // No direct store writes here to avoid type conflicts\n\n  return {\n    isSignedIn: !!user,\n    user,\n    events,\n    signIn,\n    signOut,\n    createEvent,\n    isLoading,\n    error,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useHandLandmarker.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.","line":64,"column":6,"nodeType":"ArrayExpression","endLine":64,"endColumn":29,"suggestions":[{"desc":"Update the dependencies array to be: [video, handLandmarker, setState]","fix":{"range":[2268,2291],"text":"[video, handLandmarker, setState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect } from 'react';\nimport type { HandLandmarker, HandLandmarkerResult } from '@mediapipe/tasks-vision';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n// import { loadTask } from '../utils/loadTask';\nimport type { Percept, MediaPipeHandPayload } from '../senses/vision'; // Import new types\n\nexport function useHandLandmarker(video?: HTMLVideoElement, handLandmarker?: HandLandmarker | null) {\n  const setState = useVisionAudioStore((s) => s.setState);\n\n  useEffect(() => {\n    if (!video || !handLandmarker) return;\n    let rafId: number;\n    let frame = 0;\n    const loop = () => {\n      if ((frame++ & 1) === 1) { rafId = requestAnimationFrame(loop); return; }\n      const res: HandLandmarkerResult | undefined = handLandmarker.detectForVideo(\n        video,\n        performance.now()\n      );\n      if (res) {\n        const newPercepts: Percept<MediaPipeHandPayload>[] = [];\n        for (let i = 0; i < res.landmarks.length; i++) {\n          const landmarks = res.landmarks[i];\n          const handedness = res.handedness[i][0].categoryName as 'Left' | 'Right';\n          const score = res.handedness[i][0].score;\n\n          // Calculate a simple bounding box from landmarks (min/max x,y)\n          const xCoords = landmarks.map(lm => lm.x);\n          const yCoords = landmarks.map(lm => lm.y);\n          const xMin = Math.min(...xCoords);\n          const yMin = Math.min(...yCoords);\n          const xMax = Math.max(...xCoords);\n          const yMax = Math.max(...yCoords);\n          const width = xMax - xMin;\n          const height = yMax - yMin;\n\n          const payload: MediaPipeHandPayload = {\n            type: 'hand',\n            boxes: [[xMin, yMin, width, height]],\n            landmarks: landmarks,\n            handedness: handedness,\n            scores: [score],\n          };\n\n          newPercepts.push({\n            modality: 'vision',\n            payload: payload,\n            confidence: score,\n            ts: Date.now(),\n          });\n        }\n\n        setState(state => ({\n          percepts: [\n            ...(state.percepts || []),\n            ...newPercepts,\n          ],\n        }));\n      }\n      rafId = requestAnimationFrame(loop);\n    };\n    loop();\n    return () => cancelAnimationFrame(rafId);\n  }, [video, handLandmarker]); // Changed taskRef.current to handLandmarker\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useHealthMonitor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useImageClassifier.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useImageEmbedder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useImageSegmenter.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useIntentHandler.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has an unnecessary dependency: 'retrieveMemories'. Either exclude it or remove the dependency array.","line":269,"column":6,"nodeType":"ArrayExpression","endLine":269,"endColumn":132,"suggestions":[{"desc":"Update the dependencies array to be: [i18n.language, setPlan, setState, speakText, storeMemory, isSmallTalk, checkTriggerPhrase, executeWorkflow]","fix":{"range":[11062,11188],"text":"[i18n.language, setPlan, setState, speakText, storeMemory, isSmallTalk, checkTriggerPhrase, executeWorkflow]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport { useTranslation } from 'react-i18next';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport type { WorkflowStep } from '../store/visionAudioStore';\nimport { agentRegistry } from '../agents/registry';\nimport { useSpeechResponder } from './useSpeechResponder';\nimport type { AgentExecuteProps } from '../agents/types';\nimport { useSmallTalk } from './useSmallTalk';\nimport { useUserWorkflows } from './useUserWorkflows';\nimport { useSpeechSynthesis } from './useSpeechSynthesis';\nimport { useMemory } from './useMemory';\n\nexport const useIntentHandler = () => {\n  const { i18n } = useTranslation();\n  const setPlan = useVisionAudioStore(state => state.setPlan);\n  const setState = useVisionAudioStore(state => state.setState);\n  \n  // Obtenir les fonctions de gestion des workflows utilisateur\n  const { checkTriggerPhrase, executeWorkflow } = useUserWorkflows();\n  \n  // Get small talk detection\n  const { isSmallTalk } = useSmallTalk();\n  \n  // Get text-to-speech functionality\n  const { speakText } = useSpeechSynthesis();\n  \n  // Get memory functions\n  const { storeMemory, retrieveMemories } = useMemory();\n\n  // This hook sets up the speech synthesis engine\n  useSpeechResponder();\n\n  const handleIntent = useCallback(async (intent: string, isInternal = false) => {\n    try {\n      // V├®rifier d'abord si l'intent correspond ├á un d├®clencheur de workflow utilisateur\n      if (!isInternal) {\n        const triggerMatch = await checkTriggerPhrase(intent);\n        \n        if (triggerMatch.matched && triggerMatch.workflowId) {\n          console.log(`D├®clencheur de workflow d├®tect├®: \"${intent}\" -> Workflow ID: ${triggerMatch.workflowId}`);\n          \n          setState({ intent: 'processing' });\n          setPlan([{ \n            label: `Ex├®cution du workflow personnalis├® (d├®clencheur: \"${intent}\")`,\n            status: 'running' \n          }]); \n          \n          // Ex├®cuter le workflow personnalis├®\n          const success = await executeWorkflow(triggerMatch.workflowId);\n          \n          if (success) {\n            setPlan(prev => prev?.map(step => ({ ...step, status: 'completed' })) || []);\n            speakText('Action termin├®e avec succ├¿s');\n          } else {\n            setPlan(prev => prev?.map(step => ({ ...step, status: 'failed' })) || []);\n            speakText('Erreur lors de l\\'ex├®cution de l\\'action');\n          }\n          \n          setTimeout(() => setPlan(null), 5000);\n          setState({ intent: undefined, listeningActive: false });\n          return;\n        }\n        \n        // V├®rifier si c'est une commande li├®e ├á la m├®moire\n        const memoryKeywords = ['souviens-toi', 'rappelle-toi', 'n\\'oublie pas', 'm├®morise'];\n        const memoryPhrases = ['tu te souviens', 'souviens-toi que', 'rappelle-moi', 'n\\'oublie pas que'];\n        \n        const lowerIntent = intent.toLowerCase();\n        const isMemoryCommand = memoryKeywords.some(kw => lowerIntent.startsWith(kw)) || \n                              memoryPhrases.some(phrase => lowerIntent.includes(phrase));\n        \n        if (isMemoryCommand) {\n          console.log(`Commande de m├®moire d├®tect├®e: \"${intent}\"`);\n          \n          setState({ intent: 'processing' });\n          setPlan([{ \n            label: `M├®morisation: \"${intent}\"`,\n            status: 'running' \n          }]);\n          \n          // Utiliser MemoryAgent pour traiter la commande de m├®moire\n          const memoryAgent = agentRegistry.getAgent('MemoryAgent');\n          \n          if (memoryAgent) {\n            // D├®terminer l'action de m├®moire\n            let action = 'store';\n            let content = '';\n            \n            if (lowerIntent.includes('rappelle-moi') || lowerIntent.includes('tu te souviens')) {\n              action = 'retrieve';\n              // Extraire le sujet de la recherche\n              const searchTerms = lowerIntent.replace(/^(rappelle-moi|est-ce que tu te souviens)\\s*(de|d'|du|des|\\w+)\\s*/i, '');\n              const result = await memoryAgent.execute({\n                action,\n                query: { text: searchTerms, limit: 3 }\n              });\n              \n              if (result.success && Array.isArray(result.output) && result.output.length > 0) {\n                setPlan(prev => prev?.map(step => ({ ...step, status: 'completed' })) || []);\n                const memories = result.output;\n                const response = `Oui, je me souviens: ${memories.map(m => m.content).join('. ')}`;  \n                speakText(response);\n                \n                // Mettre ├á jour les compteurs d'acc├¿s des m├®moires r├®cup├®r├®es\n                memories.forEach(memory => {\n                  memoryAgent.execute({\n                    action: 'update',\n                    id: memory.id,\n                    updates: {\n                      accessCount: (memory.accessCount || 0) + 1,\n                      lastAccessed: Date.now()\n                    }\n                  });\n                });\n              } else {\n                setPlan(prev => prev?.map(step => ({ ...step, status: 'completed' })) || []);\n                speakText(`D├®sol├®, je ne me souviens pas de ├ºa.`);\n              }\n            } else {\n              // C'est une commande de stockage de m├®moire\n              // Extraire le contenu ├á m├®moriser\n              if (lowerIntent.startsWith('souviens-toi que')) {\n                content = intent.substring(16).trim();\n              } else if (lowerIntent.startsWith('souviens-toi')) {\n                content = intent.substring(12).trim();\n              } else if (lowerIntent.startsWith('m├®morise')) {\n                content = intent.substring(9).trim();\n              } else if (lowerIntent.startsWith('n\\'oublie pas que')) {\n                content = intent.substring(17).trim();\n              } else if (lowerIntent.startsWith('n\\'oublie pas')) {\n                content = intent.substring(13).trim();\n              } else {\n                content = intent;\n              }\n              \n              const result = await memoryAgent.execute({\n                action,\n                content,\n                type: 'fact',\n                tags: ['voice_command'],\n                source: 'user_instruction'\n              });\n              \n              if (result.success) {\n                setPlan(prev => prev?.map(step => ({ ...step, status: 'completed' })) || []);\n                speakText(`J'ai m├®moris├® : ${content}`);\n              } else {\n                setPlan(prev => prev?.map(step => ({ ...step, status: 'failed' })) || []);\n                speakText('D├®sol├®, je n\\'ai pas pu m├®moriser cette information');\n              }\n            }\n            \n            setTimeout(() => setPlan(null), 5000);\n            setState({ intent: undefined, listeningActive: false });\n            return;\n          }\n        }\n        \n        // V├®rifier si c'est du small talk et utiliser SmallTalkAgent le cas ├®ch├®ant\n        if (isSmallTalk(intent)) {\n          console.log(`Small talk d├®tect├®: \"${intent}\"`);\n          \n          setState({ intent: 'processing' });\n          setPlan([{ \n            label: `Conversation: \"${intent}\"`,\n            status: 'running' \n          }]);\n          \n          // Utiliser SmallTalkAgent pour traiter le small talk\n          const smallTalkAgent = agentRegistry.getAgent('SmallTalkAgent');\n          \n          if (smallTalkAgent) {\n            const result = await smallTalkAgent.execute({\n              request: intent,\n              language: i18n.language\n            });\n            \n            if (result.success) {\n              setPlan(prev => prev?.map(step => ({ ...step, status: 'completed' })) || []);\n              speakText(result.output);\n              \n              // Stocker l'interaction dans la m├®moire\n              try {\n                await storeMemory(`Interaction: ${intent} -> ${result.output}`, {\n                  type: 'interaction',\n                  tags: ['conversation', 'small_talk']\n                });\n              } catch (error) {\n                console.error('Error storing conversation in memory:', error);\n              }\n            } else {\n              setPlan(prev => prev?.map(step => ({ ...step, status: 'failed' })) || []);\n              speakText('Je suis d├®sol├®e, je ne peux pas r├®pondre ├á cela pour le moment');\n            }\n            \n            setTimeout(() => setPlan(null), 5000);\n            setState({ intent: undefined, listeningActive: false });\n            return;\n          }\n        }\n      }\n      \n      // Si ce n'est pas un d├®clencheur de workflow utilisateur ni du small talk, continuer avec le PlannerAgent normal\n      const planner = agentRegistry.getAgent('PlannerAgent');\n      if (!planner) {\n        console.error('PlannerAgent not found!');\n        speakText('Erreur lors de l\\'ex├®cution de l\\'action');\n        if (!isInternal) setState({ listeningActive: false });\n        return;\n      }\n\n      setState({ intent: 'processing' });\n      if (!isInternal) {\n        setPlan([]); \n      }\n\n      let plannerProps: AgentExecuteProps = { request: intent };\n      if (intent.toLowerCase().startsWith('load template')) {\n        plannerProps = { request: '', loadFromTemplate: intent.substring(14).trim() };\n      } else if (intent.toLowerCase().startsWith('resume checkpoint')) {\n        plannerProps = { request: '', resumeFromCheckpointId: intent.substring(18).trim() };\n      }\n\n      const result = await planner.execute({\n        ...plannerProps,\n        language: i18n.language,\n        onPlanUpdate: (updatedPlan: WorkflowStep[]) => {\n          setPlan(updatedPlan);\n        },\n      });\n\n      if (result.success) {\n        if (!isInternal) speakText('Action termin├®e avec succ├¿s');\n        \n        // Stocker l'intention et le r├®sultat dans la m├®moire\n        try {\n          await storeMemory(`Commande ex├®cut├®e: ${intent}`, {\n            type: 'interaction',\n            tags: ['command', 'planner_execution'],\n            metadata: { success: true }\n          });\n        } catch (error) {\n          console.error('Error storing command result in memory:', error);\n        }\n      } else {\n        console.error('PlannerAgent execution failed:', result.error);\n        if (!isInternal) speakText('Erreur lors de l\\'ex├®cution de l\\'action');\n        \n        // Stocker l'├®chec dans la m├®moire\n        try {\n          await storeMemory(`├ëchec d'ex├®cution: ${intent}`, {\n            type: 'interaction',\n            tags: ['command', 'planner_execution', 'error'],\n            metadata: { error: result.error, success: false }\n          });\n        } catch (error) {\n          console.error('Error storing command failure in memory:', error);\n        }\n      }\n    } catch (error) {\n      console.error('Error handling intent:', error);\n      if (!isInternal) speakText('Erreur lors de l\\'ex├®cution de l\\'action');\n    } finally {\n      if (!isInternal) {\n        setTimeout(() => setPlan(null), 5000);\n        setState({ intent: undefined, listeningActive: false });\n      }\n    }\n  }, [i18n.language, setPlan, setState, speakText, storeMemory, retrieveMemories, isSmallTalk, checkTriggerPhrase, executeWorkflow]);\n\n  return { handleIntent };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useMcpClient.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useMediaPermissions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":29,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":29,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1158,1161],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1158,1161],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":42,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":45,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1378,1381],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1378,1381],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":55,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":55,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2155,2158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2155,2158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2264,2267],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2264,2267],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":49,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":52,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2356,2359],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2356,2359],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useState, useEffect, useCallback } from 'react';\n\n/**\n * React hook to query and request camera / microphone permissions in a unified way.\n * Works gracefully when the Permissions API is not available (falls back to prompt state).\n */\nexport interface MediaPermissionsState {\n  camera: PermissionState;\n  microphone: PermissionState;\n}\n\nexport interface UseMediaPermissionsResult {\n  /** Current permission states */\n  permissions: MediaPermissionsState;\n  /** Manually refresh permission states */\n  refreshPermissions: () => Promise<void>;\n  /**\n   * Request camera stream. Will trigger the browser permission dialog if needed.\n   * Returns the MediaStream or null if the user denied / an error occurred.\n   */\n  requestCamera: (constraints?: MediaStreamConstraints) => Promise<MediaStream | null>;\n  /** Request microphone stream. */\n  requestMicrophone: (constraints?: MediaStreamConstraints) => Promise<MediaStream | null>;\n}\n\n// Helper to query a single permission; returns 'prompt' if API unsupported\nasync function queryPermission(name: PermissionName): Promise<PermissionState> {\n  try {\n    if ('permissions' in navigator && (navigator as any).permissions.query) {\n      // Some browsers (e.g. Safari) do not yet support 'camera' / 'microphone' names.\n      // Wrap in try/catch to avoid unhandled rejections.\n       \n      const status = await (navigator as any).permissions.query({ name });\n      return status.state as PermissionState;\n    }\n  } catch {\n    // Ignore errors and fall through to prompt\n  }\n  return 'prompt';\n}\n\nexport function useMediaPermissions(): UseMediaPermissionsResult {\n  const [permissions, setPermissions] = useState<MediaPermissionsState>({ camera: 'prompt', microphone: 'prompt' });\n\n  const refreshPermissions = useCallback(async () => {\n    const [cam, mic] = await Promise.all([queryPermission('camera'), queryPermission('microphone')]);\n    setPermissions({ camera: cam, microphone: mic });\n  }, []);\n\n  useEffect(() => {\n    refreshPermissions();\n\n    // Register onchange listeners if supported\n    const listeners: Array<PermissionStatus> = [];\n    if ('permissions' in navigator && (navigator as any).permissions.query) {\n      (async () => {\n        try {\n          const camStatus = await (navigator as any).permissions.query({ name: 'camera' });\n          const micStatus = await (navigator as any).permissions.query({ name: 'microphone' });\n          camStatus.onchange = micStatus.onchange = () => refreshPermissions();\n          listeners.push(camStatus, micStatus);\n        } catch {\n          /* ignore */\n        }\n      })();\n    }\n\n    return () => {\n      listeners.forEach((l) => (l.onchange = null));\n    };\n  }, [refreshPermissions]);\n\n  const requestCamera = useCallback(async (constraints: MediaStreamConstraints = { video: true }): Promise<MediaStream | null> => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      await refreshPermissions();\n      return stream;\n    } catch (err) {\n      console.error('Camera permission denied or error:', err);\n      await refreshPermissions();\n      return null;\n    }\n  }, [refreshPermissions]);\n\n  const requestMicrophone = useCallback(async (constraints: MediaStreamConstraints = { audio: true }): Promise<MediaStream | null> => {\n    try {\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      await refreshPermissions();\n      return stream;\n    } catch (err) {\n      console.error('Microphone permission denied or error:', err);\n      await refreshPermissions();\n      return null;\n    }\n  }, [refreshPermissions]);\n\n  return {\n    permissions,\n    refreshPermissions,\n    requestCamera,\n    requestMicrophone,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useMediaPipeModels.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":58,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":58,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1747,1750],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1747,1750],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":59,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":59,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1831,1834],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1831,1834],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":60,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":60,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1915,1918],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1915,1918],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1999,2002],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1999,2002],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":62,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":62,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2084,2087],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2084,2087],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":63,"column":81,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":63,"endColumn":84,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2177,2180],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2177,2180],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":64,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":64,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2267,2270],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2267,2270],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":65,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":65,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2351,2354],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2351,2354],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":66,"column":77,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":66,"endColumn":80,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2433,2436],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2433,2436],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":72,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":72,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2586,2589],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2586,2589],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'models'. Either include it or remove the dependency array.","line":91,"column":6,"nodeType":"ArrayExpression","endLine":91,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [models]","fix":{"range":[2991,2993],"text":"[models]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":11,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useState, useRef } from 'react';\nimport type {\n  FaceLandmarker,\n  HandLandmarker,\n  ObjectDetector,\n  PoseLandmarker,\n  ImageClassifier,\n  GestureRecognizer,\n  ImageSegmenter,\n  ImageEmbedder,\n} from '@mediapipe/tasks-vision';\nimport type { AudioClassifier } from '@mediapipe/tasks-audio';\nimport { loadTask } from '../utils/loadTask';\n\ninterface MediaPipeModels {\n  faceLandmarker: FaceLandmarker | null;\n  handLandmarker: HandLandmarker | null;\n  objectDetector: ObjectDetector | null;\n  poseLandmarker: PoseLandmarker | null;\n  audioClassifier: AudioClassifier | null;\n  imageClassifier: ImageClassifier | null;\n  gestureRecognizer: GestureRecognizer | null;\n  imageSegmenter: ImageSegmenter | null;\n  imageEmbedder: ImageEmbedder | null;\n}\n\ninterface UseMediaPipeModelsResult {\n  models: MediaPipeModels;\n  loading: boolean;\n  error: Error | null;\n}\n\nexport function useMediaPipeModels(): UseMediaPipeModelsResult {\n  const [models, setModels] = useState<MediaPipeModels>({\n    faceLandmarker: null,\n    handLandmarker: null,\n    objectDetector: null,\n    poseLandmarker: null,\n    audioClassifier: null,\n    imageClassifier: null,\n    gestureRecognizer: null,\n    imageSegmenter: null,\n    imageEmbedder: null,\n  });\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<Error | null>(null);\n  const isMounted = useRef(true);\n\n  useEffect(() => {\n    const loadAllModels = async () => {\n      try {\n        setLoading(true);\n        const vision = await import('@mediapipe/tasks-vision');\n        const audio = await import('@mediapipe/tasks-audio');\n\n        const loadedModels: Partial<MediaPipeModels> = {};\n\n        loadedModels.faceLandmarker = await loadTask(vision.FaceLandmarker as any);\n        loadedModels.handLandmarker = await loadTask(vision.HandLandmarker as any);\n        loadedModels.objectDetector = await loadTask(vision.ObjectDetector as any);\n        loadedModels.poseLandmarker = await loadTask(vision.PoseLandmarker as any);\n        loadedModels.audioClassifier = await loadTask(audio.AudioClassifier as any, false);\n        loadedModels.imageClassifier = await loadTask(vision.ImageClassifier as any);\n        loadedModels.gestureRecognizer = await loadTask(vision.GestureRecognizer as any);\n        loadedModels.imageSegmenter = await loadTask(vision.ImageSegmenter as any);\n        loadedModels.imageEmbedder = await loadTask(vision.ImageEmbedder as any);\n\n        if (isMounted.current) {\n          setModels(loadedModels as MediaPipeModels);\n          setLoading(false);\n        }\n      } catch (err: any) {\n        if (isMounted.current) {\n          setError(err);\n          setLoading(false);\n        }\n      }\n    };\n\n    loadAllModels();\n\n    return () => {\n      isMounted.current = false;\n      // Clean up models when component unmounts\n      Object.values(models).forEach(model => {\n        if (model && typeof model.close === 'function') {\n          model.close();\n        }\n      });\n    };\n  }, []); // Empty dependency array ensures this runs once on mount\n\n  return { models, loading, error };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useMemory.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":24,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":24,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[743,746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[743,746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":61,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":61,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1824,1827],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1824,1827],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":89,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":89,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":135,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":135,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":179,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":179,"endColumn":21},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'state' is defined but never used. Allowed unused args must match /^_/u.","line":222,"column":16,"nodeType":null,"messageId":"unusedVar","endLine":222,"endColumn":21}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useMemory.ts\n * \n * React hook for interacting with the MemoryAgent to store and retrieve memories.\n * Provides an easy-to-use interface for components to leverage the memory system.\n */\n\nimport { useCallback, useState } from 'react';\nimport { agentRegistry } from '../agents/registry';\nimport type { Memory, MemoryQuery } from '../agents/MemoryAgent';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n\ninterface UseMemoryOptions {\n  defaultLimit?: number;\n}\n\ninterface UseMemoryResult {\n  // Core memory operations\n  storeMemory: (content: string, options?: {\n    type?: 'fact' | 'preference' | 'interaction' | 'context';\n    tags?: string[];\n    source?: string;\n    confidence?: number;\n    metadata?: Record<string, any>;\n  }) => Promise<Memory | null>;\n  \n  retrieveMemories: (query: MemoryQuery) => Promise<Memory[]>;\n  \n  updateMemory: (id: string, updates: Partial<Memory>) => Promise<Memory | null>;\n  \n  deleteMemory: (id: string) => Promise<boolean>;\n  \n  // Utility functions\n  summarizeMemories: (context: string, limit?: number) => Promise<string>;\n  \n  getRecentMemories: (limit?: number) => Promise<Memory[]>;\n  \n  // State\n  isLoading: boolean;\n  error: string | null;\n  clearError: () => void;\n}\n\nexport const useMemory = (options: UseMemoryOptions = {}): UseMemoryResult => {\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const { defaultLimit = 5 } = options;\n  \n  const setState = useVisionAudioStore(s => s.setState);\n\n  /**\n   * Store a new memory\n   */\n  const storeMemory = useCallback(async (\n    content: string, \n    options: {\n      type?: 'fact' | 'preference' | 'interaction' | 'context';\n      tags?: string[];\n      source?: string;\n      confidence?: number;\n      metadata?: Record<string, any>;\n    } = {}\n  ): Promise<Memory | null> => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const memoryAgent = agentRegistry.getAgent('MemoryAgent');\n      \n      if (!memoryAgent) {\n        throw new Error('MemoryAgent not found in registry');\n      }\n      \n      const result = await memoryAgent.execute({\n        action: 'store',\n        content,\n        type: options.type || 'fact',\n        tags: options.tags || [],\n        source: options.source || 'user_interaction',\n        confidence: options.confidence || 0.9,\n        metadata: options.metadata\n      });\n      \n      if (!result.success) {\n        throw new Error(result.error || 'Failed to store memory');\n      }\n      \n      // Update store with latest memory for context\n      setState(state => ({\n        lastMemoryOperation: {\n          type: 'store',\n          timestamp: Date.now(),\n          memory: result.output\n        }\n      }));\n      \n      return result.output as Memory;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error storing memory';\n      setError(errorMessage);\n      console.error('[useMemory] Error storing memory:', err);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [setState]);\n\n  /**\n   * Retrieve memories based on a query\n   */\n  const retrieveMemories = useCallback(async (query: MemoryQuery): Promise<Memory[]> => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const memoryAgent = agentRegistry.getAgent('MemoryAgent');\n      \n      if (!memoryAgent) {\n        throw new Error('MemoryAgent not found in registry');\n      }\n      \n      const result = await memoryAgent.execute({\n        action: 'retrieve',\n        query: {\n          ...query,\n          limit: query.limit || defaultLimit\n        }\n      });\n      \n      if (!result.success) {\n        throw new Error(result.error || 'Failed to retrieve memories');\n      }\n      \n      // Update store with latest memory operation\n      setState(state => ({\n        lastMemoryOperation: {\n          type: 'retrieve',\n          timestamp: Date.now(),\n          query\n        }\n      }));\n      \n      return result.output as Memory[];\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error retrieving memories';\n      setError(errorMessage);\n      console.error('[useMemory] Error retrieving memories:', err);\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [defaultLimit, setState]);\n\n  /**\n   * Update an existing memory\n   */\n  const updateMemory = useCallback(async (id: string, updates: Partial<Memory>): Promise<Memory | null> => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const memoryAgent = agentRegistry.getAgent('MemoryAgent');\n      \n      if (!memoryAgent) {\n        throw new Error('MemoryAgent not found in registry');\n      }\n      \n      const result = await memoryAgent.execute({\n        action: 'update',\n        id,\n        updates\n      });\n      \n      if (!result.success) {\n        throw new Error(result.error || `Failed to update memory with ID ${id}`);\n      }\n      \n      // Update store with latest memory operation\n      setState(state => ({\n        lastMemoryOperation: {\n          type: 'update',\n          timestamp: Date.now(),\n          memoryId: id\n        }\n      }));\n      \n      return result.output as Memory;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : `Unknown error updating memory ${id}`;\n      setError(errorMessage);\n      console.error(`[useMemory] Error updating memory ${id}:`, err);\n      return null;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [setState]);\n\n  /**\n   * Delete a memory\n   */\n  const deleteMemory = useCallback(async (id: string): Promise<boolean> => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const memoryAgent = agentRegistry.getAgent('MemoryAgent');\n      \n      if (!memoryAgent) {\n        throw new Error('MemoryAgent not found in registry');\n      }\n      \n      const result = await memoryAgent.execute({\n        action: 'delete',\n        id\n      });\n      \n      if (!result.success) {\n        throw new Error(result.error || `Failed to delete memory with ID ${id}`);\n      }\n      \n      // Update store with latest memory operation\n      setState(state => ({\n        lastMemoryOperation: {\n          type: 'delete',\n          timestamp: Date.now(),\n          memoryId: id\n        }\n      }));\n      \n      return result.output as boolean;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : `Unknown error deleting memory ${id}`;\n      setError(errorMessage);\n      console.error(`[useMemory] Error deleting memory ${id}:`, err);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [setState]);\n\n  /**\n   * Get a summary of memories related to a context\n   */\n  const summarizeMemories = useCallback(async (context: string, limit = defaultLimit): Promise<string> => {\n    setIsLoading(true);\n    setError(null);\n    \n    try {\n      const memoryAgent = agentRegistry.getAgent('MemoryAgent');\n      \n      if (!memoryAgent) {\n        throw new Error('MemoryAgent not found in registry');\n      }\n      \n      const result = await memoryAgent.execute({\n        action: 'summarize',\n        context,\n        limit\n      });\n      \n      if (!result.success) {\n        throw new Error(result.error || 'Failed to summarize memories');\n      }\n      \n      return result.output as string;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Unknown error summarizing memories';\n      setError(errorMessage);\n      console.error('[useMemory] Error summarizing memories:', err);\n      return 'Unable to summarize memories at this time.';\n    } finally {\n      setIsLoading(false);\n    }\n  }, [defaultLimit]);\n\n  /**\n   * Get the most recent memories\n   */\n  const getRecentMemories = useCallback(async (limit = defaultLimit): Promise<Memory[]> => {\n    return retrieveMemories({\n      limit,\n      sortBy: 'timestamp'\n    });\n  }, [defaultLimit, retrieveMemories]);\n\n  /**\n   * Clear any errors\n   */\n  const clearError = useCallback(() => {\n    setError(null);\n  }, []);\n\n  return {\n    storeMemory,\n    retrieveMemories,\n    updateMemory,\n    deleteMemory,\n    summarizeMemories,\n    getRecentMemories,\n    isLoading,\n    error,\n    clearError\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useNotifications.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useObjectDetector.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'useRef' is defined but never used. Allowed unused vars must match /^_/u.","line":1,"column":21,"nodeType":null,"messageId":"unusedVar","endLine":1,"endColumn":27},{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'loadTask' is defined but never used. Allowed unused vars must match /^_/u.","line":4,"column":10,"nodeType":null,"messageId":"unusedVar","endLine":4,"endColumn":18},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.","line":48,"column":6,"nodeType":"ArrayExpression","endLine":48,"endColumn":29,"suggestions":[{"desc":"Update the dependencies array to be: [video, objectDetector, setState]","fix":{"range":[1766,1789],"text":"[video, objectDetector, setState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\nimport type { ObjectDetector, ObjectDetectorResult } from '@mediapipe/tasks-vision';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport { loadTask } from '../utils/loadTask';\nimport type { Percept } from '../types';\nimport type { MediaPipeObjectPayload } from '../senses/vision';\n\nexport function useObjectDetector(video?: HTMLVideoElement, objectDetector?: ObjectDetector | null) {\n  const setState = useVisionAudioStore((s) => s.setState);\n\n  useEffect(() => {\n    if (!video || !objectDetector) return;\n    let rafId: number;\n    let frame = 0;\n    const loop = () => {\n      if ((frame++ & 1) === 1) { rafId = requestAnimationFrame(loop); return; }\n      const res: ObjectDetectorResult | undefined = objectDetector.detectForVideo(\n        video,\n        performance.now()\n      );\n      if (res) {\n        setState(state => ({\n          percepts: [\n            ...(state.percepts || []),\n            ...res.detections.map((d): Percept<MediaPipeObjectPayload> => ({\n              modality: 'vision',\n              payload: {\n                type: 'object',\n                boxes: d.boundingBox ? [[\n                  d.boundingBox.originX,\n                  d.boundingBox.originY,\n                  d.boundingBox.originX + d.boundingBox.width,\n                  d.boundingBox.originY + d.boundingBox.height\n                ]] : [],\n                classes: [d.categories[0].categoryName],\n                scores: [d.categories[0].score],\n              },\n              confidence: d.categories[0].score,\n              ts: Date.now(),\n            })),\n          ],\n        }));\n      }\n      rafId = requestAnimationFrame(loop);\n    };\n    loop();\n    return () => cancelAnimationFrame(rafId);\n  }, [video, objectDetector]); // Changed taskRef.current to objectDetector\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\usePhase2.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\usePhase3.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\usePlanTracer.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'TraceStep' is defined but never used. Allowed unused vars must match /^_/u.","line":9,"column":43,"nodeType":null,"messageId":"unusedVar","endLine":9,"endColumn":52}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * usePlanTracer.ts\n * \n * Hook React pour acc├®der aux traces d'ex├®cution du PlannerAgent\n * depuis les composants d'interface utilisateur.\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { planTracer, type PlanTrace, type TraceStep } from '../utils/planTracer';\n\ninterface UsePlanTracerResult {\n  /**\n   * Toutes les traces disponibles\n   */\n  traces: PlanTrace[];\n  \n  /**\n   * Trace actuellement s├®lectionn├®e\n   */\n  selectedTrace: PlanTrace | null;\n  \n  /**\n   * S├®lectionner une trace par son ID\n   */\n  selectTrace: (traceId: string) => void;\n  \n  /**\n   * Obtenir une trace sp├®cifique par son ID\n   */\n  getTrace: (traceId: string) => PlanTrace | null;\n  \n  /**\n   * Supprimer une trace sp├®cifique\n   */\n  deleteTrace: (traceId: string) => void;\n  \n  /**\n   * Nettoyer les traces anciennes\n   */\n  cleanupTraces: () => void;\n  \n  /**\n   * Obtenir des statistiques sur les traces\n   */\n  getTracesStats: () => {\n    total: number;\n    successful: number;\n    failed: number;\n    averageDuration: number;\n    averageStepCount: number;\n  };\n  \n  /**\n   * ├ëtat de chargement\n   */\n  loading: boolean;\n}\n\n/**\n * Hook pour acc├®der aux traces d'ex├®cution des plans\n * \n * @param options - Options de configuration\n * @returns Interface pour interagir avec les traces\n */\nexport function usePlanTracer(options: {\n  refreshInterval?: number;\n  limit?: number;\n} = {}): UsePlanTracerResult {\n  const [traces, setTraces] = useState<PlanTrace[]>([]);\n  const [selectedTrace, setSelectedTrace] = useState<PlanTrace | null>(null);\n  const [loading, setLoading] = useState(true);\n\n  // Configurer les valeurs par d├®faut\n  const refreshInterval = options.refreshInterval || 5000; // 5 secondes\n  const limit = options.limit || 20;\n\n  // Charger et mettre ├á jour les traces\n  const refreshTraces = useCallback(() => {\n    setLoading(true);\n    \n    // R├®cup├®rer les traces r├®centes\n    const recentTraces = planTracer.getRecentTraces(limit);\n    setTraces(recentTraces);\n    \n    // Mettre ├á jour la trace s├®lectionn├®e si elle existe\n    if (selectedTrace) {\n      const updatedTrace = planTracer.getTrace(selectedTrace.id);\n      if (updatedTrace) {\n        setSelectedTrace(updatedTrace);\n      }\n    }\n    \n    setLoading(false);\n  }, [limit, selectedTrace]);\n\n  // S├®lectionner une trace par son ID\n  const selectTrace = useCallback((traceId: string) => {\n    const trace = planTracer.getTrace(traceId);\n    setSelectedTrace(trace);\n  }, []);\n\n  // Obtenir une trace sp├®cifique\n  const getTrace = useCallback((traceId: string) => {\n    return planTracer.getTrace(traceId);\n  }, []);\n\n  // Supprimer une trace\n  const deleteTrace = useCallback((traceId: string) => {\n    const deleted = planTracer.deleteTrace(traceId);\n    if (deleted && selectedTrace?.id === traceId) {\n      setSelectedTrace(null);\n    }\n    \n    // Actualiser la liste\n    refreshTraces();\n  }, [selectedTrace, refreshTraces]);\n\n  // Nettoyer les traces anciennes\n  const cleanupTraces = useCallback(() => {\n    planTracer.cleanup();\n    refreshTraces();\n  }, [refreshTraces]);\n\n  // Calculer des statistiques sur les traces\n  const getTracesStats = useCallback(() => {\n    const total = traces.length;\n    \n    if (total === 0) {\n      return {\n        total: 0,\n        successful: 0,\n        failed: 0,\n        averageDuration: 0,\n        averageStepCount: 0,\n      };\n    }\n    \n    const successful = traces.filter(t => \n      t.steps.some(s => s.operation === 'plan_execution' && s.details.metadata?.success === true)\n    ).length;\n    \n    const failed = total - successful;\n    \n    const durations = traces\n      .filter(t => t.endTime && t.startTime)\n      .map(t => (t.endTime as number) - t.startTime);\n    \n    const averageDuration = durations.length > 0\n      ? durations.reduce((sum, d) => sum + d, 0) / durations.length\n      : 0;\n    \n    const averageStepCount = traces.reduce((sum, t) => sum + t.steps.length, 0) / total;\n    \n    return {\n      total,\n      successful,\n      failed,\n      averageDuration,\n      averageStepCount,\n    };\n  }, [traces]);\n\n  // Configurer l'actualisation p├®riodique\n  useEffect(() => {\n    // Charger les traces initiales\n    refreshTraces();\n    \n    // Configurer l'actualisation p├®riodique\n    const intervalId = setInterval(refreshTraces, refreshInterval);\n    \n    // Nettoyer l'intervalle lors du d├®montage\n    return () => clearInterval(intervalId);\n  }, [refreshInterval, refreshTraces]);\n\n  return {\n    traces,\n    selectedTrace,\n    selectTrace,\n    getTrace,\n    deleteTrace,\n    cleanupTraces,\n    getTracesStats,\n    loading,\n  };\n}\n\nexport default usePlanTracer;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\usePoseLandmarker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useProactiveSuggestions.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":162,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":162,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5091,5094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5091,5094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * hooks/useProactiveSuggestions.ts\n * Hook React pour acc├®der aux suggestions proactives\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { agentRegistry } from '../agents/registry';\nimport { useContextManager } from './useContextManager';\nimport type { ProactiveSuggestionsAgent, Suggestion } from '../agents/ProactiveSuggestionsAgent';\nimport type { ContextItem } from '../context/types';\n\n/**\n * Hook pour acc├®der aux fonctionnalit├®s de suggestions proactives\n */\nexport function useProactiveSuggestions() {\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [suggestions, setSuggestions] = useState<Suggestion[]>([]);\n  \n  // R├®cup├®ration du gestionnaire de contexte\n  const contextManager = useContextManager();\n  \n  /**\n   * R├®cup├¿re l'agent de suggestions proactives\n   */\n  const getSuggestionsAgent = useCallback((): ProactiveSuggestionsAgent => {\n    const agent = agentRegistry.getAgent('Proactive Suggestions');\n    if (!agent) {\n      throw new Error(\"Agent de suggestions proactives non disponible\");\n    }\n    // Cast s├®curis├® car nous v├®rifions que le nom correspond\n    return agent as unknown as ProactiveSuggestionsAgent;\n  }, []);\n\n  /**\n   * G├®n├¿re des suggestions bas├®es sur le contexte actuel\n   */\n  const generateSuggestions = useCallback(async (contextItems?: ContextItem[]): Promise<Suggestion[]> => {\n    try {\n      setIsLoading(true);\n      \n      // Si aucun contexte n'est fourni, r├®cup├®rer le contexte pertinent\n      const context = contextItems || await contextManager.getRelevantContext('suggest_proactive_actions', 10);\n      \n      if (!context || context.length === 0) {\n        throw new Error(\"Aucun contexte disponible pour g├®n├®rer des suggestions\");\n      }\n      \n      const agent = getSuggestionsAgent();\n      const result = await agent.execute({\n        intent: 'generate_suggestions',\n        parameters: { context }\n      });\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la g├®n├®ration des suggestions\");\n      }\n      \n      const newSuggestions = result.output?.suggestions || [];\n      setSuggestions(newSuggestions);\n      \n      return newSuggestions;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [contextManager, getSuggestionsAgent]);\n\n  /**\n   * R├®cup├¿re les suggestions actuelles\n   */\n  const getSuggestions = useCallback(async (): Promise<Suggestion[]> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getSuggestionsAgent();\n      const result = await agent.execute({\n        intent: 'get_suggestions'\n      });\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la r├®cup├®ration des suggestions\");\n      }\n      \n      const currentSuggestions = result.output?.suggestions || [];\n      setSuggestions(currentSuggestions);\n      \n      return currentSuggestions;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSuggestionsAgent]);\n\n  /**\n   * Ignore une suggestion sp├®cifique\n   */\n  const dismissSuggestion = useCallback(async (suggestionId: string): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getSuggestionsAgent();\n      const result = await agent.execute({\n        intent: 'dismiss_suggestion',\n        parameters: { suggestionId }\n      });\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la suppression de la suggestion\");\n      }\n      \n      // Met ├á jour l'├®tat local\n      setSuggestions(prev => prev.filter(s => s.id !== suggestionId || s.dismissed === true));\n      \n      return true;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSuggestionsAgent]);\n\n  /**\n   * Supprime toutes les suggestions\n   */\n  const clearAllSuggestions = useCallback(async (): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getSuggestionsAgent();\n      const result = await agent.execute({\n        intent: 'clear_suggestions'\n      });\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la suppression des suggestions\");\n      }\n      \n      // Met ├á jour l'├®tat local\n      setSuggestions([]);\n      \n      return true;\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSuggestionsAgent]);\n\n  /**\n   * Ex├®cute une suggestion sp├®cifique\n   */\n  const executeSuggestion = useCallback(async (suggestionId: string): Promise<{\n    success: boolean;\n    intent?: string;\n    parameters?: Record<string, any>;\n  }> => {\n    try {\n      setIsLoading(true);\n      \n      const agent = getSuggestionsAgent();\n      const result = await agent.execute({\n        intent: 'execute_suggestion',\n        parameters: { suggestionId }\n      });\n      \n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'ex├®cution de la suggestion\");\n      }\n      \n      // Met ├á jour l'├®tat local\n      setSuggestions(prev => prev.filter(s => s.id !== suggestionId || s.dismissed === true));\n      \n      return {\n        success: true,\n        intent: result.output?.intent,\n        parameters: result.output?.parameters\n      };\n    } catch (err) {\n      setError(err instanceof Error ? err.message : String(err));\n      return { success: false };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSuggestionsAgent]);\n\n  /**\n   * Rafra├«chit p├®riodiquement les suggestions\n   */\n  useEffect(() => {\n    // G├®n├¿re des suggestions initiales\n    void getSuggestions();\n\n    // Rafra├«chit les suggestions toutes les 5 minutes\n    const refreshInterval = setInterval(() => {\n      void generateSuggestions();\n    }, 5 * 60 * 1000);\n\n    return () => clearInterval(refreshInterval);\n  }, [getSuggestions, generateSuggestions]);\n\n  return {\n    // ├ëtat\n    suggestions,\n    isLoading,\n    error,\n    \n    // Actions\n    generateSuggestions,\n    getSuggestions,\n    dismissSuggestion,\n    clearAllSuggestions,\n    executeSuggestion,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useRobot.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":28,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":28,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[952,955],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[952,955],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Hook React pour l'interaction avec l'API robot\n */\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { type RobotCommand, type RobotStatus } from '../api/services/rosBridgeService.js';\n\ninterface UseRobotReturn {\n  // ├ëtat\n  status: RobotStatus | null;\n  isConnected: boolean;\n  isLoading: boolean;\n  error: string | null;\n  \n  // Actions\n  moveRobot: (command: RobotCommand) => Promise<boolean>;\n  sayText: (text: string, language?: string) => Promise<boolean>;\n  setGoal: (x: number, y: number, theta?: number) => Promise<boolean>;\n  emergencyStop: () => Promise<boolean>;\n  refreshStatus: () => Promise<void>;\n}\n\nexport const useRobot = (): UseRobotReturn => {\n  const [status, setStatus] = useState<RobotStatus | null>(null);\n  const [isLoading, setIsLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const apiCall = useCallback(async (endpoint: string, method: string = 'GET', body?: any) => {\n    const token = localStorage.getItem('authToken');\n    if (!token) {\n      throw new Error('Token d\\'authentification manquant');\n    }\n\n    const response = await fetch(`/api/robot${endpoint}`, {\n      method,\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${token}`\n      },\n      body: body ? JSON.stringify(body) : undefined\n    });\n\n    if (!response.ok) {\n      const errorData = await response.json();\n      throw new Error(errorData.error || `Erreur HTTP ${response.status}`);\n    }\n\n    return response.json();\n  }, []);\n\n  const moveRobot = useCallback(async (command: RobotCommand): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const result = await apiCall('/move', 'POST', command);\n      return result.success;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erreur inconnue';\n      setError(errorMessage);\n      console.error('Erreur moveRobot:', errorMessage);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [apiCall]);\n\n  const sayText = useCallback(async (text: string, language: string = 'fr'): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const result = await apiCall('/say', 'POST', { text, language });\n      return result.success;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erreur inconnue';\n      setError(errorMessage);\n      console.error('Erreur sayText:', errorMessage);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [apiCall]);\n\n  const setGoal = useCallback(async (x: number, y: number, theta: number = 0): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const result = await apiCall('/goal', 'POST', { x, y, theta });\n      return result.success;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erreur inconnue';\n      setError(errorMessage);\n      console.error('Erreur setGoal:', errorMessage);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [apiCall]);\n\n  const emergencyStop = useCallback(async (): Promise<boolean> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const result = await apiCall('/stop', 'POST');\n      return result.success;\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erreur inconnue';\n      setError(errorMessage);\n      console.error('Erreur emergencyStop:', errorMessage);\n      return false;\n    } finally {\n      setIsLoading(false);\n    }\n  }, [apiCall]);\n\n  const refreshStatus = useCallback(async (): Promise<void> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n      \n      const result = await apiCall('/status');\n      if (result.success) {\n        setStatus(result.data.robot);\n      }\n    } catch (err) {\n      const errorMessage = err instanceof Error ? err.message : 'Erreur inconnue';\n      setError(errorMessage);\n      console.error('Erreur refreshStatus:', errorMessage);\n    } finally {\n      setIsLoading(false);\n    }\n  }, [apiCall]);\n\n  // Rafra├«chir le statut p├®riodiquement\n  useEffect(() => {\n    refreshStatus();\n    \n    const interval = setInterval(refreshStatus, 5000); // Toutes les 5 secondes\n    \n    return () => clearInterval(interval);\n  }, [refreshStatus]);\n\n  return {\n    status,\n    isConnected: status?.connected || false,\n    isLoading,\n    error,\n    moveRobot,\n    sayText,\n    setGoal,\n    emergencyStop,\n    refreshStatus\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useScheduler.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":54,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":57,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1830,1833],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1830,1833],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":56,"column":71,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":56,"endColumn":74,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1847,1850],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1847,1850],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":78,"column":55,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":78,"endColumn":58,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2519,2522],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2519,2522],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useScheduler - Hook for interacting with SchedulerAgent\n */\n\nimport { useState, useCallback } from 'react';\nimport { agentRegistry } from '../agents/registry';\n\nexport const useScheduler = () => {\n  const [loading, setLoading] = useState(false);\n  const [error, setError] = useState<string | null>(null);\n\n  const findAvailability = useCallback(async (startDate: Date, endDate: Date, duration: number = 60) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const agent = agentRegistry.getAgent('SchedulerAgent');\n      if (!agent) throw new Error('SchedulerAgent not found');\n      \n      const result = await agent.execute({\n        intent: 'find_availability',\n        parameters: { startDate, endDate, duration }\n      });\n      \n      setLoading(false);\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Availability check failed';\n      setError(errorMsg);\n      setLoading(false);\n      return { success: false, output: null, error: errorMsg };\n    }\n  }, []);\n\n  const suggestTime = useCallback(async (purpose: string, duration: number = 60, preferredTimeOfDay?: string) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const agent = agentRegistry.getAgent('SchedulerAgent');\n      if (!agent) throw new Error('SchedulerAgent not found');\n      \n      const result = await agent.execute({\n        intent: 'suggest_time',\n        parameters: { purpose, duration, preferredTimeOfDay }\n      });\n      \n      setLoading(false);\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Time suggestion failed';\n      setError(errorMsg);\n      setLoading(false);\n      return { success: false, output: null, error: errorMsg };\n    }\n  }, []);\n\n  const detectConflicts = useCallback(async (events: any[], newEvent: any) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const agent = agentRegistry.getAgent('SchedulerAgent');\n      if (!agent) throw new Error('SchedulerAgent not found');\n      \n      const result = await agent.execute({\n        intent: 'detect_conflicts',\n        parameters: { events, newEvent }\n      });\n      \n      setLoading(false);\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Conflict detection failed';\n      setError(errorMsg);\n      setLoading(false);\n      return { success: false, output: null, error: errorMsg };\n    }\n  }, []);\n\n  const optimizeSchedule = useCallback(async (events: any[]) => {\n    setLoading(true);\n    setError(null);\n    try {\n      const agent = agentRegistry.getAgent('SchedulerAgent');\n      if (!agent) throw new Error('SchedulerAgent not found');\n      \n      const result = await agent.execute({\n        intent: 'optimize_schedule',\n        parameters: { events }\n      });\n      \n      setLoading(false);\n      return result;\n    } catch (err) {\n      const errorMsg = err instanceof Error ? err.message : 'Schedule optimization failed';\n      setError(errorMsg);\n      setLoading(false);\n      return { success: false, output: null, error: errorMsg };\n    }\n  }, []);\n\n  return {\n    loading,\n    error,\n    findAvailability,\n    suggestTime,\n    detectConflicts,\n    optimizeSchedule\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useSecurity.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useSilenceTriggers.ts","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'config' object makes the dependencies of useCallback Hook (at line 75) change on every render. To fix this, wrap the initialization of 'config' in its own useMemo() Hook.","line":36,"column":9,"nodeType":"VariableDeclarator","endLine":39,"endColumn":4}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * hooks/useSilenceTriggers.ts\n * Hook pour la d├®tection des p├®riodes de silence et le d├®clenchement d'actions proactives\n */\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n\n// Configuration par d├®faut pour les d├®clencheurs de silence\nexport interface SilenceTriggerOptions {\n  // Dur├®e de silence (en ms) avant de d├®clencher une action proactive\n  silenceThreshold: number;\n  // Intervalle (en ms) pour v├®rifier les p├®riodes de silence\n  checkInterval: number;\n  // Callback ├á ex├®cuter quand un silence est d├®tect├®\n  onSilenceDetected?: () => void;\n  // Si true, red├®marre le compteur apr├¿s un d├®clenchement\n  resetAfterTrigger: boolean;\n}\n\nconst DEFAULT_OPTIONS: SilenceTriggerOptions = {\n  silenceThreshold: 30000, // 30 secondes par d├®faut\n  checkInterval: 5000,     // V├®rification toutes les 5 secondes\n  resetAfterTrigger: true,\n};\n\n/**\n * Hook pour la d├®tection des p├®riodes de silence et le d├®clenchement d'actions proactives\n */\nexport function useSilenceTriggers(options: Partial<SilenceTriggerOptions> = {}) {\n  const [isSilent, setIsSilent] = useState<boolean>(false);\n  const [silenceDuration, setSilenceDuration] = useState<number>(0);\n  const [isActive, setIsActive] = useState<boolean>(true);\n  \n  // Combine les options par d├®faut avec les options fournies\n  const config = {\n    ...DEFAULT_OPTIONS,\n    ...options,\n  };\n  \n  // S├®lecteurs cibl├®s du store\n  const lastSilenceMs = useVisionAudioStore((s) => s.lastSilenceMs);\n  const speechDetected = useVisionAudioStore((s) => s.speechDetected);\n  const setState = useVisionAudioStore((s) => s.setState);\n  \n  /**\n   * V├®rifier le temps ├®coul├® depuis la derni├¿re interaction audio\n   */\n  const checkSilence = useCallback(() => {\n    if (!isActive) return;\n    \n    const now = Date.now();\n    const lastInteraction = lastSilenceMs;\n    const elapsed = now - lastInteraction;\n    \n    setSilenceDuration(elapsed);\n    \n    // Si le seuil de silence est d├®pass├® et qu'on n'est pas d├®j├á en ├®tat de silence\n    if (elapsed >= config.silenceThreshold && !isSilent) {\n      setIsSilent(true);\n      \n      // Ex├®cute le callback si d├®fini\n      if (config.onSilenceDetected) {\n        config.onSilenceDetected();\n      }\n      \n      // R├®initialise le compteur si configur├® ainsi\n      if (config.resetAfterTrigger) {\n        setState({ lastSilenceMs: now });\n      }\n    } else if (elapsed < config.silenceThreshold && isSilent) {\n      // L'utilisateur a interagi, on n'est plus en ├®tat de silence\n      setIsSilent(false);\n    }\n  }, [config, isSilent, isActive, lastSilenceMs, setState]);\n  \n  /**\n   * D├®marre la d├®tection de silence\n   */\n  const startSilenceDetection = useCallback(() => {\n    setIsActive(true);\n  }, []);\n  \n  /**\n   * Arr├¬te la d├®tection de silence\n   */\n  const stopSilenceDetection = useCallback(() => {\n    setIsActive(false);\n    setIsSilent(false);\n  }, []);\n  \n  /**\n   * R├®initialise manuellement le compteur de silence\n   */\n  const resetSilenceTimer = useCallback(() => {\n    const now = Date.now();\n    setState({ lastSilenceMs: now });\n    setSilenceDuration(0);\n    setIsSilent(false);\n  }, [setState]);\n  \n  // Effet pour configurer la v├®rification p├®riodique du silence\n  useEffect(() => {\n    // V├®rification initiale\n    checkSilence();\n    \n    // V├®rification p├®riodique\n    const interval = setInterval(checkSilence, config.checkInterval);\n    \n    // Nettoyage ├á la destruction du composant\n    return () => clearInterval(interval);\n  }, [checkSilence, config.checkInterval]);\n  \n  // Effet pour r├®initialiser le compteur de silence quand l'utilisateur parle\n  useEffect(() => {\n    if (speechDetected) {\n      resetSilenceTimer();\n    }\n  }, [speechDetected, resetSilenceTimer]);\n  \n  return {\n    // ├ëtat\n    isSilent,\n    silenceDuration,\n    isActive,\n    \n    // Propri├®t├®s\n    silenceThreshold: config.silenceThreshold,\n    \n    // Actions\n    startSilenceDetection,\n    stopSilenceDetection,\n    resetSilenceTimer,\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useSmallTalk.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useSpeechResponder.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useSpeechSynthesis.temp.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[983,986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[983,986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useSpeechSynthesis - Hook pour la synth├¿se vocale\n * \n * Ce hook permet d'acc├®der facilement aux fonctionnalit├®s de synth├¿se vocale\n * pour communiquer verbalement avec l'utilisateur et d'autres assistants.\n */\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport { agentRegistry } from '../agents/registry';\nimport type { VoiceSettings, SpeechSynthesisIntent, SpeechFormat } from '../agents/SpeechSynthesisAgent';\n\nexport interface SpeechSynthesisOptions {\n  autoStart?: boolean;\n  language?: string;\n  voice?: string;\n  rate?: number;\n  pitch?: number;\n  volume?: number;\n}\n\nexport type SpeechState = 'idle' | 'speaking' | 'paused' | 'error';\n\nexport const useSpeechSynthesis = (options: SpeechSynthesisOptions = {}) => {\n  const [state, setState] = useState<SpeechState>('idle');\n  const [error, setError] = useState<Error | null>(null);\n  const [availableVoices, setAvailableVoices] = useState<any[]>([]);\n  const [currentSettings, setCurrentSettings] = useState<VoiceSettings>({\n    voice: options.voice || '',\n    rate: options.rate || 1.0,\n    pitch: options.pitch || 1.0,\n    volume: options.volume || 1.0,\n    lang: options.language || 'fr-FR'\n  });\n\n  const audioEnabled = useVisionAudioStore((state) => state.audioEnabled);\n  const setLastSpokenText = useVisionAudioStore((state) => state.setLastSpokenText);\n\n  /**\n   * Initialise la synth├¿se vocale et charge les voix disponibles\n   */\n  useEffect(() => {\n    const initVoices = async () => {\n      try {\n        const registry = agentRegistry;\n        const agent = registry.getAgent('SpeechSynthesisAgent');\n        \n        if (agent) {\n          const result = await agent.execute({\n            intent: 'get_voices' as SpeechSynthesisIntent,\n            parameters: {}\n          });\n          \n          if (result.success && result.output.voices) {\n            setAvailableVoices(result.output.voices);\n            \n            // Mettre ├á jour la voix courante si ce n'est pas d├®j├á fait\n            if (!currentSettings.voice && result.output.currentVoice) {\n              setCurrentSettings(prev => ({\n                ...prev,\n                voice: result.output.currentVoice\n              }));\n            }\n          } else {\n            console.warn('Failed to get voices:', result.error);\n          }\n        }\n      } catch (err) {\n        console.error('Error initializing speech synthesis:', err);\n        setError(err instanceof Error ? err : new Error('Failed to initialize speech synthesis'));\n      }\n    };\n\n    initVoices();\n  }, [currentSettings]);\n\n  /**\n   * Convertit le texte en parole\n   */\n  const speak = useCallback(async (\n    text: string,\n    speakOptions: {\n      settings?: Partial<VoiceSettings>;\n      format?: SpeechFormat;\n    } = {}\n  ) => {\n    // Ne rien faire si l'audio est d├®sactiv├®\n    if (!audioEnabled) return { success: false, reason: 'audio_disabled' };\n\n    try {\n      setState('speaking');\n      setError(null);\n      setLastSpokenText(text);\n      \n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (!agent) {\n        throw new Error('SpeechSynthesisAgent not registered');\n      }\n      \n      const mergedSettings = {\n        ...currentSettings,\n        ...speakOptions.settings\n      };\n      \n      const result = await agent.execute({\n        intent: 'speak' as SpeechSynthesisIntent,\n        parameters: {\n          text,\n          settings: mergedSettings,\n          format: speakOptions.format || 'text'\n        }\n      });\n      \n      if (!result.success) {\n        throw result.error || new Error('Failed to speak');\n      }\n      \n      return result;\n    } catch (err) {\n      console.error('Speech synthesis error:', err);\n      setState('error');\n      setError(err instanceof Error ? err : new Error('Unknown speech synthesis error'));\n      return { success: false, error: err };\n    }\n  }, [audioEnabled, currentSettings, setLastSpokenText]);\n\n  /**\n   * Arr├¬te la parole en cours\n   */\n  const stop = useCallback(async () => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'stop_speaking' as SpeechSynthesisIntent,\n          parameters: {}\n        });\n        \n        if (result.success) {\n          setState('idle');\n          return true;\n        }\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Failed to stop speaking:', err);\n      return false;\n    }\n  }, []);\n\n  /**\n   * V├®rifie si la synth├¿se vocale est en cours\n   */\n  const checkSpeaking = useCallback(async () => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'is_speaking' as SpeechSynthesisIntent,\n          parameters: {}\n        });\n        \n        if (result.success) {\n          setState(result.output.speaking ? 'speaking' : 'idle');\n          return result.output.speaking;\n        }\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Failed to check speaking status:', err);\n      return false;\n    }\n  }, []);\n\n  /**\n   * Met ├á jour les param├¿tres de voix\n   */\n  const updateSettings = useCallback(async (settings: Partial<VoiceSettings>) => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'update_settings' as SpeechSynthesisIntent,\n          parameters: {\n            settings\n          }\n        });\n        \n        if (result.success) {\n          setCurrentSettings(result.output.settings);\n          return true;\n        }\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Failed to update voice settings:', err);\n      setError(err instanceof Error ? err : new Error('Failed to update voice settings'));\n      return false;\n    }\n  }, []);\n\n  /**\n   * R├®cup├¿re les voix disponibles pour une langue sp├®cifique\n   */\n  const getVoices = useCallback(async (lang?: string) => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'get_voices' as SpeechSynthesisIntent,\n          parameters: {\n            lang\n          }\n        });\n        \n        if (result.success) {\n          setAvailableVoices(result.output.voices);\n          return result.output.voices;\n        }\n      }\n      \n      return [];\n    } catch (err) {\n      console.error('Failed to get voices:', err);\n      return [];\n    }\n  }, []);\n\n  return {\n    speak,\n    stop,\n    checkSpeaking,\n    updateSettings,\n    getVoices,\n    state,\n    error,\n    availableVoices,\n    currentSettings\n  };\n};\n\nexport default useSpeechSynthesis;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useSpeechSynthesis.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[983,986],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[983,986],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useSpeechSynthesis - Hook pour la synth├¿se vocale\n * \n * Ce hook permet d'acc├®der facilement aux fonctionnalit├®s de synth├¿se vocale\n * pour communiquer verbalement avec l'utilisateur et d'autres assistants.\n */\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\nimport { agentRegistry } from '../agents/registry';\nimport type { VoiceSettings, SpeechSynthesisIntent, SpeechFormat } from '../agents/SpeechSynthesisAgent';\n\nexport interface SpeechSynthesisOptions {\n  autoStart?: boolean;\n  language?: string;\n  voice?: string;\n  rate?: number;\n  pitch?: number;\n  volume?: number;\n}\n\nexport type SpeechState = 'idle' | 'speaking' | 'paused' | 'error';\n\nexport const useSpeechSynthesis = (options: SpeechSynthesisOptions = {}) => {\n  const [state, setState] = useState<SpeechState>('idle');\n  const [error, setError] = useState<Error | null>(null);\n  const [availableVoices, setAvailableVoices] = useState<any[]>([]);\n  const [currentSettings, setCurrentSettings] = useState<VoiceSettings>({\n    voice: options.voice || '',\n    rate: options.rate || 1.0,\n    pitch: options.pitch || 1.0,\n    volume: options.volume || 1.0,\n    lang: options.language || 'fr-FR'\n  });\n\n  const audioEnabled = useVisionAudioStore((state) => state.audioEnabled);\n\n  /**\n   * Initialise la synth├¿se vocale et charge les voix disponibles\n   */\n  useEffect(() => {\n    const initVoices = async () => {\n      try {\n        const registry = agentRegistry;\n        const agent = registry.getAgent('SpeechSynthesisAgent');\n        \n        if (agent) {\n          const result = await agent.execute({\n            intent: 'get_voices' as SpeechSynthesisIntent,\n            parameters: {}\n          });\n          \n          if (result.success && result.output.voices) {\n            setAvailableVoices(result.output.voices);\n            \n            // Mettre ├á jour la voix courante si ce n'est pas d├®j├á fait\n            if (result.output.currentVoice) {\n              setCurrentSettings(prev => {\n                // Ne mettre ├á jour que si la voix n'est pas d├®j├á d├®finie\n                if (!prev.voice) {\n                  return {\n                    ...prev,\n                    voice: result.output.currentVoice\n                  };\n                }\n                return prev;\n              });\n            }\n          } else {\n            console.warn('Failed to get voices:', result.error);\n          }\n        }\n      } catch (err) {\n        console.error('Error initializing speech synthesis:', err);\n        setError(err instanceof Error ? err : new Error('Failed to initialize speech synthesis'));\n      }\n    };\n\n    initVoices();\n  }, []); // Ex├®cuter une seule fois au montage\n\n  /**\n   * Convertit le texte en parole\n   */\n  const speak = useCallback(async (\n    text: string,\n    speakOptions: {\n      settings?: Partial<VoiceSettings>;\n      format?: SpeechFormat;\n    } = {}\n  ) => {\n    // Ne rien faire si l'audio est d├®sactiv├®\n    if (!audioEnabled) return { success: false, reason: 'audio_disabled' };\n\n    try {\n      setState('speaking');\n      setError(null);\n\n      // Trigger MetaHuman speech animation (lazy loaded)\n      const metaHumanAgent = agentRegistry.getAgent('MetaHumanAgent');\n      if (metaHumanAgent) {\n        await metaHumanAgent.execute({\n          intent: 'animate_speech',\n          parameters: { text: text, duration: text.length * 0.08 } // Estimate duration for animation\n        });\n      }\n      \n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (!agent) {\n        throw new Error('SpeechSynthesisAgent not registered');\n      }\n      \n      const mergedSettings = {\n        ...currentSettings,\n        ...speakOptions.settings\n      };\n      \n      const result = await agent.execute({\n        intent: 'speak' as SpeechSynthesisIntent,\n        parameters: {\n          text,\n          settings: mergedSettings,\n          format: speakOptions.format || 'text'\n        }\n      });\n      \n      if (!result.success) {\n        throw result.error || new Error('Failed to speak');\n      }\n      \n      return result;\n    } catch (err) {\n      console.error('Speech synthesis error:', err);\n      setState('error');\n      setError(err instanceof Error ? err : new Error('Unknown speech synthesis error'));\n      return { success: false, error: err };\n    }\n  }, [audioEnabled, currentSettings]);\n\n  /**\n   * Arr├¬te la parole en cours\n   */\n  const stop = useCallback(async () => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'stop_speaking' as SpeechSynthesisIntent,\n          parameters: {}\n        });\n        \n        if (result.success) {\n          setState('idle');\n          return true;\n        }\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Failed to stop speaking:', err);\n      return false;\n    }\n  }, []);\n\n  /**\n   * V├®rifie si la synth├¿se vocale est en cours\n   */\n  const checkSpeaking = useCallback(async () => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'is_speaking' as SpeechSynthesisIntent,\n          parameters: {}\n        });\n        \n        if (result.success) {\n          setState(result.output.speaking ? 'speaking' : 'idle');\n          return result.output.speaking;\n        }\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Failed to check speaking status:', err);\n      return false;\n    }\n  }, []);\n\n  /**\n   * Met ├á jour les param├¿tres de voix\n   */\n  const updateSettings = useCallback(async (settings: Partial<VoiceSettings>) => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'update_settings' as SpeechSynthesisIntent,\n          parameters: {\n            settings\n          }\n        });\n        \n        if (result.success) {\n          setCurrentSettings(result.output.settings);\n          return true;\n        }\n      }\n      \n      return false;\n    } catch (err) {\n      console.error('Failed to update voice settings:', err);\n      setError(err instanceof Error ? err : new Error('Failed to update voice settings'));\n      return false;\n    }\n  }, []);\n\n  /**\n   * R├®cup├¿re les voix disponibles pour une langue sp├®cifique\n   */\n  const getVoices = useCallback(async (lang?: string) => {\n    try {\n      const registry = agentRegistry;\n      const agent = registry.getAgent('SpeechSynthesisAgent');\n      \n      if (agent) {\n        const result = await agent.execute({\n          intent: 'get_voices' as SpeechSynthesisIntent,\n          parameters: {\n            lang\n          }\n        });\n        \n        if (result.success) {\n          setAvailableVoices(result.output.voices);\n          return result.output.voices;\n        }\n      }\n      \n      return [];\n    } catch (err) {\n      console.error('Failed to get voices:', err);\n      return [];\n    }\n  }, []);\n\n  return {\n    speak,\n    stop,\n    checkSpeaking,\n    updateSettings,\n    getVoices,\n    state,\n    error,\n    availableVoices,\n    currentSettings\n  };\n};\n\nexport default useSpeechSynthesis;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useSystemIntegration.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":20,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":20,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[584,587],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[584,587],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":70,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":73,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[966,969],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[966,969],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'listIntegrations'. Either include it or remove the dependency array.","line":102,"column":6,"nodeType":"ArrayExpression","endLine":102,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [getSystemIntegrationAgent, listIntegrations]","fix":{"range":[3179,3206],"text":"[getSystemIntegrationAgent, listIntegrations]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3355,3358],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3355,3358],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'listIntegrations'. Either include it or remove the dependency array.","line":226,"column":6,"nodeType":"ArrayExpression","endLine":226,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [getSystemIntegrationAgent, listIntegrations]","fix":{"range":[6534,6561],"text":"[getSystemIntegrationAgent, listIntegrations]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'listIntegrations'. Either include it or remove the dependency array.","line":271,"column":6,"nodeType":"ArrayExpression","endLine":271,"endColumn":33,"suggestions":[{"desc":"Update the dependencies array to be: [getSystemIntegrationAgent, listIntegrations]","fix":{"range":[7694,7721],"text":"[getSystemIntegrationAgent, listIntegrations]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * hooks/useSystemIntegration.ts\n * \n * Hook React pour g├®rer les int├®grations syst├¿me\n * Permet de cr├®er, ex├®cuter et g├®rer des int├®grations avec des syst├¿mes externes\n */\n\nimport { useState, useCallback, useEffect } from 'react';\nimport { agentRegistry } from '../agents/AgentRegistry';\nimport { toast } from 'sonner';\nimport type { \n  SystemIntegrationConfig, \n  SystemIntegrationType \n} from '../agents/SystemIntegrationAgent';\n\n// Interface pour les r├®sultats des op├®rations d'int├®gration\nexport interface IntegrationResult {\n  success: boolean;\n  message?: string;\n  data?: any;\n  error?: string;\n}\n\n// Interface du hook d'int├®gration syst├¿me\nexport interface SystemIntegrationHook {\n  // ├ëtat\n  isLoading: boolean;\n  error: string | null;\n  integrations: SystemIntegrationConfig[];\n  \n  // Actions\n  registerIntegration: (config: SystemIntegrationConfig) => Promise<IntegrationResult>;\n  executeIntegration: (integrationId: string, params: Record<string, any>) => Promise<IntegrationResult>;\n  listIntegrations: (type?: SystemIntegrationType) => Promise<SystemIntegrationConfig[]>;\n  updateIntegration: (integrationId: string, updates: Partial<SystemIntegrationConfig>) => Promise<IntegrationResult>;\n  deleteIntegration: (integrationId: string) => Promise<IntegrationResult>;\n  testIntegration: (integrationId: string) => Promise<IntegrationResult>;\n}\n\n/**\n * Hook pour g├®rer les int├®grations syst├¿me\n */\nexport const useSystemIntegration = (): SystemIntegrationHook => {\n  const [isLoading, setIsLoading] = useState<boolean>(false);\n  const [error, setError] = useState<string | null>(null);\n  const [integrations, setIntegrations] = useState<SystemIntegrationConfig[]>([]);\n\n  /**\n   * Obtenir l'agent d'int├®gration syst├¿me\n   */\n  const getSystemIntegrationAgent = useCallback(() => {\n    const agent = agentRegistry.getAgent('System Integration Agent');\n    if (!agent) {\n      throw new Error(\"Agent d'int├®gration syst├¿me non disponible\");\n    }\n    return agent;\n  }, []);\n\n  /**\n   * Enregistrer une nouvelle int├®gration\n   */\n  const registerIntegration = useCallback(async (\n    config: SystemIntegrationConfig\n  ): Promise<IntegrationResult> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const agent = getSystemIntegrationAgent();\n\n      const result = await agent.execute({\n        intent: 'register_integration',\n        parameters: { config }\n      });\n\n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'enregistrement de l'int├®gration\");\n      }\n\n      // Rafra├«chir la liste des int├®grations\n      void listIntegrations();\n\n      toast.success(`Int├®gration \"${config.name}\" enregistr├®e avec succ├¿s!`);\n\n      return {\n        success: true,\n        message: result.output?.message || `Int├®gration \"${config.name}\" enregistr├®e avec succ├¿s`,\n        data: result.output\n      };\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      toast.error(`Erreur: ${errMsg}`);\n      \n      return {\n        success: false,\n        error: errMsg\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSystemIntegrationAgent]);\n\n  /**\n   * Ex├®cuter une int├®gration\n   */\n  const executeIntegration = useCallback(async (\n    integrationId: string,\n    params: Record<string, any>\n  ): Promise<IntegrationResult> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const agent = getSystemIntegrationAgent();\n\n      const result = await agent.execute({\n        intent: 'execute_integration',\n        parameters: { integrationId, params }\n      });\n\n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'ex├®cution de l'int├®gration\");\n      }\n\n      toast.success(`Int├®gration ex├®cut├®e avec succ├¿s!`);\n\n      return {\n        success: true,\n        message: result.output?.message || \"Int├®gration ex├®cut├®e avec succ├¿s\",\n        data: result.output?.result\n      };\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      toast.error(`Erreur: ${errMsg}`);\n      \n      return {\n        success: false,\n        error: errMsg\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSystemIntegrationAgent]);\n\n  /**\n   * Lister les int├®grations\n   */\n  const listIntegrations = useCallback(async (\n    type?: SystemIntegrationType\n  ): Promise<SystemIntegrationConfig[]> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const agent = getSystemIntegrationAgent();\n\n      const result = await agent.execute({\n        intent: 'list_integrations',\n        parameters: type ? { type } : {}\n      });\n\n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la r├®cup├®ration des int├®grations\");\n      }\n\n      const integrationsList = result.output?.integrations || [];\n      setIntegrations(integrationsList);\n\n      return integrationsList;\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      console.error(`Erreur lors de la r├®cup├®ration des int├®grations: ${errMsg}`);\n      return [];\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSystemIntegrationAgent]);\n\n  /**\n   * Mettre ├á jour une int├®gration\n   */\n  const updateIntegration = useCallback(async (\n    integrationId: string,\n    updates: Partial<SystemIntegrationConfig>\n  ): Promise<IntegrationResult> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const agent = getSystemIntegrationAgent();\n\n      const result = await agent.execute({\n        intent: 'update_integration',\n        parameters: { integrationId, updates }\n      });\n\n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la mise ├á jour de l'int├®gration\");\n      }\n\n      // Rafra├«chir la liste des int├®grations\n      void listIntegrations();\n\n      toast.success(`Int├®gration mise ├á jour avec succ├¿s!`);\n\n      return {\n        success: true,\n        message: result.output?.message || \"Int├®gration mise ├á jour avec succ├¿s\",\n        data: result.output\n      };\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      toast.error(`Erreur: ${errMsg}`);\n      \n      return {\n        success: false,\n        error: errMsg\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSystemIntegrationAgent]);\n\n  /**\n   * Supprimer une int├®gration\n   */\n  const deleteIntegration = useCallback(async (\n    integrationId: string\n  ): Promise<IntegrationResult> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const agent = getSystemIntegrationAgent();\n\n      const result = await agent.execute({\n        intent: 'delete_integration',\n        parameters: { integrationId }\n      });\n\n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la suppression de l'int├®gration\");\n      }\n\n      // Rafra├«chir la liste des int├®grations\n      void listIntegrations();\n\n      toast.success(`Int├®gration supprim├®e avec succ├¿s!`);\n\n      return {\n        success: true,\n        message: result.output?.message || \"Int├®gration supprim├®e avec succ├¿s\",\n        data: result.output\n      };\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      toast.error(`Erreur: ${errMsg}`);\n      \n      return {\n        success: false,\n        error: errMsg\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSystemIntegrationAgent]);\n\n  /**\n   * Tester une int├®gration\n   */\n  const testIntegration = useCallback(async (\n    integrationId: string\n  ): Promise<IntegrationResult> => {\n    try {\n      setIsLoading(true);\n      setError(null);\n\n      const agent = getSystemIntegrationAgent();\n\n      const result = await agent.execute({\n        intent: 'test_integration',\n        parameters: { integrationId }\n      });\n\n      if (!result.success) {\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec du test de l'int├®gration\");\n      }\n\n      toast.success(`Test d'int├®gration r├®ussi!`);\n\n      return {\n        success: true,\n        message: result.output?.message || \"Test d'int├®gration r├®ussi\",\n        data: result.output?.testResult\n      };\n    } catch (err) {\n      const errMsg = err instanceof Error ? err.message : String(err);\n      setError(errMsg);\n      toast.error(`Erreur de test: ${errMsg}`);\n      \n      return {\n        success: false,\n        error: errMsg\n      };\n    } finally {\n      setIsLoading(false);\n    }\n  }, [getSystemIntegrationAgent]);\n\n  // Initialisation: charger les int├®grations existantes\n  useEffect(() => {\n    void listIntegrations();\n  }, [listIntegrations]);\n\n  return {\n    // ├ëtat\n    isLoading,\n    error,\n    integrations,\n    \n    // Actions\n    registerIntegration,\n    executeIntegration,\n    listIntegrations,\n    updateIntegration,\n    deleteIntegration,\n    testIntegration\n  };\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useTranslation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useUnrealEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":16,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":19,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[623,626],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[623,626],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":247,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":247,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7155,7158],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7155,7158],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":255,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":255,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7342,7345],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7342,7345],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * useUnrealEngine.ts\n * \n * React hook for managing Unreal Engine 5.6 MetaHuman integration\n * Provides easy-to-use interface for controlling MetaHuman avatar\n */\n\nimport { useState, useEffect, useCallback, useRef } from 'react';\nimport { unrealEngineService } from '../services/UnrealEngineService';\nimport type { MetaHumanExpression, MetaHumanSpeech, MetaHumanPose, MetaHumanBlendShape } from '../services/UnrealEngineService';\nimport { useMetaHumanStore } from '../store/metaHumanStore';\n\nexport interface UnrealEngineStatus {\n  isConnected: boolean;\n  isConnecting: boolean;\n  error: string | null;\n  lastMessage: any;\n  reconnectAttempts: number;\n}\n\nexport const useUnrealEngine = () => {\n  const [status, setStatus] = useState<UnrealEngineStatus>({\n    isConnected: false,\n    isConnecting: false,\n    error: null,\n    lastMessage: null,\n    reconnectAttempts: 0\n  });\n\n  const {\n    blendShapeWeights,\n    pose,\n    currentAnimation,\n    speechText,\n    isSpeaking,\n    setExpression,\n    setPose,\n    setSpeech,\n    setBlendShapeWeight\n  } = useMetaHumanStore();\n\n  const connectionAttempted = useRef(false);\n\n  // Initialize connection to Unreal Engine\n  const connect = useCallback(async () => {\n    if (status.isConnecting) return;\n\n    setStatus(prev => ({ ...prev, isConnecting: true, error: null }));\n\n    try {\n      const success = await unrealEngineService.connect();\n      setStatus(prev => ({\n        ...prev,\n        isConnected: success,\n        isConnecting: false,\n        error: success ? null : 'Failed to connect to Unreal Engine'\n      }));\n      return success;\n    } catch (error) {\n      setStatus(prev => ({\n        ...prev,\n        isConnected: false,\n        isConnecting: false,\n        error: error instanceof Error ? error.message : 'Connection failed'\n      }));\n      return false;\n    }\n  }, [status.isConnecting]);\n\n  // Disconnect from Unreal Engine\n  const disconnect = useCallback(() => {\n    unrealEngineService.disconnect();\n    setStatus(prev => ({\n      ...prev,\n      isConnected: false,\n      isConnecting: false,\n      error: null\n    }));\n  }, []);\n\n  // Send expression to MetaHuman\n  const sendExpression = useCallback((name: string, intensity: number = 1, duration?: number) => {\n    const expression: MetaHumanExpression = {\n      name,\n      intensity,\n      duration,\n      blendMode: 'replace'\n    };\n\n    const success = unrealEngineService.setExpression(expression);\n    if (success) {\n      // Update local store\n      setExpression(name, intensity);\n    }\n    return success;\n  }, [setExpression]);\n\n  // Send speech to MetaHuman with lip sync\n  const sendSpeech = useCallback((text: string, audioUrl?: string, voice?: string) => {\n    const speech: MetaHumanSpeech = {\n      text,\n      audioUrl,\n      voice: voice || 'default',\n      duration: text.length * 50 // Rough estimate: 50ms per character\n    };\n\n    const success = unrealEngineService.speak(speech);\n    if (success) {\n      // Update local store\n      setSpeech(text, true);\n      \n      // Auto-stop speaking after estimated duration\n      setTimeout(() => {\n        setSpeech('', false);\n      }, speech.duration);\n    }\n    return success;\n  }, [setSpeech]);\n\n  // Send pose/animation to MetaHuman\n  const sendPose = useCallback((name: string, transition: number = 0.5, loop: boolean = true) => {\n    const pose: MetaHumanPose = {\n      name,\n      transition,\n      loop\n    };\n\n    const success = unrealEngineService.setPose(pose);\n    if (success) {\n      // Update local store\n      setPose(name);\n    }\n    return success;\n  }, [setPose]);\n\n  // Send individual blend shape\n  const sendBlendShape = useCallback((name: string, value: number, transition: number = 0.2) => {\n    const blendShape: MetaHumanBlendShape = {\n      name,\n      value,\n      transition\n    };\n\n    const success = unrealEngineService.setBlendShape(blendShape);\n    if (success) {\n      // Update local store\n      setBlendShapeWeight(name, value);\n    }\n    return success;\n  }, [setBlendShapeWeight]);\n\n  // Control camera\n  const setCamera = useCallback((\n    position: { x: number; y: number; z: number },\n    rotation: { x: number; y: number; z: number }\n  ) => {\n    return unrealEngineService.setCamera(position, rotation);\n  }, []);\n\n  const playAnimation = useCallback((animationName: string, loop: boolean = false) => {\n    return unrealEngineService.setPose({ name: animationName, loop });\n  }, []);\n\n  // UE 5.6 specific methods\n  const configureLumen = useCallback((settings: {\n    globalIllumination?: boolean;\n    reflections?: boolean;\n    quality?: 'low' | 'medium' | 'high' | 'epic';\n    updateRate?: number;\n  }) => {\n    return unrealEngineService.configureLumen(settings);\n  }, []);\n\n  const configureNanite = useCallback((settings: {\n    enabled?: boolean;\n    clusterCulling?: boolean;\n    programmableRaster?: boolean;\n    maxTriangles?: number;\n  }) => {\n    return unrealEngineService.configureNanite(settings);\n  }, []);\n\n  const configureChaosPhysics = useCallback((settings: {\n    enabled?: boolean;\n    clothSimulation?: boolean;\n    hairPhysics?: boolean;\n    fluidSimulation?: boolean;\n  }) => {\n    return unrealEngineService.configureChaosPhysics(settings);\n  }, []);\n\n  const playMetaSound = useCallback((settings: {\n    soundAsset: string;\n    volume?: number;\n    pitch?: number;\n    spatialAudio?: boolean;\n    position?: { x: number; y: number; z: number };\n  }) => {\n    return unrealEngineService.playMetaSound(settings);\n  }, []);\n\n  // Control lighting\n  const setLighting = useCallback((\n    intensity: number,\n    color: string = '#ffffff',\n    direction?: { x: number; y: number; z: number }\n  ) => {\n    return unrealEngineService.setLighting({ intensity, color, direction });\n  }, []);\n\n  // Preset expressions for common emotions\n  const expressionPresets = {\n    happy: () => sendExpression('joy', 0.8),\n    sad: () => sendExpression('sadness', 0.7),\n    surprised: () => sendExpression('surprise', 0.9),\n    angry: () => sendExpression('anger', 0.6),\n    confused: () => sendExpression('confusion', 0.5),\n    thinking: () => sendExpression('concentration', 0.4),\n    neutral: () => sendExpression('neutral', 0.0),\n    excited: () => sendExpression('excitement', 1.0),\n    worried: () => sendExpression('worry', 0.6),\n    calm: () => sendExpression('calm', 0.3)\n  };\n\n  // Preset poses for common actions\n  const posePresets = {\n    idle: () => sendPose('idle', 0.5, true),\n    greeting: () => sendPose('wave_hello', 0.3, false),\n    thinking: () => sendPose('hand_to_chin', 0.4, true),\n    explaining: () => sendPose('gesturing', 0.3, true),\n    listening: () => sendPose('attentive', 0.4, true),\n    nodding: () => sendPose('nod_yes', 0.2, false),\n    shaking: () => sendPose('shake_no', 0.2, false),\n    pointing: () => sendPose('point_forward', 0.3, false)\n  };\n\n  // Setup event listeners\n  useEffect(() => {\n    const handleConnected = () => {\n      setStatus(prev => ({ ...prev, isConnected: true, isConnecting: false, error: null }));\n    };\n\n    const handleDisconnected = () => {\n      setStatus(prev => ({ ...prev, isConnected: false }));\n    };\n\n    const handleError = (error: any) => {\n      setStatus(prev => ({\n        ...prev,\n        error: error?.message || 'Unknown error',\n        isConnecting: false\n      }));\n    };\n\n    const handleMessage = (message: any) => {\n      setStatus(prev => ({ ...prev, lastMessage: message }));\n    };\n\n    const handleSpeechComplete = () => {\n      setSpeech('', false);\n    };\n\n    // Add event listeners\n    unrealEngineService.on('connected', handleConnected);\n    unrealEngineService.on('disconnected', handleDisconnected);\n    unrealEngineService.on('error', handleError);\n    unrealEngineService.on('message', handleMessage);\n    unrealEngineService.on('speechComplete', handleSpeechComplete);\n\n    // Cleanup\n    return () => {\n      unrealEngineService.off('connected', handleConnected);\n      unrealEngineService.off('disconnected', handleDisconnected);\n      unrealEngineService.off('error', handleError);\n      unrealEngineService.off('message', handleMessage);\n      unrealEngineService.off('speechComplete', handleSpeechComplete);\n    };\n  }, [setSpeech]);\n\n  // Auto-connect on mount (optional)\n  useEffect(() => {\n    if (!connectionAttempted.current) {\n      connectionAttempted.current = true;\n      // Attempt to connect automatically\n      connect().catch(error => {\n        console.log('Auto-connect failed, manual connection required:', error);\n      });\n    }\n  }, [connect]);\n\n  // Sync local state changes to Unreal Engine\n  useEffect(() => {\n    if (!status.isConnected) return;\n\n    // Sync blend shapes\n    Object.entries(blendShapeWeights).forEach(([name, weight]) => {\n      if (weight > 0) {\n        sendBlendShape(name, weight);\n      }\n    });\n  }, [blendShapeWeights, status.isConnected, sendBlendShape]);\n\n  return {\n    // Connection status\n    status,\n    isConnected: status.isConnected,\n    isConnecting: status.isConnecting,\n    error: status.error,\n\n    // Connection control\n    connect,\n    disconnect,\n\n    // MetaHuman control\n    sendExpression,\n    sendSpeech,\n    sendPose,\n    sendBlendShape,\n    setCamera,\n    setLighting,\n\n    // UE 5.6 specific methods\n    playAnimation,\n    configureLumen,\n    configureNanite,\n    configureChaosPhysics,\n    playMetaSound,\n\n    // Presets\n    expressionPresets,\n    posePresets,\n\n    // Current state from store\n    currentState: {\n      blendShapeWeights,\n      pose,\n      currentAnimation,\n      speechText,\n      isSpeaking\n    }\n  };\n};\n\nexport default useUnrealEngine;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useUserWorkflows.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[979,982],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[979,982],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'getAllWorkflows'. Either include it or remove the dependency array.","line":97,"column":6,"nodeType":"ArrayExpression","endLine":97,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [getAllWorkflows, getUserWorkflowAgent]","fix":{"range":[3146,3168],"text":"[getAllWorkflows, getUserWorkflowAgent]"}}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useCallback has a missing dependency: 'getAllWorkflows'. Either include it or remove the dependency array.","line":132,"column":6,"nodeType":"ArrayExpression","endLine":132,"endColumn":28,"suggestions":[{"desc":"Update the dependencies array to be: [getAllWorkflows, getUserWorkflowAgent]","fix":{"range":[4138,4160],"text":"[getAllWorkflows, getUserWorkflowAgent]"}}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":137,"column":88,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":137,"endColumn":91,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4305,4308],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4305,4308],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'getAllWorkflows'. Either include it or remove the dependency array.","line":277,"column":6,"nodeType":"ArrayExpression","endLine":277,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [getAllWorkflows]","fix":{"range":[8492,8494],"text":"[getAllWorkflows]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\r\n * hooks/useUserWorkflows.ts\r\n * \r\n * Hook React pour g├®rer les workflows d├®finis par l'utilisateur\r\n * Permet de cr├®er, ex├®cuter et g├®rer des workflows personnalis├®s.\r\n */\r\n\r\nimport { useState, useCallback, useEffect } from 'react';\r\nimport { agentRegistry } from '../agents/registry';\r\nimport type { UserWorkflowAgent, WorkflowDefinition } from '../agents/UserWorkflowAgent';\r\nimport { toast } from 'sonner';\r\n\r\n// Interface pour les workflows g├®r├®s\r\nexport interface ManagedWorkflow {\r\n  id: string;\r\n  name: string;\r\n  description: string;\r\n  trigger: string;\r\n  stepCount: number;\r\n}\r\n\r\n// Interface de retour du hook\r\nexport interface UserWorkflowsHook {\r\n  // ├ëtat\r\n  isLoading: boolean;\r\n  error: string | null;\r\n  workflows: ManagedWorkflow[];\r\n  \r\n  // Actions\r\n  createWorkflow: (definition: WorkflowDefinition) => Promise<string | null>;\r\n  deleteWorkflow: (workflowId: string) => Promise<boolean>;\r\n  executeWorkflow: (workflowId: string, args?: Record<string, any>) => Promise<boolean>;\r\n  getAllWorkflows: () => Promise<ManagedWorkflow[]>;\r\n  parseNaturalLanguage: (instruction: string) => Promise<WorkflowDefinition | null>;\r\n  checkTriggerPhrase: (phrase: string) => Promise<{\r\n    matched: boolean;\r\n    workflowId?: string;\r\n    confidence?: number;\r\n  }>;\r\n}\r\n\r\n/**\r\n * Hook pour g├®rer les workflows d├®finis par l'utilisateur\r\n */\r\nexport const useUserWorkflows = (): UserWorkflowsHook => {\r\n  const [isLoading, setIsLoading] = useState<boolean>(false);\r\n  const [error, setError] = useState<string | null>(null);\r\n  const [workflows, setWorkflows] = useState<ManagedWorkflow[]>([]);\r\n  \r\n  // Note: lastSpokenText n'existe pas dans le store actuel\r\n  // const lastSpokenText = useVisionAudioStore(s => s.lastSpokenText);\r\n  \r\n  /**\r\n   * Obtenir l'agent de workflows\r\n   */\r\n  const getUserWorkflowAgent = useCallback((): UserWorkflowAgent => {\r\n    const agent = agentRegistry.getAgent('User Workflow Agent');\r\n    if (!agent) {\r\n      throw new Error(\"Agent de workflows utilisateur non disponible\");\r\n    }\r\n    return agent as unknown as UserWorkflowAgent;\r\n  }, []);\r\n  \r\n  /**\r\n   * Cr├®er un nouveau workflow ├á partir d'une d├®finition\r\n   */\r\n  const createWorkflow = useCallback(async (definition: WorkflowDefinition): Promise<string | null> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n      \r\n      const agent = getUserWorkflowAgent();\r\n      \r\n      const result = await agent.execute({\r\n        intent: 'create_workflow',\r\n        parameters: { definition }\r\n      });\r\n      \r\n      if (!result.success) {\r\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la cr├®ation du workflow\");\r\n      }\r\n      \r\n      // Rafra├«chir la liste des workflows\r\n      void getAllWorkflows();\r\n      \r\n      toast.success(`Workflow \"${definition.name}\" cr├®├® avec succ├¿s!`);\r\n      \r\n      return result.output?.workflowId || null;\r\n    } catch (err) {\r\n      const errMsg = err instanceof Error ? err.message : String(err);\r\n      setError(errMsg);\r\n      toast.error(`Erreur: ${errMsg}`);\r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [getUserWorkflowAgent]);\r\n  \r\n  /**\r\n   * Supprimer un workflow existant\r\n   */\r\n  const deleteWorkflow = useCallback(async (workflowId: string): Promise<boolean> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n      \r\n      const agent = getUserWorkflowAgent();\r\n      \r\n      const result = await agent.execute({\r\n        intent: 'delete_workflow',\r\n        parameters: { workflowId }\r\n      });\r\n      \r\n      if (!result.success) {\r\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la suppression du workflow\");\r\n      }\r\n      \r\n      // Rafra├«chir la liste des workflows\r\n      void getAllWorkflows();\r\n      \r\n      toast.success(\"Workflow supprim├® avec succ├¿s!\");\r\n      \r\n      return true;\r\n    } catch (err) {\r\n      const errMsg = err instanceof Error ? err.message : String(err);\r\n      setError(errMsg);\r\n      toast.error(`Erreur: ${errMsg}`);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [getUserWorkflowAgent]);\r\n  \r\n  /**\r\n   * Ex├®cuter un workflow existant\r\n   */\r\n  const executeWorkflow = useCallback(async (workflowId: string, args?: Record<string, any>): Promise<boolean> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n      \r\n      const agent = getUserWorkflowAgent();\r\n      \r\n      const result = await agent.execute({\r\n        intent: 'execute_workflow',\r\n        parameters: { workflowId, args }\r\n      });\r\n      \r\n      if (!result.success) {\r\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'ex├®cution du workflow\");\r\n      }\r\n      \r\n      toast.success(\"Workflow ex├®cut├® avec succ├¿s!\");\r\n      \r\n      return true;\r\n    } catch (err) {\r\n      const errMsg = err instanceof Error ? err.message : String(err);\r\n      setError(errMsg);\r\n      toast.error(`Erreur: ${errMsg}`);\r\n      return false;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [getUserWorkflowAgent]);\r\n  \r\n  /**\r\n   * R├®cup├®rer tous les workflows d├®finis par l'utilisateur\r\n   */\r\n  const getAllWorkflows = useCallback(async (): Promise<ManagedWorkflow[]> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n      \r\n      const agent = getUserWorkflowAgent();\r\n      \r\n      const result = await agent.execute({\r\n        intent: 'get_workflows'\r\n      });\r\n      \r\n      if (!result.success) {\r\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la r├®cup├®ration des workflows\");\r\n      }\r\n      \r\n      const workflowsList = result.output?.workflows || [];\r\n      setWorkflows(workflowsList);\r\n      \r\n      return workflowsList;\r\n    } catch (err) {\r\n      const errMsg = err instanceof Error ? err.message : String(err);\r\n      setError(errMsg);\r\n      return [];\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [getUserWorkflowAgent]);\r\n  \r\n  /**\r\n   * Parser une instruction en langage naturel pour cr├®er un workflow\r\n   */\r\n  const parseNaturalLanguage = useCallback(async (instruction: string): Promise<WorkflowDefinition | null> => {\r\n    try {\r\n      setIsLoading(true);\r\n      setError(null);\r\n      \r\n      const agent = getUserWorkflowAgent();\r\n      \r\n      const result = await agent.execute({\r\n        intent: 'parse_natural_language_workflow',\r\n        parameters: { instruction }\r\n      });\r\n      \r\n      if (!result.success) {\r\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de l'analyse de l'instruction\");\r\n      }\r\n      \r\n      return result.output?.definition || null;\r\n    } catch (err) {\r\n      const errMsg = err instanceof Error ? err.message : String(err);\r\n      setError(errMsg);\r\n      toast.error(`Erreur: ${errMsg}`);\r\n      return null;\r\n    } finally {\r\n      setIsLoading(false);\r\n    }\r\n  }, [getUserWorkflowAgent]);\r\n  \r\n  /**\r\n   * V├®rifier si une phrase correspond ├á un d├®clencheur de workflow\r\n   */\r\n  const checkTriggerPhrase = useCallback(async (phrase: string): Promise<{\r\n    matched: boolean;\r\n    workflowId?: string;\r\n    confidence?: number;\r\n  }> => {\r\n    try {\r\n      const agent = getUserWorkflowAgent();\r\n      \r\n      const result = await agent.execute({\r\n        intent: 'check_trigger_match',\r\n        parameters: { phrase }\r\n      });\r\n      \r\n      if (!result.success) {\r\n        throw new Error(typeof result.error === 'string' ? result.error : \"├ëchec de la v├®rification du d├®clencheur\");\r\n      }\r\n      \r\n      const matched = result.output?.matched || false;\r\n      \r\n      if (matched) {\r\n        const workflowId = result.output?.workflowId;\r\n        const confidence = result.output?.confidence;\r\n        \r\n        if (workflowId) {\r\n          // Si correspondance exacte ou confidence ├®lev├®e, ex├®cuter automatiquement\r\n          if (!result.output?.partialMatch || (confidence && confidence > 0.9)) {\r\n            void executeWorkflow(workflowId);\r\n          }\r\n        }\r\n        \r\n        return {\r\n          matched,\r\n          workflowId,\r\n          confidence\r\n        };\r\n      }\r\n      \r\n      return { matched: false };\r\n    } catch (err) {\r\n      console.error(\"Erreur lors de la v├®rification du d├®clencheur:\", err);\r\n      return { matched: false };\r\n    }\r\n  }, [getUserWorkflowAgent, executeWorkflow]);\r\n  \r\n  // Initialisation: charger les workflows existants\r\n  useEffect(() => {\r\n    void getAllWorkflows();\r\n  }, []); // eslint-disable-line react-hooks/exhaustive-deps\r\n  \r\n  // D├®tecter les phrases de d├®clenchement dans le texte parl├®\r\n  // Note: D├®sactiv├® car lastSpokenText n'existe pas dans le store\r\n  // useEffect(() => {\r\n  //   if (lastSpokenText) {\r\n  //     void checkTriggerPhrase(lastSpokenText);\r\n  //   }\r\n  // }, [lastSpokenText, checkTriggerPhrase]);\r\n  \r\n  return {\r\n    // ├ëtat\r\n    isLoading,\r\n    error,\r\n    workflows,\r\n    \r\n    // Actions\r\n    createWorkflow,\r\n    deleteWorkflow,\r\n    executeWorkflow,\r\n    getAllWorkflows,\r\n    parseNaturalLanguage,\r\n    checkTriggerPhrase\r\n  };\r\n};\r\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useVoiceIntent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useWakeWord.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":31,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":34,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[500,503],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[500,503],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'setState'. Either include it or remove the dependency array.","line":50,"column":6,"nodeType":"ArrayExpression","endLine":50,"endColumn":27,"suggestions":[{"desc":"Update the dependencies array to be: [audioCtx, micStream, setState]","fix":{"range":[1623,1644],"text":"[audioCtx, micStream, setState]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useEffect, useRef } from 'react';\nimport { useVisionAudioStore } from '../store/visionAudioStore';\n\n/**\n * Wake-word detection using Picovoice Porcupine WASM.\n * Requires env var VITE_PV_ACCESS_KEY and keyword model.\n * Falls back silently if libs or key are missing.\n */\nexport function useWakeWord(audioCtx?: AudioContext, micStream?: MediaStream) {\n  const setState = useVisionAudioStore((s) => s.setState);\n  // Store WebVoiceProcessor instance for cleanup\n  const processorRef = useRef<any>(null);\n\n  useEffect(() => {\n    if (!audioCtx || !micStream) return;\n\n    (async () => {\n      try {\n        const accessKey = import.meta.env.VITE_PV_ACCESS_KEY as string | undefined;\n        if (!accessKey) return;\n        const {\n          PorcupineWorkerFactory,\n          WebVoiceProcessor,\n          BuiltInKeyword,\n        } = await import('@picovoice/porcupine-web');\n\n        const porcupine = await PorcupineWorkerFactory.create({\n          accessKey,\n          keywords: [BuiltInKeyword.PORCUPINE], // TODO: replace by custom \"lisa\" keyword\n        });\n\n        porcupine.onmessage = (event: MessageEvent) => {\n          if (event.data.keywordLabel) {\n            // Wake-word detected!\n            setState({ listeningActive: true });\n          }\n        };\n\n        const wvp = await WebVoiceProcessor.init({ engines: [porcupine] });\n        processorRef.current = wvp;\n        await wvp.startProcessing(micStream);\n      } catch (err) {\n        console.warn('Wake-word engine failed, falling back to regex.', err);\n      }\n    })();\n\n    return () => {\n      processorRef.current?.release();\n    };\n  }, [audioCtx, micStream]);\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useWebSearch.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":109,"column":36,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":109,"endColumn":39,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3889,3892],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3889,3892],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { useCallback } from 'react';\nimport { useTranslation } from 'react-i18next';\n\nexport interface WebSearchOptions {\n  apiKey?: string;\n  searchEngineId?: string;\n  maxResults?: number;\n}\n\nexport interface WebSearchResult {\n  title: string;\n  snippet: string;\n  link: string;\n  source: string;\n}\n\n/**\n * Hook for performing web searches and returning concise answers\n */\nexport function useWebSearch(options: WebSearchOptions = {}) {\n  const { i18n } = useTranslation();\n  \n  const apiKey = options.apiKey || process.env.VITE_GOOGLE_SEARCH_API_KEY;\n  const searchEngineId = options.searchEngineId || process.env.VITE_GOOGLE_SEARCH_ENGINE_ID;\n  const maxResults = options.maxResults || 3;\n\n  /**\n   * Determine if a query is a web search question\n   */\n  const isWebSearchQuery = useCallback((query: string): boolean => {\n    const lowerQuery = query.toLowerCase().trim();\n    \n    // List of question starters that suggest web search\n    const englishQuestionStarters = [\n      'what is', 'what are', 'who is', 'who are',\n      'where is', 'where are', 'when is', 'when did',\n      'why is', 'why are', 'how to', 'how do',\n      'can you tell me about', 'search for', 'look up',\n      'find information about', 'tell me about'\n    ];\n    \n    const frenchQuestionStarters = [\n      'qu\\'est-ce que', 'qu\\'est ce que', 'qui est', 'qui sont',\n      'o├╣ est', 'o├╣ sont', 'quand est', 'quand a',\n      'pourquoi est', 'pourquoi sont', 'comment',\n      'peux-tu me dire', 'cherche', 'recherche',\n      'trouve des informations sur', 'parle-moi de'\n    ];\n    \n    const spanishQuestionStarters = [\n      'qu├® es', 'qui├®n es', 'qui├®nes son',\n      'd├│nde est├í', 'd├│nde est├ín', 'cu├índo es', 'cu├índo fue',\n      'por qu├® es', 'por qu├® son', 'c├│mo',\n      'puedes decirme sobre', 'busca', 'encuentra',\n      'encuentra informaci├│n sobre', 'h├íblame de'\n    ];\n    \n    // Check if query starts with any of the question patterns\n    return [\n      ...englishQuestionStarters,\n      ...frenchQuestionStarters,\n      ...spanishQuestionStarters\n    ].some(starter => lowerQuery.startsWith(starter) || lowerQuery.includes(starter));\n  }, []);\n  \n  /**\n   * Extract a query suitable for search from natural language input\n   */\n  const prepareSearchQuery = useCallback((text: string): string => {\n    // Remove question words and other unnecessary text\n    const cleanQuery = text\n      .replace(/^(what|who|where|when|why|how|can you|could you|tell me|search for|look up|find|please)/i, '')\n      .replace(/^(qu'est[- ]ce que|qui|o├╣|quand|pourquoi|comment|peux[- ]tu|pourrais[- ]tu|dis[- ]moi|cherche|recherche|trouve|s'il te pla├«t)/i, '')\n      .replace(/^(qu├®|qui├®n|qui├®nes|d├│nde|cu├índo|por qu├®|c├│mo|puedes|podr├¡as|dime|busca|encuentra|por favor)/i, '')\n      .trim()\n      .replace(/\\?+$/, ''); // Remove trailing question marks\n    \n    return cleanQuery || text; // If nothing left after cleaning, use original text\n  }, []);\n\n  /**\n   * Perform a web search and get concise results\n   */\n  const performWebSearch = useCallback(async (query: string): Promise<WebSearchResult[]> => {\n    if (!apiKey || !searchEngineId) {\n      console.warn('Missing API key or search engine ID for web search');\n      return [];\n    }\n    \n    // Prepare the search query\n    const searchQuery = prepareSearchQuery(query);\n    \n    try {\n      // Use Google Custom Search API\n      const url = `https://www.googleapis.com/customsearch/v1?key=${apiKey}&cx=${searchEngineId}&q=${encodeURIComponent(searchQuery)}&num=${maxResults}`;\n      \n      const response = await fetch(url);\n      if (!response.ok) {\n        throw new Error(`Search API error: ${response.statusText}`);\n      }\n      \n      const data = await response.json();\n      \n      if (!data.items || data.items.length === 0) {\n        return [];\n      }\n      \n      // Transform API response to our result format\n      return data.items.map((item: any) => ({\n        title: item.title,\n        snippet: item.snippet,\n        link: item.link,\n        source: item.displayLink || new URL(item.link).hostname\n      })).slice(0, maxResults);\n      \n    } catch (error) {\n      console.error('Error performing web search:', error);\n      return [];\n    }\n  }, [apiKey, maxResults, prepareSearchQuery, searchEngineId]);\n\n  /**\n   * Create a concise answer from search results\n   */\n  const createConciseAnswer = useCallback((results: WebSearchResult[], query: string): string => {\n    if (results.length === 0) {\n      return i18n.language.startsWith('fr')\n        ? `Je n'ai pas pu trouver d'information sur \"${query}\".`\n        : i18n.language.startsWith('es')\n          ? `No pude encontrar informaci├│n sobre \"${query}\".`\n          : `I couldn't find information about \"${query}\".`;\n    }\n    \n    // For a single result, use more of its content\n    if (results.length === 1) {\n      const result = results[0];\n      return `${result.snippet} (Source: ${result.source})`;\n    }\n    \n    // For multiple results, combine snippets\n    const combinedAnswer = results.map((result, i) => \n      `${i + 1}. ${result.snippet} (${result.source})`\n    ).join('\\n\\n');\n    \n    return combinedAnswer;\n  }, [i18n.language]);\n\n  return {\n    isWebSearchQuery,\n    performWebSearch,\n    createConciseAnswer\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useWorkflowEngine.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\hooks\\useWorkflowManager.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\i18n.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\lib\\smallTalk.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":50,"column":102,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":50,"endColumn":105,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1919,1922],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1919,1922],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Core logic for handling small talk conversations.\n * This module is framework-agnostic and can be used in any JavaScript/TypeScript environment.\n */\n\nconst DEFAULT_LLM_API = 'https://api.openai.com/v1/chat/completions';\n\nexport interface SmallTalkOptions {\n  apiKey?: string;\n  apiEndpoint?: string;\n  maxTokens?: number;\n  temperature?: number;\n  model?: string;\n}\n\n/**\n * Get a basic default response if API is not available\n */\nfunction getDefaultResponse(_text: string, language: string): string {\n    const isFrench = language.startsWith('fr');\n    const isSpanish = language.startsWith('es');\n    \n    const defaultResponses = {\n      en: [\n        \"I'm sorry, I'm having trouble connecting to my knowledge base right now.\",\n        \"I'd love to chat more, but my language abilities are limited at the moment.\",\n      ],\n      fr: [\n        \"Je suis d├®sol├®e, j'ai du mal ├á me connecter ├á ma base de connaissances pour le moment.\",\n        \"J'aimerais discuter davantage, mais mes capacit├®s linguistiques sont limit├®es actuellement.\",\n      ],\n      es: [\n        \"Lo siento, estoy teniendo problemas para conectarme a mi base de conocimientos en este momento.\",\n        \"Me encantar├¡a charlar m├ís, pero mis habilidades ling├╝├¡sticas son limitadas actualmente.\",\n      ]\n    };\n    \n    const responses = isFrench ? defaultResponses.fr : isSpanish ? defaultResponses.es : defaultResponses.en;\n    return responses[Math.floor(Math.random() * responses.length)];\n}\n\n/**\n * Processes a small talk query using an LLM API.\n * @param text The user's input text.\n * @param options Configuration for the API call.\n * @param conversationHistory The history of the conversation for context.\n * @param language The current language for the response.\n * @returns A promise that resolves to the AI's response.\n */\nexport async function processSmallTalk(text: string, options: SmallTalkOptions, conversationHistory: any[] = [], language = 'en'): Promise<string> {\n  const { apiKey, apiEndpoint = DEFAULT_LLM_API, model = 'gpt-3.5-turbo', maxTokens = 100, temperature = 0.7 } = options;\n\n  if (!apiKey) {\n    console.warn('No LLM API key provided for small talk');\n    return getDefaultResponse(text, language);\n  }\n\n  try {\n    const payload = {\n      model,\n      messages: [\n        {\n          role: 'system',\n          content: `You are Lisa, a friendly virtual assistant. Keep responses brief (1-2 sentences max) and conversational. Current language: ${language}`\n        },\n        ...conversationHistory.map((msg: {role: string, content: string}) => ({ role: msg.role, content: msg.content })),\n        { role: 'user', content: text }\n      ],\n      max_tokens: maxTokens,\n      temperature: temperature,\n    };\n\n    const response = await fetch(apiEndpoint, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${apiKey}`\n      },\n      body: JSON.stringify(payload)\n    });\n\n    if (!response.ok) {\n      throw new Error(`API error: ${response.statusText}`);\n    }\n\n    const data = await response.json();\n    return data.choices[0].message.content.trim();\n  } catch (error) {\n    console.error('Error processing small talk:', error);\n    return getDefaultResponse(text, language);\n  }\n}\n\n/**\n * Detect if an utterance is small talk rather than a command\n */\nexport function isSmallTalk(text: string): boolean {\n  const lowerText = text.toLowerCase();\n  const commandKeywords = ['weather', 'alarm', 'todo', 'list', 'remind', 'calendar', 'cancel'];\n  if (commandKeywords.some(keyword => lowerText.includes(keyword))) {\n    return false;\n  }\n\n  const smallTalkPatterns = [\n    /how are you/i, /what.*your name/i, /who are you/i, /hello/i, /hi/i, \n    /thank(s| you)/i, /good (morning|afternoon|evening|night)/i,\n    /tell me a joke/i, /i('m| am) (sad|happy|tired|bored)/i,\n    // Add more patterns for other languages as needed\n  ];\n\n  return smallTalkPatterns.some(pattern => pattern.test(lowerText));\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\main-vivante.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\main.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\manifesto\\config.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\manifesto\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\manifesto\\initLisaVivante.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\manifesto\\validation.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\AgentsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\AudioPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\ChatPage.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has missing dependencies: 'conversations', 'createConversation', 'currentConversationId', and 'setCurrentConversation'. Either include them or remove the dependency array.","line":21,"column":6,"nodeType":"ArrayExpression","endLine":21,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [conversations, createConversation, currentConversationId, setCurrentConversation]","fix":{"range":[674,676],"text":"[conversations, createConversation, currentConversationId, setCurrentConversation]"}}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Chat Page\n * Page principale du chat fullscreen\n */\n\nimport { useEffect } from 'react';\nimport { ChatLayout } from '../components/chat';\nimport { useChatHistoryStore } from '../store/chatHistoryStore';\n\nexport const ChatPage = () => {\n  const { conversations, currentConversationId, createConversation, setCurrentConversation } = useChatHistoryStore();\n\n  // Auto-create first conversation if none exists\n  useEffect(() => {\n    if (conversations.length === 0) {\n      const id = createConversation();\n      setCurrentConversation(id);\n    } else if (!currentConversationId && conversations.length > 0) {\n      setCurrentConversation(conversations[0].id);\n    }\n  }, []);\n\n  return <ChatLayout />;\n};\n\nexport default ChatPage;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\DashboardModern.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\DashboardPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\LisaVivanteApp.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\SettingsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\SystemPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\ToolsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\VisionPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\pages\\WorkflowsPage.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\plugins\\PluginBuilderService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[885,888],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[885,888],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":121,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":121,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3637,3640],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3637,3640],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":124,"column":20,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":124,"endColumn":23,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3745,3748],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3745,3748],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":126,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":126,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3906,3909],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3906,3909],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":136,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":136,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4381,4384],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4381,4384],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file A service for bundling plugin source code into a runnable format.\n * This service uses esbuild (via its WASM package) to transpile and bundle\n * TypeScript/JavaScript source files into a single JS file for a Web Worker.\n */\n\n// In a real application, you would import the WASM version of esbuild.\n// import * as esbuild from 'esbuild-wasm';\n\n/**\n * Represents a map of file paths to their string content.\n * This acts as a virtual file system for the builder.\n */\nexport type VirtualFileSystem = Map<string, string>;\n\n/**\n * Options for the build process.\n */\nexport interface BuildOptions {\n  entryPoint: string; // e.g., './src/index.ts'\n  vfs: VirtualFileSystem;\n  // Add other esbuild options as needed (e.g., external dependencies)\n}\n\n/**\n * The result of a successful build.\n */\nexport interface BuildResult {\n  outputCode: string;\n  sourceMap?: string;\n  warnings: any[];\n}\n\nexport class PluginBuilderService {\n  private isInitialized = false;\n\n  constructor() {\n    // The constructor is a good place to kick off the esbuild initialization.\n    this.initialize();\n  }\n\n  /**\n   * Initializes the esbuild WASM service.\n   * This must be called once before any builds can be run.\n   */\n  async initialize(): Promise<void> {\n    if (this.isInitialized) {\n      return;\n    }\n    try {\n      // In a real app, you'd fetch the wasm file from a CDN or local assets.\n      // await esbuild.initialize({\n      //   wasmURL: '/path/to/esbuild.wasm',\n      // });\n      this.isInitialized = true;\n      console.log('PluginBuilderService (esbuild-wasm) initialized.');\n    } catch (error) {\n      console.error('Failed to initialize esbuild-wasm:', error);\n      throw new Error('Could not initialize the plugin builder service.');\n    }\n  }\n\n  /**\n   * Builds a plugin from a virtual file system.\n   * @param options - The build configuration.\n   * @returns The bundled JavaScript code as a string.\n   */\n  async build(options: BuildOptions): Promise<BuildResult> {\n    if (!this.isInitialized) {\n      throw new Error('PluginBuilderService is not initialized.');\n    }\n\n    console.log(`Starting build for entry point: ${options.entryPoint}`);\n\n    // This is a placeholder for the actual esbuild call.\n    // The real implementation would require a custom plugin for esbuild\n    // to resolve modules from the virtual file system.\n    const mockBuildResult = {\n      outputFiles: [\n        {\n          path: '<stdout>',\n          contents: new TextEncoder().encode(\n            `// Mock build output for ${options.entryPoint}\\nconsole.log('Plugin loaded!');`\n          ),\n          text: `// Mock build output for ${options.entryPoint}\\nconsole.log('Plugin loaded!');`,\n        },\n      ],\n      warnings: [],\n    };\n\n    /*\n    // Real implementation would look something like this:\n    const result = await esbuild.build({\n      entryPoints: [options.entryPoint],\n      bundle: true,\n      write: false, // Return the result in memory\n      format: 'esm',\n      platform: 'browser',\n      plugins: [this.inMemoryResolverPlugin(options.vfs)],\n    });\n    */\n\n    if (mockBuildResult.warnings.length > 0) {\n      console.warn('Build completed with warnings:', mockBuildResult.warnings);\n    }\n\n    const outputCode = mockBuildResult.outputFiles[0].text;\n    console.log('Build successful.');\n\n    return {\n      outputCode,\n      warnings: mockBuildResult.warnings,\n    };\n  }\n\n  /**\n   * An esbuild plugin to resolve imports from the in-memory virtual file system.\n   * @param vfs - The virtual file system map.\n   * @returns An esbuild plugin configuration.\n   */\n  private inMemoryResolverPlugin(vfs: VirtualFileSystem): any { // `any` should be `esbuild.Plugin`\n    return {\n      name: 'in-memory-resolver',\n      setup(build: any) { // `any` should be `esbuild.PluginBuild`\n        // Intercept module paths and resolve them from the VFS\n        build.onResolve({ filter: /.*/ }, (args: any) => {\n          // Basic path resolution logic\n          const path = args.importer ? new URL(args.path, `file://${args.importer}`).pathname.slice(1) : args.path;\n          if (vfs.has(path)) {\n            return { path, namespace: 'vfs' };\n          }\n          return { path: args.path, external: true }; // Fallback to external\n        });\n\n        // Load the content for the resolved path from the VFS\n        build.onLoad({ filter: /.*/, namespace: 'vfs' }, (args: any) => {\n          return {\n            contents: vfs.get(args.path),\n            loader: 'ts', // or 'js', 'tsx', etc. based on file extension\n          };\n        });\n      },\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\plugins\\PluginLoader.test.ts","messages":[{"ruleId":"@typescript-eslint/triple-slash-reference","severity":2,"message":"Do not use a triple slash reference for vitest, use `import` style instead.","line":1,"column":1,"nodeType":"Line","messageId":"tripleSlashReference","endLine":1,"endColumn":33}],"suppressedMessages":[],"errorCount":1,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/// <reference types=\"vitest\" />\n\n/**\n * @file Unit tests for the PluginLoader.\n */\n\nimport { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';\nimport { PluginLoader } from './PluginLoader';\nimport type { PluginManifest } from './PluginManifest';\n\n// Mock registries\nconst mockAgentRegistry = {\n  register: vi.fn(),\n  unregister: vi.fn(),\n};\n\nconst mockNodeRegistry = {\n  register: vi.fn(),\n  unregister: vi.fn(),\n};\n\ndescribe('PluginLoader', () => {\n  let pluginLoader: PluginLoader;\n\n  const mockManifest: PluginManifest = {\n    id: 'test-plugin',\n    name: 'Test Plugin',\n    version: '1.0.0',\n    description: 'A test plugin',\n    author: 'Test Author',\n    resources: [\n      { id: 'TestAgent', type: 'agent', entry: './TestAgent.js' },\n      { id: 'TestNode', type: 'workflow-node', entry: './TestNode.js' },\n    ],\n  };\n\n  beforeEach(() => {\n    // Mock the global fetch function\n    vi.stubGlobal('fetch', vi.fn());\n    // Instantiate PluginLoader with mock dependencies\n    pluginLoader = new PluginLoader(mockAgentRegistry, mockNodeRegistry);\n  });\n\n  afterEach(() => {\n    // Clear all mocks after each test\n    vi.clearAllMocks();\n    vi.restoreAllMocks();\n  });\n\n  it('should load a plugin from a manifest URL and register its resources', async () => {\n    (fetch as vi.Mock).mockResolvedValueOnce({\n      ok: true,\n      json: () => Promise.resolve(mockManifest),\n    });\n\n    await pluginLoader.loadPluginFromUrl('http://localhost/plugins/test-plugin/manifest.json');\n\n    expect(fetch).toHaveBeenCalledWith('http://localhost/plugins/test-plugin/manifest.json');\n    \n    // Check if resources were registered with the correct IDs and placeholder objects\n    expect(mockAgentRegistry.register).toHaveBeenCalledWith('TestAgent', {\n      id: 'TestAgent',\n      url: 'http://localhost/plugins/test-plugin/TestAgent.js',\n    });\n    expect(mockNodeRegistry.register).toHaveBeenCalledWith('TestNode', {\n      id: 'TestNode',\n      url: 'http://localhost/plugins/test-plugin/TestNode.js',\n    });\n  });\n\n  it('should handle fetch errors gracefully', async () => {\n    (fetch as vi.Mock).mockRejectedValueOnce(new Error('Network Error'));\n\n    await expect(pluginLoader.loadPluginFromUrl('http://invalid-url/manifest.json')).rejects.toThrow('Network Error');\n  });\n  \n  it('should warn if a plugin is already loaded', async () => {\n    const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});\n\n    // First load\n    (fetch as vi.Mock).mockResolvedValue({\n      ok: true,\n      json: () => Promise.resolve(mockManifest),\n    });\n    await pluginLoader.loadPluginFromUrl('http://localhost/plugins/test-plugin/manifest.json');\n\n    // Attempt to load again\n    await pluginLoader.loadPluginFromUrl('http://localhost/plugins/test-plugin/manifest.json');\n\n    expect(consoleWarnSpy).toHaveBeenCalledWith(\"Plugin 'Test Plugin' is already loaded.\");\n    // Fetch should only be called once because the second call is blocked\n    expect(fetch).toHaveBeenCalledTimes(1);\n\n    consoleWarnSpy.mockRestore();\n  });\n});\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\plugins\\PluginLoader.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'PluginResource' is defined but never used. Allowed unused vars must match /^_/u.","line":6,"column":26,"nodeType":null,"messageId":"unusedVar","endLine":6,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":39,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":42,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[468,471],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[468,471],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":16,"column":37,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":16,"endColumn":40,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[583,586],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[583,586],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":8,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":11,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[854,857],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[854,857],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":111,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":111,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3988,3991],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3988,3991],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":5,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Manages the dynamic loading, registration, and lifecycle of plugins.\n * Plugins are loaded into isolated Web Workers for security and performance.\n */\n\nimport { PluginManifest, PluginResource } from './PluginManifest';\n\n// A simplified representation of registries where plugins can add their components.\n// In a real app, these would be more robust singleton or context-provided services.\ninterface IAgentRegistry {\n  register: (id: string, constructor: any) => void;\n  unregister: (id: string) => void;\n}\n\ninterface INodeRegistry {\n  register: (id: string, component: any) => void;\n  unregister: (id: string) => void;\n}\n\n/**\n * Represents a fully loaded and running plugin instance.\n */\nexport interface LoadedPlugin {\n  manifest: PluginManifest;\n  worker: Worker;\n  // In a real implementation, this would be a Comlink-wrapped API\n  api: any; \n  cleanup: () => void;\n}\n\nexport class PluginLoader {\n  private loadedPlugins = new Map<string, LoadedPlugin>();\n\n  constructor(\n    // Dependencies are injected for testability\n    private agentRegistry: IAgentRegistry,\n    private nodeRegistry: INodeRegistry\n  ) {}\n\n  /**\n   * Loads a plugin from a URL pointing to its manifest file.\n   * @param manifestUrl - The URL to the plugin's manifest.json.\n   */\n  async loadPluginFromUrl(manifestUrl: string): Promise<void> {\n    try {\n      const response = await fetch(manifestUrl);\n      if (!response.ok) {\n        throw new Error(`Failed to fetch manifest: ${response.statusText}`);\n      }\n      const manifest: PluginManifest = await response.json();\n\n      if (this.loadedPlugins.has(manifest.id)) {\n        console.warn(`Plugin '${manifest.name}' is already loaded.`);\n        return;\n      }\n\n      // The base URL for resolving relative resource paths\n      const baseUrl = manifestUrl.substring(0, manifestUrl.lastIndexOf('/') + 1);\n\n      // For now, we'll just register the resources directly.\n      // A full implementation would create a Web Worker and load the script.\n      console.log(`Loading plugin: ${manifest.name} v${manifest.version}`);\n      this.registerPluginResources(manifest, baseUrl);\n\n      // In a full sandbox implementation:\n      // const worker = new Worker(new URL(entryPoint, baseUrl));\n      // const api = Comlink.wrap(worker);\n      // await api.initialize(); // Let the plugin set itself up\n\n      // Store the loaded plugin\n      this.loadedPlugins.set(manifest.id, {\n        manifest,\n        worker: null, // Placeholder\n        api: null, // Placeholder\n        cleanup: () => this.unregisterPlugin(manifest.id),\n      });\n\n      console.log(`Successfully loaded plugin: ${manifest.name}`);\n    } catch (error) {\n      console.error('Failed to load plugin:', error);\n      throw error;\n    }\n  }\n\n  /**\n   * Registers the resources from a plugin's manifest into the application.\n   * @param manifest - The plugin's manifest.\n   * @param baseUrl - The base URL for resolving resource paths.\n   */\n  private registerPluginResources(manifest: PluginManifest, baseUrl: string): void {\n    for (const resource of manifest.resources) {\n      const resourceUrl = new URL(resource.entry, baseUrl).href;\n      console.log(`  - Registering resource '${resource.id}' from ${resourceUrl}`);\n\n      // This is a simplified registration. A real implementation would dynamically\n      // import the module from the URL and pass the exported class/component.\n      const placeholderComponent = { id: resource.id, url: resourceUrl };\n\n      switch (resource.type) {\n        case 'agent':\n          this.agentRegistry.register(resource.id, placeholderComponent);\n          break;\n        case 'workflow-node':\n          this.nodeRegistry.register(resource.id, placeholderComponent);\n          break;\n        case 'panel':\n          // Handle panel registration\n          console.log(`Panel resource '${resource.id}' registration is not yet implemented.`);\n          break;\n        default:\n          console.warn(`Unknown resource type: ${(resource as any).type}`);\n      }\n    }\n  }\n\n  /**\n   * Unloads a plugin and removes its components from the application.\n   * @param pluginId - The ID of the plugin to unregister.\n   */\n  unregisterPlugin(pluginId: string): void {\n    const plugin = this.loadedPlugins.get(pluginId);\n    if (!plugin) {\n      console.warn(`Plugin with ID '${pluginId}' not found.`);\n      return;\n    }\n\n    console.log(`Unloading plugin: ${plugin.manifest.name}`);\n\n    // Unregister all resources provided by this plugin\n    for (const resource of plugin.manifest.resources) {\n      switch (resource.type) {\n        case 'agent':\n          this.agentRegistry.unregister(resource.id);\n          break;\n        case 'workflow-node':\n          this.nodeRegistry.unregister(resource.id);\n          break;\n        // Add other resource types as needed\n      }\n    }\n\n    // Terminate the worker if it exists\n    plugin.worker?.terminate();\n\n    this.loadedPlugins.delete(pluginId);\n    console.log(`Successfully unloaded plugin: ${plugin.manifest.name}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\plugins\\PluginManifest.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\prompts\\toneGuide.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\router\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\routes.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\senses\\hearing.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'HearingWorkerMessage' is defined but never used. Allowed unused vars must match /^_/u.","line":5,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":5,"endColumn":31}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/senses/hearing.ts\nimport type { Percept } from '../types';\n\n// Define the type for messages sent to the worker\ninterface HearingWorkerMessage {\n  type: 'LOAD_STT_MODEL' | 'PROCESS_AUDIO';\n  payload?: Record<string, unknown>;\n}\n\n// Define the type for messages received from the worker\nexport interface HearingPerceptPayload {\n  text?: string;\n  emotion?: string;\n  sentiment?: string;\n  intent?: string;\n}\n\nlet hearingWorker: Worker | null = null;\nlet isWorkerInitialized = false;\n\n// Callback for percepts received from the worker\nlet onPerceptCallback: ((percept: Percept<HearingPerceptPayload>) => void) | null = null;\n\n/**\n * Initializes the hearing Web Worker and loads the STT model.\n */\nasync function initializeHearingWorker(): Promise<void> {\n  if (isWorkerInitialized) {\n    console.warn('Hearing worker already initialized.');\n    return;\n  }\n\n  if (typeof Worker === 'undefined') {\n    console.error('Web Workers are not supported in this environment. Falling back to Web Speech API (not yet implemented).');\n    // TODO: Implement Web Speech API fallback here\n    return;\n  }\n\n  hearingWorker = new Worker(new URL('../workers/hearingWorker.ts', import.meta.url), { type: 'module' });\n\n  hearingWorker.onmessage = (event: MessageEvent<Percept<HearingPerceptPayload>>) => {\n    if (onPerceptCallback) {\n      onPerceptCallback(event.data);\n    }\n  };\n\n  hearingWorker.onerror = (error: ErrorEvent) => {\n    console.error('Hearing worker error:', error);\n  };\n\n  // Send a message to the worker to load the STT model (no audio context passed from here)\n  hearingWorker.postMessage({ type: 'LOAD_STT_MODEL', payload: {} });\n  isWorkerInitialized = true;\n  console.log('Hearing worker initialized and STT model load message sent.');\n}\n\n/**\n * Processes an audio chunk using the hearing worker.\n * @param audioData The audio data (e.g., Float32Array).\n */\nfunction processAudioChunk(audioData: Float32Array): void {\n  if (!isWorkerInitialized || !hearingWorker) {\n    console.warn('Hearing worker not initialized. Cannot process audio chunk.');\n    return;\n  }\n\n  hearingWorker.postMessage({ type: 'PROCESS_AUDIO', payload: audioData }, [audioData.buffer]);\n}\n\n/**\n * Sets the callback function for receiving hearing percepts.\n * @param callback The callback function.\n */\nfunction setOnPerceptCallback(callback: ((percept: Percept<HearingPerceptPayload>) => void) | null) {\n  onPerceptCallback = callback;\n}\n\n/**\n * Terminates the hearing worker.\n */\nfunction terminateHearingWorker(): void {\n  if (hearingWorker) {\n    hearingWorker.terminate();\n    hearingWorker = null;\n    isWorkerInitialized = false;\n    console.log('Hearing worker terminated.');\n  }\n}\n\nexport const hearingSense = {\n  initialize: initializeHearingWorker,\n  processAudio: processAudioChunk,\n  terminate: terminateHearingWorker,\n  setOnPerceptCallback: setOnPerceptCallback,\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\senses\\vision.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\AuditService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\ForgetService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\GitHubCacheService.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'GitHubCacheDB' is defined but never used. Allowed unused vars must match /^_/u.","line":13,"column":11,"nodeType":null,"messageId":"unusedVar","endLine":13,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[459,462],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[459,462],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":26,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":26,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[624,627],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[624,627],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":34,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":34,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[749,752],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[749,752],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":43,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":43,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[916,919],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[916,919],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":13,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":16,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1078,1081],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1078,1081],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":79,"column":23,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":79,"endColumn":26,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1726,1729],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1726,1729],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":93,"column":41,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":93,"endColumn":44,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2091,2094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2091,2094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":97,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":97,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2248,2251],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2248,2251],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2328,2331],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2328,2331],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":87,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":90,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2382,2385],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2382,2385],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":98,"column":103,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":98,"endColumn":106,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2398,2401],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2398,2401],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":102,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":102,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2536,2539],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2536,2539],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":132,"column":91,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":132,"endColumn":94,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4067,4070],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4067,4070],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":155,"column":60,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":155,"endColumn":63,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4693,4696],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4693,4696],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":167,"column":59,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":167,"endColumn":62,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5077,5080],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5077,5080],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":189,"column":68,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":189,"endColumn":71,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5843,5846],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5843,5846],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":211,"column":66,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":211,"endColumn":69,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6552,6555],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6552,6555],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":232,"column":73,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":232,"endColumn":76,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7127,7130],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7127,7130],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":254,"column":79,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":254,"endColumn":82,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7784,7787],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7784,7787],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":276,"column":80,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":276,"endColumn":83,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[8514,8517],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[8514,8517],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":298,"column":85,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":298,"endColumn":88,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9187,9190],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9187,9190],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":320,"column":92,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":320,"endColumn":95,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9975,9978],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9975,9978],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":342,"column":65,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":342,"endColumn":68,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10654,10657],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10654,10657],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":364,"column":67,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":364,"endColumn":70,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[11371,11374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[11371,11374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":386,"column":64,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":386,"endColumn":67,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[12011,12014],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[12011,12014],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":26,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Service de cache pour les donn├®es GitHub utilisant IndexedDB\n * \n * Ce service permet de stocker localement les r├®sultats des requ├¬tes\n * ├á l'API GitHub pour am├®liorer les performances et r├®duire les appels API.\n */\n\nimport { createLogger } from '../utils/logger';\n\nconst logger = createLogger('GitHubCacheService');\n\n// D├®finition des types pour la base de donn├®es\ninterface GitHubCacheDB {\n  repositories: {\n    key: string;\n    value: {\n      data: any;\n      timestamp: number;\n      username?: string;\n    };\n    indexes: { 'by-username': string };\n  };\n  repository: {\n    key: string;\n    value: {\n      data: any;\n      timestamp: number;\n      repoFullName?: string;\n    };\n  };\n  issues: {\n    key: string;\n    value: {\n      data: any;\n      timestamp: number;\n      repoFullName?: string;\n    };\n    indexes: { 'by-repo': string };\n  };\n  pullRequests: {\n    key: string;\n    value: {\n      data: any;\n      timestamp: number;\n      repoFullName?: string;\n    };\n    indexes: { 'by-repo': string };\n  };\n  commits: {\n    key: string;\n    value: {\n      data: any;\n      timestamp: number;\n      repoFullName?: string;\n    };\n    indexes: { 'by-repo': string };\n  };\n  readmes: {\n    key: string;\n    value: {\n      content: string;\n      url: string;\n      timestamp: number;\n    };\n  };\n}\n\n// Configurer les dur├®es de validit├® du cache (en millisecondes)\nconst CACHE_DURATION = {\n  repositories: 1000 * 60 * 30, // 30 minutes\n  repository: 1000 * 60 * 30,   // 30 minutes\n  issues: 1000 * 60 * 15,       // 15 minutes\n  pullRequests: 1000 * 60 * 15, // 15 minutes\n  commits: 1000 * 60 * 30,      // 30 minutes\n  readmes: 1000 * 60 * 60,      // 1 heure\n};\n\nclass GitHubCacheService {\n  private db: Promise<any>;\n  private static instance: GitHubCacheService;\n\n  private constructor() {\n    this.db = this.initDatabase();\n  }\n\n  public static getInstance(): GitHubCacheService {\n    if (!GitHubCacheService.instance) {\n      GitHubCacheService.instance = new GitHubCacheService();\n    }\n    return GitHubCacheService.instance;\n  }\n\n  private async initDatabase(): Promise<any> {\n    try {\n      // Import dynamique d'idb pour ├®viter l'├®chec de r├®solution au build si non install├®\n      const modName = 'idb';\n      const idbMod: any = await import(/* @vite-ignore */ modName);\n      const openDB = (idbMod as any)?.openDB as (name: string, version: number, opts: any) => Promise<any>;\n      if (!openDB) throw new Error('openDB not available');\n\n      const db = await openDB('github-cache', 1, {\n        upgrade(db: any) {\n          // Cr├®er les object stores pour chaque type de donn├®es\n          if (!db.objectStoreNames.contains('repositories')) {\n            const reposStore = db.createObjectStore('repositories', { keyPath: 'key' });\n            reposStore.createIndex('by-username', 'username');\n          }\n          if (!db.objectStoreNames.contains('repository')) {\n            db.createObjectStore('repository', { keyPath: 'key' });\n          }\n          if (!db.objectStoreNames.contains('issues')) {\n            const issuesStore = db.createObjectStore('issues', { keyPath: 'key' });\n            issuesStore.createIndex('by-repo', 'repoFullName');\n          }\n          if (!db.objectStoreNames.contains('pullRequests')) {\n            const prsStore = db.createObjectStore('pullRequests', { keyPath: 'key' });\n            prsStore.createIndex('by-repo', 'repoFullName');\n          }\n          if (!db.objectStoreNames.contains('commits')) {\n            const commitsStore = db.createObjectStore('commits', { keyPath: 'key' });\n            commitsStore.createIndex('by-repo', 'repoFullName');\n          }\n          if (!db.objectStoreNames.contains('readmes')) {\n            db.createObjectStore('readmes', { keyPath: 'key' });\n          }\n        },\n      });\n      logger.info('Base de donn├®es GitHubCache initialis├®e avec succ├¿s');\n      return db;\n    } catch (error) {\n      // Fallback no-op cache (d├®sactive le cache si idb indisponible)\n      logger.warn('IndexedDB (idb) indisponible, d├®sactivation du cache GitHub', error as any);\n      const noop = async () => undefined;\n      return {\n        get: noop,\n        put: noop,\n        clear: noop,\n        transaction: () => ({ store: { openCursor: async () => null } }),\n        objectStoreNames: { contains: () => false },\n      };\n    }\n  }\n\n  /**\n   * V├®rifie si les donn├®es en cache sont valides\n   */\n  private isCacheValid(timestamp: number, type: keyof typeof CACHE_DURATION): boolean {\n    const now = Date.now();\n    return now - timestamp < CACHE_DURATION[type];\n  }\n\n  /**\n   * G├®n├¿re une cl├® unique pour un ├®l├®ment de cache\n   */\n  private generateKey(type: string, params: Record<string, any>): string {\n    const paramsString = Object.entries(params)\n      .sort(([keyA], [keyB]) => keyA.localeCompare(keyB))\n      .map(([key, value]) => `${key}=${value}`)\n      .join('&');\n    \n    return `${type}:${paramsString}`;\n  }\n\n  /**\n   * R├®cup├¿re les d├®p├┤ts en cache ou null si le cache est invalide/inexistant\n   */\n  public async getRepositories(username: string): Promise<any | null> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('repositories', { username });\n      const cachedData = await db.get('repositories', key);\n      \n      if (cachedData && this.isCacheValid(cachedData.timestamp, 'repositories')) {\n        logger.info(`Cache hit pour les d├®p├┤ts de ${username}`);\n        return cachedData.data;\n      }\n      \n      logger.info(`Cache miss pour les d├®p├┤ts de ${username}`);\n      return null;\n    } catch (error) {\n      logger.error('Erreur lors de la r├®cup├®ration des d├®p├┤ts en cache', error);\n      return null;\n    }\n  }\n\n  /**\n   * R├®cup├¿re un d├®p├┤t sp├®cifique en cache ou null si le cache est invalide/inexistant\n   */\n  public async getRepository(owner: string, repo: string): Promise<any | null> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('repository', { owner, repo });\n      const cachedData = await db.get('repository', key);\n      \n      if (cachedData && this.isCacheValid(cachedData.timestamp, 'repository')) {\n        logger.info(`Cache hit pour le d├®p├┤t ${owner}/${repo}`);\n        return cachedData.data;\n      }\n      \n      logger.info(`Cache miss pour le d├®p├┤t ${owner}/${repo}`);\n      return null;\n    } catch (error) {\n      logger.error('Erreur lors de la r├®cup├®ration du d├®p├┤t en cache', error);\n      return null;\n    }\n  }\n\n  /**\n   * Stocke les d├®p├┤ts dans le cache\n   */\n  public async cacheRepositories(username: string, repositories: any): Promise<void> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('repositories', { username });\n      \n      await db.put('repositories', {\n        key,\n        data: repositories,\n        timestamp: Date.now(),\n        username\n      });\n      \n      logger.info(`D├®p├┤ts de ${username} mis en cache`);\n    } catch (error) {\n      logger.error('Erreur lors de la mise en cache des d├®p├┤ts', error);\n    }\n  }\n  \n  /**\n   * Stocke un d├®p├┤t sp├®cifique dans le cache\n   */\n  public async cacheRepository(owner: string, repo: string, repository: any): Promise<void> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('repository', { owner, repo });\n      const repoFullName = `${owner}/${repo}`;\n      \n      await db.put('repository', {\n        key,\n        data: repository,\n        timestamp: Date.now(),\n        repoFullName\n      });\n      \n      logger.info(`D├®p├┤t ${repoFullName} mis en cache`);\n    } catch (error) {\n      logger.error('Erreur lors de la mise en cache du d├®p├┤t', error);\n    }\n  }\n\n  /**\n   * R├®cup├¿re les issues en cache ou null si le cache est invalide/inexistant\n   */\n  public async getIssues(owner: string, repo: string, state: string): Promise<any | null> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('issues', { owner, repo, state });\n      const cachedData = await db.get('issues', key);\n      \n      if (cachedData && this.isCacheValid(cachedData.timestamp, 'issues')) {\n        logger.info(`Cache hit pour les issues de ${owner}/${repo}`);\n        return cachedData.data;\n      }\n      \n      logger.info(`Cache miss pour les issues de ${owner}/${repo}`);\n      return null;\n    } catch (error) {\n      logger.error('Erreur lors de la r├®cup├®ration des issues en cache', error);\n      return null;\n    }\n  }\n\n  /**\n   * Stocke les issues dans le cache\n   */\n  public async cacheIssues(owner: string, repo: string, state: string, issues: any): Promise<void> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('issues', { owner, repo, state });\n      const repoFullName = `${owner}/${repo}`;\n      \n      await db.put('issues', {\n        key,\n        data: issues,\n        timestamp: Date.now(),\n        repoFullName\n      });\n      \n      logger.info(`Issues de ${repoFullName} mises en cache`);\n    } catch (error) {\n      logger.error('Erreur lors de la mise en cache des issues', error);\n    }\n  }\n\n  /**\n   * R├®cup├¿re les pull requests en cache ou null si le cache est invalide/inexistant\n   */\n  public async getPullRequests(owner: string, repo: string, state: string): Promise<any | null> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('pullRequests', { owner, repo, state });\n      const cachedData = await db.get('pullRequests', key);\n      \n      if (cachedData && this.isCacheValid(cachedData.timestamp, 'pullRequests')) {\n        logger.info(`Cache hit pour les pull requests de ${owner}/${repo}`);\n        return cachedData.data;\n      }\n      \n      logger.info(`Cache miss pour les pull requests de ${owner}/${repo}`);\n      return null;\n    } catch (error) {\n      logger.error('Erreur lors de la r├®cup├®ration des pull requests en cache', error);\n      return null;\n    }\n  }\n\n  /**\n   * Stocke les pull requests dans le cache\n   */\n  public async cachePullRequests(owner: string, repo: string, state: string, pullRequests: any): Promise<void> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('pullRequests', { owner, repo, state });\n      const repoFullName = `${owner}/${repo}`;\n      \n      await db.put('pullRequests', {\n        key,\n        data: pullRequests,\n        timestamp: Date.now(),\n        repoFullName\n      });\n      \n      logger.info(`Pull requests de ${repoFullName} mises en cache`);\n    } catch (error) {\n      logger.error('Erreur lors de la mise en cache des pull requests', error);\n    }\n  }\n\n  /**\n   * R├®cup├¿re les commits en cache ou null si le cache est invalide/inexistant\n   */\n  public async getCommits(owner: string, repo: string): Promise<any | null> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('commits', { owner, repo });\n      const cachedData = await db.get('commits', key);\n      \n      if (cachedData && this.isCacheValid(cachedData.timestamp, 'commits')) {\n        logger.info(`Cache hit pour les commits de ${owner}/${repo}`);\n        return cachedData.data;\n      }\n      \n      logger.info(`Cache miss pour les commits de ${owner}/${repo}`);\n      return null;\n    } catch (error) {\n      logger.error('Erreur lors de la r├®cup├®ration des commits en cache', error);\n      return null;\n    }\n  }\n\n  /**\n   * Stocke les commits dans le cache\n   */\n  public async cacheCommits(owner: string, repo: string, commits: any): Promise<void> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('commits', { owner, repo });\n      const repoFullName = `${owner}/${repo}`;\n      \n      await db.put('commits', {\n        key,\n        data: commits,\n        timestamp: Date.now(),\n        repoFullName\n      });\n      \n      logger.info(`Commits de ${repoFullName} mis en cache`);\n    } catch (error) {\n      logger.error('Erreur lors de la mise en cache des commits', error);\n    }\n  }\n\n  /**\n   * R├®cup├¿re le README en cache ou null si le cache est invalide/inexistant\n   */\n  public async getReadme(owner: string, repo: string): Promise<any | null> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('readmes', { owner, repo });\n      const cachedData = await db.get('readmes', key);\n      \n      if (cachedData && this.isCacheValid(cachedData.timestamp, 'readmes')) {\n        logger.info(`Cache hit pour le README de ${owner}/${repo}`);\n        return {\n          content: cachedData.content,\n          url: cachedData.url\n        };\n      }\n      \n      logger.info(`Cache miss pour le README de ${owner}/${repo}`);\n      return null;\n    } catch (error) {\n      logger.error('Erreur lors de la r├®cup├®ration du README en cache', error);\n      return null;\n    }\n  }\n\n  /**\n   * Stocke le README dans le cache\n   */\n  public async cacheReadme(owner: string, repo: string, content: string, url: string): Promise<void> {\n    try {\n      const db = await this.db;\n      const key = this.generateKey('readmes', { owner, repo });\n      \n      await db.put('readmes', {\n        key,\n        content,\n        url,\n        timestamp: Date.now()\n      });\n      \n      logger.info(`README de ${owner}/${repo} mis en cache`);\n    } catch (error) {\n      logger.error('Erreur lors de la mise en cache du README', error);\n    }\n  }\n\n  /**\n   * Efface les donn├®es obsol├¿tes du cache\n   */\n  public async clearStaleCache(): Promise<void> {\n    try {\n      const db = await this.db;\n      const now = Date.now();\n      \n      // Nettoyer les d├®p├┤ts obsol├¿tes\n      const repoTx = db.transaction('repositories', 'readwrite');\n      const repoCursor = await repoTx.store.openCursor();\n      \n      while (repoCursor) {\n        if (now - repoCursor.value.timestamp > CACHE_DURATION.repositories) {\n          await repoCursor.delete();\n          logger.info('Suppression d\\'un ├®l├®ment de cache de d├®p├┤t obsol├¿te');\n        }\n        await repoCursor.continue();\n      }\n      \n      // Nettoyer les issues obsol├¿tes\n      const issueTx = db.transaction('issues', 'readwrite');\n      const issueCursor = await issueTx.store.openCursor();\n      \n      while (issueCursor) {\n        if (now - issueCursor.value.timestamp > CACHE_DURATION.issues) {\n          await issueCursor.delete();\n          logger.info('Suppression d\\'un ├®l├®ment de cache d\\'issue obsol├¿te');\n        }\n        await issueCursor.continue();\n      }\n      \n      // Continuer avec les autres types de donn├®es...\n      logger.info('Nettoyage du cache termin├®');\n    } catch (error) {\n      logger.error('Erreur lors du nettoyage du cache', error);\n    }\n  }\n\n  /**\n   * Efface toutes les donn├®es du cache\n   */\n  public async clearAllCache(): Promise<void> {\n    try {\n      const db = await this.db;\n      \n      await db.clear('repositories');\n      await db.clear('repository');\n      await db.clear('issues');\n      await db.clear('pullRequests');\n      await db.clear('commits');\n      await db.clear('readmes');\n      \n      logger.info('Cache enti├¿rement effac├®');\n    } catch (error) {\n      logger.error('Erreur lors de l\\'effacement complet du cache', error);\n    }\n  }\n}\n\nexport default GitHubCacheService;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\IntegrationService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\MemoryService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\RAGService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\RosService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":84,"column":104,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":84,"endColumn":107,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2372,2375],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2372,2375],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import ROSLIB from 'roslib';\nconst { Ros, Topic, Service } = ROSLIB;\n\nexport class RosService {\n  private ros: InstanceType<typeof Ros>;\n  private isConnected: boolean = false;\n  private connectionPromise: Promise<void>;\n  private resolveConnection!: () => void;\n  private rejectConnection!: (error: Error) => void;\n\n  constructor(url: string) {\n    this.ros = new Ros({ url });\n\n    this.connectionPromise = new Promise((resolve, reject) => {\n      this.resolveConnection = resolve;\n      this.rejectConnection = reject;\n    });\n\n    this.ros.on('connection', () => {\n      console.log('Connected to ROS Bridge.');\n      this.isConnected = true;\n      this.resolveConnection();\n    });\n\n    this.ros.on('error', (error) => {\n      console.error('Error connecting to ROS Bridge:', error);\n      this.isConnected = false;\n      this.rejectConnection(new Error(`ROS connection error: ${error.message || error}`));\n    });\n\n    this.ros.on('close', () => {\n      console.log('Disconnected from ROS Bridge.');\n      this.isConnected = false;\n      // Optionally, try to reconnect here\n    });\n  }\n\n  public async ensureConnection(): Promise<void> {\n    if (this.isConnected) {\n      return Promise.resolve();\n    }\n    return this.connectionPromise;\n  }\n\n  public isCurrentlyConnected(): boolean {\n    return this.isConnected;\n  }\n\n  public disconnect(): void {\n    this.ros.close();\n  }\n\n  public publish(topicName: string, messageType: string, message: Message): void {\n    this.ensureConnection().then(() => {\n      const topic = new Topic({\n        ros: this.ros,\n        name: topicName,\n        messageType: messageType\n      });\n      topic.publish(message);\n      console.log(`Published to ${topicName}:`, message);\n    }).catch(error => {\n      console.error(`Failed to publish to ${topicName}:`, error);\n    });\n  }\n\n  public subscribe(topicName: string, messageType: string, callback: (message: Message) => void): Topic {\n    const topic = new Topic({\n      ros: this.ros,\n      name: topicName,\n      messageType: messageType\n    });\n\n    topic.subscribe(callback);\n    console.log(`Subscribed to ${topicName}`);\n    return topic;\n  }\n\n  public unsubscribe(topic: Topic): void {\n    topic.unsubscribe();\n    console.log(`Unsubscribed from ${topic.name}`);\n  }\n\n  public async callService(serviceName: string, serviceType: string, request: ServiceRequest): Promise<any> {\n    await this.ensureConnection();\n\n    const service = new Service({\n      ros: this.ros,\n      name: serviceName,\n      serviceType: serviceType\n    });\n\n    return new Promise((resolve, reject) => {\n      service.callService(request, (result) => {\n        console.log(`Service ${serviceName} call successful:`, result);\n        resolve(result);\n      }, (error) => {\n        console.error(`Service ${serviceName} call failed:`, error);\n        reject(new Error(`ROS service call failed: ${error}`));\n      });\n    });\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\UnrealEngineService.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":9,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":12,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[376,379],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[376,379],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":56,"column":34,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":56,"endColumn":42},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":295,"column":31,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":295,"endColumn":39},{"ruleId":"@typescript-eslint/no-unsafe-function-type","severity":2,"message":"The `Function` type accepts any function-like value.\nPrefer explicitly defining any function parameters and return type.","line":305,"column":32,"nodeType":"Identifier","messageId":"bannedFunctionType","endLine":305,"endColumn":40},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":318,"column":38,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":318,"endColumn":41,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7476,7479],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7476,7479],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":405,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":405,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[10027,10030],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[10027,10030],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":3,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * UnrealEngineService.ts\n * \n * Service for communicating with Unreal Engine 5.6 MetaHuman instance\n * Handles WebSocket communication, avatar control, and real-time synchronization\n */\n\nexport interface MetaHumanCommand {\n  type: 'expression' | 'speech' | 'pose' | 'animation' | 'blendshape' | 'camera' | 'lighting' | 'lumen' | 'nanite' | 'chaos' | 'metasound';\n  data: any;\n  timestamp?: number;\n  id?: string;\n  priority?: 'low' | 'normal' | 'high' | 'critical';\n  ue56Features?: {\n    useLumen?: boolean;\n    useNanite?: boolean;\n    useChaosPhysics?: boolean;\n    useMetaSounds?: boolean;\n  };\n}\n\nexport interface MetaHumanExpression {\n  name: string;\n  intensity: number;\n  duration?: number;\n  blendMode?: 'replace' | 'additive';\n}\n\nexport interface MetaHumanSpeech {\n  text: string;\n  audioUrl?: string;\n  visemes?: Array<{ time: number; viseme: string; intensity: number }>;\n  duration?: number;\n  voice?: string;\n}\n\nexport interface MetaHumanPose {\n  name: string;\n  transition?: number;\n  loop?: boolean;\n}\n\nexport interface MetaHumanBlendShape {\n  name: string;\n  value: number;\n  transition?: number;\n}\n\nexport class UnrealEngineService {\n  private ws: WebSocket | null = null;\n  private isConnected = false;\n  private reconnectAttempts = 0;\n  private maxReconnectAttempts = 5;\n  private reconnectDelay = 1000;\n  private messageQueue: MetaHumanCommand[] = [];\n  private listeners: Map<string, Function[]> = new Map();\n\n  // Default Unreal Engine WebSocket endpoint\n  private readonly defaultEndpoint = 'ws://localhost:8080/metahuman';\n  private endpoint: string;\n\n  constructor(endpoint?: string) {\n    this.endpoint = endpoint || this.defaultEndpoint;\n    this.setupEventListeners();\n  }\n\n  /**\n   * Connect to Unreal Engine instance\n   */\n  async connect(): Promise<boolean> {\n    try {\n      console.log(`Connecting to Unreal Engine at ${this.endpoint}...`);\n      \n      this.ws = new WebSocket(this.endpoint);\n      \n      return new Promise((resolve, reject) => {\n        if (!this.ws) {\n          reject(new Error('Failed to create WebSocket'));\n          return;\n        }\n\n        this.ws.onopen = () => {\n          console.log('Connected to Unreal Engine MetaHuman service');\n          this.isConnected = true;\n          this.reconnectAttempts = 0;\n          this.processMessageQueue();\n          this.emit('connected');\n          resolve(true);\n        };\n\n        this.ws.onerror = (error) => {\n          console.error('Unreal Engine connection error:', error);\n          this.isConnected = false;\n          this.emit('error', error);\n          reject(error);\n        };\n\n        this.ws.onclose = () => {\n          console.log('Disconnected from Unreal Engine');\n          this.isConnected = false;\n          this.emit('disconnected');\n          this.handleReconnection();\n        };\n\n        this.ws.onmessage = (event) => {\n          this.handleMessage(event.data);\n        };\n\n        // Timeout after 5 seconds\n        setTimeout(() => {\n          if (!this.isConnected) {\n            reject(new Error('Connection timeout'));\n          }\n        }, 5000);\n      });\n    } catch (error) {\n      console.error('Failed to connect to Unreal Engine:', error);\n      return false;\n    }\n  }\n\n  /**\n   * Disconnect from Unreal Engine\n   */\n  disconnect(): void {\n    if (this.ws) {\n      this.ws.close();\n      this.ws = null;\n    }\n    this.isConnected = false;\n  }\n\n  /**\n   * Send command to Unreal Engine\n   */\n  sendCommand(command: MetaHumanCommand): boolean {\n    const commandWithId = {\n      ...command,\n      id: this.generateId(),\n      timestamp: Date.now()\n    };\n\n    if (!this.isConnected || !this.ws) {\n      console.warn('Not connected to Unreal Engine, queuing command:', command.type);\n      this.messageQueue.push(commandWithId);\n      return false;\n    }\n\n    try {\n      this.ws.send(JSON.stringify(commandWithId));\n      console.log('Sent command to Unreal Engine:', command.type);\n      return true;\n    } catch (error) {\n      console.error('Failed to send command:', error);\n      this.messageQueue.push(commandWithId);\n      return false;\n    }\n  }\n\n  /**\n   * Set MetaHuman facial expression\n   */\n  setExpression(expression: MetaHumanExpression): boolean {\n    return this.sendCommand({\n      type: 'expression',\n      data: expression\n    });\n  }\n\n  /**\n   * Make MetaHuman speak with lip sync\n   */\n  speak(speech: MetaHumanSpeech): boolean {\n    return this.sendCommand({\n      type: 'speech',\n      data: speech\n    });\n  }\n\n  /**\n   * Set MetaHuman pose\n   */\n  setPose(pose: MetaHumanPose): boolean {\n    return this.sendCommand({\n      type: 'pose',\n      data: pose\n    });\n  }\n\n  /**\n   * Configure Lumen lighting (UE 5.6)\n   */\n  configureLumen(settings: {\n    globalIllumination?: boolean;\n    reflections?: boolean;\n    quality?: 'low' | 'medium' | 'high' | 'epic';\n    updateRate?: number;\n  }): boolean {\n    return this.sendCommand({\n      type: 'lumen',\n      data: settings,\n      ue56Features: { useLumen: true }\n    });\n  }\n\n  /**\n   * Configure Nanite virtualized geometry (UE 5.6)\n   */\n  configureNanite(settings: {\n    enabled?: boolean;\n    clusterCulling?: boolean;\n    programmableRaster?: boolean;\n    maxTriangles?: number;\n  }): boolean {\n    return this.sendCommand({\n      type: 'nanite',\n      data: settings,\n      ue56Features: { useNanite: true }\n    });\n  }\n\n  /**\n   * Configure Chaos Physics (UE 5.6)\n   */\n  configureChaosPhysics(settings: {\n    enabled?: boolean;\n    clothSimulation?: boolean;\n    hairPhysics?: boolean;\n    fluidSimulation?: boolean;\n  }): boolean {\n    return this.sendCommand({\n      type: 'chaos',\n      data: settings,\n      ue56Features: { useChaosPhysics: true }\n    });\n  }\n\n  /**\n   * Play MetaSound (UE 5.6)\n   */\n  playMetaSound(settings: {\n    soundAsset: string;\n    volume?: number;\n    pitch?: number;\n    spatialAudio?: boolean;\n    position?: { x: number; y: number; z: number };\n  }): boolean {\n    return this.sendCommand({\n      type: 'metasound',\n      data: settings,\n      ue56Features: { useMetaSounds: true }\n    });\n  }\n\n  /**\n   * Control individual blend shapes\n   */\n  setBlendShape(blendShape: MetaHumanBlendShape): boolean {\n    return this.sendCommand({\n      type: 'blendshape',\n      data: blendShape\n    });\n  }\n\n  /**\n   * Control camera in Unreal Engine\n   */\n  setCamera(position: { x: number; y: number; z: number }, rotation: { x: number; y: number; z: number }): boolean {\n    return this.sendCommand({\n      type: 'camera',\n      data: { position, rotation }\n    });\n  }\n\n  /**\n   * Control lighting\n   */\n  setLighting(lighting: { intensity: number; color: string; direction?: { x: number; y: number; z: number } }): boolean {\n    return this.sendCommand({\n      type: 'lighting',\n      data: lighting\n    });\n  }\n\n  /**\n   * Check if connected to Unreal Engine\n   */\n  isConnectedToUnreal(): boolean {\n    return this.isConnected;\n  }\n\n  /**\n   * Add event listener\n   */\n  on(event: string, callback: Function): void {\n    if (!this.listeners.has(event)) {\n      this.listeners.set(event, []);\n    }\n    this.listeners.get(event)!.push(callback);\n  }\n\n  /**\n   * Remove event listener\n   */\n  off(event: string, callback: Function): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      const index = callbacks.indexOf(callback);\n      if (index > -1) {\n        callbacks.splice(index, 1);\n      }\n    }\n  }\n\n  /**\n   * Emit event to listeners\n   */\n  private emit(event: string, data?: any): void {\n    const callbacks = this.listeners.get(event);\n    if (callbacks) {\n      callbacks.forEach(callback => callback(data));\n    }\n  }\n\n  /**\n   * Handle incoming messages from Unreal Engine\n   */\n  private handleMessage(data: string): void {\n    try {\n      const message = JSON.parse(data);\n      console.log('Received from Unreal Engine:', message);\n      this.emit('message', message);\n      \n      // Handle specific message types\n      switch (message.type) {\n        case 'status':\n          this.emit('status', message.data);\n          break;\n        case 'error':\n          this.emit('unrealError', message.data);\n          break;\n        case 'animation_complete':\n          this.emit('animationComplete', message.data);\n          break;\n        case 'speech_complete':\n          this.emit('speechComplete', message.data);\n          break;\n      }\n    } catch (error) {\n      console.error('Failed to parse message from Unreal Engine:', error);\n    }\n  }\n\n  /**\n   * Process queued messages when connection is restored\n   */\n  private processMessageQueue(): void {\n    while (this.messageQueue.length > 0 && this.isConnected) {\n      const command = this.messageQueue.shift();\n      if (command && this.ws) {\n        try {\n          this.ws.send(JSON.stringify(command));\n          console.log('Processed queued command:', command.type);\n        } catch (error) {\n          console.error('Failed to process queued command:', error);\n          // Put it back at the front of the queue\n          this.messageQueue.unshift(command);\n          break;\n        }\n      }\n    }\n  }\n\n  /**\n   * Handle reconnection logic\n   */\n  private handleReconnection(): void {\n    if (this.reconnectAttempts < this.maxReconnectAttempts) {\n      this.reconnectAttempts++;\n      console.log(`Attempting to reconnect (${this.reconnectAttempts}/${this.maxReconnectAttempts})...`);\n      \n      setTimeout(() => {\n        this.connect().catch(error => {\n          console.error('Reconnection failed:', error);\n        });\n      }, this.reconnectDelay * this.reconnectAttempts);\n    } else {\n      console.error('Max reconnection attempts reached');\n      this.emit('maxReconnectAttemptsReached');\n    }\n  }\n\n  /**\n   * Setup default event listeners\n   */\n  private setupEventListeners(): void {\n    this.on('connected', () => {\n      console.log('Ô£à MetaHuman service connected to Unreal Engine');\n    });\n\n    this.on('disconnected', () => {\n      console.log('ÔØî MetaHuman service disconnected from Unreal Engine');\n    });\n\n    this.on('error', (error: any) => {\n      console.error('­ƒÜ¿ Unreal Engine service error:', error);\n    });\n  }\n\n  /**\n   * Generate unique ID for commands\n   */\n  private generateId(): string {\n    return Date.now().toString(36) + Math.random().toString(36).substr(2, 9);\n  }\n}\n\n// Singleton instance\nexport const unrealEngineService = new UnrealEngineService();\n\nexport default unrealEngineService;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\WorkflowService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\services\\aiService.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\setupTests.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\store\\appStore.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":45,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":45,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1734,1737],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1734,1737],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":48,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":48,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1839,1842],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1839,1842],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":52,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":52,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1918,1921],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1918,1921],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":32,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":35,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4065,4068],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4065,4068],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":134,"column":35,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":134,"endColumn":38,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4256,4259],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4256,4259],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":29,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":32,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5091,5094],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5091,5094],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":33,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":36,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5685,5688],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5685,5688],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":178,"column":43,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":178,"endColumn":46,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5695,5698],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5695,5698],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":180,"column":53,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":180,"endColumn":56,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[5796,5799],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[5796,5799],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":9,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import { create } from 'zustand';\nimport { persist, subscribeWithSelector } from 'zustand/middleware';\nimport type { Percept, VisionPayload } from '../senses/vision'; // Import new types\n\n/* ---------- Shared domain types (copied from previous store) ---------- */\nexport interface CalendarEvent {\n  id: string;\n  summary: string;\n  start: { dateTime: string; timeZone: string };\n  end: { dateTime: string; timeZone: string };\n  description?: string;\n  location?: string;\n}\n\n// These types are now replaced or augmented by VisionPayload\n// export type FaceResult = { landmarks: Float32Array; boundingBox: DOMRectReadOnly; score: number }[];\n// export type HandResult = { landmarks: Float32Array; handedness: 'Left' | 'Right'; score: number }[];\n// export type ObjectResult = { box: DOMRectReadOnly; category: string; score: number }[];\nexport type PoseResult = { landmarks: Float32Array; score: number }[];\nexport type AudioResult = { category: string; score: number; timestamp: number };\n\nimport type { HearingPerceptPayload } from '../senses/hearing';\n\nexport interface Alarm { id: string; time: number; label?: string; triggered?: boolean; recurrence?: 'daily' | 'weekdays' }\nexport interface Timer { id: string; finish: number; label?: string; triggered?: boolean }\nexport interface Todo { id: string; text: string }\n\nexport interface ChatMessage { role: string; content: string }\n\nexport interface ConversationContext {\n  lastUtterance?: string;\n  lastIntent?: string;\n  lastSpokenText?: string;\n  subject?: string;\n  timestamp: number;\n  followUpExpected?: boolean;\n  chatHistory?: ChatMessage[];\n}\n\nexport interface WorkflowStep {\n  id: number;\n  description: string;\n  agent: string;\n  command: string;\n  args: Record<string, any>;\n  dependencies: number[];\n  status: 'pending' | 'in_progress' | 'completed' | 'failed';\n  result?: any;\n  startTime?: number;\n  endTime?: number;\n  duration?: number;\n  output?: any;\n  error?: string;\n}\n\nexport type NodeExecutionStatus = 'idle' | 'running' | 'success' | 'failed' | 'skipped';\nexport type EdgeExecutionStatus = 'idle' | 'active' | 'skipped';\n\n/* ---------- Slice definitions ---------- */\n\ninterface VisionSlice {\n  percepts?: Percept<VisionPayload>[]; // Updated to use new Percept type\n  lastSilenceMs: number;\n  smileDetected: boolean;\n  speechDetected: boolean;\n}\n\ninterface AudioSlice {\n  audio?: AudioResult;\n  audioEnabled: boolean;\n  hearingPercepts?: Percept<HearingPerceptPayload>[];\n  setAudioEnabled: (enabled: boolean) => void;\n}\n\ninterface WorkflowSlice {\n  plan: WorkflowStep[] | null;\n  templates: string[];\n  checkpoints: string[];\n  nodeExecutionStatus: Record<string, NodeExecutionStatus>;\n  edgeExecutionStatus: Record<string, EdgeExecutionStatus>;\n  setPlan: (plan: WorkflowStep[] | null) => void;\n  setTemplates: (templates: string[]) => void;\n  setCheckpoints: (checkpoints: string[]) => void;\n  setNodeExecutionStatus: (nodeId: string, status: NodeExecutionStatus) => void;\n  setEdgeExecutionStatus: (edgeId: string, status: EdgeExecutionStatus) => void;\n  resetExecutionStatus: () => void;\n}\n\ninterface UiSlice {\n  todos: Todo[];\n  alarms: Alarm[];\n  timers: Timer[];\n  listeningActive: boolean;\n  clipboardMonitoringEnabled: boolean;\n  clipboardSummary?: string;\n  lastPlanExplanation: string | null;\n  lastPlanTraceId?: string;\n  intent?: string;\n  intentPayload?: unknown;\n  conversationContext?: ConversationContext;\n  featureFlags: {\n    advancedVision: boolean;\n    advancedHearing: boolean;\n  };\n  setLastPlanExplanation: (explanation: string | null, traceId?: string) => void;\n}\n\ninterface CommonSlice {\n  setState: (\n    partial: Partial<AppState> | ((state: AppState) => Partial<AppState>)\n  ) => void;\n}\n\nexport type AppState = VisionSlice & AudioSlice & WorkflowSlice & UiSlice & CommonSlice;\n// Legacy compatibility\nexport type VisionAudioState = AppState;\n\n/* ---------- Slice creators ---------- */\n\nconst createVisionSlice = (): VisionSlice => ({\n  percepts: [],\n  lastSilenceMs: 0,\n  smileDetected: false,\n  speechDetected: false,\n});\n\nconst createAudioSlice = (set: any): AudioSlice => ({\n  audio: undefined,\n  audioEnabled: true,\n  hearingPercepts: [],\n  setAudioEnabled: (enabled) => set({ audioEnabled: enabled }),\n});\n\nconst createWorkflowSlice = (set: any): WorkflowSlice => ({\n  plan: null,\n  templates: [],\n  checkpoints: [],\n  nodeExecutionStatus: {},\n  edgeExecutionStatus: {},\n  setPlan: (plan) => set({ plan }),\n  setTemplates: (templates) => set({ templates }),\n  setCheckpoints: (checkpoints) => set({ checkpoints }),\n  setNodeExecutionStatus: (nodeId, status) =>\n    set((state: AppState) => ({\n      nodeExecutionStatus: { ...state.nodeExecutionStatus, [nodeId]: status },\n    })),\n  setEdgeExecutionStatus: (edgeId, status) =>\n    set((state: AppState) => ({\n      edgeExecutionStatus: { ...state.edgeExecutionStatus, [edgeId]: status },\n    })),\n  resetExecutionStatus: () =>\n    set(() => ({\n      nodeExecutionStatus: {} as Record<string, NodeExecutionStatus>,\n      edgeExecutionStatus: {} as Record<string, EdgeExecutionStatus>,\n    })),\n});\n\nconst createUiSlice = (set: any): UiSlice => ({\n  todos: [],\n  alarms: [],\n  timers: [],\n  listeningActive: false,\n  clipboardMonitoringEnabled: false,\n  clipboardSummary: undefined,\n  lastPlanExplanation: null,\n  lastPlanTraceId: undefined,\n  intent: undefined,\n  intentPayload: undefined,\n  conversationContext: undefined,\n  featureFlags: {\n    advancedVision: false, // D├®sactiv├® par d├®faut pour ├®viter les boucles infinies\n    advancedHearing: false,\n  },\n  setLastPlanExplanation: (explanation, traceId) =>\n    set({ lastPlanExplanation: explanation, lastPlanTraceId: traceId }),\n});\n\nconst createCommonSlice = (set: any, get: any): CommonSlice => ({\n  setState: (partial) =>\n    set(typeof partial === 'function' ? (partial as any)(get()) : partial),\n});\n\n/* ---------- Store ---------- */\n\nexport const useAppStore = create<AppState>()(\n  subscribeWithSelector(\n    persist(\n      (set, get) => ({\n        ...createVisionSlice(),\n        ...createAudioSlice(set),\n        ...createWorkflowSlice(set),\n        ...createUiSlice(set),\n        ...createCommonSlice(set, get),\n      }),\n      { name: 'lisa-store' }\n    )\n  )\n);\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\store\\chatHistoryStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\store\\metaHumanStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\store\\visionAudioStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\test\\setup.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\tools\\CodeInterpreterTool.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":7,"column":45,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":7,"endColumn":48,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[242,245],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[242,245],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":17,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":17,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[402,405],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[402,405],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":25,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":28,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1072,1075],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1072,1075],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * CodeInterpreterTool: A tool for executing Python code in a sandboxed environment using Pyodide.\n */\n\n// Minimal local type to avoid importing from 'pyodide' at build time\ntype PyodideAPI = {\n  runPythonAsync: (code: string) => Promise<any>;\n  loadPackage?: (name: string) => Promise<void>;\n};\n\ninterface ExecuteProps {\n  code: string;\n}\n\ninterface ExecuteResult {\n  success: boolean;\n  output?: any;\n  error?: string;\n}\n\nexport class CodeInterpreterTool {\n  name = 'CodeInterpreterTool';\n  description = 'Executes Python code in a sandboxed environment. The final expression or a variable named `result` will be returned.';\n\n  private static pyodideInstance: Promise<PyodideAPI> | null = null;\n\n  private static getPyodide(): Promise<PyodideAPI> {\n    if (this.pyodideInstance) {\n      return this.pyodideInstance;\n    }\n\n    console.log('Initializing Pyodide...');\n    const cdnBase = 'https://cdn.jsdelivr.net/pyodide/v0.25.1/full/';\n    const mjsUrl = `${cdnBase}pyodide.mjs`;\n    this.pyodideInstance = import(/* @vite-ignore */ mjsUrl)\n      .then(async (mod: any) => {\n        const pyodide: PyodideAPI = await mod.loadPyodide({ indexURL: cdnBase });\n        console.log('Pyodide initialized successfully.');\n        return pyodide;\n      })\n      .catch((error: Error) => {\n        console.error('Failed to initialize Pyodide:', error);\n        this.pyodideInstance = null; // Reset on failure to allow retry\n        throw error; // Re-throw to propagate the error\n      });\n\n    return this.pyodideInstance;\n  }\n\n  async execute({ code }: ExecuteProps): Promise<ExecuteResult> {\n    if (!code || typeof code !== 'string') {\n      return { success: false, error: 'A valid code string must be provided.' };\n    }\n\n    try {\n      const pyodide = await CodeInterpreterTool.getPyodide();\n      const result = await pyodide.runPythonAsync(code);\n      return { success: true, output: result };\n    } catch (error: unknown) {\n      console.error(`${this.name} execution failed:`, error);\n      const message = error instanceof Error ? error.message : String(error);\n      return { success: false, error: message };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\tools\\WebContentReaderTool.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":87,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":87,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2928,2931],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2928,2931],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebContentReaderTool: A tool for fetching, parsing, and summarizing the content of a web page.\n */\n\ninterface ExecuteProps {\n  url: string;\n}\n\ninterface ExecuteResult {\n  success: boolean;\n  output?: { summary: string } | null;\n  error?: string | null;\n}\n\nexport class WebContentReaderTool {\n  name = 'WebContentReaderTool';\n  description = 'Reads and summarizes the content of a given URL.';\n\n  private async summarize(url: string, textContent: string): Promise<string> {\n    const OPENAI_API_KEY = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!OPENAI_API_KEY) {\n      throw new Error('OpenAI API key is not configured for summarization.');\n    }\n  \n\n    const prompt = `Please provide a concise summary of the following web page content from ${url}. Focus on the main points and key takeaways.\\n\\n---\\n\\n${textContent}`;\n\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-3.5-turbo',\n        messages: [{ role: 'user', content: prompt }],\n        max_tokens: 500,\n        temperature: 0.5,\n      }),\n    });\n\n    if (!response.ok) {\n      const errorBody = await response.text();\n      throw new Error(`Summarization API request failed: ${errorBody}`);\n    }\n\n    const result = await response.json();\n    return result.choices[0].message.content;\n  }\n\n  private extractMainContent(html: string): string {\n    const parser = new DOMParser();\n    const doc = parser.parseFromString(html, 'text/html');\n\n    // Remove unwanted elements\n    doc.querySelectorAll('script, style, nav, footer, header, aside').forEach(el => el.remove());\n\n    // Get text from the main content area, or body as a fallback\n    const mainContent = doc.querySelector('main, article, body') as HTMLElement | null;\n    return mainContent ? mainContent.innerText.replace(/\\s\\s+/g, ' ').trim() : '';\n  }\n\n  async execute({ url }: ExecuteProps): Promise<ExecuteResult> {\n    if (!url || typeof url !== 'string') {\n      return { success: false, error: 'A valid URL must be provided.', output: null };\n    }\n\n    try {\n      // Use a CORS proxy to fetch website content from the client-side\n      const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;\n      const response = await fetch(proxyUrl);\n\n      if (!response.ok) {\n        throw new Error(`Failed to fetch URL content. Status: ${response.status}`);\n      }\n\n      const html = await response.text();\n      const textContent = this.extractMainContent(html);\n\n      if (!textContent) {\n        return { success: false, error: 'Could not extract meaningful content from the URL.', output: null };\n      }\n\n      const summary = await this.summarize(url, textContent);\n\n      return { success: true, output: { summary } };\n    } catch (error: any) {\n      console.error('WebContentReaderTool execution failed:', error);\n      return { success: false, error: error.message, output: null };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\tools\\WebSearchTool.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":85,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":85,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2731,2734],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2731,2734],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WebSearchTool: A tool for searching the web and summarizing results.\n */\n\n\n\ninterface SearchResult {\n  title: string;\n  snippet: string;\n}\n\ninterface ExecuteProps {\n  query: string;\n}\n\ninterface ExecuteResult {\n  success: boolean;\n  output?: { summary: string } | null;\n  error?: string | null;\n}\n\nexport class WebSearchTool {\n  name = 'WebSearchTool';\n  description = 'Performs a web search and provides a concise answer.';\n\n  private async summarize(query: string, searchResults: SearchResult[]): Promise<string> {\n    const OPENAI_API_KEY = import.meta.env.VITE_OPENAI_API_KEY;\n    if (!OPENAI_API_KEY) {\n      throw new Error('OpenAI API key is not configured for summarization.');\n    }\n\n    const content = searchResults.map(r => `Title: ${r.title}\\nSnippet: ${r.snippet}`).join('\\n\\n');\n    const prompt = `Based on the following search results for the query \"${query}\", provide a concise, helpful answer. Do not just list the results. Synthesize them into a coherent response.\\n\\n${content}`;\n\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${OPENAI_API_KEY}`,\n      },\n      body: JSON.stringify({\n        model: 'gpt-3.5-turbo',\n        messages: [{ role: 'user', content: prompt }],\n        temperature: 0.7,\n      }),\n    });\n\n    if (!response.ok) {\n      throw new Error('Summarization API request failed');\n    }\n\n    const result = await response.json();\n    return result.choices[0].message.content;\n  }\n\n  async execute({ query }: ExecuteProps): Promise<ExecuteResult> {\n    const GOOGLE_API_KEY = import.meta.env.VITE_GOOGLE_API_KEY;\n    const GOOGLE_CX = import.meta.env.VITE_GOOGLE_CX;\n    if (!GOOGLE_API_KEY || !GOOGLE_CX) {\n      return { success: false, error: 'Google Search API is not configured.', output: null };\n    }\n\n    if (!query || typeof query !== 'string') {\n      return { success: false, error: 'A valid search query must be provided.', output: null };\n    }\n\n    try {\n      const searchUrl = `https://www.googleapis.com/customsearch/v1?key=${GOOGLE_API_KEY}&cx=${GOOGLE_CX}&q=${encodeURIComponent(query)}`;\n      const response = await fetch(searchUrl);\n\n      if (!response.ok) {\n        throw new Error('Google Search API request failed');\n      }\n\n      const searchData = await response.json();\n      const searchResults = searchData.items || [];\n\n      if (searchResults.length === 0) {\n        return { success: true, output: { summary: 'No relevant search results found.' } };\n      }\n\n      const summary = await this.summarize(query, searchResults);\n\n      return { success: true, output: { summary } };\n    } catch (error: any) {\n      console.error('WebSearchTool execution failed:', error);\n      return { success: false, error: error.message, output: null };\n    }\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\tools\\tests\\CodeInterpreterTool.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\tools\\tests\\WebContentReaderTool.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\tools\\tests\\WebSearchTool.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\Planner.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":27,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":27,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[737,740],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[737,740],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[949,952],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[949,952],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":127,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":127,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3842,3845],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3842,3845],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Planner.ts\n * \n * Type definitions for the PlannerAgent and workflow execution system\n */\n\nimport type { AgentExecuteProps, AgentExecuteResult } from '../agents/types.js';\n\n/**\n * Status of a workflow step\n */\nexport type WorkflowStepStatus = 'pending' | 'in_progress' | 'completed' | 'failed';\n\n/**\n * Represents a single step in a workflow\n */\nexport interface WorkflowStep {\n  /** Unique identifier for this step */\n  id: number;\n  /** Human-readable description of what this step does */\n  description: string;\n  /** Name of the agent responsible for executing this step */\n  agent: string;\n  /** The command/function to call on the agent */\n  command: string;\n  /** Arguments to pass to the command */\n  args: Record<string, any>;\n  /** IDs of steps that must complete before this one can start */\n  dependencies: number[];\n  /** Current execution status */\n  status: WorkflowStepStatus;\n  /** Output of the step execution */\n  result?: any;\n  /** Performance timestamp when step started */\n  startTime?: number;\n  /** Performance timestamp when step completed */\n  endTime?: number;\n  /** Execution time in milliseconds */\n  duration?: number;\n}\n\n/**\n * Input properties for the PlannerAgent execute method\n */\nexport interface PlannerAgentExecuteProps extends AgentExecuteProps {\n  /** Name to save the current plan as a reusable template */\n  saveAsTemplate?: string;\n  /** Name of an existing template to load instead of generating a new plan */\n  loadFromTemplate?: string;\n  /** ID of a checkpoint to resume execution from */\n  resumeFromCheckpointId?: string;\n  /** Callback to notify UI of plan updates */\n  onPlanUpdate?: (plan: WorkflowStep[]) => void;\n}\n\n/**\n * A custom error class for detailed reporting when a workflow step fails.\n * Extends the native Error class to ensure type compatibility.\n */\nexport class WorkflowErrorReport extends Error {\n  /** The step that failed */\n  failedStep: WorkflowStep;\n  /** Whether the error can be recovered by revising the plan */\n  isRecoverable: boolean;\n  /** Suggested action to recover */\n  recoveryHint?: string;\n\n  constructor(message: string, failedStep: WorkflowStep, isRecoverable = false, recoveryHint?: string) {\n    super(message);\n    this.name = 'WorkflowErrorReport';\n    this.failedStep = failedStep;\n    this.isRecoverable = isRecoverable;\n    this.recoveryHint = recoveryHint;\n\n    // This is necessary for custom errors to work correctly in TypeScript\n    Object.setPrototypeOf(this, WorkflowErrorReport.prototype);\n  }\n}\n\n/**\n * Result of a workflow plan execution.\n * Extends the standard agent result to include planner-specific data.\n */\nexport interface PlannerResult extends AgentExecuteResult {\n  /** Whether the execution was successful */\n  success: boolean;\n  /** The final state of all workflow steps */\n  plan: WorkflowStep[];\n  /** Detailed error report if the workflow failed */\n  error?: WorkflowErrorReport | Error | string;\n  /** Human-readable summary of the execution, mapped to output */\n  output: string;\n  /** Total execution time in milliseconds */\n  totalDuration?: number;\n  /** A detailed explanation of the generated plan */\n  explanation?: string | null;\n  /** The unique identifier for the execution trace */\n  traceId?: string | null;\n}\n\n/**\n * Log event types for workflow execution\n */\nexport type WorkflowEventType = \n  | 'plan_generated'\n  | 'plan_loaded'\n  | 'step_started'\n  | 'step_completed'\n  | 'step_failed'\n  | 'plan_revised'\n  | 'plan_completed'\n  | 'plan_failed'\n  | 'checkpoint_created'\n  | 'checkpoint_resumed'\n  | 'template_saved'\n  | 'template_loaded';\n\n/**\n * Structure of a workflow log event\n */\nexport interface WorkflowEvent {\n  /** Type of event */\n  type: WorkflowEventType;\n  /** Timestamp when the event occurred */\n  timestamp: number;\n  /** Additional data specific to the event type */\n  payload: any;\n  /** Human-readable message */\n  message: string;\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\chat.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\global.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\google.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\idb.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\index.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\porcupine-web.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\prom-client.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\pyodide.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\react-json-view.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\roslib.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\types\\speech.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\WorkflowEngine.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'BaseAgent' is defined but never used. Allowed unused vars must match /^_/u.","line":14,"column":15,"nodeType":null,"messageId":"unusedVar","endLine":14,"endColumn":24},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":33,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":33,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[888,891],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[888,891],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":36,"column":12,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":36,"endColumn":15,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1005,1008],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1005,1008],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":91,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":91,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[2392,2395],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[2392,2395],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * WorkflowEngine.ts\n * \n * A dedicated engine for executing multi-step workflows with advanced features:\n * - Parallel execution of independent steps\n * - Auto-retry and recovery mechanisms\n * - Workflow visualization helpers\n * - Execution history and performance metrics\n */\n\nimport { v4 as uuidv4 } from 'uuid';\nimport { saveToStorage, loadFromStorage } from './storage';\nimport { agentRegistry } from '../agents/registry';\nimport type { BaseAgent } from '../agents/types';\n\n// Storage keys\nconst WORKFLOW_HISTORY_KEY = 'workflow_history';\nconst WORKFLOW_TEMPLATES_KEY = 'workflow_templates';\n\n// Constants\nconst MAX_RETRIES = 3;\nconst RETRY_DELAY = 2000; // ms\nconst MAX_HISTORY_ITEMS = 50;\nconst MAX_PARALLEL_STEPS = 3;\n\n// --- Type Definitions ---\n\nexport interface WorkflowStep {\n  id: number;\n  description: string;\n  agent: string;\n  command: string;\n  args: Record<string, any>;\n  dependencies: number[];\n  status: 'pending' | 'waiting' | 'in_progress' | 'completed' | 'failed';\n  result?: any;\n  startTime?: number;\n  endTime?: number;\n  duration?: number;\n  retryCount?: number;\n}\n\nexport interface Workflow {\n  id: string;\n  name: string;\n  description: string;\n  steps: WorkflowStep[];\n  createdAt: number;\n  updatedAt: number;\n  status: 'pending' | 'in_progress' | 'completed' | 'failed' | 'paused';\n  progress: number; // 0-100\n  elapsedTime?: number;\n}\n\nexport interface WorkflowHistoryItem {\n  id: string;\n  workflow: Workflow;\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  outcome: 'completed' | 'failed' | 'cancelled';\n  summary?: string;\n}\n\nexport interface WorkflowTemplate {\n  id: string;\n  name: string;\n  description: string;\n  steps: Omit<WorkflowStep, 'status' | 'result' | 'startTime' | 'endTime' | 'duration' | 'retryCount'>[];\n  tags: string[];\n  createdAt: number;\n  updatedAt: number;\n}\n\nexport interface WorkflowEngineOptions {\n  maxRetries?: number;\n  retryDelay?: number;\n  maxParallelSteps?: number;\n  onStepUpdate?: (step: WorkflowStep) => void;\n  onWorkflowUpdate?: (workflow: Workflow) => void;\n}\n\ntype WorkflowEventType = 'step-started' | 'step-completed' | 'step-failed' | 'workflow-started' | \n                         'workflow-completed' | 'workflow-failed' | 'workflow-paused' | 'workflow-resumed';\n\ninterface WorkflowEvent {\n  type: WorkflowEventType;\n  workflowId: string;\n  stepId?: number;\n  timestamp: number;\n  data?: any;\n}\n\n// --- WorkflowEngine Class ---\n\nexport class WorkflowEngine {\n  private templates: Map<string, WorkflowTemplate>;\n  private history: WorkflowHistoryItem[];\n  private activeWorkflows: Map<string, Workflow>;\n  private options: Required<WorkflowEngineOptions>;\n  private eventListeners: Map<WorkflowEventType, Array<(event: WorkflowEvent) => void>>;\n  private workflowAbortControllers: Map<string, AbortController>;\n\n  constructor(options: WorkflowEngineOptions = {}) {\n    // Initialize options with defaults\n    this.options = {\n      maxRetries: options.maxRetries ?? MAX_RETRIES,\n      retryDelay: options.retryDelay ?? RETRY_DELAY,\n      maxParallelSteps: options.maxParallelSteps ?? MAX_PARALLEL_STEPS,\n      onStepUpdate: options.onStepUpdate ?? (() => {}),\n      onWorkflowUpdate: options.onWorkflowUpdate ?? (() => {})\n    };\n\n    // Load saved data\n    this.templates = new Map(loadFromStorage<[string, WorkflowTemplate][]>(WORKFLOW_TEMPLATES_KEY) ?? []);\n    this.history = loadFromStorage<WorkflowHistoryItem[]>(WORKFLOW_HISTORY_KEY) ?? [];\n    this.activeWorkflows = new Map();\n    this.eventListeners = new Map();\n    this.workflowAbortControllers = new Map();\n\n    // Limit history size\n    if (this.history.length > MAX_HISTORY_ITEMS) {\n      this.history = this.history.slice(-MAX_HISTORY_ITEMS);\n      this.saveHistory();\n    }\n  }\n\n  // --- Public API ---\n\n  /**\n   * Create a new workflow from a template or raw steps\n   */\n  createWorkflow(params: {\n    name: string,\n    description: string,\n    templateId?: string,\n    steps?: Omit<WorkflowStep, 'status' | 'result' | 'startTime' | 'endTime' | 'duration' | 'retryCount'>[]\n  }): Workflow {\n    let steps: WorkflowStep[];\n\n    if (params.templateId) {\n      const template = this.templates.get(params.templateId);\n      if (!template) throw new Error(`Template ${params.templateId} not found`);\n      steps = template.steps.map(step => ({\n        ...step,\n        status: 'pending' as const,\n        retryCount: 0\n      }));\n    } else if (params.steps) {\n      steps = params.steps.map(step => ({\n        ...step,\n        status: 'pending' as const,\n        retryCount: 0\n      }));\n    } else {\n      throw new Error('Either templateId or steps must be provided');\n    }\n\n    const workflow: Workflow = {\n      id: uuidv4(),\n      name: params.name,\n      description: params.description,\n      steps,\n      createdAt: Date.now(),\n      updatedAt: Date.now(),\n      status: 'pending',\n      progress: 0\n    };\n\n    this.activeWorkflows.set(workflow.id, workflow);\n    return workflow;\n  }\n\n  /**\n   * Execute a workflow\n   */\n  async executeWorkflow(workflowId: string): Promise<Workflow> {\n    const workflow = this.activeWorkflows.get(workflowId);\n    if (!workflow) throw new Error(`Workflow ${workflowId} not found`);\n\n    // Create abort controller for this workflow\n    const abortController = new AbortController();\n    this.workflowAbortControllers.set(workflowId, abortController);\n\n    // Create history entry\n    const historyItem: WorkflowHistoryItem = {\n      id: uuidv4(),\n      workflow: JSON.parse(JSON.stringify(workflow)), // deep copy\n      startTime: Date.now(),\n      outcome: 'completed' // optimistic default\n    };\n    \n    // Start execution\n    workflow.status = 'in_progress';\n    workflow.updatedAt = Date.now();\n    this.notifyWorkflowUpdate(workflow);\n    this.emitEvent({ type: 'workflow-started', workflowId, timestamp: Date.now() });\n\n    try {\n      // Execute workflow steps\n      await this.executeSteps(workflow, abortController.signal);\n      \n      // Complete workflow\n      workflow.status = 'completed';\n      workflow.progress = 100;\n      workflow.updatedAt = Date.now();\n      workflow.elapsedTime = Date.now() - historyItem.startTime;\n      \n      // Update history\n      historyItem.endTime = Date.now();\n      historyItem.duration = historyItem.endTime - historyItem.startTime;\n      historyItem.outcome = 'completed';\n      historyItem.summary = this.generateWorkflowSummary(workflow);\n      historyItem.workflow = JSON.parse(JSON.stringify(workflow)); // Final state\n      \n      this.history.push(historyItem);\n      this.saveHistory();\n      \n      this.notifyWorkflowUpdate(workflow);\n      this.emitEvent({ type: 'workflow-completed', workflowId, timestamp: Date.now() });\n      \n      // Clean up\n      this.workflowAbortControllers.delete(workflowId);\n      \n      return workflow;\n    } catch (error) {\n      // Handle failure\n      workflow.status = 'failed';\n      workflow.updatedAt = Date.now();\n      workflow.elapsedTime = Date.now() - historyItem.startTime;\n      \n      // Update history\n      historyItem.endTime = Date.now();\n      historyItem.duration = historyItem.endTime - historyItem.startTime;\n      historyItem.outcome = 'failed';\n      historyItem.summary = `Failed: ${error instanceof Error ? error.message : String(error)}`;\n      historyItem.workflow = JSON.parse(JSON.stringify(workflow)); // Final state\n      \n      this.history.push(historyItem);\n      this.saveHistory();\n      \n      this.notifyWorkflowUpdate(workflow);\n      this.emitEvent({ \n        type: 'workflow-failed', \n        workflowId, \n        timestamp: Date.now(),\n        data: { error: error instanceof Error ? error.message : String(error) }\n      });\n      \n      // Clean up\n      this.workflowAbortControllers.delete(workflowId);\n      \n      throw error;\n    }\n  }\n\n  /**\n   * Pause a running workflow\n   */\n  pauseWorkflow(workflowId: string): void {\n    const workflow = this.activeWorkflows.get(workflowId);\n    if (!workflow) throw new Error(`Workflow ${workflowId} not found`);\n    \n    if (workflow.status !== 'in_progress') {\n      throw new Error(`Cannot pause workflow in ${workflow.status} state`);\n    }\n    \n    const abortController = this.workflowAbortControllers.get(workflowId);\n    if (abortController) {\n      abortController.abort('Workflow paused by user');\n    }\n    \n    workflow.status = 'paused';\n    workflow.updatedAt = Date.now();\n    this.notifyWorkflowUpdate(workflow);\n    this.emitEvent({ type: 'workflow-paused', workflowId, timestamp: Date.now() });\n  }\n\n  /**\n   * Resume a paused workflow\n   */\n  async resumeWorkflow(workflowId: string): Promise<Workflow> {\n    const workflow = this.activeWorkflows.get(workflowId);\n    if (!workflow) throw new Error(`Workflow ${workflowId} not found`);\n    \n    if (workflow.status !== 'paused') {\n      throw new Error(`Cannot resume workflow in ${workflow.status} state`);\n    }\n    \n    workflow.status = 'in_progress';\n    workflow.updatedAt = Date.now();\n    this.notifyWorkflowUpdate(workflow);\n    this.emitEvent({ type: 'workflow-resumed', workflowId, timestamp: Date.now() });\n    \n    return this.executeWorkflow(workflowId);\n  }\n\n  /**\n   * Cancel a workflow\n   */\n  cancelWorkflow(workflowId: string): void {\n    const workflow = this.activeWorkflows.get(workflowId);\n    if (!workflow) throw new Error(`Workflow ${workflowId} not found`);\n    \n    if (workflow.status === 'completed' || workflow.status === 'failed') {\n      throw new Error(`Cannot cancel workflow in ${workflow.status} state`);\n    }\n    \n    const abortController = this.workflowAbortControllers.get(workflowId);\n    if (abortController) {\n      abortController.abort('Workflow cancelled by user');\n    }\n    \n    // Find and mark all in-progress steps as failed\n    workflow.steps\n      .filter(step => step.status === 'in_progress')\n      .forEach(step => {\n        step.status = 'failed';\n        step.endTime = Date.now();\n        if (step.startTime) {\n          step.duration = step.endTime - step.startTime;\n        }\n        this.options.onStepUpdate(step);\n      });\n    \n    // Add to history\n    const historyItem: WorkflowHistoryItem = {\n      id: uuidv4(),\n      workflow: JSON.parse(JSON.stringify(workflow)),\n      startTime: workflow.steps.find(s => s.startTime)?.startTime || Date.now(),\n      endTime: Date.now(),\n      outcome: 'cancelled',\n      summary: 'Workflow cancelled by user'\n    };\n    \n    if (historyItem.endTime && historyItem.startTime) {\n      historyItem.duration = historyItem.endTime - historyItem.startTime;\n    }\n    \n    this.history.push(historyItem);\n    this.saveHistory();\n    \n    // Clean up\n    this.workflowAbortControllers.delete(workflowId);\n    this.activeWorkflows.delete(workflowId);\n  }\n\n  /**\n   * Save a workflow as a template\n   */\n  saveAsTemplate(workflowId: string, name: string, description: string, tags: string[] = []): WorkflowTemplate {\n    const workflow = this.activeWorkflows.get(workflowId);\n    if (!workflow) throw new Error(`Workflow ${workflowId} not found`);\n    \n    // Extract reusable steps from workflow\n    const templateSteps = workflow.steps.map(({\n      id, description, agent, command, args, dependencies\n    }) => ({\n      id, description, agent, command, args, dependencies\n    }));\n    \n    const template: WorkflowTemplate = {\n      id: uuidv4(),\n      name,\n      description,\n      steps: templateSteps,\n      tags,\n      createdAt: Date.now(),\n      updatedAt: Date.now()\n    };\n    \n    this.templates.set(template.id, template);\n    this.saveTemplates();\n    \n    return template;\n  }\n\n  /**\n   * Get all workflow templates\n   */\n  getTemplates(): WorkflowTemplate[] {\n    return Array.from(this.templates.values());\n  }\n\n  /**\n   * Get workflow history\n   */\n  getHistory(): WorkflowHistoryItem[] {\n    return [...this.history];\n  }\n\n  /**\n   * Subscribe to workflow events\n   */\n  addEventListener(\n    event: WorkflowEventType | '*', \n    callback: (event: WorkflowEvent) => void\n  ): () => void {\n    if (event === '*') {\n      // Subscribe to all event types\n      const allEvents: WorkflowEventType[] = [\n        'step-started', 'step-completed', 'step-failed',\n        'workflow-started', 'workflow-completed', 'workflow-failed',\n        'workflow-paused', 'workflow-resumed'\n      ];\n      \n      const unsubscribes = allEvents.map(e => this.addEventListener(e, callback));\n      return () => unsubscribes.forEach(unsub => unsub());\n    }\n    \n    if (!this.eventListeners.has(event)) {\n      this.eventListeners.set(event, []);\n    }\n    \n    const listeners = this.eventListeners.get(event)!;\n    listeners.push(callback);\n    \n    return () => {\n      const index = listeners.indexOf(callback);\n      if (index !== -1) {\n        listeners.splice(index, 1);\n      }\n    };\n  }\n\n  // --- Private Methods ---\n\n  private async executeSteps(workflow: Workflow, signal: AbortSignal): Promise<void> {\n    const totalSteps = workflow.steps.length;\n    const completedSteps = () => workflow.steps.filter(s => s.status === 'completed').length;\n    \n    // Mark initial steps as waiting\n    workflow.steps.forEach(step => {\n      if (step.dependencies.length === 0) {\n        step.status = 'waiting';\n      }\n    });\n    \n    // Continue until all steps are completed or workflow fails\n    while (completedSteps() < totalSteps) {\n      if (signal.aborted) {\n        throw new Error(`Workflow execution aborted: ${signal.reason}`);\n      }\n      \n      // Find steps that can be executed (all dependencies satisfied)\n      const executableSteps = workflow.steps.filter(step => {\n        if (step.status !== 'waiting') return false;\n        \n        // Check if all dependencies are completed\n        return step.dependencies.every(depId => {\n          const depStep = workflow.steps.find(s => s.id === depId);\n          return depStep && depStep.status === 'completed';\n        });\n      });\n      \n      if (executableSteps.length === 0 && completedSteps() < totalSteps) {\n        // Check for deadlock\n        const pendingOrWaiting = workflow.steps.filter(s => \n          s.status === 'pending' || s.status === 'waiting' || s.status === 'in_progress'\n        );\n        \n        if (pendingOrWaiting.length > 0) {\n          // Wait for in-progress steps to complete\n          if (workflow.steps.some(s => s.status === 'in_progress')) {\n            await new Promise(resolve => setTimeout(resolve, 100));\n            continue;\n          } else {\n            // Deadlock detected\n            throw new Error('Workflow deadlock: no executable steps but workflow not complete');\n          }\n        }\n      }\n      \n      // Execute steps in parallel, up to maxParallelSteps\n      const stepPromises: Promise<void>[] = [];\n      const stepsToRun = executableSteps.slice(0, this.options.maxParallelSteps);\n      \n      for (const step of stepsToRun) {\n        stepPromises.push(this.executeStep(workflow, step, signal));\n      }\n      \n      if (stepPromises.length === 0 && completedSteps() < totalSteps) {\n        // No steps to execute but workflow not complete - wait for in-progress steps\n        await new Promise(resolve => setTimeout(resolve, 100));\n        continue;\n      }\n      \n      // Wait for all parallel steps to complete\n      await Promise.all(stepPromises);\n      \n      // Update workflow progress\n      workflow.progress = Math.round((completedSteps() / totalSteps) * 100);\n      workflow.updatedAt = Date.now();\n      this.notifyWorkflowUpdate(workflow);\n    }\n  }\n\n  private async executeStep(\n    workflow: Workflow, \n    step: WorkflowStep,\n    signal: AbortSignal\n  ): Promise<void> {\n    // Mark as in progress\n    step.status = 'in_progress';\n    step.startTime = Date.now();\n    step.retryCount = step.retryCount ?? 0;\n    \n    this.notifyStepUpdate(step);\n    this.emitEvent({\n      type: 'step-started',\n      workflowId: workflow.id,\n      stepId: step.id,\n      timestamp: Date.now()\n    });\n    \n    try {\n      // Get agent from registry\n      const agent = agentRegistry.getAgent(step.agent);\n      if (!agent) {\n        throw new Error(`Agent \"${step.agent}\" not found in registry`);\n      }\n      \n      // Execute the agent command\n      const result = await Promise.race([\n        agent.execute({\n          ...step.args,\n          command: step.command\n        }),\n        new Promise<never>((_, reject) => {\n          signal.addEventListener('abort', () => {\n            reject(new Error(`Step execution aborted: ${signal.reason}`));\n          });\n        })\n      ]);\n      \n      // Mark as completed\n      step.status = 'completed';\n      step.endTime = Date.now();\n      step.duration = step.endTime - step.startTime;\n      step.result = result;\n      \n      this.notifyStepUpdate(step);\n      this.emitEvent({\n        type: 'step-completed',\n        workflowId: workflow.id,\n        stepId: step.id,\n        timestamp: Date.now(),\n        data: { result }\n      });\n      \n      // Check subsequent steps that can now be executed\n      this.updateDependentSteps(workflow, step);\n      \n    } catch (error) {\n      // Handle retry logic\n      step.retryCount = (step.retryCount ?? 0) + 1;\n      \n      if (step.retryCount <= this.options.maxRetries && !signal.aborted) {\n        // Retry after delay\n        await new Promise(resolve => setTimeout(resolve, this.options.retryDelay));\n        return this.executeStep(workflow, step, signal);\n      }\n      \n      // Mark as failed if max retries exceeded\n      step.status = 'failed';\n      step.endTime = Date.now();\n      step.duration = step.endTime - step.startTime;\n      step.result = { \n        error: error instanceof Error ? error.message : String(error),\n        success: false\n      };\n      \n      this.notifyStepUpdate(step);\n      this.emitEvent({\n        type: 'step-failed',\n        workflowId: workflow.id,\n        stepId: step.id,\n        timestamp: Date.now(),\n        data: { error: error instanceof Error ? error.message : String(error) }\n      });\n      \n      throw error;\n    }\n  }\n\n  private updateDependentSteps(workflow: Workflow, completedStep: WorkflowStep): void {\n    workflow.steps\n      .filter(step => \n        step.status === 'pending' && \n        step.dependencies.includes(completedStep.id)\n      )\n      .forEach(step => {\n        // Check if all dependencies are now completed\n        const allDependenciesMet = step.dependencies.every(depId => {\n          const depStep = workflow.steps.find(s => s.id === depId);\n          return depStep && depStep.status === 'completed';\n        });\n        \n        if (allDependenciesMet) {\n          step.status = 'waiting';\n          this.notifyStepUpdate(step);\n        }\n      });\n  }\n\n  private notifyStepUpdate(step: WorkflowStep): void {\n    this.options.onStepUpdate(JSON.parse(JSON.stringify(step)));\n  }\n\n  private notifyWorkflowUpdate(workflow: Workflow): void {\n    this.options.onWorkflowUpdate(JSON.parse(JSON.stringify(workflow)));\n  }\n\n  private emitEvent(event: WorkflowEvent): void {\n    const listeners = this.eventListeners.get(event.type) || [];\n    listeners.forEach(listener => listener(event));\n  }\n\n  private saveHistory(): void {\n    // Limit history size\n    if (this.history.length > MAX_HISTORY_ITEMS) {\n      this.history = this.history.slice(-MAX_HISTORY_ITEMS);\n    }\n    saveToStorage(WORKFLOW_HISTORY_KEY, this.history);\n  }\n\n  private saveTemplates(): void {\n    saveToStorage(WORKFLOW_TEMPLATES_KEY, Array.from(this.templates.entries()));\n  }\n\n  private generateWorkflowSummary(workflow: Workflow): string {\n    const totalSteps = workflow.steps.length;\n    const completedSteps = workflow.steps.filter(s => s.status === 'completed').length;\n    const failedSteps = workflow.steps.filter(s => s.status === 'failed').length;\n    \n    const timeTaken = workflow.elapsedTime \n      ? `${(workflow.elapsedTime / 1000).toFixed(2)} seconds` \n      : 'unknown time';\n      \n    return `Completed ${completedSteps}/${totalSteps} steps (${failedSteps} failed) in ${timeTaken}`;\n  }\n}\n\n// Create singleton instance\nexport const workflowEngine = new WorkflowEngine();\nexport default workflowEngine;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\buildPlannerPrompt.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\cn.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\handleAgentError.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\loadTask.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":3,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":3,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[160,163],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[160,163],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":5,"column":50,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":5,"endColumn":53,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[299,302],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[299,302],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// Generic loader for MediaPipe .task models\n// Decides GPU vs CPU delegate based on availability\nexport async function loadTask<T extends { createFromOptions: any }>(TaskCtor: T, gpuPreferred = true) {\n  // If WebGPU supported and preferred, use it\n  const delegate = gpuPreferred && (navigator as any).gpu ? 'GPU' : 'CPU';\n  return await TaskCtor.createFromOptions({ baseOptions: { delegate } });\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\logger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\planTracer.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\planTracer.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\revisePlan.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'error' is defined but never used.","line":155,"column":12,"nodeType":null,"messageId":"unusedVar","endLine":155,"endColumn":17}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * revisePlan.ts\n * \n * Module isol├® pour la r├®vision de plans qui ont ├®chou├®.\n * Fournit une API claire pour corriger et adapter les workflows d├®faillants.\n */\n\nimport { logEvent } from './logger';\nimport { planTracer } from './planTracer';\nimport type { WorkflowStep } from '../types/Planner';\n\ninterface RevisePlanOptions {\n  /**\n   * ID de trace pour enregistrer les op├®rations\n   */\n  traceId?: string;\n  \n  /**\n   * API Key pour le mod├¿le LLM\n   */\n  apiKey: string;\n  \n  /**\n   * Mod├¿le ├á utiliser pour la r├®vision\n   */\n  model?: string;\n  \n  /**\n   * Nombre maximum de tentatives de r├®vision\n   */\n  maxAttempts?: number;\n  \n  /**\n   * Callback pour les explications contextuelles destin├®es ├á l'UI\n   */\n  onExplanation?: (explanation: string) => void;\n}\n\nconst DEFAULT_OPTIONS: Partial<RevisePlanOptions> = {\n  model: 'gpt-4-turbo-preview',\n  maxAttempts: 3\n};\n\n/**\n * Construit un prompt pour r├®viser un plan qui a ├®chou├®\n */\nfunction buildRevisionPrompt(\n  request: string, \n  failedPlan: WorkflowStep[],\n  errorMessage?: string,\n  attempt: number = 1\n): string {\n  const maxAttempts = 3;\n  \n  // Extraire les ├®tapes et erreurs\n  const planSteps = JSON.stringify(failedPlan, null, 2);\n  const errorDetail = errorMessage ? `with error: ${errorMessage}` : 'for unknown reasons';\n  \n  let urgencyPrefix = '';\n  if (attempt > 1) {\n    urgencyPrefix = attempt === 2 \n      ? \"La premi├¿re r├®vision n'a pas fonctionn├®. Essayez une approche diff├®rente. \"\n      : `IMPORTANT: Ceci est notre derni├¿re tentative (${attempt}/${maxAttempts}). Soyez tr├¿s pr├®cis. `;\n  }\n\n  return `${urgencyPrefix}Le plan suivant a ├®chou├® ${errorDetail}:\n\n\\`\\`\\`json\n${planSteps}\n\\`\\`\\`\n\nLa requ├¬te originale ├®tait: \"${request}\"\n\nR├®visez ce plan pour r├®soudre le probl├¿me. Consid├®rez ces options:\n1. Corriger les arguments des ├®tapes existantes\n2. Ajouter des ├®tapes pr├®paratoires ou de v├®rification\n3. Ajuster les d├®pendances entre les ├®tapes\n4. Utiliser un agent diff├®rent si n├®cessaire\n\nR├®pondez UNIQUEMENT avec le JSON du plan r├®vis├®. Conservez la m├¬me structure mais avec les modifications n├®cessaires.`;\n}\n\n/**\n * Appelle l'API LLM pour r├®viser un plan\n */\nasync function callLLM(prompt: string, options: RevisePlanOptions): Promise<string> {\n  const response = await fetch('https://api.openai.com/v1/chat/completions', {\n    method: 'POST',\n    headers: {\n      'Content-Type': 'application/json',\n      'Authorization': `Bearer ${options.apiKey}`\n    },\n    body: JSON.stringify({\n      model: options.model || DEFAULT_OPTIONS.model,\n      messages: [{ role: 'user', content: prompt }],\n      temperature: 0,\n      response_format: { type: 'json_object' },\n    }),\n  });\n  \n  if (!response.ok) {\n    const errorText = await response.text();\n    throw new Error(`LLM API request failed: ${response.status} ${errorText}`);\n  }\n  \n  const result = await response.json();\n  return result.choices[0].message.content;\n}\n\n/**\n * G├®n├¿re une explication pour l'UI sur les changements apport├®s\n */\nasync function generateExplanation(\n  originalPlan: WorkflowStep[],\n  revisedPlan: WorkflowStep[],\n  errorMessage: string | undefined,\n  options: RevisePlanOptions\n): Promise<string> {\n  // Cr├®er un prompt pour expliquer les changements\n  const prompt = `Expliquez bri├¿vement les changements effectu├®s pour corriger ce plan qui a ├®chou├® ${errorMessage ? `avec l'erreur: \"${errorMessage}\"` : 'sans raison connue'}.\n\nPlan original:\n\\`\\`\\`json\n${JSON.stringify(originalPlan.map(s => ({id: s.id, description: s.description})), null, 2)}\n\\`\\`\\`\n\nPlan r├®vis├®:\n\\`\\`\\`json\n${JSON.stringify(revisedPlan.map(s => ({id: s.id, description: s.description})), null, 2)}\n\\`\\`\\`\n\nDonnez un r├®sum├® des modifications en 1-2 phrases, dans un langage simple pour l'utilisateur:`;\n\n  try {\n    const response = await fetch('https://api.openai.com/v1/chat/completions', {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json',\n        'Authorization': `Bearer ${options.apiKey}`\n      },\n      body: JSON.stringify({\n        model: 'gpt-3.5-turbo', // Mod├¿le plus rapide et moins cher pour de simples explications\n        messages: [{ role: 'user', content: prompt }],\n        temperature: 0.3,\n        max_tokens: 100,\n      }),\n    });\n    \n    if (!response.ok) {\n      return \"Plan r├®vis├® avec corrections techniques.\";\n    }\n    \n    const result = await response.json();\n    return result.choices[0].message.content.trim();\n  } catch (error) {\n    return \"Plan r├®vis├® avec corrections techniques.\";\n  }\n}\n\n/**\n * Fonction principale pour r├®viser un plan qui a ├®chou├®\n */\nexport async function revisePlan(\n  request: string,\n  failedPlan: WorkflowStep[],\n  errorMessage?: string,\n  attempt: number = 1,\n  options: Partial<RevisePlanOptions> = {}\n): Promise<{\n  plan: WorkflowStep[];\n  explanation: string;\n}> {\n  // Fusionner les options avec les valeurs par d├®faut\n  const finalOptions: RevisePlanOptions = { \n    ...DEFAULT_OPTIONS, \n    ...options,\n    apiKey: options.apiKey || ''\n  };\n  \n  if (!finalOptions.apiKey) {\n    throw new Error('API key is required for plan revision');\n  }\n\n  const maxAttempts = finalOptions.maxAttempts || DEFAULT_OPTIONS.maxAttempts || 3;\n  if (attempt > maxAttempts) {\n    throw new Error(`Maximum revision attempts (${maxAttempts}) exceeded`);\n  }\n\n  try {\n    // Construire le prompt de r├®vision\n    const prompt = buildRevisionPrompt(request, failedPlan, errorMessage, attempt);\n    \n    // Enregistrer l'op├®ration dans la trace si un ID de trace est fourni\n    if (finalOptions.traceId) {\n      planTracer.addStep(finalOptions.traceId, 'plan_revision', {\n        prompt,\n        metadata: { attempt, errorMessage }\n      });\n    }\n    \n    // Journal pour le d├®bogage\n    logEvent('plan_revision_attempt', \n      { attempt, error: errorMessage }, \n      `Attempting plan revision (${attempt}/${maxAttempts})`\n    );\n\n    // Appeler l'API LLM pour obtenir le plan r├®vis├®\n    const revisionJson = await callLLM(prompt, finalOptions);\n    \n    try {\n      // Traiter la r├®ponse JSON\n      const revisedPlan = JSON.parse(revisionJson);\n      \n      // Valider la structure du plan\n      if (!Array.isArray(revisedPlan)) {\n        throw new Error('Revised plan is not a valid array');\n      }\n      \n      // Normaliser le plan r├®vis├®\n      const normalizedPlan = revisedPlan.map(step => ({\n        ...step,\n        status: 'pending',\n        dependencies: Array.isArray(step.dependencies) ? step.dependencies : [],\n        args: step.args || {},\n      }));\n      \n      // G├®n├®rer une explication des changements\n      const explanation = await generateExplanation(\n        failedPlan,\n        normalizedPlan,\n        errorMessage,\n        finalOptions\n      );\n      \n      // Fournir l'explication via le callback si disponible\n      if (finalOptions.onExplanation) {\n        finalOptions.onExplanation(explanation);\n      }\n      \n      // Enregistrer le r├®sultat dans la trace\n      if (finalOptions.traceId) {\n        planTracer.addStep(finalOptions.traceId, 'plan_revision', {\n          result: normalizedPlan,\n          explanation,\n          metadata: { success: true, attempt }\n        });\n      }\n      \n      // Journal pour le d├®bogage\n      logEvent('plan_revision_success', \n        { attempt, stepCount: normalizedPlan.length }, \n        `Plan revision successful (${attempt}/${maxAttempts})`\n      );\n      \n      return {\n        plan: normalizedPlan,\n        explanation\n      };\n    } catch (error) {\n      // En cas d'erreur de parsing ou de validation\n      const errorMsg = error instanceof Error ? error.message : String(error);\n      \n      // Enregistrer l'erreur dans la trace\n      if (finalOptions.traceId) {\n        planTracer.addStep(finalOptions.traceId, 'plan_revision', {\n          error: errorMsg,\n          metadata: { success: false, attempt }\n        });\n      }\n      \n      throw new Error(`Failed to revise plan: ${errorMsg}`);\n    }\n  } catch (error) {\n    const errorMsg = error instanceof Error ? error.message : String(error);\n    \n    // Journal pour le d├®bogage\n    logEvent('plan_revision_failed', \n      { attempt, error: errorMsg }, \n      `Plan revision failed (${attempt}/${maxAttempts}): ${errorMsg}`\n    );\n    \n    throw new Error(`Plan revision failed: ${errorMsg}`);\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\runWorkflowPlan.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\startupLogger.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":312,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":312,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7743,7746],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7743,7746],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":313,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":313,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7792,7795],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7792,7795],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":314,"column":14,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":314,"endColumn":17,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[7868,7871],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[7868,7871],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * Syst├¿me de logs structur├® pour l'audit du d├®marrage de l'application\n * Permet de tracer et diagnostiquer les probl├¿mes de d├®marrage\n */\n\nexport type LogLevel = 'debug' | 'info' | 'warn' | 'error' | 'critical';\nexport type LogCategory = \n  | 'startup' \n  | 'component' \n  | 'store' \n  | 'worker' \n  | 'api' \n  | 'render' \n  | 'effect'\n  | 'performance';\n\ninterface LogEntry {\n  timestamp: number;\n  level: LogLevel;\n  category: LogCategory;\n  component?: string;\n  message: string;\n  data?: unknown;\n  error?: Error;\n  duration?: number;\n}\n\nclass StartupLogger {\n  private logs: LogEntry[] = [];\n  private startTime: number = Date.now();\n  private timers: Map<string, number> = new Map();\n  private enabled: boolean = true;\n\n  constructor() {\n    // Activer les logs en dev ou si explicitement demand├®\n    this.enabled = import.meta.env.DEV || localStorage.getItem('lisa:debug') === 'true';\n    \n    if (this.enabled) {\n      console.log('%c[StartupLogger] Initialized', 'color: #00ff88; font-weight: bold');\n    }\n  }\n\n  /**\n   * Log un message avec niveau et cat├®gorie\n   */\n  log(\n    level: LogLevel,\n    category: LogCategory,\n    message: string,\n    data?: unknown,\n    component?: string\n  ): void {\n    if (!this.enabled) return;\n\n    const entry: LogEntry = {\n      timestamp: Date.now(),\n      level,\n      category,\n      component,\n      message,\n      data,\n    };\n\n    this.logs.push(entry);\n\n    // Console output avec couleurs\n    const color = this.getColorForLevel(level);\n    const prefix = `[${category}${component ? `/${component}` : ''}]`;\n    const elapsed = `+${(entry.timestamp - this.startTime).toFixed(0)}ms`;\n    \n    console.log(\n      `%c${prefix} %c${elapsed} %c${message}`,\n      `color: ${color}; font-weight: bold`,\n      'color: #888',\n      'color: inherit',\n      data || ''\n    );\n  }\n\n  /**\n   * D├®marrer un timer pour mesurer la dur├®e\n   */\n  startTimer(name: string): void {\n    if (!this.enabled) return;\n    this.timers.set(name, Date.now());\n  }\n\n  /**\n   * Arr├¬ter un timer et logger la dur├®e\n   */\n  endTimer(name: string, category: LogCategory, component?: string): number {\n    if (!this.enabled) return 0;\n    \n    const startTime = this.timers.get(name);\n    if (!startTime) {\n      this.log('warn', category, `Timer \"${name}\" not found`, undefined, component);\n      return 0;\n    }\n\n    const duration = Date.now() - startTime;\n    this.timers.delete(name);\n\n    this.log(\n      'info',\n      'performance',\n      `${name} completed`,\n      { duration: `${duration}ms` },\n      component\n    );\n\n    return duration;\n  }\n\n  /**\n   * Logger une erreur\n   */\n  error(\n    category: LogCategory,\n    message: string,\n    error: Error | unknown,\n    component?: string\n  ): void {\n    const entry: LogEntry = {\n      timestamp: Date.now(),\n      level: 'error',\n      category,\n      component,\n      message,\n      error: error instanceof Error ? error : new Error(String(error)),\n    };\n\n    this.logs.push(entry);\n\n    console.error(\n      `[${category}${component ? `/${component}` : ''}] ${message}`,\n      error\n    );\n  }\n\n  /**\n   * Obtenir tous les logs\n   */\n  getLogs(): LogEntry[] {\n    return [...this.logs];\n  }\n\n  /**\n   * Obtenir les logs filtr├®s\n   */\n  getLogsByCategory(category: LogCategory): LogEntry[] {\n    return this.logs.filter(log => log.category === category);\n  }\n\n  getLogsByLevel(level: LogLevel): LogEntry[] {\n    return this.logs.filter(log => log.level === level);\n  }\n\n  getLogsByComponent(component: string): LogEntry[] {\n    return this.logs.filter(log => log.component === component);\n  }\n\n  /**\n   * Obtenir un r├®sum├® des logs\n   */\n  getSummary(): {\n    total: number;\n    byLevel: Record<LogLevel, number>;\n    byCategory: Record<LogCategory, number>;\n    errors: LogEntry[];\n    warnings: LogEntry[];\n    startupTime: number;\n  } {\n    const byLevel: Record<LogLevel, number> = {\n      debug: 0,\n      info: 0,\n      warn: 0,\n      error: 0,\n      critical: 0,\n    };\n\n    const byCategory: Record<LogCategory, number> = {\n      startup: 0,\n      component: 0,\n      store: 0,\n      worker: 0,\n      api: 0,\n      render: 0,\n      effect: 0,\n      performance: 0,\n    };\n\n    this.logs.forEach(log => {\n      byLevel[log.level]++;\n      byCategory[log.category]++;\n    });\n\n    return {\n      total: this.logs.length,\n      byLevel,\n      byCategory,\n      errors: this.logs.filter(log => log.level === 'error' || log.level === 'critical'),\n      warnings: this.logs.filter(log => log.level === 'warn'),\n      startupTime: Date.now() - this.startTime,\n    };\n  }\n\n  /**\n   * Exporter les logs en JSON\n   */\n  exportLogs(): string {\n    return JSON.stringify({\n      summary: this.getSummary(),\n      logs: this.logs,\n    }, null, 2);\n  }\n\n  /**\n   * Afficher le r├®sum├® dans la console\n   */\n  printSummary(): void {\n    if (!this.enabled) return;\n\n    const summary = this.getSummary();\n    \n    console.group('%c­ƒôè Startup Logs Summary', 'color: #00ff88; font-weight: bold; font-size: 14px');\n    console.log(`ÔÅ▒´©Å  Total startup time: ${summary.startupTime}ms`);\n    console.log(`­ƒôØ Total logs: ${summary.total}`);\n    console.log(`ÔØî Errors: ${summary.byLevel.error + summary.byLevel.critical}`);\n    console.log(`ÔÜá´©Å  Warnings: ${summary.byLevel.warn}`);\n    \n    console.group('By Category:');\n    Object.entries(summary.byCategory).forEach(([cat, count]) => {\n      if (count > 0) {\n        console.log(`  ${cat}: ${count}`);\n      }\n    });\n    console.groupEnd();\n\n    if (summary.errors.length > 0) {\n      console.group('ÔØî Errors:');\n      summary.errors.forEach(err => {\n        console.error(`  [${err.component || err.category}] ${err.message}`, err.error);\n      });\n      console.groupEnd();\n    }\n\n    if (summary.warnings.length > 0) {\n      console.group('ÔÜá´©Å  Warnings:');\n      summary.warnings.forEach(warn => {\n        console.warn(`  [${warn.component || warn.category}] ${warn.message}`, warn.data);\n      });\n      console.groupEnd();\n    }\n\n    console.groupEnd();\n  }\n\n  /**\n   * Nettoyer les logs\n   */\n  clear(): void {\n    this.logs = [];\n    this.timers.clear();\n    this.startTime = Date.now();\n    console.log('%c[StartupLogger] Logs cleared', 'color: #00ff88');\n  }\n\n  /**\n   * Activer/d├®sactiver les logs\n   */\n  setEnabled(enabled: boolean): void {\n    this.enabled = enabled;\n    localStorage.setItem('lisa:debug', enabled ? 'true' : 'false');\n  }\n\n  private getColorForLevel(level: LogLevel): string {\n    switch (level) {\n      case 'debug': return '#888';\n      case 'info': return '#00aaff';\n      case 'warn': return '#ffaa00';\n      case 'error': return '#ff4444';\n      case 'critical': return '#ff0000';\n      default: return '#fff';\n    }\n  }\n}\n\n// Instance singleton\nexport const startupLogger = new StartupLogger();\n\n// Helpers pour faciliter l'utilisation\nexport const logStartup = (message: string, data?: unknown) => \n  startupLogger.log('info', 'startup', message, data);\n\nexport const logComponent = (component: string, message: string, data?: unknown) =>\n  startupLogger.log('info', 'component', message, data, component);\n\nexport const logStore = (store: string, message: string, data?: unknown) =>\n  startupLogger.log('info', 'store', message, data, store);\n\nexport const logWorker = (worker: string, message: string, data?: unknown) =>\n  startupLogger.log('info', 'worker', message, data, worker);\n\nexport const logError = (category: LogCategory, message: string, error: Error | unknown, component?: string) =>\n  startupLogger.error(category, message, error, component);\n\nexport const logPerformance = (name: string, duration: number) =>\n  startupLogger.log('info', 'performance', `${name}: ${duration}ms`);\n\n// Exposer globalement pour debug\nif (typeof window !== 'undefined') {\n  (window as any).startupLogger = startupLogger;\n  (window as any).printStartupSummary = () => startupLogger.printSummary();\n  (window as any).exportStartupLogs = () => {\n    const logs = startupLogger.exportLogs();\n    console.log(logs);\n    return logs;\n  };\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\storage.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\utils\\structuredLogger.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\vite-env.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workers\\drawWorker.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workers\\hearingWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":10,"column":18,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":10,"endColumn":21,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[271,274],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[271,274],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":11,"column":24,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":11,"endColumn":27,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[306,309],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[306,309],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":12,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":12,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[338,341],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[338,341],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":22,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":25,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[371,374],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[371,374],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":4,"fixableErrorCount":0,"fixableWarningCount":0,"source":"\n// src/workers/hearingWorker.ts\nimport { pipeline, env } from '@xenova/transformers';\nimport type { HearingPerceptPayload } from '../senses/hearing';\nimport type { Percept } from '../types';\n\n// Disable local model checks\nenv.allowLocalModels = false;\n\nlet sttPipeline: any = null;\nlet sentimentPipeline: any = null;\nlet intentPipeline: any = null;\nlet emotionPipeline: any = null;\n\n// Function to load the STT model (Whisper-tiny)\nasync function loadSttModel() {\n  try {\n    console.log('Loading Whisper-tiny STT model...');\n    sttPipeline = await pipeline('automatic-speech-recognition', 'Xenova/whisper-tiny');\n    console.log('Whisper-tiny STT model loaded successfully.');\n\n    console.log('Loading sentiment analysis model...');\n    sentimentPipeline = await pipeline('sentiment-analysis', 'Xenova/distilbert-base-uncased-finetuned-sst-2-english');\n    console.log('Sentiment analysis model loaded successfully.');\n\n    console.log('Loading intent recognition model...');\n    intentPipeline = await pipeline('text-classification', 'Xenova/distilbert-base-uncased-mnli');\n    console.log('Intent recognition model loaded successfully.');\n\n    console.log('Loading speech emotion recognition model...');\n    emotionPipeline = await pipeline('audio-classification', 'Xenova/wav2vec2-base-finetuned-emotion');\n    console.log('Speech emotion recognition model loaded successfully.');\n\n  } catch (error) {\n    console.error('Failed to load STT or NLU/SER models:', error);\n  }\n}\n\n// Function to process audio chunk and perform STT\nasync function processAudio(audioData: Float32Array) {\n  if (!sttPipeline || !sentimentPipeline || !intentPipeline || !emotionPipeline) {\n    console.warn('STT or NLU/SER models not loaded yet. Skipping audio processing.');\n    return;\n  }\n\n  try {\n    const transcription = await sttPipeline(audioData);\n    const text = transcription.text;\n\n    let sentiment: string | undefined;\n    if (text) {\n      const sentimentResult = await sentimentPipeline(text);\n      sentiment = sentimentResult[0]?.label; // Assuming the first label is the sentiment\n    }\n\n    let intent: string | undefined;\n    if (text) {\n      const intentResult = await intentPipeline(text);\n      intent = intentResult[0]?.label; // Assuming the first label is the intent\n    }\n\n    let emotion: string | undefined;\n    if (audioData) {\n      const emotionResult = await emotionPipeline(audioData);\n      // Assuming the emotion pipeline returns a classification with labels and scores\n      emotion = emotionResult[0]?.label; // Get the top emotion label\n    }\n\n    const percept: Percept<HearingPerceptPayload> = {\n      modality: 'hearing',\n      payload: { text, sentiment, intent, emotion },\n      confidence: transcription.score || 1.0,\n      ts: Date.now(),\n    };\n\n    self.postMessage(percept);\n\n  } catch (error) {\n    console.error('Error during audio processing:', error);\n  }\n}\n\n// Listen for messages from the main thread\nself.onmessage = (event: MessageEvent) => {\n  const { type, payload } = event.data;\n\n  switch (type) {\n    case 'LOAD_STT_MODEL':\n      loadSttModel();\n      break;\n    case 'PROCESS_AUDIO':\n      processAudio(payload);\n      break;\n    default:\n      console.warn('Unknown message type:', type);\n  }\n};\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workers\\visionWorker.ts","messages":[{"ruleId":"@typescript-eslint/no-unused-vars","severity":1,"message":"'frame' is defined but never used. Allowed unused args must match /^_/u.","line":22,"column":23,"nodeType":null,"messageId":"unusedVar","endLine":22,"endColumn":28},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":22,"column":30,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":22,"endColumn":33,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[699,702],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[699,702],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"// src/workers/visionWorker.ts\nimport * as tf from '@tensorflow/tfjs';\nimport { loadGraphModel } from '@tensorflow/tfjs-converter';\n\n// Placeholder for YOLOv8-n model URL\nconst YOLOV8N_MODEL_URL = 'https://tfhub.dev/tensorflow/yolov8n/detection/1?tfjs-format=graph_model';\n\nlet model: tf.GraphModel | null = null;\n\n// Function to load the YOLOv8-n model\nasync function loadModel() {\n  try {\n    console.log('Loading YOLOv8-n model...');\n    model = await loadGraphModel(YOLOV8N_MODEL_URL);\n    console.log('YOLOv8-n model loaded successfully.');\n  } catch (error) {\n    console.error('Failed to load YOLOv8-n model:', error);\n  }\n}\n\n// Function to process a video frame\nfunction processFrame(frame: any) {\n  if (!model) {\n    console.warn('Model not loaded yet. Skipping frame processing.');\n    return;\n  }\n\n  // In a real application, you would convert the frame (e.g., ImageData, HTMLVideoElement)\n  // into a TensorFlow tensor, preprocess it (resize, normalize), and then run inference.\n  // For this example, we'll simulate the inference.\n\n  try {\n    // Simulate input tensor creation from frame\n    // Assuming frame is an ImageData or similar that can be converted to a tensor\n    // For a real implementation, you'd use tf.browser.fromPixels(frame)\n    const inputTensor = tf.zeros([640, 640, 3]); // Dummy tensor for simulation\n\n    // Perform inference\n    const predictions = model.execute(inputTensor.expandDims(0));\n\n    // Dispose of the input tensor to free memory\n    inputTensor.dispose();\n    tf.dispose(predictions); // Dispose of output tensors\n\n    // Simulate detection results\n    const simulatedDetections = [\n      { box: [10, 20, 50, 60], class: 'person', score: 0.95 },\n      { box: [100, 120, 150, 160], class: 'car', score: 0.88 },\n    ];\n\n    // Post the results back to the main thread\n    self.postMessage({\n      modality: 'vision',\n      payload: simulatedDetections,\n      confidence: 0.9,\n      ts: Date.now(),\n    });\n\n  } catch (error) {\n    console.error('Error during frame processing:', error);\n  }\n}\n\n// Listen for messages from the main thread\nself.onmessage = (event: MessageEvent) => {\n  const { type, payload } = event.data;\n\n  switch (type) {\n    case 'LOAD_MODEL':\n      loadModel();\n      break;\n    case 'PROCESS_FRAME':\n      processFrame(payload);\n      break;\n    default:\n      console.warn('Unknown message type:', type);\n  }\n};","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\WorkflowExecutor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\agents\\AFlowOptimizerAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":13,"column":44,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":13,"endColumn":47,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[359,362],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[359,362],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":31,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":31,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[832,835],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[832,835],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":32,"column":10,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":32,"endColumn":13,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[881,884],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[881,884],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":3,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Agent that optimizes a workflow graph using a Monte Carlo Tree Search (MCTS)\n * approach, inspired by the AFlow paper.\n */\n\n// --- Data Structures ---\n\n/**\n * Represents a workflow in a simplified JSON format.\n * In a real app, this would match the React Flow state.\n */\nexport interface WorkflowJSON {\n  nodes: { id: string; type: string; data: any }[];\n  edges: { id: string; source: string; target: string }[];\n}\n\n/**\n * Defines the optimization objective.\n * The values indicate the weight of each objective.\n */\nexport interface OptimizationObjective {\n  passRate?: number; // e.g., 1.0 to maximize success rate\n  tokenCost?: number; // e.g., -1.0 to minimize token cost\n}\n\n/**\n * Represents a proposed change to the workflow.\n */\nexport interface WorkflowStep {\n  operator: 'add' | 'remove' | 'replace';\n  node?: any; // The node to add or replace with\n  edge?: any;\n  targetNodeId?: string; // The ID of the node to modify/remove\n}\n\n/**\n * The result of the optimization process.\n */\nexport interface OptimizationResult {\n  originalJson: WorkflowJSON;\n  optimizedJson: WorkflowJSON;\n  improvementScore: number;\n  steps: WorkflowStep[];\n}\n\n// --- Agent Class ---\n\nexport class AFlowOptimizerAgent {\n  /**\n   * Optimizes a given workflow based on a specified objective.\n   * This is a simplified MCTS wrapper.\n   *\n   * @param flowJson - The current workflow structure.\n   * @param objective - The optimization goals.\n   * @param availableOperatorPlugins - A list of available operator nodes (e.g., 'ReviewAndReviseNode').\n   * @returns The optimized workflow and the steps taken.\n   */\n  optimize(\n    flowJson: WorkflowJSON,\n    objective: OptimizationObjective = { passRate: 1.0, tokenCost: -1.0 },\n    availableOperatorPlugins: string[] = ['ReviewAndReviseNode', 'EnsembleNode', 'RetryWithExponentialBackoffNode']\n  ): OptimizationResult {\n    console.log('Starting workflow optimization with objective:', objective);\n\n    // This is a placeholder for the MCTS implementation.\n    const bestSteps: WorkflowStep[] = [];\n    const optimizedJson = JSON.parse(JSON.stringify(flowJson)); // Deep copy\n\n    // Mock optimization: Add a 'ReviewAndRevise' node after the first LLM prompt node found.\n    const firstLlmNode = optimizedJson.nodes.find(node => node.type === 'llmPromptNode');\n\n    if (firstLlmNode && availableOperatorPlugins.includes('ReviewAndReviseNode')) {\n      const reviewNodeId = `review-${firstLlmNode.id}`;\n      const reviewNode = {\n        id: reviewNodeId,\n        type: 'ReviewAndReviseNode',\n        data: { prompt: 'Critically review the previous output for flaws.' },\n      };\n\n      const step: WorkflowStep = {\n        operator: 'add',\n        node: reviewNode,\n        edge: { id: `e-${firstLlmNode.id}-${reviewNodeId}`, source: firstLlmNode.id, target: reviewNodeId },\n      };\n      \n      bestSteps.push(step);\n      \n      // Apply the step\n      optimizedJson.nodes.push(reviewNode);\n      optimizedJson.edges.push(step.edge);\n\n      console.log(`Optimization proposed: Add a 'ReviewAndReviseNode' after node '${firstLlmNode.id}'.`);\n    }\n\n    return {\n      originalJson: flowJson,\n      optimizedJson,\n      improvementScore: 0.15, // Mock improvement score\n      steps: bestSteps,\n    };\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\agents\\GeminiCodeAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\agents\\GeminiCodeAgent.ts","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":94,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":94,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[3149,3152],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[3149,3152],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":114,"column":21,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":114,"endColumn":24,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[4129,4132],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[4129,4132],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"/**\n * @file Agent that interfaces with Google's Gemini Pro via the Gemini CLI\n * and provides a fallback to a local Code Gemma model.\n */\n\nimport { exec } from 'child_process';\nimport { promises as fs } from 'fs';\nimport * as path from 'path';\nimport { promisify } from 'util';\n\n// Promisify the exec function for async/await usage\nconst execAsync = promisify(exec);\n\n// --- Data Structures ---\n\nexport interface CodeGenerationContext {\n  language: string;\n  fileContent?: string; // Content of the file being edited\n}\n\nexport interface GenerationResult {\n  success: boolean;\n  content?: string; // The generated code or diff\n  error?: string;\n  source: 'gemini' | 'gemma' | 'error';\n}\n\n// --- Agent Class ---\n\nexport class GeminiCodeAgent {\n  private readonly GEMINI_CLI_PATH = 'gemini'; // Assumes 'gemini' is in the system's PATH\n  private readonly GEMINI_CREDENTIALS_PATH = path.join(process.env.USERPROFILE || '', '.gemini', 'credentials.json');\n  private readonly DAILY_REQUEST_QUOTA_LIMIT = 900;\n  private currentRequestCount = 0; // This should be persisted\n\n  constructor() {\n    this.loadRequestCount();\n  }\n\n  /**\n   * Reads the local Gemini credentials to check for API key presence.\n   * In a real app, this would use Windows DPAPI for decryption.\n   */\n  private async checkCredentials(): Promise<boolean> {\n    try {\n      const stats = await fs.stat(this.GEMINI_CREDENTIALS_PATH);\n      return stats.isFile();\n    } catch {\n      return false;\n    }\n  }\n\n  /**\n   * Generates code using either Gemini Pro or a local fallback.\n   * @param prompt - The natural language prompt for code generation.\n   * @param context - Optional context, like language or current file content.\n   * @returns The generated code or an error message.\n   */\n  async generateCode(prompt: string): Promise<GenerationResult> {\n    if (this.currentRequestCount >= this.DAILY_REQUEST_QUOTA_LIMIT) {\n      console.warn('Gemini daily quota reached. Falling back to local Code Gemma.');\n      return this.generateWithGemma(prompt);\n    }\n\n    if (!(await this.checkCredentials())) {\n        return { success: false, error: 'Gemini credentials not found.', source: 'error' };\n    }\n\n    try {\n      // The Gemini CLI command might look different; this is an educated guess.\n      // Using stdin for the prompt is more secure and robust.\n      const options = {\n        cwd: process.env.HOME || process.env.USERPROFILE,\n      };\n\n      // Escape double quotes in the prompt to prevent command injection\n      const escapedPrompt = prompt.replace(/\"/g, '\\\\\"');\n\n      const { stdout, stderr } = await execAsync(`${this.GEMINI_CLI_PATH} \"${escapedPrompt}\"`, options);\n\n      if (stderr) {\n        console.error('Gemini CLI Error:', stderr);\n        // Don't fallback on CLI error, it might be a user issue\n        return { success: false, error: stderr, source: 'gemini' };\n      }\n\n      this.incrementRequestCount();\n      \n      // Here you would parse the stdout to get the rate-limit headers if the CLI provides them.\n      // For now, we just increment our local counter.\n\n      return { success: true, content: stdout, source: 'gemini' };\n\n    } catch (error: any) {\n      console.error('Failed to execute Gemini CLI:', error);\n      // Fallback on execution failure\n      return this.generateWithGemma(prompt);\n    }\n  }\n\n  /**\n   * Fallback mechanism to use a local Code Gemma model via transformers.\n   * @param prompt - The code generation prompt.\n   * @returns The generated code or an error message.\n   */\n  private async generateWithGemma(prompt: string): Promise<GenerationResult> {\n    console.log('Using local Code Gemma model...');\n    // This is a placeholder for the actual implementation using Hugging Face's transformers.js\n    // It would require loading the quantized model and running inference.\n    // e.g., const pipeline = await pipeline('text-generation', 'google/codegemma-7b-it');\n    try {\n      const mockGemmaOutput = `// Code Gemma fallback response for prompt: \"${prompt}\"\\nconsole.log(\"Hello from local Gemma!\");`;\n      return { success: true, content: mockGemmaOutput, source: 'gemma' };\n    } catch (error: any) {\n      return { success: false, error: error.message, source: 'error' };\n    }\n  }\n\n  private async loadRequestCount(): Promise<void> {\n    // In a real app, this would be read from a persistent store like IndexedDB.\n    this.currentRequestCount = 0; \n  }\n\n  private async incrementRequestCount(): Promise<void> {\n    this.currentRequestCount++;\n    // In a real app, this would be saved to a persistent store.\n  }\n}\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\agents\\WindsurfAgent.test.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\agents\\WindsurfAgent.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\executor\\WorkflowExecutor.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\index.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodeConfigRegistry.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\ConditionNode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\ContentGeneratorNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\CustomNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\DelayNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\ForEachNode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\GitHubNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\HttpRequestNode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\LogNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\MQTTNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\MemoryNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\NLUNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\PersonalizationNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\PowerShellNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\RosNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\RosPublisherNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\RosServiceNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\RosSubscriberNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\SetNode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\SubWorkflowNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\WebhookNode.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\llmPromptNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\nodeTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\nodes\\windForecastNode.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\optimizer\\AFlowCore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\panels\\CodeEditor.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":21,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":21,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[576,579],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[576,579],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":23,"column":28,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":23,"endColumn":31,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[668,671],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[668,671],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"React Hook useEffect has a missing dependency: 'initMonaco'. Either include it or remove the dependency array.","line":61,"column":6,"nodeType":"ArrayExpression","endLine":61,"endColumn":8,"suggestions":[{"desc":"Update the dependencies array to be: [initMonaco]","fix":{"range":[1808,1810],"text":"[initMonaco]"}}],"suppressions":[{"kind":"directive","justification":""}]}],"errorCount":0,"fatalErrorCount":0,"warningCount":2,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useEffect, useRef } from 'react';\nimport useWorkflowStore from '../store/useWorkflowStore';\n\n// Types d'├®diteur de code\ninterface CodeEditorProps {\n  value: string;\n  onChange: (code: string) => void;\n  language?: 'javascript' | 'python' | 'json';\n  height?: string;\n  readOnly?: boolean;\n}\n\n// Composant d'├®diteur de code bas├® sur Monaco Editor avec chargement dynamique\nconst CodeEditor: React.FC<CodeEditorProps> = ({ \n  value, \n  onChange, \n  language = 'javascript', \n  height = '200px',\n  readOnly = false\n}) => {\n  const editorRef = useRef<any>(null);\n  const containerRef = useRef<HTMLDivElement>(null);\n  const monacoRef = useRef<any>(null);\n  const darkMode = useWorkflowStore(state => state.darkMode);\n\n  // Chargement dynamique de Monaco Editor\n  useEffect(() => {\n    // ├ëviter de recharger Monaco s'il est d├®j├á charg├®\n    if (window.monaco) {\n      monacoRef.current = window.monaco;\n      initMonaco();\n      return;\n    }\n\n    const script = document.createElement('script');\n    script.src = 'https://unpkg.com/monaco-editor@0.36.1/min/vs/loader.js';\n    script.async = true;\n    script.onload = () => {\n      // @ts-expect-error: Monaco AMD loader 'require' is attached on window at runtime\n      window.require.config({\n        paths: {\n          vs: 'https://unpkg.com/monaco-editor@0.36.1/min/vs'\n        }\n      });\n      \n      // @ts-expect-error: Monaco AMD loader 'require' is attached on window at runtime\n      window.require(['vs/editor/editor.main'], () => {\n        monacoRef.current = window.monaco;\n        initMonaco();\n      });\n    };\n\n    document.body.appendChild(script);\n\n    return () => {\n      if (editorRef.current) {\n        editorRef.current.dispose();\n      }\n    };\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  // Mise ├á jour du th├¿me lorsque le mode sombre change\n  useEffect(() => {\n    if (monacoRef.current && editorRef.current) {\n      monacoRef.current.editor.setTheme(darkMode ? 'vs-dark' : 'vs');\n    }\n  }, [darkMode]);\n\n  // Mise ├á jour du contenu de l'├®diteur lorsque la valeur change\n  useEffect(() => {\n    if (editorRef.current) {\n      const currentValue = editorRef.current.getValue();\n      if (value !== currentValue) {\n        editorRef.current.setValue(value);\n      }\n    }\n  }, [value]);\n\n  // Initialisation de Monaco Editor\n  const initMonaco = useCallback(() => {\n    if (!containerRef.current || editorRef.current) return;\n\n    // Configurer les langages\n    const languageMap = {\n      'javascript': 'javascript',\n      'python': 'python',\n      'json': 'json',\n    };\n\n    // Cr├®er l'├®diteur\n    editorRef.current = monacoRef.current.editor.create(containerRef.current, {\n      value: value,\n      language: languageMap[language],\n      theme: darkMode ? 'vs-dark' : 'vs',\n      automaticLayout: true,\n      minimap: {\n        enabled: false\n      },\n      scrollBeyondLastLine: false,\n      lineNumbers: 'on',\n      readOnly: readOnly,\n      fontSize: 14,\n      tabSize: 2,\n    });\n\n    // ├ëv├®nement onChange\n    editorRef.current.onDidChangeModelContent(() => {\n      const newValue = editorRef.current.getValue();\n      if (newValue !== value) {\n        onChange(newValue);\n      }\n    });\n  }, [value, language, darkMode, readOnly, onChange]);\n\n  // Rendu de l'├®diteur avec fallback\n  return (\n    <div>\n      <div\n        ref={containerRef}\n        style={{ \n          width: '100%', \n          height: height, \n          border: `1px solid ${darkMode ? '#4B5563' : '#E5E7EB'}`,\n          borderRadius: '0.375rem',\n        }}\n      />\n      {!window.monaco && (\n        <textarea\n          className={`w-full h-full p-2 font-mono text-sm ${\n            darkMode ? 'bg-gray-800 text-gray-200' : 'bg-white text-gray-800'\n          } border ${\n            darkMode ? 'border-gray-700' : 'border-gray-300'\n          } rounded-md`}\n          value={value}\n          onChange={(e) => onChange(e.target.value)}\n          style={{ height }}\n          readOnly={readOnly}\n        />\n      )}\n    </div>\n  );\n};\n\nexport default CodeEditor;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\panels\\NodeConfigPanel.tsx","messages":[{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'theme' conditional could make the dependencies of useMemo Hook (at line 255) change on every render. To fix this, wrap the initialization of 'theme' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":43,"endColumn":4},{"ruleId":"react-hooks/exhaustive-deps","severity":1,"message":"The 'theme' conditional could make the dependencies of useMemo Hook (at line 279) change on every render. To fix this, wrap the initialization of 'theme' in its own useMemo() Hook.","line":27,"column":9,"nodeType":"VariableDeclarator","endLine":43,"endColumn":4},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":46,"column":63,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":46,"endColumn":66,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[1716,1719],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[1716,1719],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":158,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":158,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6205,6208],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6205,6208],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":159,"column":56,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":159,"endColumn":59,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6294,6297],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6294,6297],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]},{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":160,"column":57,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":160,"endColumn":60,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[6384,6387],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[6384,6387],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":6,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useMemo } from 'react';\nimport type { Node } from 'reactflow';\nimport useWorkflowStore from '../store/useWorkflowStore';\nimport { nodeTypes } from '../nodes/nodeTypes';\nimport { getNodeConfigComponent } from '../nodeConfigRegistry';\nimport CodeEditor from './CodeEditor';\nimport { z } from 'zod';\n\ninterface NodeConfigPanelProps {\n  node: Node;\n  onClose: () => void;\n}\n\n// Configuration dynamique des champs du n┼ôud\nconst NodeConfigPanel: React.FC<NodeConfigPanelProps> = ({ node, onClose }) => {\n  const updateNode = useWorkflowStore(state => state.updateNode);\n  const executionResults = useWorkflowStore(state => state.executionResults);\n  const darkMode = useWorkflowStore(state => state.darkMode);\n  const [activeTab, setActiveTab] = React.useState('config');\n  \n  const nodeType = node.data.type;\n  // Cherche un panneau de config sp├®cifique enregistr├®\n  const SpecificConfigPanel = getNodeConfigComponent(nodeType);\n  const nodeInfo = nodeTypes[nodeType];\n  \n  // Th├¿me et styles\n  const theme = darkMode ? {\n    panel: 'bg-gray-800 text-white',\n    header: 'bg-gray-700',\n    input: 'bg-gray-700 border-gray-600 text-white',\n    button: 'bg-blue-600 hover:bg-blue-700',\n    secondaryButton: 'bg-gray-600 hover:bg-gray-700',\n    text: 'text-white',\n    textSecondary: 'text-gray-300',\n  } : {\n    panel: 'bg-white text-gray-800',\n    header: 'bg-gray-50',\n    input: 'bg-white border-gray-300 text-gray-800',\n    button: 'bg-blue-500 hover:bg-blue-600',\n    secondaryButton: 'bg-gray-200 hover:bg-gray-300',\n    text: 'text-gray-800',\n    textSecondary: 'text-gray-600',\n  };\n  \n  // Mise ├á jour de la config du n┼ôud\n  const handleConfigChange = useCallback((key: string, value: any) => {\n    updateNode(node.id, { \n      config: { \n        ...node.data.config, \n        [key]: value \n      } \n    });\n  }, [node, updateNode]);\n  \n  // Mise ├á jour du nom/label du n┼ôud\n  const handleLabelChange = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {\n    updateNode(node.id, { label: e.target.value });\n  }, [node, updateNode]);\n  \n  // Rendu des champs de configuration selon le sch├®ma Zod\n  const renderConfigFields = useMemo(() => {\n    if (!nodeInfo?.configSchema) return null;\n\n    // Iterate over the Zod schema to render fields\n    return Object.entries(nodeInfo.configSchema.shape).map(([key, schema]) => {\n      const currentSchema = schema as z.ZodAny; // Cast to ZodAny to access properties\n      const value = node.data.config?.[key] ?? currentSchema.default ?? '';\n      const isOptional = currentSchema.isOptional();\n      const isNullable = currentSchema.isNullable();\n      const required = isOptional || isNullable ? '' : '*' ; // Adjust required logic\n      const description = currentSchema.description; // Zod's .describe() method\n\n      // Determine the base schema type\n      let baseSchema = currentSchema;\n      while (baseSchema instanceof z.ZodOptional || baseSchema instanceof z.ZodNullable) {\n        baseSchema = baseSchema.unwrap();\n      }\n\n      const typeName = baseSchema._def.typeName;\n\n      switch (typeName) {\n        case z.ZodString.name: {\n          const stringSchema = baseSchema as z.ZodString;\n          const isCode = stringSchema._def.metadata?.format === 'code';\n          const isExpression = stringSchema._def.metadata?.expression === true;\n          const isEnum = stringSchema._def.enum !== undefined;\n\n          if (isCode || isExpression) {\n            return (\n              <div key={key} className=\"mb-4\">\n                <label className={`block mb-2 font-medium ${theme.text}`}>\n                  {key} {required}\n                </label>\n                <CodeEditor\n                  value={value as string || ''}\n                  language={isCode ? (node.data.config?.language || 'javascript') : 'javascript'}\n                  onChange={(code) => handleConfigChange(key, code)}\n                  height=\"200px\"\n                />\n                {description && (\n                  <p className={`mt-1 text-xs ${theme.textSecondary}`}>{description}</p>\n                )}\n              </div>\n            );\n          } else if (isEnum) {\n            return (\n              <div key={key} className=\"mb-4\">\n                <label className={`block mb-2 font-medium ${theme.text}`}>\n                  {key} {required}\n                </label>\n                <select\n                  className={`w-full px-3 py-2 border rounded-md ${theme.input}`}\n                  value={value as string}\n                  onChange={(e) => handleConfigChange(key, e.target.value)}\n                >\n                  {stringSchema._def.enum.map((option: string) => (\n                    <option key={option} value={option}>\n                      {option}\n                    </option>\n                  ))}\n                </select>\n                {description && (\n                  <p className={`mt-1 text-xs ${theme.textSecondary}`}>{description}</p>\n                )}\n              </div>\n            );\n          } else {\n            return (\n              <div key={key} className=\"mb-4\">\n                <label className={`block mb-2 font-medium ${theme.text}`}>\n                  {key} {required}\n                </label>\n                <input\n                  type=\"text\"\n                  className={`w-full px-3 py-2 border rounded-md ${theme.input}`}\n                  value={value as string}\n                  onChange={(e) => handleConfigChange(key, e.target.value)}\n                />\n                {description && (\n                  <p className={`mt-1 text-xs ${theme.textSecondary}`}>{description}</p>\n                )}\n              </div>\n            );\n          }\n        }\n\n        case z.ZodNumber.name: {\n          const numberSchema = baseSchema as z.ZodNumber;\n          return (\n            <div key={key} className=\"mb-4\">\n              <label className={`block mb-2 font-medium ${theme.text}`}>\n                {key} {required}\n              </label>\n              <input\n                type=\"number\"\n                className={`w-full px-3 py-2 border rounded-md ${theme.input}`}\n                value={value as number}\n                min={numberSchema._def.checks.find((c: any) => c.kind === 'min')?.value}\n                max={numberSchema._def.checks.find((c: any) => c.kind === 'max')?.value}\n                step={numberSchema._def.checks.find((c: any) => c.kind === 'step')?.value || 1}\n                onChange={(e) => handleConfigChange(key, parseFloat(e.target.value))}\n              />\n              {description && (\n                <p className={`mt-1 text-xs ${theme.textSecondary}`}>{description}</p>\n              )}\n            </div>\n          );\n        }\n\n        case z.ZodBoolean.name: {\n          return (\n            <div key={key} className=\"mb-4 flex items-center\">\n              <input\n                type=\"checkbox\"\n                id={`${node.id}-${key}`}\n                className=\"w-4 h-4 mr-2\"\n                checked={!!value}\n                onChange={(e) => handleConfigChange(key, e.target.checked)}\n              />\n              <label\n                htmlFor={`${node.id}-${key}`}\n                className={`font-medium ${theme.text}`}\n              >\n                {key} {required}\n              </label>\n              {description && (\n                <p className={`ml-6 text-xs ${theme.textSecondary}`}>{description}</p>\n              )}\n            </div>\n          );\n        }\n\n        case z.ZodObject.name: {\n          return (\n            <div key={key} className=\"mb-4\">\n              <label className={`block mb-2 font-medium ${theme.text}`}>\n                {key} {required}\n              </label>\n              <textarea\n                className={`w-full px-3 py-2 border rounded-md font-mono text-sm ${theme.input}`}\n                value={typeof value === 'object' ? JSON.stringify(value, null, 2) : '{}'}\n                rows={5}\n                onChange={(e) => {\n                  try {\n                    const parsed = JSON.parse(e.target.value);\n                    handleConfigChange(key, parsed);\n                  } catch {\n                    // Ignorer les erreurs de parsing pendant la frappe\n                  }\n                }}\n              />\n              {description && (\n                <p className={`mt-1 text-xs ${theme.textSecondary}`}>{description}</p>\n              )}\n            </div>\n          );\n        }\n\n        case z.ZodArray.name: {\n          // For arrays, we'll render a textarea for JSON input for simplicity\n          return (\n            <div key={key} className=\"mb-4\">\n              <label className={`block mb-2 font-medium ${theme.text}`}>\n                {key} {required}\n              </label>\n              <textarea\n                className={`w-full px-3 py-2 border rounded-md font-mono text-sm ${theme.input}`}\n                value={Array.isArray(value) ? JSON.stringify(value, null, 2) : '[]'}\n                rows={5}\n                onChange={(e) => {\n                  try {\n                    const parsed = JSON.parse(e.target.value);\n                    if (Array.isArray(parsed)) {\n                      handleConfigChange(key, parsed);\n                    } else {\n                      // Handle invalid array input\n                    }\n                  } catch {\n                    // Ignore parsing errors during typing\n                  }\n                }}\n              />\n              {description && (\n                <p className={`mt-1 text-xs ${theme.textSecondary}`}>{description}</p>\n              )}\n            </div>\n          );\n        }\n\n        default:\n          console.warn(`Unsupported Zod type: ${typeName} for key: ${key}`);\n          return null;\n      }\n    });\n  }, [node, nodeInfo, handleConfigChange, theme]);\n  \n  // Rendu des exemples disponibles\n  const renderExamples = useMemo(() => {\n    if (!nodeInfo?.examples || nodeInfo.examples.length === 0) return null;\n    \n    return (\n      <div className=\"mt-6 border-t border-gray-200 dark:border-gray-700 pt-4\">\n        <h3 className={`font-bold ${theme.text} mb-2`}>Exemples</h3>\n        <div className=\"space-y-2\">\n          {nodeInfo.examples.map((example, index) => (\n            <button\n              key={index}\n              className={`block w-full text-left px-3 py-2 rounded-md text-sm \n                ${theme.secondaryButton} transition-colors`}\n              onClick={() => updateNode(node.id, { config: example.config })}\n            >\n              <div className=\"font-medium\">{example.title}</div>\n              <div className={`text-xs ${theme.textSecondary}`}>{example.description}</div>\n            </button>\n          ))}\n        </div>\n      </div>\n    );\n  }, [nodeInfo, updateNode, node.id, theme]);\n  \n  // Si un panneau sp├®cifique existe, d├®l├¿gue enti├¿rement le rendu\n  if (SpecificConfigPanel) {\n    return <SpecificConfigPanel node={node} onClose={onClose} />;\n  }\n\n  return (\n    <div \n      className={`w-80 border-l overflow-y-auto h-full ${theme.panel} border-gray-200 dark:border-gray-700`}\n    >\n      {/* En-t├¬te du panneau */}\n      <div className={`p-4 border-b flex justify-between items-center ${theme.header} border-gray-200 dark:border-gray-700`}>\n        <h2 className=\"font-bold\">Configuration du n┼ôud</h2>\n        <button \n          className=\"w-8 h-8 flex items-center justify-center rounded-md hover:bg-gray-200 dark:hover:bg-gray-600\"\n          onClick={onClose}\n        >\n          Ô£ò\n        </button>\n      </div>\n      \n      <div className=\"flex border-b border-gray-200 dark:border-gray-700\">\n        <button\n          className={`flex-1 py-2 text-center text-sm font-medium ${activeTab === 'config' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'}`}\n          onClick={() => setActiveTab('config')}\n        >\n          Configuration\n        </button>\n        <button\n          className={`flex-1 py-2 text-center text-sm font-medium ${activeTab === 'data' ? 'border-b-2 border-blue-500 text-blue-500' : 'text-gray-500 hover:text-gray-700 dark:text-gray-400 dark:hover:text-gray-200'}`}\n          onClick={() => setActiveTab('data')}\n        >\n          Donn├®es\n        </button>\n      </div>\n\n      <div className=\"p-4\">\n        {activeTab === 'config' && (\n          <>\n            {/* Type de n┼ôud et description */}\n            <div className=\"mb-6\">\n              <div className={`font-medium ${theme.textSecondary} text-sm mb-1`}>\n                Type de n┼ôud\n              </div>\n              <div className={`font-bold text-lg ${theme.text}`}>\n                {nodeInfo?.name || nodeType}\n              </div>\n              <div className={`mt-1 text-sm ${theme.textSecondary}`}>\n                {nodeInfo?.description || ''}\n              </div>\n            </div>\n            \n            {/* Nom du n┼ôud */}\n            <div className=\"mb-6\">\n              <label className={`block mb-2 font-medium ${theme.text}`}>\n                Nom du n┼ôud\n              </label>\n              <input\n                type=\"text\"\n                className={`w-full px-3 py-2 border rounded-md ${theme.input}`}\n                value={node.data.label}\n                onChange={handleLabelChange}\n              />\n            </div>\n            \n            {/* Champs de configuration dynamiques */}\n            <div>{renderConfigFields}</div>\n            \n            {/* Exemples pr├®d├®finis */}\n            {renderExamples}\n          </>\n        )}\n        {activeTab === 'data' && (\n          <div className=\"mt-4\">\n            <h3 className={`font-bold ${theme.text} mb-2`}>Donn├®es d'ex├®cution</h3>\n            <pre className={`p-2 rounded-md overflow-auto text-xs ${theme.input}`}>\n              {JSON.stringify(executionResults[node.id], null, 2) || 'Aucune donn├®e d\\'ex├®cution pour ce n┼ôud.'}\n            </pre>\n          </div>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default NodeConfigPanel;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\panels\\WorkflowPanel.tsx","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\panels\\WorkflowToolbar.tsx","messages":[{"ruleId":"@typescript-eslint/no-explicit-any","severity":1,"message":"Unexpected any. Specify a different type.","line":250,"column":58,"nodeType":"TSAnyKeyword","messageId":"unexpectedAny","endLine":250,"endColumn":61,"suggestions":[{"messageId":"suggestUnknown","fix":{"range":[9015,9018],"text":"unknown"},"desc":"Use `unknown` instead, this will force you to explicitly, and safely assert the type is correct."},{"messageId":"suggestNever","fix":{"range":[9015,9018],"text":"never"},"desc":"Use `never` instead, this is useful when instantiating generic type parameters that you don't need to know the type of."}]}],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":1,"fixableErrorCount":0,"fixableWarningCount":0,"source":"import React, { useCallback, useState } from 'react';\nimport useWorkflowStore from '../store/useWorkflowStore';\nimport { WorkflowExecutor } from '../executor/WorkflowExecutor';\n\ninterface WorkflowToolbarProps {\n  sidebarOpen: boolean;\n  toggleSidebar: () => void;\n}\n\n// Barre d'outils flottante pour l'├®diteur de workflow\nconst WorkflowToolbar: React.FC<WorkflowToolbarProps> = ({ sidebarOpen, toggleSidebar }) => {\n  const [saveDialogOpen, setSaveDialogOpen] = useState(false);\n  const [workflowName, setWorkflowName] = useState('');\n  const [workflowDescription, setWorkflowDescription] = useState('');\n  \n  // Acc├¿s au store\n  const nodes = useWorkflowStore(state => state.nodes);\n  const edges = useWorkflowStore(state => state.edges);\n  const isExecuting = useWorkflowStore(state => state.isExecuting);\n  const darkMode = useWorkflowStore(state => state.darkMode);\n  const setExecuting = useWorkflowStore(state => state.setExecuting);\n  const setExecutionResults = useWorkflowStore(state => state.setExecutionResults);\n  const setExecutionErrors = useWorkflowStore(state => state.setExecutionErrors);\n  const setCurrentExecutingNode = useWorkflowStore(state => state.setCurrentExecutingNode);\n  const addWorkflow = useWorkflowStore(state => state.addWorkflow);\n  const workflows = useWorkflowStore(state => state.workflows);\n  const loadWorkflow = useWorkflowStore(state => state.loadWorkflow);\n  const toggleDarkMode = useWorkflowStore(state => state.toggleDarkMode);\n  const undo = useWorkflowStore(state => state.undo);\n  const redo = useWorkflowStore(state => state.redo);\n  const canUndo = useWorkflowStore(state => state.canUndo);\n  const canRedo = useWorkflowStore(state => state.canRedo);\n  const copy = useWorkflowStore(state => state.copy);\n  const cut = useWorkflowStore(state => state.cut);\n  const paste = useWorkflowStore(state => state.paste);\n  \n  // Ex├®cution du workflow\n  const executeWorkflow = useCallback(async () => {\n    if (nodes.length === 0) return;\n    \n    setExecuting(true);\n    setExecutionResults({});\n    setExecutionErrors({});\n    \n    // Configuration de l'ex├®cuteur\n    const executor = new WorkflowExecutor({\n      nodes: nodes.map(node => ({\n        id: node.id,\n        type: node.data.type,\n        config: node.data.config || {}\n      })),\n      edges: edges.map(edge => ({\n        source: edge.source,\n        target: edge.target,\n        sourceHandle: edge.sourceHandle || undefined,\n        targetHandle: edge.targetHandle || undefined\n      })),\n      stepByStep: false,\n      debugMode: true\n    });\n    \n    try {\n      // Pour simuler une ex├®cution pas ├á pas\n      for (const node of nodes) {\n        setCurrentExecutingNode(node.id);\n        // Pause pour simuler le traitement\n        await new Promise(resolve => setTimeout(resolve, 500));\n      }\n      \n      // Ex├®cution r├®elle\n      const result = await executor.execute();\n      \n      // Mise ├á jour des r├®sultats\n      setExecutionResults(result.nodeResults);\n      if (!result.success) {\n        setExecutionErrors(result.errors);\n      }\n    } catch (error) {\n      setExecutionErrors({\n        global: error instanceof Error ? error.message : String(error)\n      });\n    } finally {\n      setExecuting(false);\n      setCurrentExecutingNode(null);\n    }\n  }, [nodes, edges, setExecuting, setExecutionResults, setExecutionErrors, setCurrentExecutingNode]);\n  \n  // Sauvegarde du workflow\n  const handleSaveWorkflow = useCallback(() => {\n    if (!workflowName) return;\n    \n    const workflowId = `workflow_${Date.now()}`;\n    addWorkflow({\n      id: workflowId,\n      name: workflowName,\n      description: workflowDescription,\n      nodes: nodes.map(node => ({\n        id: node.id,\n        type: node.type || 'customNode',\n        position: node.position,\n        data: node.data\n      })),\n      edges: edges.map(edge => ({\n        id: edge.id,\n        source: edge.source,\n        target: edge.target,\n        sourceHandle: edge.sourceHandle || undefined,\n        targetHandle: edge.targetHandle || undefined\n      })),\n      created: new Date().toISOString(),\n      updated: new Date().toISOString()\n    });\n    \n    setSaveDialogOpen(false);\n    setWorkflowName('');\n    setWorkflowDescription('');\n  }, [workflowName, workflowDescription, nodes, edges, addWorkflow, setSaveDialogOpen, setWorkflowName, setWorkflowDescription]);\n  \n  // Cr├®ation d'un nouveau workflow vide\n  const handleNewWorkflow = useCallback(() => {\n    if (nodes.length > 0) {\n      if (!window.confirm('Voulez-vous vraiment cr├®er un nouveau workflow ? Les changements non sauvegard├®s seront perdus.')) {\n        return;\n      }\n    }\n    \n    useWorkflowStore.setState({\n      nodes: [],\n      edges: [],\n      selectedNode: null,\n      executionResults: {},\n      executionErrors: {},\n      currentExecutingNode: null,\n      currentWorkflowId: null\n    });\n  }, [nodes.length]);\n  \n  // Th├¿me\n  const theme = darkMode\n    ? 'bg-gray-800 text-white'\n    : 'bg-white text-gray-800';\n  \n  // Rendu du dialogue de sauvegarde\n  const renderSaveDialog = () => {\n    if (!saveDialogOpen) return null;\n    \n    return (\n      <div className=\"fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50\">\n        <div className={`${darkMode ? 'bg-gray-800' : 'bg-white'} p-6 rounded-lg shadow-xl max-w-md w-full`}>\n          <h2 className={`text-xl font-bold mb-4 ${darkMode ? 'text-white' : 'text-gray-800'}`}>\n            Sauvegarder le workflow\n          </h2>\n          \n          <div className=\"mb-4\">\n            <label className={`block mb-2 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>\n              Nom du workflow\n            </label>\n            <input\n              type=\"text\"\n              className={`w-full px-3 py-2 border rounded-md ${\n                darkMode ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'\n              }`}\n              value={workflowName}\n              onChange={(e) => setWorkflowName(e.target.value)}\n              placeholder=\"Mon workflow\"\n            />\n          </div>\n          \n          <div className=\"mb-6\">\n            <label className={`block mb-2 ${darkMode ? 'text-gray-200' : 'text-gray-700'}`}>\n              Description\n            </label>\n            <textarea\n              className={`w-full px-3 py-2 border rounded-md ${\n                darkMode ? 'bg-gray-700 border-gray-600 text-white' : 'bg-white border-gray-300'\n              }`}\n              value={workflowDescription}\n              onChange={(e) => setWorkflowDescription(e.target.value)}\n              placeholder=\"Description du workflow...\"\n              rows={3}\n            />\n          </div>\n          \n          <div className=\"flex justify-end gap-2\">\n            <button\n              className={`px-4 py-2 rounded-md ${\n                darkMode ? 'bg-gray-600 hover:bg-gray-700' : 'bg-gray-200 hover:bg-gray-300'\n              }`}\n              onClick={() => setSaveDialogOpen(false)}\n            >\n              Annuler\n            </button>\n            <button\n              className=\"px-4 py-2 bg-blue-500 text-white rounded-md hover:bg-blue-600 disabled:bg-blue-300\"\n              onClick={handleSaveWorkflow}\n              disabled={!workflowName}\n            >\n              Sauvegarder\n            </button>\n          </div>\n        </div>\n      </div>\n    );\n  };\n  \n  return (\n    <>\n      <div className={`p-2 rounded-md shadow-lg ${theme} flex items-center gap-2`}>\n        {/* Bouton toggle sidebar */}\n        <button\n          className={`p-2 rounded hover:bg-gray-200 hover:bg-opacity-20`}\n          onClick={toggleSidebar}\n          title={sidebarOpen ? 'Masquer la barre lat├®rale' : 'Afficher la barre lat├®rale'}\n        >\n          {sidebarOpen ? 'ÔùÇ' : 'ÔûÂ'}\n        </button>\n        \n        {/* Bouton nouveau workflow */}\n        <button\n          className=\"px-3 py-1 bg-blue-500 text-white rounded hover:bg-blue-600\"\n          onClick={handleNewWorkflow}\n        >\n          Nouveau\n        </button>\n        \n        {/* Bouton sauvegarder */}\n        <button\n          className=\"px-3 py-1 bg-green-500 text-white rounded hover:bg-green-600\"\n          onClick={() => setSaveDialogOpen(true)}\n          disabled={nodes.length === 0}\n        >\n          Sauvegarder\n        </button>\n        \n        {/* Menu d├®roulant des workflows */}\n        <div className=\"relative group\">\n          <button\n            className=\"px-3 py-1 bg-purple-500 text-white rounded hover:bg-purple-600\"\n          >\n            Charger\n          </button>\n          \n          <div className=\"absolute left-0 mt-1 w-64 bg-white dark:bg-gray-800 shadow-lg rounded-md overflow-hidden hidden group-hover:block z-10\">\n            {Object.values(workflows).length === 0 ? (\n              <div className=\"p-3 text-gray-500 dark:text-gray-400 text-sm\">\n                Aucun workflow sauvegard├®\n              </div>\n            ) : (\n              <div className=\"max-h-64 overflow-y-auto\">\n                {Object.values(workflows).map((workflow: any) => (\n                  <button\n                    key={workflow.id}\n                    className=\"w-full text-left px-4 py-2 hover:bg-gray-100 dark:hover:bg-gray-700\"\n                    onClick={() => loadWorkflow(workflow.id)}\n                  >\n                    <div className=\"font-medium\">{workflow.name}</div>\n                    <div className=\"text-xs text-gray-500 dark:text-gray-400\">\n                      {workflow.description || 'Aucune description'}\n                    </div>\n                  </button>\n                ))}\n              </div>\n            )}\n          </div>\n        </div>\n        \n        {/* S├®parateur */}\n        <div className=\"h-6 border-l border-gray-300 dark:border-gray-700 mx-1\"></div>\n        \n        {/* Bouton ex├®cuter */}\n        <button\n          className={`px-3 py-1 rounded ${\n            isExecuting\n              ? 'bg-red-500 hover:bg-red-600'\n              : 'bg-yellow-500 hover:bg-yellow-600'\n          } text-white`}\n          onClick={executeWorkflow}\n          disabled={isExecuting || nodes.length === 0}\n        >\n          {isExecuting ? 'Ex├®cution en cours...' : 'Ex├®cuter'}\n        </button>\n        \n        {/* S├®parateur */}\n        <div className=\"h-6 border-l border-gray-300 dark:border-gray-700 mx-1\"></div>\n        \n        {/* Bouton mode sombre */}\n        <button\n          className=\"p-2 rounded hover:bg-gray-200 hover:bg-opacity-20\"\n          onClick={toggleDarkMode}\n          title={darkMode ? 'Mode clair' : 'Mode sombre'}\n        >\n          {darkMode ? 'ÔÿÇ´©Å' : '­ƒîÖ'}\n        </button>\n\n        {/* Boutons Undo/Redo */}\n        <button\n          className=\"px-3 py-1 rounded hover:bg-gray-200 hover:bg-opacity-20\"\n          onClick={undo}\n          disabled={!canUndo}\n          title=\"Annuler\"\n        >\n          Ôå®´©Å\n        </button>\n        <button\n          className=\"px-3 py-1 rounded hover:bg-gray-200 hover:bg-opacity-20\"\n          onClick={redo}\n          disabled={!canRedo}\n          title=\"R├®tablir\"\n        >\n          Ôå¬´©Å\n        </button>\n\n        {/* Boutons Copier/Couper/Coller */}\n        <button\n          className=\"px-3 py-1 rounded hover:bg-gray-200 hover:bg-opacity-20\"\n          onClick={copy}\n          title=\"Copier les n┼ôuds s├®lectionn├®s\"\n        >\n          ­ƒôï\n        </button>\n        <button\n          className=\"px-3 py-1 rounded hover:bg-gray-200 hover:bg-opacity-20\"\n          onClick={cut}\n          title=\"Couper les n┼ôuds s├®lectionn├®s\"\n        >\n          Ô£é´©Å\n        </button>\n        <button\n          className=\"px-3 py-1 rounded hover:bg-gray-200 hover:bg-opacity-20\"\n          onClick={paste}\n          title=\"Coller les n┼ôuds\"\n        >\n          Þ▓╝Òéèõ╗ÿÒüæ\n        </button>\n      </div>\n      \n      {/* Dialogue de sauvegarde */}\n      {renderSaveDialog()}\n    </>\n  );\n};\n\nexport default WorkflowToolbar;\n","usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\store\\useWorkflowStore.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\store\\workflowStoreTypes.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]},{"filePath":"C:\\Users\\patri\\CascadeProjects\\Lisa\\src\\workflow\\types\\workflow.d.ts","messages":[],"suppressedMessages":[],"errorCount":0,"fatalErrorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0,"usedDeprecatedRules":[]}]
